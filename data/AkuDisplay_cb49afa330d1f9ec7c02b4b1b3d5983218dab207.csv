,Unnamed: 0,name,return_type,signature,params,summary,source_code,extent,file_path,sum_tokenize
0,0,stbi__sse2_available,int,int stbi__sse2_available(),[],检测SSE2指令集是否可用,"static int stbi__sse2_available(void)
{
   // If we're even attempting to compile this on GCC/Clang, that means
   // -msse2 is on, which means the compiler is allowed to use SSE2
   // instructions at will, and so are we.
   return 1;
}","{'begin': {'line': 765, 'column': 1}, 'end': {'line': 771, 'column': 2}}",play_bmp_sequence.c,"['检测', 'SSE2', '指令', '指令集', '是否', '可用']"
1,1,stbi__start_mem,void,"void stbi__start_mem(stbi__context * s, const stbi_uc * buffer, int len)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'buffer', 'type': 'const stbi_uc *'}, {'name': 'len', 'type': 'int'}]",初始化内存图像读取上下文参数,"static void stbi__start_mem(stbi__context *s, stbi_uc const *buffer, int len)
{
   s->io.read = NULL;
   s->read_from_callbacks = 0;
   s->callback_already_read = 0;
   s->img_buffer = s->img_buffer_original = (stbi_uc *) buffer;
   s->img_buffer_end = s->img_buffer_original_end = (stbi_uc *) buffer+len;
}","{'begin': {'line': 826, 'column': 1}, 'end': {'line': 833, 'column': 2}}",play_bmp_sequence.c,"['初始', '初始化', '内存', '图像', '读取', '上下', '下文', '上下文', '参数']"
2,2,stbi__start_callbacks,void,"void stbi__start_callbacks(stbi__context * s, stbi_io_callbacks * c, void * user)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'c', 'type': 'stbi_io_callbacks *'}, {'name': 'user', 'type': 'void *'}]",初始化图像读取回调及缓冲区设置,"static void stbi__start_callbacks(stbi__context *s, stbi_io_callbacks *c, void *user)
{
   s->io = *c;
   s->io_user_data = user;
   s->buflen = sizeof(s->buffer_start);
   s->read_from_callbacks = 1;
   s->callback_already_read = 0;
   s->img_buffer = s->img_buffer_original = s->buffer_start;
   stbi__refill_buffer(s);
   s->img_buffer_original_end = s->img_buffer_end;
}","{'begin': {'line': 836, 'column': 1}, 'end': {'line': 846, 'column': 2}}",play_bmp_sequence.c,"['初始', '初始化', '图像', '读取', '回调', '及', '缓冲', '缓冲区', '设置']"
3,3,stbi__stdio_read,int,"int stbi__stdio_read(void * user, char * data, int size)","[{'name': 'user', 'type': 'void *'}, {'name': 'data', 'type': 'char *'}, {'name': 'size', 'type': 'int'}]",使用fread读取指定大小的文件数据,"static int stbi__stdio_read(void *user, char *data, int size)
{
   return (int) fread(data,1,size,(FILE*) user);
}","{'begin': {'line': 850, 'column': 1}, 'end': {'line': 853, 'column': 2}}",play_bmp_sequence.c,"['使用', 'fread', '读取', '指定', '大小', '的', '文件', '数据']"
4,4,stbi__stdio_skip,void,"void stbi__stdio_skip(void * user, int n)","[{'name': 'user', 'type': 'void *'}, {'name': 'n', 'type': 'int'}]",跳过输入流中n字节并重置结束标志,"static void stbi__stdio_skip(void *user, int n)
{
   int ch;
   fseek((FILE*) user, n, SEEK_CUR);
   ch = fgetc((FILE*) user);  /* have to read a byte to reset feof()'s flag */
   if (ch != EOF) {
      ungetc(ch, (FILE *) user);  /* push byte back onto stream if valid. */
   }
}","{'begin': {'line': 855, 'column': 1}, 'end': {'line': 863, 'column': 2}}",play_bmp_sequence.c,"['跳过', '输入', '流中', 'n', '字节', '并', '重置', '结束', '标志']"
5,5,stbi__stdio_eof,int,int stbi__stdio_eof(void * user),"[{'name': 'user', 'type': 'void *'}]",检查文件流是否结束或出错,"static int stbi__stdio_eof(void *user)
{
   return feof((FILE*) user) || ferror((FILE *) user);
}","{'begin': {'line': 865, 'column': 1}, 'end': {'line': 868, 'column': 2}}",play_bmp_sequence.c,"['检查', '文件', '流', '是否', '结束', '或', '出错']"
6,6,stbi__start_file,void,"void stbi__start_file(stbi__context * s, FILE * f)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'f', 'type': 'FILE *'}]",使用标准IO回调初始化文件读取上下文,"static void stbi__start_file(stbi__context *s, FILE *f)
{
   stbi__start_callbacks(s, &stbi__stdio_callbacks, (void *) f);
}","{'begin': {'line': 877, 'column': 1}, 'end': {'line': 880, 'column': 2}}",play_bmp_sequence.c,"['使用', '标准', 'IO', '回调', '初始', '初始化', '文件', '读取', '上下', '下文', '上下文']"
7,7,stbi__rewind,void,void stbi__rewind(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",将图像缓冲区指针重置到初始位置，用于重新读取数据流,"static void stbi__rewind(stbi__context *s)
{
   // conceptually rewind SHOULD rewind to the beginning of the stream,
   // but we just rewind to the beginning of the initial buffer, because
   // we only use it after doing 'test', which only ever looks at at most 92 bytes
   s->img_buffer = s->img_buffer_original;
   s->img_buffer_end = s->img_buffer_original_end;
}","{'begin': {'line': 886, 'column': 1}, 'end': {'line': 893, 'column': 2}}",play_bmp_sequence.c,"['将', '图像', '缓冲', '缓冲区', '指针', '重置', '到', '初始', '位置', '，', '用于', '重新', '读取', '数据', '读取数据', '流']"
8,8,stbi_failure_reason,const char *,const char * stbi_failure_reason(),[],返回最近图像加载失败的错误信息描述,"STBIDEF const char *stbi_failure_reason(void)
{
   return stbi__g_failure_reason;
}","{'begin': {'line': 972, 'column': 1}, 'end': {'line': 975, 'column': 2}}",play_bmp_sequence.c,"['返回', '最近', '图像', '加载', '失败', '的', '错误', '误信', '信息', '错误信息', '描述']"
9,9,stbi__err,int,int stbi__err(const char * str),"[{'name': 'str', 'type': 'const char *'}]",设置错误信息并返回失败状态,"static int stbi__err(const char *str)
{
   stbi__g_failure_reason = str;
   return 0;
}","{'begin': {'line': 978, 'column': 1}, 'end': {'line': 982, 'column': 2}}",play_bmp_sequence.c,"['设置', '错误', '误信', '信息', '错误信息', '并', '返回', '失败', '状态']"
10,10,stbi__malloc,void *,void * stbi__malloc(int size),"[{'name': 'size', 'type': 'int'}]",通过STBI_MALLOC分配指定大小的内存空间,"static void *stbi__malloc(size_t size)
{
    return STBI_MALLOC(size);
}","{'begin': {'line': 985, 'column': 1}, 'end': {'line': 988, 'column': 2}}",play_bmp_sequence.c,"['通过', 'STBI', '_', 'MALLOC', '分配', '指定', '大小', '的', '内存', '空间', '内存空间']"
11,11,stbi__addsizes_valid,int,"int stbi__addsizes_valid(int a, int b)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}]","好的，我需要处理用户关于函数摘要的请求。用户之前已经要求生成摘要，现在要求进一步缩减到不超过50字，并且不包含文件地址。

首先，回顾之前的回复，用户提供的函数是stbi__addsizes_valid，功能是检查两个整数相加是否溢出。之前的摘要已经是“检查两整数相加是否溢出”，符合要求，但用户可能希望更简洁。

需要确保新摘要不超过50字，同时准确传达功能。当前摘要已经非常简洁，可能无法进一步缩短而不丢失关键信息。比如“检测整数加法溢出”可能更简短，但需要确认是否准确。原函数检查a + b是否超过INT_MAX，所以“溢出”是正确的术语。

确认用户不需要文件路径，这里没有涉及。因此，最佳选择是保持原摘要，或者略微调整。比如原回复是14字，符合要求。可能用户希望更简练，但已经无法更短而不影响准确性。所以维持原摘要即可。
</think>

{""name"": ""stbi__addsizes_valid"", ""summary"": ""检查两整数相加是否溢出""}","static int stbi__addsizes_valid(int a, int b)
{
   if (b < 0) return 0;
   // now 0 <= b <= INT_MAX, hence also
   // 0 <= INT_MAX - b <= INTMAX.
   // And ""a + b <= INT_MAX"" (which might overflow) is the
   // same as a <= INT_MAX - b (no overflow)
   return a <= INT_MAX - b;
}","{'begin': {'line': 1002, 'column': 1}, 'end': {'line': 1010, 'column': 2}}",play_bmp_sequence.c,"['好', '的', '，', '我', '需要', '处理', '用户', '关于', '函数', '摘要', '的', '请求', '。', '用户', '之前', '已经', '要求', '生成', '摘要', '，', '现在', '要求', '一步', '进一步', '缩减', '减到', '缩减到', '不', '超过', '50', '字', '，', '并且', '不', '包含', '文件', '地址', '。', '\n', '\n', '首先', '，', '回顾', '之前', '的', '回复', '，', '用户', '提供', '的', '函数', '是', 'stbi', '__', 'addsizes', '_', 'valid', '，', '功能', '是', '检查', '两个', '整数', '相加', '是否', '溢出', '。', '之前', '的', '摘要', '已经', '是', '“', '检查', '两', '整数', '相加', '是否', '溢出', '”', '，', '符合', '要求', '符合要求', '，', '但', '用户', '可能', '希望', '更', '简洁', '。', '\n', '\n', '需要', '确保', '新', '摘要', '不', '超过', '50', '字', '，', '同时', '准确', '传达', '功能', '。', '当前', '摘要', '已经', '非常', '简洁', '，', '可能', '无法', '一步', '进一步', '缩短', '而', '不', '丢失', '关键', '信息', '。', '比如', '“', '检测', '整数', '加法', '溢出', '”', '可能', '更', '简短', '，', '但', '需要', '确认', '是否', '准确', '。', '函数', '原函数', '检查', 'a', ' ', '+', ' ', 'b', '是否', '超过', 'INT', '_', 'MAX', '，', '所以', '“', '溢出', '”', '是', '正确', '的', '术语', '。', '\n', '\n', '确认', '用户', '不', '需要', '文件', '路径', '，', '这里', '没有', '涉及', '。', '因此', '，', '最佳', '选择', '是', '保持', '原', '摘要', '，', '或者', '略微', '调整', '。', '比如', '原', '回复', '是', '14', '字', '，', '符合', '要求', '符合要求', '。', '可能', '用户', '希望', '更', '简练', '，', '但', '已经', '无法', '更', '短', '而', '不', '影响', '准确', '准确性', '。', '所以', '维持', '原', '摘要', '即可', '。', '\n', '<', '/', 'think', '>', '\n', '\n', '{', '""', 'name', '""', ':', ' ', '""', 'stbi', '__', 'addsizes', '_', 'valid', '""', ',', ' ', '""', 'summary', '""', ':', ' ', '""', '检查', '两', '整数', '相加', '是否', '溢出', '""', '}']"
12,12,stbi__mul2sizes_valid,int,"int stbi__mul2sizes_valid(int a, int b)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}]",检查两整数相乘是否溢出，处理负数和零的情况。,"static int stbi__mul2sizes_valid(int a, int b)
{
   if (a < 0 || b < 0) return 0;
   if (b == 0) return 1; // mul-by-0 is always safe
   // portable way to check for no overflows in a*b
   return a <= INT_MAX/b;
}","{'begin': {'line': 1014, 'column': 1}, 'end': {'line': 1020, 'column': 2}}",play_bmp_sequence.c,"['检查', '两', '整数', '相乘', '是否', '溢出', '，', '处理', '负数', '和', '零', '的', '情况', '。']"
13,13,stbi__mad2sizes_valid,int,"int stbi__mad2sizes_valid(int a, int b, int add)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}, {'name': 'add', 'type': 'int'}]",验证a*b及与add之和的有效性,"static int stbi__mad2sizes_valid(int a, int b, int add)
{
   return stbi__mul2sizes_valid(a, b) && stbi__addsizes_valid(a*b, add);
}","{'begin': {'line': 1024, 'column': 1}, 'end': {'line': 1027, 'column': 2}}",play_bmp_sequence.c,"['验证', 'a', '*', 'b', '及', '与', 'add', '之', '和', '的', '有效', '有效性']"
14,14,stbi__mad3sizes_valid,int,"int stbi__mad3sizes_valid(int a, int b, int c, int add)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}, {'name': 'c', 'type': 'int'}, {'name': 'add', 'type': 'int'}]",检查三个数相乘加值是否有效防止溢出,"static int stbi__mad3sizes_valid(int a, int b, int c, int add)
{
   return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&
      stbi__addsizes_valid(a*b*c, add);
}","{'begin': {'line': 1031, 'column': 1}, 'end': {'line': 1035, 'column': 2}}",play_bmp_sequence.c,"['检查', '三个', '数', '相乘', '加值', '是否', '有效', '防止', '溢出']"
15,15,stbi__mad4sizes_valid,int,"int stbi__mad4sizes_valid(int a, int b, int c, int d, int add)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}, {'name': 'c', 'type': 'int'}, {'name': 'd', 'type': 'int'}, {'name': 'add', 'type': 'int'}]",验证四数相乘及加值运算的有效性,"static int stbi__mad4sizes_valid(int a, int b, int c, int d, int add)
{
   return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&
      stbi__mul2sizes_valid(a*b*c, d) && stbi__addsizes_valid(a*b*c*d, add);
}","{'begin': {'line': 1039, 'column': 1}, 'end': {'line': 1043, 'column': 2}}",play_bmp_sequence.c,"['验证', '四数', '相乘', '及', '加值', '运算', '的', '有效', '有效性']"
16,16,stbi__malloc_mad2,void *,"void * stbi__malloc_mad2(int a, int b, int add)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}, {'name': 'add', 'type': 'int'}]",分配a*b+add内存，校验无效返回空,"static void *stbi__malloc_mad2(int a, int b, int add)
{
   if (!stbi__mad2sizes_valid(a, b, add)) return NULL;
   return stbi__malloc(a*b + add);
}","{'begin': {'line': 1048, 'column': 1}, 'end': {'line': 1052, 'column': 2}}",play_bmp_sequence.c,"['分配', 'a', '*', 'b', '+', 'add', '内存', '，', '校验', '无效', '返回', '空']"
17,17,stbi__malloc_mad3,void *,"void * stbi__malloc_mad3(int a, int b, int c, int add)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}, {'name': 'c', 'type': 'int'}, {'name': 'add', 'type': 'int'}]",分配a*b*c + add大小的内存，检查有效性,"static void *stbi__malloc_mad3(int a, int b, int c, int add)
{
   if (!stbi__mad3sizes_valid(a, b, c, add)) return NULL;
   return stbi__malloc(a*b*c + add);
}","{'begin': {'line': 1055, 'column': 1}, 'end': {'line': 1059, 'column': 2}}",play_bmp_sequence.c,"['分配', 'a', '*', 'b', '*', 'c', ' ', '+', ' ', 'add', '大小', '的', '内存', '，', '检查', '有效', '有效性']"
18,18,stbi__malloc_mad4,void *,"void * stbi__malloc_mad4(int a, int b, int c, int d, int add)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}, {'name': 'c', 'type': 'int'}, {'name': 'd', 'type': 'int'}, {'name': 'add', 'type': 'int'}]",验证参数后分配指定大小的内存,"static void *stbi__malloc_mad4(int a, int b, int c, int d, int add)
{
   if (!stbi__mad4sizes_valid(a, b, c, d, add)) return NULL;
   return stbi__malloc(a*b*c*d + add);
}","{'begin': {'line': 1062, 'column': 1}, 'end': {'line': 1066, 'column': 2}}",play_bmp_sequence.c,"['验证', '参数', '后', '分配', '指定', '大小', '的', '内存']"
19,19,stbi__addints_valid,int,"int stbi__addints_valid(int a, int b)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}]",检查两个整数相加是否溢出,"static int stbi__addints_valid(int a, int b)
{
   if ((a >= 0) != (b >= 0)) return 1; // a and b have different signs, so no overflow
   if (a < 0 && b < 0) return a >= INT_MIN - b; // same as a + b >= INT_MIN; INT_MIN - b cannot overflow since b < 0.
   return a <= INT_MAX - b;
}","{'begin': {'line': 1070, 'column': 1}, 'end': {'line': 1075, 'column': 2}}",play_bmp_sequence.c,"['检查', '两个', '整数', '相加', '是否', '溢出']"
20,20,stbi__mul2shorts_valid,int,"int stbi__mul2shorts_valid(int a, int b)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}]",检查两数相乘结果是否在short范围内,"static int stbi__mul2shorts_valid(int a, int b)
{
   if (b == 0 || b == -1) return 1; // multiplication by 0 is always 0; check for -1 so SHRT_MIN/b doesn't overflow
   if ((a >= 0) == (b >= 0)) return a <= SHRT_MAX/b; // product is positive, so similar to mul2sizes_valid
   if (b < 0) return a <= SHRT_MIN / b; // same as a * b >= SHRT_MIN
   return a >= SHRT_MIN / b;
}","{'begin': {'line': 1078, 'column': 1}, 'end': {'line': 1084, 'column': 2}}",play_bmp_sequence.c,"['检查', '两', '数', '相乘', '结果', '是否', '在', 'short', '范围', '内']"
21,21,stbi_image_free,void,void stbi_image_free(void * retval_from_stbi_load),"[{'name': 'retval_from_stbi_load', 'type': 'void *'}]",释放由stbi_load加载的图像内存,"STBIDEF void stbi_image_free(void *retval_from_stbi_load)
{
   STBI_FREE(retval_from_stbi_load);
}","{'begin': {'line': 1101, 'column': 1}, 'end': {'line': 1104, 'column': 2}}",play_bmp_sequence.c,"['释放', '由', 'stbi', '_', 'load', '加载', '的', '图像', '内存']"
22,22,stbi_set_flip_vertically_on_load,void,void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip),"[{'name': 'flag_true_if_should_flip', 'type': 'int'}]",设置图像加载时垂直翻转标志,"STBIDEF void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip)
{
   stbi__vertically_flip_on_load_global = flag_true_if_should_flip;
}","{'begin': {'line': 1116, 'column': 1}, 'end': {'line': 1119, 'column': 2}}",play_bmp_sequence.c,"['设置', '图像', '加载', '时', '垂直', '翻转', '标志']"
23,23,stbi_set_flip_vertically_on_load_thread,void,void stbi_set_flip_vertically_on_load_thread(int flag_true_if_should_flip),"[{'name': 'flag_true_if_should_flip', 'type': 'int'}]",设置加载图像时垂直翻转的线程局部标志,"STBIDEF void stbi_set_flip_vertically_on_load_thread(int flag_true_if_should_flip)
{
   stbi__vertically_flip_on_load_local = flag_true_if_should_flip;
   stbi__vertically_flip_on_load_set = 1;
}","{'begin': {'line': 1126, 'column': 1}, 'end': {'line': 1130, 'column': 2}}",play_bmp_sequence.c,"['设置', '加载', '图像', '时', '垂直', '翻转', '的', '线程', '局部', '标志']"
24,24,stbi__load_main,void *,"void * stbi__load_main(stbi__context * s, int * x, int * y, int * comp, int req_comp, stbi__result_info * ri, int bpc)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'ri', 'type': 'stbi__result_info *'}, {'name': 'bpc', 'type': 'int'}]",自动检测并加载支持的图像格式数据。,"static void *stbi__load_main(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)
{
   memset(ri, 0, sizeof(*ri)); // make sure it's initialized if we add new fields
   ri->bits_per_channel = 8; // default is 8 so most paths don't have to be changed
   ri->channel_order = STBI_ORDER_RGB; // all current input & output are this, but this is here so we can add BGR order
   ri->num_channels = 0;

   // test the formats with a very explicit header first (at least a FOURCC
   // or distinctive magic number first)
   #ifndef STBI_NO_PNG
   if (stbi__png_test(s))  return stbi__png_load(s,x,y,comp,req_comp, ri);
   #endif
   #ifndef STBI_NO_BMP
   if (stbi__bmp_test(s))  return stbi__bmp_load(s,x,y,comp,req_comp, ri);
   #endif
   #ifndef STBI_NO_GIF
   if (stbi__gif_test(s))  return stbi__gif_load(s,x,y,comp,req_comp, ri);
   #endif
   #ifndef STBI_NO_PSD
   if (stbi__psd_test(s))  return stbi__psd_load(s,x,y,comp,req_comp, ri, bpc);
   #else
   STBI_NOTUSED(bpc);
   #endif
   #ifndef STBI_NO_PIC
   if (stbi__pic_test(s))  return stbi__pic_load(s,x,y,comp,req_comp, ri);
   #endif

   // then the formats that can end up attempting to load with just 1 or 2
   // bytes matching expectations; these are prone to false positives, so
   // try them later
   #ifndef STBI_NO_JPEG
   if (stbi__jpeg_test(s)) return stbi__jpeg_load(s,x,y,comp,req_comp, ri);
   #endif
   #ifndef STBI_NO_PNM
   if (stbi__pnm_test(s))  return stbi__pnm_load(s,x,y,comp,req_comp, ri);
   #endif

   #ifndef STBI_NO_HDR
   if (stbi__hdr_test(s)) {
      float *hdr = stbi__hdr_load(s, x,y,comp,req_comp, ri);
      return stbi__hdr_to_ldr(hdr, *x, *y, req_comp ? req_comp : *comp);
   }
   #endif

   #ifndef STBI_NO_TGA
   // test tga last because it's a crappy test!
   if (stbi__tga_test(s))
      return stbi__tga_load(s,x,y,comp,req_comp, ri);
   #endif

   return stbi__errpuc(""unknown image type"", ""Image not of any known type, or corrupt"");
}","{'begin': {'line': 1137, 'column': 1}, 'end': {'line': 1188, 'column': 2}}",play_bmp_sequence.c,"['自动', '动检', '检测', '自动检测', '并', '加载', '支持', '的', '图像', '格式', '图像格式', '数据', '。']"
25,25,stbi__convert_16_to_8,stbi_uc *,"stbi_uc * stbi__convert_16_to_8(stbi__uint16 * orig, int w, int h, int channels)","[{'name': 'orig', 'type': 'stbi__uint16 *'}, {'name': 'w', 'type': 'int'}, {'name': 'h', 'type': 'int'}, {'name': 'channels', 'type': 'int'}]",将16位图像数据转换为8位，释放原内存。,"static stbi_uc *stbi__convert_16_to_8(stbi__uint16 *orig, int w, int h, int channels)
{
   int i;
   int img_len = w * h * channels;
   stbi_uc *reduced;

   reduced = (stbi_uc *) stbi__malloc(img_len);
   if (reduced == NULL) return stbi__errpuc(""outofmem"", ""Out of memory"");

   for (i = 0; i < img_len; ++i)
      reduced[i] = (stbi_uc)((orig[i] >> 8) & 0xFF); // top half of each byte is sufficient approx of 16->8 bit scaling

   STBI_FREE(orig);
   return reduced;
}","{'begin': {'line': 1190, 'column': 1}, 'end': {'line': 1204, 'column': 2}}",play_bmp_sequence.c,"['将', '16', '位', '图像', '数据', '转换', '为', '8', '位', '，', '释放', '原', '内存', '。']"
26,26,stbi__convert_8_to_16,stbi__uint16 *,"stbi__uint16 * stbi__convert_8_to_16(stbi_uc * orig, int w, int h, int channels)","[{'name': 'orig', 'type': 'stbi_uc *'}, {'name': 'w', 'type': 'int'}, {'name': 'h', 'type': 'int'}, {'name': 'channels', 'type': 'int'}]",将8位像素数据转换为16位并释放原内存,"static stbi__uint16 *stbi__convert_8_to_16(stbi_uc *orig, int w, int h, int channels)
{
   int i;
   int img_len = w * h * channels;
   stbi__uint16 *enlarged;

   enlarged = (stbi__uint16 *) stbi__malloc(img_len*2);
   if (enlarged == NULL) return (stbi__uint16 *) stbi__errpuc(""outofmem"", ""Out of memory"");

   for (i = 0; i < img_len; ++i)
      enlarged[i] = (stbi__uint16)((orig[i] << 8) + orig[i]); // replicate to high and low byte, maps 0->0, 255->0xffff

   STBI_FREE(orig);
   return enlarged;
}","{'begin': {'line': 1206, 'column': 1}, 'end': {'line': 1220, 'column': 2}}",play_bmp_sequence.c,"['将', '8', '位', '像素', '数据', '转换', '为', '16', '位', '并', '释放', '原', '内存']"
27,27,stbi__vertical_flip,void,"void stbi__vertical_flip(void * image, int w, int h, int bytes_per_pixel)","[{'name': 'image', 'type': 'void *'}, {'name': 'w', 'type': 'int'}, {'name': 'h', 'type': 'int'}, {'name': 'bytes_per_pixel', 'type': 'int'}]",垂直翻转图像数据的内存块,"static void stbi__vertical_flip(void *image, int w, int h, int bytes_per_pixel)
{
   int row;
   size_t bytes_per_row = (size_t)w * bytes_per_pixel;
   stbi_uc temp[2048];
   stbi_uc *bytes = (stbi_uc *)image;

   for (row = 0; row < (h>>1); row++) {
      stbi_uc *row0 = bytes + row*bytes_per_row;
      stbi_uc *row1 = bytes + (h - row - 1)*bytes_per_row;
      // swap row0 with row1
      size_t bytes_left = bytes_per_row;
      while (bytes_left) {
         size_t bytes_copy = (bytes_left < sizeof(temp)) ? bytes_left : sizeof(temp);
         memcpy(temp, row0, bytes_copy);
         memcpy(row0, row1, bytes_copy);
         memcpy(row1, temp, bytes_copy);
         row0 += bytes_copy;
         row1 += bytes_copy;
         bytes_left -= bytes_copy;
      }
   }
}","{'begin': {'line': 1222, 'column': 1}, 'end': {'line': 1244, 'column': 2}}",play_bmp_sequence.c,"['垂直', '翻转', '图像', '数据', '的', '内存', '块']"
28,28,stbi__vertical_flip_slices,void,"void stbi__vertical_flip_slices(void * image, int w, int h, int z, int bytes_per_pixel)","[{'name': 'image', 'type': 'void *'}, {'name': 'w', 'type': 'int'}, {'name': 'h', 'type': 'int'}, {'name': 'z', 'type': 'int'}, {'name': 'bytes_per_pixel', 'type': 'int'}]",对图像的每个切片进行垂直翻转处理,"static void stbi__vertical_flip_slices(void *image, int w, int h, int z, int bytes_per_pixel)
{
   int slice;
   int slice_size = w * h * bytes_per_pixel;

   stbi_uc *bytes = (stbi_uc *)image;
   for (slice = 0; slice < z; ++slice) {
      stbi__vertical_flip(bytes, w, h, bytes_per_pixel);
      bytes += slice_size;
   }
}","{'begin': {'line': 1247, 'column': 1}, 'end': {'line': 1257, 'column': 2}}",play_bmp_sequence.c,"['对', '图像', '的', '每个', '切片', '进行', '垂直', '翻转', '处理']"
29,29,stbi__load_and_postprocess_8bit,unsigned char *,"unsigned char * stbi__load_and_postprocess_8bit(stbi__context * s, int * x, int * y, int * comp, int req_comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",加载图像并处理为8位，支持垂直翻转,"static unsigned char *stbi__load_and_postprocess_8bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
   stbi__result_info ri;
   void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 8);

   if (result == NULL)
      return NULL;

   // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.
   STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);

   if (ri.bits_per_channel != 8) {
      result = stbi__convert_16_to_8((stbi__uint16 *) result, *x, *y, req_comp == 0 ? *comp : req_comp);
      ri.bits_per_channel = 8;
   }

   // @TODO: move stbi__convert_format to here

   if (stbi__vertically_flip_on_load) {
      int channels = req_comp ? req_comp : *comp;
      stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi_uc));
   }

   return (unsigned char *) result;
}","{'begin': {'line': 1260, 'column': 1}, 'end': {'line': 1284, 'column': 2}}",play_bmp_sequence.c,"['加载', '图像', '并', '处理', '为', '8', '位', '，', '支持', '垂直', '翻转']"
30,30,stbi__load_and_postprocess_16bit,stbi__uint16 *,"stbi__uint16 * stbi__load_and_postprocess_16bit(stbi__context * s, int * x, int * y, int * comp, int req_comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",加载16位图像，支持位深转换与垂直翻转,"static stbi__uint16 *stbi__load_and_postprocess_16bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
   stbi__result_info ri;
   void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 16);

   if (result == NULL)
      return NULL;

   // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.
   STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);

   if (ri.bits_per_channel != 16) {
      result = stbi__convert_8_to_16((stbi_uc *) result, *x, *y, req_comp == 0 ? *comp : req_comp);
      ri.bits_per_channel = 16;
   }

   // @TODO: move stbi__convert_format16 to here
   // @TODO: special case RGB-to-Y (and RGBA-to-YA) for 8-bit-to-16-bit case to keep more precision

   if (stbi__vertically_flip_on_load) {
      int channels = req_comp ? req_comp : *comp;
      stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi__uint16));
   }

   return (stbi__uint16 *) result;
}","{'begin': {'line': 1286, 'column': 1}, 'end': {'line': 1311, 'column': 2}}",play_bmp_sequence.c,"['加载', '16', '位', '图像', '，', '支持', '位深', '转换', '与', '垂直', '翻转']"
31,31,stbi__float_postprocess,void,"void stbi__float_postprocess(float * result, int * x, int * y, int * comp, int req_comp)","[{'name': 'result', 'type': 'float *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",根据配置对浮点图像数据进行垂直翻转处理,"static void stbi__float_postprocess(float *result, int *x, int *y, int *comp, int req_comp)
{
   if (stbi__vertically_flip_on_load && result != NULL) {
      int channels = req_comp ? req_comp : *comp;
      stbi__vertical_flip(result, *x, *y, channels * sizeof(float));
   }
}","{'begin': {'line': 1314, 'column': 1}, 'end': {'line': 1320, 'column': 2}}",play_bmp_sequence.c,"['根据', '配置', '对', '浮点', '图像', '数据', '进行', '垂直', '翻转', '处理']"
32,32,stbi__fopen,FILE *,"FILE * stbi__fopen(const char * filename, const char * mode)","[{'name': 'filename', 'type': 'const char *'}, {'name': 'mode', 'type': 'const char *'}]",跨平台安全打开文件，支持UTF-8路径,"static FILE *stbi__fopen(char const *filename, char const *mode)
{
   FILE *f;
#if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
   wchar_t wMode[64];
   wchar_t wFilename[1024];
	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, filename, -1, wFilename, sizeof(wFilename)/sizeof(*wFilename)))
      return 0;

	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, mode, -1, wMode, sizeof(wMode)/sizeof(*wMode)))
      return 0;

#if defined(_MSC_VER) && _MSC_VER >= 1400
	if (0 != _wfopen_s(&f, wFilename, wMode))
		f = 0;
#else
   f = _wfopen(wFilename, wMode);
#endif

#elif defined(_MSC_VER) && _MSC_VER >= 1400
   if (0 != fopen_s(&f, filename, mode))
      f=0;
#else
   f = fopen(filename, mode);
#endif
   return f;
}","{'begin': {'line': 1337, 'column': 1}, 'end': {'line': 1363, 'column': 2}}",play_bmp_sequence.c,"['平台', '跨平台', '安全', '打开', '文件', '，', '支持', 'UTF', '-', '8', '路径']"
33,33,stbi__sse2_available,int,int stbi__sse2_available(),[],检测SSE2指令集支持状态并返回可用性,"static int stbi__sse2_available(void)
{
   // If we're even attempting to compile this on GCC/Clang, that means
   // -msse2 is on, which means the compiler is allowed to use SSE2
   // instructions at will, and so are we.
   return 1;
}","{'begin': {'line': 765, 'column': 1}, 'end': {'line': 771, 'column': 2}}",play_bmp_sequence.c,"['检测', 'SSE2', '指令', '指令集', '支持', '状态', '并', '返回', '可用', '可用性']"
34,34,stbi_load,stbi_uc *,"stbi_uc * stbi_load(const char * filename, int * x, int * y, int * comp, int req_comp)","[{'name': 'filename', 'type': 'const char *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",加载图像文件数据，返回像素指针及尺寸信息。,"STBIDEF stbi_uc *stbi_load(char const *filename, int *x, int *y, int *comp, int req_comp)
{
   FILE *f = stbi__fopen(filename, ""rb"");
   unsigned char *result;
   if (!f) return stbi__errpuc(""can't fopen"", ""Unable to open file"");
   result = stbi_load_from_file(f,x,y,comp,req_comp);
   fclose(f);
   return result;
}","{'begin': {'line': 1366, 'column': 1}, 'end': {'line': 1374, 'column': 2}}",play_bmp_sequence.c,"['加载', '图像', '文件', '图像文件', '数据', '，', '返回', '像素', '指针', '及', '尺寸', '信息', '。']"
35,35,stbi__start_mem,void,"void stbi__start_mem(stbi__context * s, const stbi_uc * buffer, int len)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'buffer', 'type': 'const stbi_uc *'}, {'name': 'len', 'type': 'int'}]",初始化内存读取上下文，设置缓冲区起始和结束位置,"static void stbi__start_mem(stbi__context *s, stbi_uc const *buffer, int len)
{
   s->io.read = NULL;
   s->read_from_callbacks = 0;
   s->callback_already_read = 0;
   s->img_buffer = s->img_buffer_original = (stbi_uc *) buffer;
   s->img_buffer_end = s->img_buffer_original_end = (stbi_uc *) buffer+len;
}","{'begin': {'line': 826, 'column': 1}, 'end': {'line': 833, 'column': 2}}",play_bmp_sequence.c,"['初始', '初始化', '内存', '读取', '上下', '下文', '上下文', '，', '设置', '缓冲', '缓冲区', '起始', '和', '结束', '位置']"
36,36,stbi_load_from_file,stbi_uc *,"stbi_uc * stbi_load_from_file(FILE * f, int * x, int * y, int * comp, int req_comp)","[{'name': 'f', 'type': 'FILE *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",从文件指针加载图像数据，并调整文件指针位置,"STBIDEF stbi_uc *stbi_load_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
{
   unsigned char *result;
   stbi__context s;
   stbi__start_file(&s,f);
   result = stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
   if (result) {
      // need to 'unget' all the characters in the IO buffer
      fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);
   }
   return result;
}","{'begin': {'line': 1376, 'column': 1}, 'end': {'line': 1387, 'column': 2}}",play_bmp_sequence.c,"['文件', '从文件', '指针', '加载', '图像', '数据', '，', '并', '调整', '文件', '指针', '位置']"
37,37,stbi__start_callbacks,void,"void stbi__start_callbacks(stbi__context * s, stbi_io_callbacks * c, void * user)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'c', 'type': 'stbi_io_callbacks *'}, {'name': 'user', 'type': 'void *'}]",初始化上下文回调接口及缓冲区,"static void stbi__start_callbacks(stbi__context *s, stbi_io_callbacks *c, void *user)
{
   s->io = *c;
   s->io_user_data = user;
   s->buflen = sizeof(s->buffer_start);
   s->read_from_callbacks = 1;
   s->callback_already_read = 0;
   s->img_buffer = s->img_buffer_original = s->buffer_start;
   stbi__refill_buffer(s);
   s->img_buffer_original_end = s->img_buffer_end;
}","{'begin': {'line': 836, 'column': 1}, 'end': {'line': 846, 'column': 2}}",play_bmp_sequence.c,"['初始', '初始化', '上下', '下文', '上下文', '回调', '接口', '及', '缓冲', '缓冲区']"
38,38,stbi_load_from_file_16,stbi_us *,"stbi_us * stbi_load_from_file_16(FILE * f, int * x, int * y, int * comp, int req_comp)","[{'name': 'f', 'type': 'FILE *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",从文件加载16位图像数据并调整文件指针,"STBIDEF stbi__uint16 *stbi_load_from_file_16(FILE *f, int *x, int *y, int *comp, int req_comp)
{
   stbi__uint16 *result;
   stbi__context s;
   stbi__start_file(&s,f);
   result = stbi__load_and_postprocess_16bit(&s,x,y,comp,req_comp);
   if (result) {
      // need to 'unget' all the characters in the IO buffer
      fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);
   }
   return result;
}","{'begin': {'line': 1389, 'column': 1}, 'end': {'line': 1400, 'column': 2}}",play_bmp_sequence.c,"['文件', '从文件', '加载', '16', '位', '图像', '数据', '并', '调整', '文件', '指针']"
39,39,stbi_load_16,stbi_us *,"stbi_us * stbi_load_16(const char * filename, int * x, int * y, int * comp, int req_comp)","[{'name': 'filename', 'type': 'const char *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",加载16位图像文件，返回宽高及通道数,"STBIDEF stbi_us *stbi_load_16(char const *filename, int *x, int *y, int *comp, int req_comp)
{
   FILE *f = stbi__fopen(filename, ""rb"");
   stbi__uint16 *result;
   if (!f) return (stbi_us *) stbi__errpuc(""can't fopen"", ""Unable to open file"");
   result = stbi_load_from_file_16(f,x,y,comp,req_comp);
   fclose(f);
   return result;
}","{'begin': {'line': 1402, 'column': 1}, 'end': {'line': 1410, 'column': 2}}",play_bmp_sequence.c,"['加载', '16', '位', '图像', '文件', '图像文件', '，', '返回', '宽高及', '通道', '数']"
40,40,stbi__stdio_read,int,"int stbi__stdio_read(void * user, char * data, int size)","[{'name': 'user', 'type': 'void *'}, {'name': 'data', 'type': 'char *'}, {'name': 'size', 'type': 'int'}]",使用fread读取指定大小的数据到缓冲区,"static int stbi__stdio_read(void *user, char *data, int size)
{
   return (int) fread(data,1,size,(FILE*) user);
}","{'begin': {'line': 850, 'column': 1}, 'end': {'line': 853, 'column': 2}}",play_bmp_sequence.c,"['使用', 'fread', '读取', '指定', '大小', '的', '数据', '到', '缓冲', '缓冲区']"
41,41,stbi__stdio_skip,void,"void stbi__stdio_skip(void * user, int n)","[{'name': 'user', 'type': 'void *'}, {'name': 'n', 'type': 'int'}]",跳过指定字节数并重置文件结束标志,"static void stbi__stdio_skip(void *user, int n)
{
   int ch;
   fseek((FILE*) user, n, SEEK_CUR);
   ch = fgetc((FILE*) user);  /* have to read a byte to reset feof()'s flag */
   if (ch != EOF) {
      ungetc(ch, (FILE *) user);  /* push byte back onto stream if valid. */
   }
}","{'begin': {'line': 855, 'column': 1}, 'end': {'line': 863, 'column': 2}}",play_bmp_sequence.c,"['跳过', '指定', '字节', '节数', '字节数', '并', '重置', '文件', '结束', '标志']"
42,42,stbi_load_16_from_memory,stbi_us *,"stbi_us * stbi_load_16_from_memory(const stbi_uc * buffer, int len, int * x, int * y, int * channels_in_file, int desired_channels)","[{'name': 'buffer', 'type': 'const stbi_uc *'}, {'name': 'len', 'type': 'int'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'channels_in_file', 'type': 'int *'}, {'name': 'desired_channels', 'type': 'int'}]",从内存加载16位图像数据，支持通道数转换,"STBIDEF stbi_us *stbi_load_16_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);
}","{'begin': {'line': 1415, 'column': 1}, 'end': {'line': 1420, 'column': 2}}",play_bmp_sequence.c,"['从', '内存', '加载', '16', '位', '图像', '数据', '，', '支持', '通道', '数', '转换']"
43,43,stbi__stdio_eof,int,int stbi__stdio_eof(void * user),"[{'name': 'user', 'type': 'void *'}]",检查文件流结束或错误状态,"static int stbi__stdio_eof(void *user)
{
   return feof((FILE*) user) || ferror((FILE *) user);
}","{'begin': {'line': 865, 'column': 1}, 'end': {'line': 868, 'column': 2}}",play_bmp_sequence.c,"['检查', '文件', '流', '结束', '或', '错误', '状态']"
44,44,stbi_load_16_from_callbacks,stbi_us *,"stbi_us * stbi_load_16_from_callbacks(const stbi_io_callbacks * clbk, void * user, int * x, int * y, int * channels_in_file, int desired_channels)","[{'name': 'clbk', 'type': 'const stbi_io_callbacks *'}, {'name': 'user', 'type': 'void *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'channels_in_file', 'type': 'int *'}, {'name': 'desired_channels', 'type': 'int'}]",通过回调加载并处理16位图像数据,"STBIDEF stbi_us *stbi_load_16_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *channels_in_file, int desired_channels)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *)clbk, user);
   return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);
}","{'begin': {'line': 1422, 'column': 1}, 'end': {'line': 1427, 'column': 2}}",play_bmp_sequence.c,"['通过', '回调', '加载', '并', '处理', '16', '位', '图像', '数据']"
45,45,stbi__start_file,void,"void stbi__start_file(stbi__context * s, FILE * f)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'f', 'type': 'FILE *'}]",使用标准IO回调初始化文件处理上下文,"static void stbi__start_file(stbi__context *s, FILE *f)
{
   stbi__start_callbacks(s, &stbi__stdio_callbacks, (void *) f);
}","{'begin': {'line': 877, 'column': 1}, 'end': {'line': 880, 'column': 2}}",play_bmp_sequence.c,"['使用', '标准', 'IO', '回调', '初始', '初始化', '文件', '处理', '上下', '下文', '上下文']"
46,46,stbi__rewind,void,void stbi__rewind(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",重置图像缓冲区到初始位置,"static void stbi__rewind(stbi__context *s)
{
   // conceptually rewind SHOULD rewind to the beginning of the stream,
   // but we just rewind to the beginning of the initial buffer, because
   // we only use it after doing 'test', which only ever looks at at most 92 bytes
   s->img_buffer = s->img_buffer_original;
   s->img_buffer_end = s->img_buffer_original_end;
}","{'begin': {'line': 886, 'column': 1}, 'end': {'line': 893, 'column': 2}}",play_bmp_sequence.c,"['重置', '图像', '缓冲', '缓冲区', '到', '初始', '位置']"
47,47,stbi_load_from_memory,stbi_uc *,"stbi_uc * stbi_load_from_memory(const stbi_uc * buffer, int len, int * x, int * y, int * comp, int req_comp)","[{'name': 'buffer', 'type': 'const stbi_uc *'}, {'name': 'len', 'type': 'int'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",从内存加载图像数据并解码为8位像素,"STBIDEF stbi_uc *stbi_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
}","{'begin': {'line': 1429, 'column': 1}, 'end': {'line': 1434, 'column': 2}}",play_bmp_sequence.c,"['从', '内存', '加载', '图像', '数据', '并', '解码', '为', '8', '位', '像素']"
48,48,stbi_load_from_callbacks,stbi_uc *,"stbi_uc * stbi_load_from_callbacks(const stbi_io_callbacks * clbk, void * user, int * x, int * y, int * comp, int req_comp)","[{'name': 'clbk', 'type': 'const stbi_io_callbacks *'}, {'name': 'user', 'type': 'void *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",通过回调加载图像数据并返回像素指针,"STBIDEF stbi_uc *stbi_load_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
}","{'begin': {'line': 1436, 'column': 1}, 'end': {'line': 1441, 'column': 2}}",play_bmp_sequence.c,"['通过', '回调', '加载', '图像', '数据', '并', '返回', '像素', '指针']"
49,49,stbi_load_gif_from_memory,stbi_uc *,"stbi_uc * stbi_load_gif_from_memory(const stbi_uc * buffer, int len, int ** delays, int * x, int * y, int * z, int * comp, int req_comp)","[{'name': 'buffer', 'type': 'const stbi_uc *'}, {'name': 'len', 'type': 'int'}, {'name': 'delays', 'type': 'int **'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'z', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",从内存加载GIF图像，支持多帧及延迟时间，可垂直翻转,"STBIDEF stbi_uc *stbi_load_gif_from_memory(stbi_uc const *buffer, int len, int **delays, int *x, int *y, int *z, int *comp, int req_comp)
{
   unsigned char *result;
   stbi__context s;
   stbi__start_mem(&s,buffer,len);

   result = (unsigned char*) stbi__load_gif_main(&s, delays, x, y, z, comp, req_comp);
   if (stbi__vertically_flip_on_load) {
      stbi__vertical_flip_slices( result, *x, *y, *z, *comp );
   }

   return result;
}","{'begin': {'line': 1444, 'column': 1}, 'end': {'line': 1456, 'column': 2}}",play_bmp_sequence.c,"['从', '内存', '加载', 'GIF', '图像', '，', '支持', '多', '帧', '及', '延迟', '时间', '延迟时间', '，', '可', '垂直', '翻转']"
50,50,stbi_failure_reason,const char *,const char * stbi_failure_reason(),[],返回最近一次加载失败的错误原因描述,"STBIDEF const char *stbi_failure_reason(void)
{
   return stbi__g_failure_reason;
}","{'begin': {'line': 972, 'column': 1}, 'end': {'line': 975, 'column': 2}}",play_bmp_sequence.c,"['返回', '最近', '一次', '加载', '失败', '的', '错误', '原因', '描述']"
51,51,stbi__loadf_main,float *,"float * stbi__loadf_main(stbi__context * s, int * x, int * y, int * comp, int req_comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",加载图像数据并转换为浮点数组，支持HDR和LDR格式,"static float *stbi__loadf_main(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
   unsigned char *data;
   #ifndef STBI_NO_HDR
   if (stbi__hdr_test(s)) {
      stbi__result_info ri;
      float *hdr_data = stbi__hdr_load(s,x,y,comp,req_comp, &ri);
      if (hdr_data)
         stbi__float_postprocess(hdr_data,x,y,comp,req_comp);
      return hdr_data;
   }
   #endif
   data = stbi__load_and_postprocess_8bit(s, x, y, comp, req_comp);
   if (data)
      return stbi__ldr_to_hdr(data, *x, *y, req_comp ? req_comp : *comp);
   return stbi__errpf(""unknown image type"", ""Image not of any known type, or corrupt"");
}","{'begin': {'line': 1460, 'column': 1}, 'end': {'line': 1476, 'column': 2}}",play_bmp_sequence.c,"['加载', '图像', '数据', '并', '转换', '为', '浮点', '数组', '，', '支持', 'HDR', '和', 'LDR', '格式']"
52,52,stbi__err,int,int stbi__err(const char * str),"[{'name': 'str', 'type': 'const char *'}]",设置全局错误信息并返回0,"static int stbi__err(const char *str)
{
   stbi__g_failure_reason = str;
   return 0;
}","{'begin': {'line': 978, 'column': 1}, 'end': {'line': 982, 'column': 2}}",play_bmp_sequence.c,"['设置', '全局', '错误', '误信', '信息', '错误信息', '并', '返回', '0']"
53,53,stbi__malloc,void *,void * stbi__malloc(int size),"[{'name': 'size', 'type': 'int'}]",调用STBI_MALLOC宏分配指定大小的内存块,"static void *stbi__malloc(size_t size)
{
    return STBI_MALLOC(size);
}","{'begin': {'line': 985, 'column': 1}, 'end': {'line': 988, 'column': 2}}",play_bmp_sequence.c,"['调用', 'STBI', '_', 'MALLOC', '宏', '分配', '指定', '大小', '的', '内存', '块']"
54,54,stbi__addsizes_valid,int,"int stbi__addsizes_valid(int a, int b)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}]",检查两个整数相加是否溢出,"static int stbi__addsizes_valid(int a, int b)
{
   if (b < 0) return 0;
   // now 0 <= b <= INT_MAX, hence also
   // 0 <= INT_MAX - b <= INTMAX.
   // And ""a + b <= INT_MAX"" (which might overflow) is the
   // same as a <= INT_MAX - b (no overflow)
   return a <= INT_MAX - b;
}","{'begin': {'line': 1002, 'column': 1}, 'end': {'line': 1010, 'column': 2}}",play_bmp_sequence.c,"['检查', '两个', '整数', '相加', '是否', '溢出']"
55,55,stbi__mul2sizes_valid,int,"int stbi__mul2sizes_valid(int a, int b)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}]",检查两整数相乘是否溢出,"static int stbi__mul2sizes_valid(int a, int b)
{
   if (a < 0 || b < 0) return 0;
   if (b == 0) return 1; // mul-by-0 is always safe
   // portable way to check for no overflows in a*b
   return a <= INT_MAX/b;
}","{'begin': {'line': 1014, 'column': 1}, 'end': {'line': 1020, 'column': 2}}",play_bmp_sequence.c,"['检查', '两', '整数', '相乘', '是否', '溢出']"
56,56,stbi_loadf_from_memory,float *,"float * stbi_loadf_from_memory(const stbi_uc * buffer, int len, int * x, int * y, int * comp, int req_comp)","[{'name': 'buffer', 'type': 'const stbi_uc *'}, {'name': 'len', 'type': 'int'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",从内存加载浮点格式图像数据。,"STBIDEF float *stbi_loadf_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__loadf_main(&s,x,y,comp,req_comp);
}","{'begin': {'line': 1478, 'column': 1}, 'end': {'line': 1483, 'column': 2}}",play_bmp_sequence.c,"['从', '内存', '加载', '浮点', '格式', '图像', '数据', '。']"
57,57,stbi__mad2sizes_valid,int,"int stbi__mad2sizes_valid(int a, int b, int add)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}, {'name': 'add', 'type': 'int'}]",验证乘法和加法运算的有效性,"static int stbi__mad2sizes_valid(int a, int b, int add)
{
   return stbi__mul2sizes_valid(a, b) && stbi__addsizes_valid(a*b, add);
}","{'begin': {'line': 1024, 'column': 1}, 'end': {'line': 1027, 'column': 2}}",play_bmp_sequence.c,"['验证', '乘法', '和', '加法', '运算', '的', '有效', '有效性']"
58,58,stbi_loadf_from_callbacks,float *,"float * stbi_loadf_from_callbacks(const stbi_io_callbacks * clbk, void * user, int * x, int * y, int * comp, int req_comp)","[{'name': 'clbk', 'type': 'const stbi_io_callbacks *'}, {'name': 'user', 'type': 'void *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",通过回调加载浮点格式图像数据,"STBIDEF float *stbi_loadf_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi__loadf_main(&s,x,y,comp,req_comp);
}","{'begin': {'line': 1485, 'column': 1}, 'end': {'line': 1490, 'column': 2}}",play_bmp_sequence.c,"['通过', '回调', '加载', '浮点', '格式', '图像', '数据']"
59,59,stbi__mad3sizes_valid,int,"int stbi__mad3sizes_valid(int a, int b, int c, int add)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}, {'name': 'c', 'type': 'int'}, {'name': 'add', 'type': 'int'}]",检查三个数乘积与加法是否有效防止溢出,"static int stbi__mad3sizes_valid(int a, int b, int c, int add)
{
   return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&
      stbi__addsizes_valid(a*b*c, add);
}","{'begin': {'line': 1031, 'column': 1}, 'end': {'line': 1035, 'column': 2}}",play_bmp_sequence.c,"['检查', '三个', '数', '乘积', '与', '加法', '是否', '有效', '防止', '溢出']"
60,60,stbi_loadf,float *,"float * stbi_loadf(const char * filename, int * x, int * y, int * comp, int req_comp)","[{'name': 'filename', 'type': 'const char *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",加载浮点图像文件，返回宽高及通道信息,"STBIDEF float *stbi_loadf(char const *filename, int *x, int *y, int *comp, int req_comp)
{
   float *result;
   FILE *f = stbi__fopen(filename, ""rb"");
   if (!f) return stbi__errpf(""can't fopen"", ""Unable to open file"");
   result = stbi_loadf_from_file(f,x,y,comp,req_comp);
   fclose(f);
   return result;
}","{'begin': {'line': 1493, 'column': 1}, 'end': {'line': 1501, 'column': 2}}",play_bmp_sequence.c,"['加载', '浮点', '图像', '文件', '图像文件', '，', '返回', '宽高及', '通道', '信息']"
61,61,stbi__mad4sizes_valid,int,"int stbi__mad4sizes_valid(int a, int b, int c, int d, int add)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}, {'name': 'c', 'type': 'int'}, {'name': 'd', 'type': 'int'}, {'name': 'add', 'type': 'int'}]",检查四数相乘加某值是否有效,"static int stbi__mad4sizes_valid(int a, int b, int c, int d, int add)
{
   return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&
      stbi__mul2sizes_valid(a*b*c, d) && stbi__addsizes_valid(a*b*c*d, add);
}","{'begin': {'line': 1039, 'column': 1}, 'end': {'line': 1043, 'column': 2}}",play_bmp_sequence.c,"['检查', '四数', '相乘', '加', '某值', '是否', '有效']"
62,62,stbi_loadf_from_file,float *,"float * stbi_loadf_from_file(FILE * f, int * x, int * y, int * comp, int req_comp)","[{'name': 'f', 'type': 'FILE *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",从文件加载浮点图像数据，返回像素数组,"STBIDEF float *stbi_loadf_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_file(&s,f);
   return stbi__loadf_main(&s,x,y,comp,req_comp);
}","{'begin': {'line': 1503, 'column': 1}, 'end': {'line': 1508, 'column': 2}}",play_bmp_sequence.c,"['文件', '从文件', '加载', '浮点', '图像', '数据', '，', '返回', '像素', '数组']"
63,63,stbi_is_hdr_from_memory,int,"int stbi_is_hdr_from_memory(const stbi_uc * buffer, int len)","[{'name': 'buffer', 'type': 'const stbi_uc *'}, {'name': 'len', 'type': 'int'}]",检测内存中的图像是否为HDR格式,"STBIDEF int stbi_is_hdr_from_memory(stbi_uc const *buffer, int len)
{
   #ifndef STBI_NO_HDR
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__hdr_test(&s);
   #else
   STBI_NOTUSED(buffer);
   STBI_NOTUSED(len);
   return 0;
   #endif
}","{'begin': {'line': 1517, 'column': 1}, 'end': {'line': 1528, 'column': 2}}",play_bmp_sequence.c,"['检测', '内存', '中', '的', '图像', '是否', '为', 'HDR', '格式']"
64,64,stbi__malloc_mad2,void *,"void * stbi__malloc_mad2(int a, int b, int add)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}, {'name': 'add', 'type': 'int'}]",验证并分配a*b加add的内存空间,"static void *stbi__malloc_mad2(int a, int b, int add)
{
   if (!stbi__mad2sizes_valid(a, b, add)) return NULL;
   return stbi__malloc(a*b + add);
}","{'begin': {'line': 1048, 'column': 1}, 'end': {'line': 1052, 'column': 2}}",play_bmp_sequence.c,"['验证', '并', '分配', 'a', '*', 'b', '加', 'add', '的', '内存', '空间', '内存空间']"
65,65,stbi_is_hdr,int,int stbi_is_hdr(const char * filename),"[{'name': 'filename', 'type': 'const char *'}]",检查文件是否为HDR格式,"STBIDEF int      stbi_is_hdr          (char const *filename)
{
   FILE *f = stbi__fopen(filename, ""rb"");
   int result=0;
   if (f) {
      result = stbi_is_hdr_from_file(f);
      fclose(f);
   }
   return result;
}","{'begin': {'line': 1531, 'column': 1}, 'end': {'line': 1540, 'column': 2}}",play_bmp_sequence.c,"['检查', '文件', '是否', '为', 'HDR', '格式']"
66,66,stbi__malloc_mad3,void *,"void * stbi__malloc_mad3(int a, int b, int c, int add)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}, {'name': 'c', 'type': 'int'}, {'name': 'add', 'type': 'int'}]",分配a*b*c + add大小的内存并进行安全校验,"static void *stbi__malloc_mad3(int a, int b, int c, int add)
{
   if (!stbi__mad3sizes_valid(a, b, c, add)) return NULL;
   return stbi__malloc(a*b*c + add);
}","{'begin': {'line': 1055, 'column': 1}, 'end': {'line': 1059, 'column': 2}}",play_bmp_sequence.c,"['分配', 'a', '*', 'b', '*', 'c', ' ', '+', ' ', 'add', '大小', '的', '内存', '并', '进行', '安全', '校验']"
67,67,stbi_is_hdr_from_file,int,int stbi_is_hdr_from_file(FILE * f),"[{'name': 'f', 'type': 'FILE *'}]",检测文件是否为HDR格式图像,"STBIDEF int stbi_is_hdr_from_file(FILE *f)
{
   #ifndef STBI_NO_HDR
   long pos = ftell(f);
   int res;
   stbi__context s;
   stbi__start_file(&s,f);
   res = stbi__hdr_test(&s);
   fseek(f, pos, SEEK_SET);
   return res;
   #else
   STBI_NOTUSED(f);
   return 0;
   #endif
}","{'begin': {'line': 1542, 'column': 1}, 'end': {'line': 1556, 'column': 2}}",play_bmp_sequence.c,"['检测', '文件', '是否', '为', 'HDR', '格式', '图像']"
68,68,stbi__malloc_mad4,void *,"void * stbi__malloc_mad4(int a, int b, int c, int d, int add)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}, {'name': 'c', 'type': 'int'}, {'name': 'd', 'type': 'int'}, {'name': 'add', 'type': 'int'}]",分配四维乘积加add的内存空间,"static void *stbi__malloc_mad4(int a, int b, int c, int d, int add)
{
   if (!stbi__mad4sizes_valid(a, b, c, d, add)) return NULL;
   return stbi__malloc(a*b*c*d + add);
}","{'begin': {'line': 1062, 'column': 1}, 'end': {'line': 1066, 'column': 2}}",play_bmp_sequence.c,"['分配', '四维', '乘积', '加', 'add', '的', '内存', '空间', '内存空间']"
69,69,stbi_is_hdr_from_callbacks,int,"int stbi_is_hdr_from_callbacks(const stbi_io_callbacks * clbk, void * user)","[{'name': 'clbk', 'type': 'const stbi_io_callbacks *'}, {'name': 'user', 'type': 'void *'}]",通过回调检测图像是否为HDR格式,"STBIDEF int      stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user)
{
   #ifndef STBI_NO_HDR
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi__hdr_test(&s);
   #else
   STBI_NOTUSED(clbk);
   STBI_NOTUSED(user);
   return 0;
   #endif
}","{'begin': {'line': 1559, 'column': 1}, 'end': {'line': 1570, 'column': 2}}",play_bmp_sequence.c,"['通过', '回调', '检测', '图像', '是否', '为', 'HDR', '格式']"
70,70,stbi__addints_valid,int,"int stbi__addints_valid(int a, int b)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}]",检查两个整数相加是否溢出,"static int stbi__addints_valid(int a, int b)
{
   if ((a >= 0) != (b >= 0)) return 1; // a and b have different signs, so no overflow
   if (a < 0 && b < 0) return a >= INT_MIN - b; // same as a + b >= INT_MIN; INT_MIN - b cannot overflow since b < 0.
   return a <= INT_MAX - b;
}","{'begin': {'line': 1070, 'column': 1}, 'end': {'line': 1075, 'column': 2}}",play_bmp_sequence.c,"['检查', '两个', '整数', '相加', '是否', '溢出']"
71,71,stbi__mul2shorts_valid,int,"int stbi__mul2shorts_valid(int a, int b)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}]",检查两整数相乘是否在short范围内,"static int stbi__mul2shorts_valid(int a, int b)
{
   if (b == 0 || b == -1) return 1; // multiplication by 0 is always 0; check for -1 so SHRT_MIN/b doesn't overflow
   if ((a >= 0) == (b >= 0)) return a <= SHRT_MAX/b; // product is positive, so similar to mul2sizes_valid
   if (b < 0) return a <= SHRT_MIN / b; // same as a * b >= SHRT_MIN
   return a >= SHRT_MIN / b;
}","{'begin': {'line': 1078, 'column': 1}, 'end': {'line': 1084, 'column': 2}}",play_bmp_sequence.c,"['检查', '两', '整数', '相乘', '是否', '在', 'short', '范围', '内']"
72,72,stbi_ldr_to_hdr_gamma,void,void stbi_ldr_to_hdr_gamma(float gamma),"[{'name': 'gamma', 'type': 'float'}]",设置LDR转HDR的Gamma值,"STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma) { stbi__l2h_gamma = gamma; }
","{'begin': {'line': 1575, 'column': 1}, 'end': {'line': 1575, 'column': 79}}",play_bmp_sequence.c,"['设置', 'LDR', '转', 'HDR', '的', 'Gamma', '值']"
73,73,stbi_ldr_to_hdr_scale,void,void stbi_ldr_to_hdr_scale(float scale),"[{'name': 'scale', 'type': 'float'}]",设置LDR转HDR的缩放比例参数,"STBIDEF void   stbi_ldr_to_hdr_scale(float scale) { stbi__l2h_scale = scale; }
","{'begin': {'line': 1576, 'column': 1}, 'end': {'line': 1576, 'column': 79}}",play_bmp_sequence.c,"['设置', 'LDR', '转', 'HDR', '的', '缩放', '比例', '参数']"
74,74,stbi_image_free,void,void stbi_image_free(void * retval_from_stbi_load),"[{'name': 'retval_from_stbi_load', 'type': 'void *'}]",释放stbi_load加载的图像内存,"STBIDEF void stbi_image_free(void *retval_from_stbi_load)
{
   STBI_FREE(retval_from_stbi_load);
}","{'begin': {'line': 1101, 'column': 1}, 'end': {'line': 1104, 'column': 2}}",play_bmp_sequence.c,"['释放', 'stbi', '_', 'load', '加载', '的', '图像', '内存']"
75,75,stbi_hdr_to_ldr_gamma,void,void stbi_hdr_to_ldr_gamma(float gamma),"[{'name': 'gamma', 'type': 'float'}]",设置HDR转LDR时的伽马校正值,"STBIDEF void   stbi_hdr_to_ldr_gamma(float gamma) { stbi__h2l_gamma_i = 1/gamma; }
","{'begin': {'line': 1581, 'column': 1}, 'end': {'line': 1581, 'column': 83}}",play_bmp_sequence.c,"['设置', 'HDR', '转', 'LDR', '时', '的', '伽马', '校', '正值']"
76,76,stbi_hdr_to_ldr_scale,void,void stbi_hdr_to_ldr_scale(float scale),"[{'name': 'scale', 'type': 'float'}]",设置HDR转LDR的缩放比例,"STBIDEF void   stbi_hdr_to_ldr_scale(float scale) { stbi__h2l_scale_i = 1/scale; }
","{'begin': {'line': 1582, 'column': 1}, 'end': {'line': 1582, 'column': 83}}",play_bmp_sequence.c,"['设置', 'HDR', '转', 'LDR', '的', '缩放', '比例']"
77,77,stbi_set_flip_vertically_on_load,void,void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip),"[{'name': 'flag_true_if_should_flip', 'type': 'int'}]",设置加载图像时是否垂直翻转,"STBIDEF void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip)
{
   stbi__vertically_flip_on_load_global = flag_true_if_should_flip;
}","{'begin': {'line': 1116, 'column': 1}, 'end': {'line': 1119, 'column': 2}}",play_bmp_sequence.c,"['设置', '加载', '图像', '时', '是否', '垂直', '翻转']"
78,78,stbi_set_flip_vertically_on_load_thread,void,void stbi_set_flip_vertically_on_load_thread(int flag_true_if_should_flip),"[{'name': 'flag_true_if_should_flip', 'type': 'int'}]",设置加载图像时垂直翻转状态,"STBIDEF void stbi_set_flip_vertically_on_load_thread(int flag_true_if_should_flip)
{
   stbi__vertically_flip_on_load_local = flag_true_if_should_flip;
   stbi__vertically_flip_on_load_set = 1;
}","{'begin': {'line': 1126, 'column': 1}, 'end': {'line': 1130, 'column': 2}}",play_bmp_sequence.c,"['设置', '加载', '图像', '时', '垂直', '翻转', '状态']"
79,79,stbi__refill_buffer,void,void stbi__refill_buffer(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",重新填充输入缓冲区，处理文件结束情况,"static void stbi__refill_buffer(stbi__context *s)
{
   int n = (s->io.read)(s->io_user_data,(char*)s->buffer_start,s->buflen);
   s->callback_already_read += (int) (s->img_buffer - s->img_buffer_original);
   if (n == 0) {
      // at end of file, treat same as if from memory, but need to handle case
      // where s->img_buffer isn't pointing to safe memory, e.g. 0-byte file
      s->read_from_callbacks = 0;
      s->img_buffer = s->buffer_start;
      s->img_buffer_end = s->buffer_start+1;
      *s->img_buffer = 0;
   } else {
      s->img_buffer = s->buffer_start;
      s->img_buffer_end = s->buffer_start + n;
   }
}","{'begin': {'line': 1597, 'column': 1}, 'end': {'line': 1612, 'column': 2}}",play_bmp_sequence.c,"['重新', '填充', '输入', '缓冲', '缓冲区', '，', '处理', '文件', '结束', '情况']"
80,80,stbi__load_main,void *,"void * stbi__load_main(stbi__context * s, int * x, int * y, int * comp, int req_comp, stbi__result_info * ri, int bpc)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'ri', 'type': 'stbi__result_info *'}, {'name': 'bpc', 'type': 'int'}]",根据图像类型加载对应格式数据,"static void *stbi__load_main(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)
{
   memset(ri, 0, sizeof(*ri)); // make sure it's initialized if we add new fields
   ri->bits_per_channel = 8; // default is 8 so most paths don't have to be changed
   ri->channel_order = STBI_ORDER_RGB; // all current input & output are this, but this is here so we can add BGR order
   ri->num_channels = 0;

   // test the formats with a very explicit header first (at least a FOURCC
   // or distinctive magic number first)
   #ifndef STBI_NO_PNG
   if (stbi__png_test(s))  return stbi__png_load(s,x,y,comp,req_comp, ri);
   #endif
   #ifndef STBI_NO_BMP
   if (stbi__bmp_test(s))  return stbi__bmp_load(s,x,y,comp,req_comp, ri);
   #endif
   #ifndef STBI_NO_GIF
   if (stbi__gif_test(s))  return stbi__gif_load(s,x,y,comp,req_comp, ri);
   #endif
   #ifndef STBI_NO_PSD
   if (stbi__psd_test(s))  return stbi__psd_load(s,x,y,comp,req_comp, ri, bpc);
   #else
   STBI_NOTUSED(bpc);
   #endif
   #ifndef STBI_NO_PIC
   if (stbi__pic_test(s))  return stbi__pic_load(s,x,y,comp,req_comp, ri);
   #endif

   // then the formats that can end up attempting to load with just 1 or 2
   // bytes matching expectations; these are prone to false positives, so
   // try them later
   #ifndef STBI_NO_JPEG
   if (stbi__jpeg_test(s)) return stbi__jpeg_load(s,x,y,comp,req_comp, ri);
   #endif
   #ifndef STBI_NO_PNM
   if (stbi__pnm_test(s))  return stbi__pnm_load(s,x,y,comp,req_comp, ri);
   #endif

   #ifndef STBI_NO_HDR
   if (stbi__hdr_test(s)) {
      float *hdr = stbi__hdr_load(s, x,y,comp,req_comp, ri);
      return stbi__hdr_to_ldr(hdr, *x, *y, req_comp ? req_comp : *comp);
   }
   #endif

   #ifndef STBI_NO_TGA
   // test tga last because it's a crappy test!
   if (stbi__tga_test(s))
      return stbi__tga_load(s,x,y,comp,req_comp, ri);
   #endif

   return stbi__errpuc(""unknown image type"", ""Image not of any known type, or corrupt"");
}","{'begin': {'line': 1137, 'column': 1}, 'end': {'line': 1188, 'column': 2}}",play_bmp_sequence.c,"['根据', '图像', '类型', '加载', '对应', '格式', '数据']"
81,81,stbi__get8,stbi_uc,stbi_uc stbi__get8(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",从缓冲区或回调函数读取下一个字节数据,"static stbi_uc stbi__get8(stbi__context *s)
{
   if (s->img_buffer < s->img_buffer_end)
      return *s->img_buffer++;
   if (s->read_from_callbacks) {
      stbi__refill_buffer(s);
      return *s->img_buffer++;
   }
   return 0;
}","{'begin': {'line': 1614, 'column': 13}, 'end': {'line': 1623, 'column': 2}}",play_bmp_sequence.c,"['从', '缓冲', '缓冲区', '或', '回调', '函数', '读取', '下', '一个', '字节', '数据']"
82,82,stbi__at_eof,int,int stbi__at_eof(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",检查数据流是否已读取到末尾,"static int stbi__at_eof(stbi__context *s)
{
   if (s->io.read) {
      if (!(s->io.eof)(s->io_user_data)) return 0;
      // if feof() is true, check if buffer = end
      // special case: we've only got the special 0 character at the end
      if (s->read_from_callbacks == 0) return 1;
   }

   return s->img_buffer >= s->img_buffer_end;
}","{'begin': {'line': 1628, 'column': 13}, 'end': {'line': 1638, 'column': 2}}",play_bmp_sequence.c,"['检查', '数据', '数据流', '是否', '已', '读取', '到', '末尾']"
83,83,stbi__skip,void,"void stbi__skip(stbi__context * s, int n)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'n', 'type': 'int'}]",跳过输入流中的指定字节数,"static void stbi__skip(stbi__context *s, int n)
{
   if (n == 0) return;  // already there!
   if (n < 0) {
      s->img_buffer = s->img_buffer_end;
      return;
   }
   if (s->io.read) {
      int blen = (int) (s->img_buffer_end - s->img_buffer);
      if (blen < n) {
         s->img_buffer = s->img_buffer_end;
         (s->io.skip)(s->io_user_data, n - blen);
         return;
      }
   }
   s->img_buffer += n;
}","{'begin': {'line': 1644, 'column': 1}, 'end': {'line': 1660, 'column': 2}}",play_bmp_sequence.c,"['跳过', '输入', '流中', '的', '指定', '字节', '节数', '字节数']"
84,84,stbi__convert_16_to_8,stbi_uc *,"stbi_uc * stbi__convert_16_to_8(stbi__uint16 * orig, int w, int h, int channels)","[{'name': 'orig', 'type': 'stbi__uint16 *'}, {'name': 'w', 'type': 'int'}, {'name': 'h', 'type': 'int'}, {'name': 'channels', 'type': 'int'}]",将16位数据转换为8位，取高字节并释放原内存,"static stbi_uc *stbi__convert_16_to_8(stbi__uint16 *orig, int w, int h, int channels)
{
   int i;
   int img_len = w * h * channels;
   stbi_uc *reduced;

   reduced = (stbi_uc *) stbi__malloc(img_len);
   if (reduced == NULL) return stbi__errpuc(""outofmem"", ""Out of memory"");

   for (i = 0; i < img_len; ++i)
      reduced[i] = (stbi_uc)((orig[i] >> 8) & 0xFF); // top half of each byte is sufficient approx of 16->8 bit scaling

   STBI_FREE(orig);
   return reduced;
}","{'begin': {'line': 1190, 'column': 1}, 'end': {'line': 1204, 'column': 2}}",play_bmp_sequence.c,"['将', '16', '位', '数据', '转换', '为', '8', '位', '，', '取', '字节', '高字节', '并', '释放', '原', '内存']"
85,85,stbi__getn,int,"int stbi__getn(stbi__context * s, stbi_uc * buffer, int n)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'buffer', 'type': 'stbi_uc *'}, {'name': 'n', 'type': 'int'}]",从上下文读取指定字节到缓冲区,"static int stbi__getn(stbi__context *s, stbi_uc *buffer, int n)
{
   if (s->io.read) {
      int blen = (int) (s->img_buffer_end - s->img_buffer);
      if (blen < n) {
         int res, count;

         memcpy(buffer, s->img_buffer, blen);

         count = (s->io.read)(s->io_user_data, (char*) buffer + blen, n - blen);
         res = (count == (n-blen));
         s->img_buffer = s->img_buffer_end;
         return res;
      }
   }

   if (s->img_buffer+n <= s->img_buffer_end) {
      memcpy(buffer, s->img_buffer, n);
      s->img_buffer += n;
      return 1;
   } else
      return 0;
}","{'begin': {'line': 1666, 'column': 1}, 'end': {'line': 1688, 'column': 2}}",play_bmp_sequence.c,"['从', '上下', '下文', '上下文', '读取', '指定', '字节', '到', '缓冲', '缓冲区']"
86,86,stbi__convert_8_to_16,stbi__uint16 *,"stbi__uint16 * stbi__convert_8_to_16(stbi_uc * orig, int w, int h, int channels)","[{'name': 'orig', 'type': 'stbi_uc *'}, {'name': 'w', 'type': 'int'}, {'name': 'h', 'type': 'int'}, {'name': 'channels', 'type': 'int'}]",将8位图像数据转换为16位，高、低字节复制。,"static stbi__uint16 *stbi__convert_8_to_16(stbi_uc *orig, int w, int h, int channels)
{
   int i;
   int img_len = w * h * channels;
   stbi__uint16 *enlarged;

   enlarged = (stbi__uint16 *) stbi__malloc(img_len*2);
   if (enlarged == NULL) return (stbi__uint16 *) stbi__errpuc(""outofmem"", ""Out of memory"");

   for (i = 0; i < img_len; ++i)
      enlarged[i] = (stbi__uint16)((orig[i] << 8) + orig[i]); // replicate to high and low byte, maps 0->0, 255->0xffff

   STBI_FREE(orig);
   return enlarged;
}","{'begin': {'line': 1206, 'column': 1}, 'end': {'line': 1220, 'column': 2}}",play_bmp_sequence.c,"['将', '8', '位', '图像', '数据', '转换', '为', '16', '位', '，', '高', '、', '字节', '低字节', '复制', '。']"
87,87,stbi__vertical_flip,void,"void stbi__vertical_flip(void * image, int w, int h, int bytes_per_pixel)","[{'name': 'image', 'type': 'void *'}, {'name': 'w', 'type': 'int'}, {'name': 'h', 'type': 'int'}, {'name': 'bytes_per_pixel', 'type': 'int'}]",垂直翻转图像像素行数据,"static void stbi__vertical_flip(void *image, int w, int h, int bytes_per_pixel)
{
   int row;
   size_t bytes_per_row = (size_t)w * bytes_per_pixel;
   stbi_uc temp[2048];
   stbi_uc *bytes = (stbi_uc *)image;

   for (row = 0; row < (h>>1); row++) {
      stbi_uc *row0 = bytes + row*bytes_per_row;
      stbi_uc *row1 = bytes + (h - row - 1)*bytes_per_row;
      // swap row0 with row1
      size_t bytes_left = bytes_per_row;
      while (bytes_left) {
         size_t bytes_copy = (bytes_left < sizeof(temp)) ? bytes_left : sizeof(temp);
         memcpy(temp, row0, bytes_copy);
         memcpy(row0, row1, bytes_copy);
         memcpy(row1, temp, bytes_copy);
         row0 += bytes_copy;
         row1 += bytes_copy;
         bytes_left -= bytes_copy;
      }
   }
}","{'begin': {'line': 1222, 'column': 1}, 'end': {'line': 1244, 'column': 2}}",play_bmp_sequence.c,"['垂直', '翻转', '图像', '像素', '行', '数据']"
88,88,stbi__get16be,int,int stbi__get16be(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",从上下文读取大端16位整数值,"static int stbi__get16be(stbi__context *s)
{
   int z = stbi__get8(s);
   return (z << 8) + stbi__get8(s);
}","{'begin': {'line': 1694, 'column': 1}, 'end': {'line': 1698, 'column': 2}}",play_bmp_sequence.c,"['从', '上下', '下文', '上下文', '读取', '大端', '16', '位', '整数', '值']"
89,89,stbi__vertical_flip_slices,void,"void stbi__vertical_flip_slices(void * image, int w, int h, int z, int bytes_per_pixel)","[{'name': 'image', 'type': 'void *'}, {'name': 'w', 'type': 'int'}, {'name': 'h', 'type': 'int'}, {'name': 'z', 'type': 'int'}, {'name': 'bytes_per_pixel', 'type': 'int'}]",垂直翻转图像数据的每个切片层,"static void stbi__vertical_flip_slices(void *image, int w, int h, int z, int bytes_per_pixel)
{
   int slice;
   int slice_size = w * h * bytes_per_pixel;

   stbi_uc *bytes = (stbi_uc *)image;
   for (slice = 0; slice < z; ++slice) {
      stbi__vertical_flip(bytes, w, h, bytes_per_pixel);
      bytes += slice_size;
   }
}","{'begin': {'line': 1247, 'column': 1}, 'end': {'line': 1257, 'column': 2}}",play_bmp_sequence.c,"['垂直', '翻转', '图像', '数据', '的', '每个', '切片', '层']"
90,90,stbi__get32be,stbi__uint32,stbi__uint32 stbi__get32be(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",从大端字节流读取32位无符号整数,"static stbi__uint32 stbi__get32be(stbi__context *s)
{
   stbi__uint32 z = stbi__get16be(s);
   return (z << 16) + stbi__get16be(s);
}","{'begin': {'line': 1704, 'column': 1}, 'end': {'line': 1708, 'column': 2}}",play_bmp_sequence.c,"['大端', '从大端', '字节', '流', '读取', '32', '位', '无', '符号', '整数']"
91,91,stbi__get16le,int,int stbi__get16le(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",以小端序读取16位整数值,"static int stbi__get16le(stbi__context *s)
{
   int z = stbi__get8(s);
   return z + (stbi__get8(s) << 8);
}","{'begin': {'line': 1714, 'column': 1}, 'end': {'line': 1718, 'column': 2}}",play_bmp_sequence.c,"['以小端序', '读取', '16', '位', '整数', '值']"
92,92,stbi__load_and_postprocess_8bit,unsigned char *,"unsigned char * stbi__load_and_postprocess_8bit(stbi__context * s, int * x, int * y, int * comp, int req_comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",加载图像并转换为8位，支持垂直翻转处理,"static unsigned char *stbi__load_and_postprocess_8bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
   stbi__result_info ri;
   void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 8);

   if (result == NULL)
      return NULL;

   // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.
   STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);

   if (ri.bits_per_channel != 8) {
      result = stbi__convert_16_to_8((stbi__uint16 *) result, *x, *y, req_comp == 0 ? *comp : req_comp);
      ri.bits_per_channel = 8;
   }

   // @TODO: move stbi__convert_format to here

   if (stbi__vertically_flip_on_load) {
      int channels = req_comp ? req_comp : *comp;
      stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi_uc));
   }

   return (unsigned char *) result;
}","{'begin': {'line': 1260, 'column': 1}, 'end': {'line': 1284, 'column': 2}}",play_bmp_sequence.c,"['加载', '图像', '并', '转换', '为', '8', '位', '，', '支持', '垂直', '翻转', '处理']"
93,93,stbi__get32le,stbi__uint32,stbi__uint32 stbi__get32le(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",读取小端32位整数，两次16位合并,"static stbi__uint32 stbi__get32le(stbi__context *s)
{
   stbi__uint32 z = stbi__get16le(s);
   z += (stbi__uint32)stbi__get16le(s) << 16;
   return z;
}","{'begin': {'line': 1722, 'column': 1}, 'end': {'line': 1727, 'column': 2}}",play_bmp_sequence.c,"['读取', '小端', '32', '位', '整数', '，', '两次', '16', '位', '合并']"
94,94,stbi__compute_y,stbi_uc,"stbi_uc stbi__compute_y(int r, int g, int b)","[{'name': 'r', 'type': 'int'}, {'name': 'g', 'type': 'int'}, {'name': 'b', 'type': 'int'}]","好的，用户让我把之前的摘要再缩减到不超过50字，并且不要包含文件地址。之前的摘要已经是“RGB转亮度值，加权77/150/29后右移8位。”，共25字左右，显然在50字以内。不过用户可能希望更简洁。需要检查是否有冗余信息。

原摘要中的“加权系数”简化为“加权”可能更简洁，但用户可能希望保留关键参数。例如，77、150、29这些系数是否必要？用户可能希望保留这些数值，因为它们影响计算方式。同时，“右移8位”是位运算，相当于除以256，这可能对理解函数功能重要。所以需要保留这些关键点。

现在原摘要已经足够简短，且符合要求，可能用户只是重复之前的指令，需要确认是否还有优化空间。或者可能之前的回复已经符合要求，但用户希望进一步缩短。例如，可以去掉“后”字，变为“RGB转亮度值，加权77/150/29右移8位。”这样更紧凑，同时保持信息完整。这样字数会更少，但依然清晰。

需要确保不超出50字，同时准确描述函数功能。当前版本已经满足，但或许可以更精炼。例如，将“加权”改为“按权重”或者“使用系数”是否更合适？不过“加权”更简洁，可能更好。最终确认调整后的摘要是否符合用户要求。
</think>

{""name"": ""stbi__compute_y"", ""summary"": ""RGB转亮度值，加权77/150/29右移8位。""}","static stbi_uc stbi__compute_y(int r, int g, int b)
{
   return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);
}","{'begin': {'line': 1746, 'column': 1}, 'end': {'line': 1749, 'column': 2}}",play_bmp_sequence.c,"['好', '的', '，', '用户', '让', '我', '把', '之前', '的', '摘要', '再', '缩减', '减到', '缩减到', '不', '超过', '50', '字', '，', '并且', '不要', '包含', '文件', '地址', '。', '之前', '的', '摘要', '已经', '是', '“', 'RGB', '转', '亮度', '值', '，', '加权', '77', '/', '150', '/', '29', '后', '右移', '8', '位', '。', '”', '，', '共', '25', '字', '左右', '，', '显然', '在', '50', '字', '以内', '。', '不过', '用户', '可能', '希望', '更', '简洁', '。', '需要', '检查', '是否', '有', '冗余', '信息', '。', '\n', '\n', '原', '摘要', '中', '的', '“', '加权', '系数', '”', '简化', '为', '“', '加权', '”', '可能', '更', '简洁', '，', '但', '用户', '可能', '希望', '保留', '关键', '参数', '。', '例如', '，', '77', '、', '150', '、', '29', '这些', '系数', '是否', '必要', '？', '用户', '可能', '希望', '保留', '这些', '数值', '，', '因为', '它们', '影响', '计算', '方式', '。', '同时', '，', '“', '右移', '8', '位', '”', '是', '位', '运算', '，', '相当', '当于', '相当于', '除以', '256', '，', '这', '可能', '对', '理解', '函数', '功能', '重要', '。', '所以', '需要', '保留', '这些', '关键', '关键点', '。', '\n', '\n', '现在', '原', '摘要', '已经', '足够', '简短', '，', '且', '符合', '要求', '符合要求', '，', '可能', '用户', '只是', '重复', '之前', '的', '指令', '，', '需要', '确认', '是否', '还有', '优化', '空间', '。', '或者', '可能', '之前', '的', '回复', '已经', '符合', '要求', '符合要求', '，', '但', '用户', '希望', '一步', '进一步', '缩短', '。', '例如', '，', '可以', '去掉', '“', '后', '”', '字', '，', '变为', '“', 'RGB', '转', '亮度', '值', '，', '加权', '77', '/', '150', '/', '29', '右移', '8', '位', '。', '”', '这样', '更', '紧凑', '，', '同时', '保持', '信息', '完整', '。', '这样', '字数', '会', '更少', '，', '但', '依然', '清晰', '。', '\n', '\n', '需要', '确保', '不', '超出', '50', '字', '，', '同时', '准确', '描述', '函数', '功能', '。', '当前', '版本', '已经', '满足', '，', '但', '或许', '可以', '更', '精炼', '。', '例如', '，', '将', '“', '加权', '”', '改为', '“', '按', '权重', '”', '或者', '“', '使用', '系数', '”', '是否', '更', '合适', '？', '不过', '“', '加权', '”', '更', '简洁', '，', '可能', '更好', '。', '最终', '确认', '调整', '后', '的', '摘要', '是否', '符合', '用户', '要求', '。', '\n', '<', '/', 'think', '>', '\n', '\n', '{', '""', 'name', '""', ':', ' ', '""', 'stbi', '__', 'compute', '_', 'y', '""', ',', ' ', '""', 'summary', '""', ':', ' ', '""', 'RGB', '转', '亮度', '值', '，', '加权', '77', '/', '150', '/', '29', '右移', '8', '位', '。', '""', '}']"
95,95,stbi__convert_format,unsigned char *,"unsigned char * stbi__convert_format(unsigned char * data, int img_n, int req_comp, unsigned int x, unsigned int y)","[{'name': 'data', 'type': 'unsigned char *'}, {'name': 'img_n', 'type': 'int'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'x', 'type': 'unsigned int'}, {'name': 'y', 'type': 'unsigned int'}]",转换图像数据格式的组件数,"static unsigned char *stbi__convert_format(unsigned char *data, int img_n, int req_comp, unsigned int x, unsigned int y)
{
   int i,j;
   unsigned char *good;

   if (req_comp == img_n) return data;
   STBI_ASSERT(req_comp >= 1 && req_comp <= 4);

   good = (unsigned char *) stbi__malloc_mad3(req_comp, x, y, 0);
   if (good == NULL) {
      STBI_FREE(data);
      return stbi__errpuc(""outofmem"", ""Out of memory"");
   }

   for (j=0; j < (int) y; ++j) {
      unsigned char *src  = data + j * x * img_n   ;
      unsigned char *dest = good + j * x * req_comp;

      #define STBI__COMBO(a,b)  ((a)*8+(b))
      #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
      // convert source image with img_n components to one with req_comp components;
      // avoid switch per pixel, so use switch per scanline and massive macros
      switch (STBI__COMBO(img_n, req_comp)) {
         STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=255;                                     } break;
         STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
         STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=255;                     } break;
         STBI__CASE(2,1) { dest[0]=src[0];                                                  } break;
         STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
         STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                  } break;
         STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=255;        } break;
         STBI__CASE(3,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
         STBI__CASE(3,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = 255;    } break;
         STBI__CASE(4,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
         STBI__CASE(4,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = src[3]; } break;
         STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                    } break;
         default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return stbi__errpuc(""unsupported"", ""Unsupported format conversion"");
      }
      #undef STBI__CASE
   }

   STBI_FREE(data);
   return good;
}","{'begin': {'line': 1755, 'column': 1}, 'end': {'line': 1797, 'column': 2}}",play_bmp_sequence.c,"['转换', '图像', '数据', '格式', '数据格式', '的', '组件', '数']"
96,96,stbi__load_and_postprocess_16bit,stbi__uint16 *,"stbi__uint16 * stbi__load_and_postprocess_16bit(stbi__context * s, int * x, int * y, int * comp, int req_comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",加载并处理16位图像，转换位深及垂直翻转。,"static stbi__uint16 *stbi__load_and_postprocess_16bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
   stbi__result_info ri;
   void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 16);

   if (result == NULL)
      return NULL;

   // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.
   STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);

   if (ri.bits_per_channel != 16) {
      result = stbi__convert_8_to_16((stbi_uc *) result, *x, *y, req_comp == 0 ? *comp : req_comp);
      ri.bits_per_channel = 16;
   }

   // @TODO: move stbi__convert_format16 to here
   // @TODO: special case RGB-to-Y (and RGBA-to-YA) for 8-bit-to-16-bit case to keep more precision

   if (stbi__vertically_flip_on_load) {
      int channels = req_comp ? req_comp : *comp;
      stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi__uint16));
   }

   return (stbi__uint16 *) result;
}","{'begin': {'line': 1286, 'column': 1}, 'end': {'line': 1311, 'column': 2}}",play_bmp_sequence.c,"['加载', '并', '处理', '16', '位', '图像', '，', '转换', '位深', '及', '垂直', '翻转', '。']"
97,97,stbi__float_postprocess,void,"void stbi__float_postprocess(float * result, int * x, int * y, int * comp, int req_comp)","[{'name': 'result', 'type': 'float *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",若启用垂直翻转，处理浮点图像数据的垂直翻转操作,"static void stbi__float_postprocess(float *result, int *x, int *y, int *comp, int req_comp)
{
   if (stbi__vertically_flip_on_load && result != NULL) {
      int channels = req_comp ? req_comp : *comp;
      stbi__vertical_flip(result, *x, *y, channels * sizeof(float));
   }
}","{'begin': {'line': 1314, 'column': 1}, 'end': {'line': 1320, 'column': 2}}",play_bmp_sequence.c,"['若', '启用', '垂直', '翻转', '，', '处理', '浮点', '图像', '数据', '的', '垂直', '翻转', '操作']"
98,98,stbi__fopen,FILE *,"FILE * stbi__fopen(const char * filename, const char * mode)","[{'name': 'filename', 'type': 'const char *'}, {'name': 'mode', 'type': 'const char *'}]",跨平台UTF-8文件打开函数,"static FILE *stbi__fopen(char const *filename, char const *mode)
{
   FILE *f;
#if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
   wchar_t wMode[64];
   wchar_t wFilename[1024];
	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, filename, -1, wFilename, sizeof(wFilename)/sizeof(*wFilename)))
      return 0;

	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, mode, -1, wMode, sizeof(wMode)/sizeof(*wMode)))
      return 0;

#if defined(_MSC_VER) && _MSC_VER >= 1400
	if (0 != _wfopen_s(&f, wFilename, wMode))
		f = 0;
#else
   f = _wfopen(wFilename, wMode);
#endif

#elif defined(_MSC_VER) && _MSC_VER >= 1400
   if (0 != fopen_s(&f, filename, mode))
      f=0;
#else
   f = fopen(filename, mode);
#endif
   return f;
}","{'begin': {'line': 1337, 'column': 1}, 'end': {'line': 1363, 'column': 2}}",play_bmp_sequence.c,"['平台', '跨平台', 'UTF', '-', '8', '文件', '打开', '函数']"
99,99,stbi_load,stbi_uc *,"stbi_uc * stbi_load(const char * filename, int * x, int * y, int * comp, int req_comp)","[{'name': 'filename', 'type': 'const char *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",加载图像文件并获取尺寸与通道数,"STBIDEF stbi_uc *stbi_load(char const *filename, int *x, int *y, int *comp, int req_comp)
{
   FILE *f = stbi__fopen(filename, ""rb"");
   unsigned char *result;
   if (!f) return stbi__errpuc(""can't fopen"", ""Unable to open file"");
   result = stbi_load_from_file(f,x,y,comp,req_comp);
   fclose(f);
   return result;
}","{'begin': {'line': 1366, 'column': 1}, 'end': {'line': 1374, 'column': 2}}",play_bmp_sequence.c,"['加载', '图像', '文件', '图像文件', '并', '获取', '尺寸', '与', '通道', '数']"
100,100,stbi_load_from_file,stbi_uc *,"stbi_uc * stbi_load_from_file(FILE * f, int * x, int * y, int * comp, int req_comp)","[{'name': 'f', 'type': 'FILE *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",从文件指针加载图像数据，处理后返回,"STBIDEF stbi_uc *stbi_load_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
{
   unsigned char *result;
   stbi__context s;
   stbi__start_file(&s,f);
   result = stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
   if (result) {
      // need to 'unget' all the characters in the IO buffer
      fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);
   }
   return result;
}","{'begin': {'line': 1376, 'column': 1}, 'end': {'line': 1387, 'column': 2}}",play_bmp_sequence.c,"['文件', '从文件', '指针', '加载', '图像', '数据', '，', '处理', '后', '返回']"
101,101,stbi_load_from_file_16,stbi_us *,"stbi_us * stbi_load_from_file_16(FILE * f, int * x, int * y, int * comp, int req_comp)","[{'name': 'f', 'type': 'FILE *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",从文件加载16位图像数据，调整文件指针位置,"STBIDEF stbi__uint16 *stbi_load_from_file_16(FILE *f, int *x, int *y, int *comp, int req_comp)
{
   stbi__uint16 *result;
   stbi__context s;
   stbi__start_file(&s,f);
   result = stbi__load_and_postprocess_16bit(&s,x,y,comp,req_comp);
   if (result) {
      // need to 'unget' all the characters in the IO buffer
      fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);
   }
   return result;
}","{'begin': {'line': 1389, 'column': 1}, 'end': {'line': 1400, 'column': 2}}",play_bmp_sequence.c,"['文件', '从文件', '加载', '16', '位', '图像', '数据', '，', '调整', '文件', '指针', '位置']"
102,102,stbi_load_16,stbi_us *,"stbi_us * stbi_load_16(const char * filename, int * x, int * y, int * comp, int req_comp)","[{'name': 'filename', 'type': 'const char *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",加载16位图像文件并返回像素数据,"STBIDEF stbi_us *stbi_load_16(char const *filename, int *x, int *y, int *comp, int req_comp)
{
   FILE *f = stbi__fopen(filename, ""rb"");
   stbi__uint16 *result;
   if (!f) return (stbi_us *) stbi__errpuc(""can't fopen"", ""Unable to open file"");
   result = stbi_load_from_file_16(f,x,y,comp,req_comp);
   fclose(f);
   return result;
}","{'begin': {'line': 1402, 'column': 1}, 'end': {'line': 1410, 'column': 2}}",play_bmp_sequence.c,"['加载', '16', '位', '图像', '文件', '图像文件', '并', '返回', '像素', '数据']"
103,103,stbi_load_16_from_memory,stbi_us *,"stbi_us * stbi_load_16_from_memory(const stbi_uc * buffer, int len, int * x, int * y, int * channels_in_file, int desired_channels)","[{'name': 'buffer', 'type': 'const stbi_uc *'}, {'name': 'len', 'type': 'int'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'channels_in_file', 'type': 'int *'}, {'name': 'desired_channels', 'type': 'int'}]",从内存加载16位图像数据，支持通道数转换,"STBIDEF stbi_us *stbi_load_16_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);
}","{'begin': {'line': 1415, 'column': 1}, 'end': {'line': 1420, 'column': 2}}",play_bmp_sequence.c,"['从', '内存', '加载', '16', '位', '图像', '数据', '，', '支持', '通道', '数', '转换']"
104,104,stbi_load_16_from_callbacks,stbi_us *,"stbi_us * stbi_load_16_from_callbacks(const stbi_io_callbacks * clbk, void * user, int * x, int * y, int * channels_in_file, int desired_channels)","[{'name': 'clbk', 'type': 'const stbi_io_callbacks *'}, {'name': 'user', 'type': 'void *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'channels_in_file', 'type': 'int *'}, {'name': 'desired_channels', 'type': 'int'}]",通过回调加载并处理16位图像数据,"STBIDEF stbi_us *stbi_load_16_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *channels_in_file, int desired_channels)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *)clbk, user);
   return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);
}","{'begin': {'line': 1422, 'column': 1}, 'end': {'line': 1427, 'column': 2}}",play_bmp_sequence.c,"['通过', '回调', '加载', '并', '处理', '16', '位', '图像', '数据']"
105,105,stbi_load_from_memory,stbi_uc *,"stbi_uc * stbi_load_from_memory(const stbi_uc * buffer, int len, int * x, int * y, int * comp, int req_comp)","[{'name': 'buffer', 'type': 'const stbi_uc *'}, {'name': 'len', 'type': 'int'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",从内存缓冲区加载并解码图像数据,"STBIDEF stbi_uc *stbi_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
}","{'begin': {'line': 1429, 'column': 1}, 'end': {'line': 1434, 'column': 2}}",play_bmp_sequence.c,"['从', '内存', '缓冲', '缓冲区', '加载', '并', '解码', '图像', '数据']"
106,106,stbi_load_from_callbacks,stbi_uc *,"stbi_uc * stbi_load_from_callbacks(const stbi_io_callbacks * clbk, void * user, int * x, int * y, int * comp, int req_comp)","[{'name': 'clbk', 'type': 'const stbi_io_callbacks *'}, {'name': 'user', 'type': 'void *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",通过回调函数加载并处理图像数据。,"STBIDEF stbi_uc *stbi_load_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
}","{'begin': {'line': 1436, 'column': 1}, 'end': {'line': 1441, 'column': 2}}",play_bmp_sequence.c,"['通过', '回调', '函数', '加载', '并', '处理', '图像', '数据', '。']"
107,107,stbi_load_gif_from_memory,stbi_uc *,"stbi_uc * stbi_load_gif_from_memory(const stbi_uc * buffer, int len, int ** delays, int * x, int * y, int * z, int * comp, int req_comp)","[{'name': 'buffer', 'type': 'const stbi_uc *'}, {'name': 'len', 'type': 'int'}, {'name': 'delays', 'type': 'int **'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'z', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",从内存加载GIF图像，支持垂直翻转处理。,"STBIDEF stbi_uc *stbi_load_gif_from_memory(stbi_uc const *buffer, int len, int **delays, int *x, int *y, int *z, int *comp, int req_comp)
{
   unsigned char *result;
   stbi__context s;
   stbi__start_mem(&s,buffer,len);

   result = (unsigned char*) stbi__load_gif_main(&s, delays, x, y, z, comp, req_comp);
   if (stbi__vertically_flip_on_load) {
      stbi__vertical_flip_slices( result, *x, *y, *z, *comp );
   }

   return result;
}","{'begin': {'line': 1444, 'column': 1}, 'end': {'line': 1456, 'column': 2}}",play_bmp_sequence.c,"['从', '内存', '加载', 'GIF', '图像', '，', '支持', '垂直', '翻转', '处理', '。']"
108,108,stbi__compute_y_16,stbi__uint16,"stbi__uint16 stbi__compute_y_16(int r, int g, int b)","[{'name': 'r', 'type': 'int'}, {'name': 'g', 'type': 'int'}, {'name': 'b', 'type': 'int'}]",将RGB值转换为16位灰度值,"static stbi__uint16 stbi__compute_y_16(int r, int g, int b)
{
   return (stbi__uint16) (((r*77) + (g*150) +  (29*b)) >> 8);
}","{'begin': {'line': 1803, 'column': 1}, 'end': {'line': 1806, 'column': 2}}",play_bmp_sequence.c,"['将', 'RGB', '值', '转换', '为', '16', '位', '灰度', '值']"
109,109,stbi__convert_format16,stbi__uint16 *,"stbi__uint16 * stbi__convert_format16(stbi__uint16 * data, int img_n, int req_comp, unsigned int x, unsigned int y)","[{'name': 'data', 'type': 'stbi__uint16 *'}, {'name': 'img_n', 'type': 'int'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'x', 'type': 'unsigned int'}, {'name': 'y', 'type': 'unsigned int'}]",转换16位图像数据格式，调整通道数,"static stbi__uint16 *stbi__convert_format16(stbi__uint16 *data, int img_n, int req_comp, unsigned int x, unsigned int y)
{
   int i,j;
   stbi__uint16 *good;

   if (req_comp == img_n) return data;
   STBI_ASSERT(req_comp >= 1 && req_comp <= 4);

   good = (stbi__uint16 *) stbi__malloc(req_comp * x * y * 2);
   if (good == NULL) {
      STBI_FREE(data);
      return (stbi__uint16 *) stbi__errpuc(""outofmem"", ""Out of memory"");
   }

   for (j=0; j < (int) y; ++j) {
      stbi__uint16 *src  = data + j * x * img_n   ;
      stbi__uint16 *dest = good + j * x * req_comp;

      #define STBI__COMBO(a,b)  ((a)*8+(b))
      #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
      // convert source image with img_n components to one with req_comp components;
      // avoid switch per pixel, so use switch per scanline and massive macros
      switch (STBI__COMBO(img_n, req_comp)) {
         STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=0xffff;                                     } break;
         STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
         STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=0xffff;                     } break;
         STBI__CASE(2,1) { dest[0]=src[0];                                                     } break;
         STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
         STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                     } break;
         STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=0xffff;        } break;
         STBI__CASE(3,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
         STBI__CASE(3,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = 0xffff; } break;
         STBI__CASE(4,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
         STBI__CASE(4,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = src[3]; } break;
         STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                       } break;
         default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return (stbi__uint16*) stbi__errpuc(""unsupported"", ""Unsupported format conversion"");
      }
      #undef STBI__CASE
   }

   STBI_FREE(data);
   return good;
}","{'begin': {'line': 1812, 'column': 1}, 'end': {'line': 1854, 'column': 2}}",play_bmp_sequence.c,"['转换', '16', '位', '图像', '数据', '格式', '数据格式', '，', '调整', '通道', '数']"
110,110,stbi__loadf_main,float *,"float * stbi__loadf_main(stbi__context * s, int * x, int * y, int * comp, int req_comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",加载图像数据并转换为浮点数组，支持HDR/LDR格式,"static float *stbi__loadf_main(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
   unsigned char *data;
   #ifndef STBI_NO_HDR
   if (stbi__hdr_test(s)) {
      stbi__result_info ri;
      float *hdr_data = stbi__hdr_load(s,x,y,comp,req_comp, &ri);
      if (hdr_data)
         stbi__float_postprocess(hdr_data,x,y,comp,req_comp);
      return hdr_data;
   }
   #endif
   data = stbi__load_and_postprocess_8bit(s, x, y, comp, req_comp);
   if (data)
      return stbi__ldr_to_hdr(data, *x, *y, req_comp ? req_comp : *comp);
   return stbi__errpf(""unknown image type"", ""Image not of any known type, or corrupt"");
}","{'begin': {'line': 1460, 'column': 1}, 'end': {'line': 1476, 'column': 2}}",play_bmp_sequence.c,"['加载', '图像', '数据', '并', '转换', '为', '浮点', '数组', '，', '支持', 'HDR', '/', 'LDR', '格式']"
111,111,stbi_loadf_from_memory,float *,"float * stbi_loadf_from_memory(const stbi_uc * buffer, int len, int * x, int * y, int * comp, int req_comp)","[{'name': 'buffer', 'type': 'const stbi_uc *'}, {'name': 'len', 'type': 'int'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",从内存加载浮点型图像数据，支持指定通道数,"STBIDEF float *stbi_loadf_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__loadf_main(&s,x,y,comp,req_comp);
}","{'begin': {'line': 1478, 'column': 1}, 'end': {'line': 1483, 'column': 2}}",play_bmp_sequence.c,"['从', '内存', '加载', '浮点', '型', '图像', '数据', '，', '支持', '指定', '通道', '数']"
112,112,stbi_loadf_from_callbacks,float *,"float * stbi_loadf_from_callbacks(const stbi_io_callbacks * clbk, void * user, int * x, int * y, int * comp, int req_comp)","[{'name': 'clbk', 'type': 'const stbi_io_callbacks *'}, {'name': 'user', 'type': 'void *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",通过回调加载浮点图像数据,"STBIDEF float *stbi_loadf_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi__loadf_main(&s,x,y,comp,req_comp);
}","{'begin': {'line': 1485, 'column': 1}, 'end': {'line': 1490, 'column': 2}}",play_bmp_sequence.c,"['通过', '回调', '加载', '浮点', '图像', '数据']"
113,113,stbi_loadf,float *,"float * stbi_loadf(const char * filename, int * x, int * y, int * comp, int req_comp)","[{'name': 'filename', 'type': 'const char *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",加载图像文件为浮点数数组，返回尺寸及通道信息,"STBIDEF float *stbi_loadf(char const *filename, int *x, int *y, int *comp, int req_comp)
{
   float *result;
   FILE *f = stbi__fopen(filename, ""rb"");
   if (!f) return stbi__errpf(""can't fopen"", ""Unable to open file"");
   result = stbi_loadf_from_file(f,x,y,comp,req_comp);
   fclose(f);
   return result;
}","{'begin': {'line': 1493, 'column': 1}, 'end': {'line': 1501, 'column': 2}}",play_bmp_sequence.c,"['加载', '图像', '文件', '图像文件', '为', '浮点', '点数', '浮点数', '数组', '，', '返回', '尺寸', '及', '通道', '信息']"
114,114,stbi_loadf_from_file,float *,"float * stbi_loadf_from_file(FILE * f, int * x, int * y, int * comp, int req_comp)","[{'name': 'f', 'type': 'FILE *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",从文件加载浮点型图像数据,"STBIDEF float *stbi_loadf_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_file(&s,f);
   return stbi__loadf_main(&s,x,y,comp,req_comp);
}","{'begin': {'line': 1503, 'column': 1}, 'end': {'line': 1508, 'column': 2}}",play_bmp_sequence.c,"['文件', '从文件', '加载', '浮点', '型', '图像', '数据']"
115,115,stbi_is_hdr_from_memory,int,"int stbi_is_hdr_from_memory(const stbi_uc * buffer, int len)","[{'name': 'buffer', 'type': 'const stbi_uc *'}, {'name': 'len', 'type': 'int'}]",检查内存缓冲区是否为HDR图像格式,"STBIDEF int stbi_is_hdr_from_memory(stbi_uc const *buffer, int len)
{
   #ifndef STBI_NO_HDR
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__hdr_test(&s);
   #else
   STBI_NOTUSED(buffer);
   STBI_NOTUSED(len);
   return 0;
   #endif
}","{'begin': {'line': 1517, 'column': 1}, 'end': {'line': 1528, 'column': 2}}",play_bmp_sequence.c,"['检查', '内存', '缓冲', '缓冲区', '是否', '为', 'HDR', '图像', '格式', '图像格式']"
116,116,stbi_is_hdr,int,int stbi_is_hdr(const char * filename),"[{'name': 'filename', 'type': 'const char *'}]",检测指定文件是否为HDR图像格式,"STBIDEF int      stbi_is_hdr          (char const *filename)
{
   FILE *f = stbi__fopen(filename, ""rb"");
   int result=0;
   if (f) {
      result = stbi_is_hdr_from_file(f);
      fclose(f);
   }
   return result;
}","{'begin': {'line': 1531, 'column': 1}, 'end': {'line': 1540, 'column': 2}}",play_bmp_sequence.c,"['检测', '指定', '文件', '是否', '为', 'HDR', '图像', '格式', '图像格式']"
117,117,stbi_is_hdr_from_file,int,int stbi_is_hdr_from_file(FILE * f),"[{'name': 'f', 'type': 'FILE *'}]",检测文件是否为HDR格式,"STBIDEF int stbi_is_hdr_from_file(FILE *f)
{
   #ifndef STBI_NO_HDR
   long pos = ftell(f);
   int res;
   stbi__context s;
   stbi__start_file(&s,f);
   res = stbi__hdr_test(&s);
   fseek(f, pos, SEEK_SET);
   return res;
   #else
   STBI_NOTUSED(f);
   return 0;
   #endif
}","{'begin': {'line': 1542, 'column': 1}, 'end': {'line': 1556, 'column': 2}}",play_bmp_sequence.c,"['检测', '文件', '是否', '为', 'HDR', '格式']"
118,118,stbi_is_hdr_from_callbacks,int,"int stbi_is_hdr_from_callbacks(const stbi_io_callbacks * clbk, void * user)","[{'name': 'clbk', 'type': 'const stbi_io_callbacks *'}, {'name': 'user', 'type': 'void *'}]",通过回调检测图像是否为HDR格式,"STBIDEF int      stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user)
{
   #ifndef STBI_NO_HDR
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi__hdr_test(&s);
   #else
   STBI_NOTUSED(clbk);
   STBI_NOTUSED(user);
   return 0;
   #endif
}","{'begin': {'line': 1559, 'column': 1}, 'end': {'line': 1570, 'column': 2}}",play_bmp_sequence.c,"['通过', '回调', '检测', '图像', '是否', '为', 'HDR', '格式']"
119,119,stbi_ldr_to_hdr_gamma,void,void stbi_ldr_to_hdr_gamma(float gamma),"[{'name': 'gamma', 'type': 'float'}]",设置LDR转HDR的伽马值参数,"STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma) { stbi__l2h_gamma = gamma; }
","{'begin': {'line': 1575, 'column': 1}, 'end': {'line': 1575, 'column': 79}}",play_bmp_sequence.c,"['设置', 'LDR', '转', 'HDR', '的', '伽马', '值', '参数']"
120,120,stbi_ldr_to_hdr_scale,void,void stbi_ldr_to_hdr_scale(float scale),"[{'name': 'scale', 'type': 'float'}]",设置LDR到HDR转换的缩放比例,"STBIDEF void   stbi_ldr_to_hdr_scale(float scale) { stbi__l2h_scale = scale; }
","{'begin': {'line': 1576, 'column': 1}, 'end': {'line': 1576, 'column': 79}}",play_bmp_sequence.c,"['设置', 'LDR', '到', 'HDR', '转换', '的', '缩放', '比例']"
121,121,stbi_hdr_to_ldr_gamma,void,void stbi_hdr_to_ldr_gamma(float gamma),"[{'name': 'gamma', 'type': 'float'}]",设置HDR转LDR的伽马校正参数,"STBIDEF void   stbi_hdr_to_ldr_gamma(float gamma) { stbi__h2l_gamma_i = 1/gamma; }
","{'begin': {'line': 1581, 'column': 1}, 'end': {'line': 1581, 'column': 83}}",play_bmp_sequence.c,"['设置', 'HDR', '转', 'LDR', '的', '伽马', '校正', '参数']"
122,122,stbi_hdr_to_ldr_scale,void,void stbi_hdr_to_ldr_scale(float scale),"[{'name': 'scale', 'type': 'float'}]",设置HDR转LDR的比例参数,"STBIDEF void   stbi_hdr_to_ldr_scale(float scale) { stbi__h2l_scale_i = 1/scale; }
","{'begin': {'line': 1582, 'column': 1}, 'end': {'line': 1582, 'column': 83}}",play_bmp_sequence.c,"['设置', 'HDR', '转', 'LDR', '的', '比例', '参数']"
123,123,stbi__refill_buffer,void,void stbi__refill_buffer(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",刷新输入缓冲区，处理文件结束情况,"static void stbi__refill_buffer(stbi__context *s)
{
   int n = (s->io.read)(s->io_user_data,(char*)s->buffer_start,s->buflen);
   s->callback_already_read += (int) (s->img_buffer - s->img_buffer_original);
   if (n == 0) {
      // at end of file, treat same as if from memory, but need to handle case
      // where s->img_buffer isn't pointing to safe memory, e.g. 0-byte file
      s->read_from_callbacks = 0;
      s->img_buffer = s->buffer_start;
      s->img_buffer_end = s->buffer_start+1;
      *s->img_buffer = 0;
   } else {
      s->img_buffer = s->buffer_start;
      s->img_buffer_end = s->buffer_start + n;
   }
}","{'begin': {'line': 1597, 'column': 1}, 'end': {'line': 1612, 'column': 2}}",play_bmp_sequence.c,"['刷新', '输入', '缓冲', '缓冲区', '，', '处理', '文件', '结束', '情况']"
124,124,stbi__get8,stbi_uc,stbi_uc stbi__get8(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",从图像缓冲区读取下一个字节，必要时重新填充,"static stbi_uc stbi__get8(stbi__context *s)
{
   if (s->img_buffer < s->img_buffer_end)
      return *s->img_buffer++;
   if (s->read_from_callbacks) {
      stbi__refill_buffer(s);
      return *s->img_buffer++;
   }
   return 0;
}","{'begin': {'line': 1614, 'column': 13}, 'end': {'line': 1623, 'column': 2}}",play_bmp_sequence.c,"['从', '图像', '缓冲', '缓冲区', '读取', '下', '一个', '字节', '，', '必要', '时', '重新', '填充']"
125,125,stbi__at_eof,int,int stbi__at_eof(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",检查是否到达文件或缓冲区末尾,"static int stbi__at_eof(stbi__context *s)
{
   if (s->io.read) {
      if (!(s->io.eof)(s->io_user_data)) return 0;
      // if feof() is true, check if buffer = end
      // special case: we've only got the special 0 character at the end
      if (s->read_from_callbacks == 0) return 1;
   }

   return s->img_buffer >= s->img_buffer_end;
}","{'begin': {'line': 1628, 'column': 13}, 'end': {'line': 1638, 'column': 2}}",play_bmp_sequence.c,"['检查', '是否', '到达', '文件', '或', '缓冲', '缓冲区', '末尾']"
126,126,stbi__ldr_to_hdr,float *,"float * stbi__ldr_to_hdr(stbi_uc * data, int x, int y, int comp)","[{'name': 'data', 'type': 'stbi_uc *'}, {'name': 'x', 'type': 'int'}, {'name': 'y', 'type': 'int'}, {'name': 'comp', 'type': 'int'}]",将LDR图像转换为HDR格式，处理颜色通道和gamma校正。,"static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp)
{
   int i,k,n;
   float *output;
   if (!data) return NULL;
   output = (float *) stbi__malloc_mad4(x, y, comp, sizeof(float), 0);
   if (output == NULL) { STBI_FREE(data); return stbi__errpf(""outofmem"", ""Out of memory""); }
   // compute number of non-alpha components
   if (comp & 1) n = comp; else n = comp-1;
   for (i=0; i < x*y; ++i) {
      for (k=0; k < n; ++k) {
         output[i*comp + k] = (float) (pow(data[i*comp+k]/255.0f, stbi__l2h_gamma) * stbi__l2h_scale);
      }
   }
   if (n < comp) {
      for (i=0; i < x*y; ++i) {
         output[i*comp + n] = data[i*comp + n]/255.0f;
      }
   }
   STBI_FREE(data);
   return output;
}","{'begin': {'line': 1858, 'column': 1}, 'end': {'line': 1879, 'column': 2}}",play_bmp_sequence.c,"['将', 'LDR', '图像', '转换', '为', 'HDR', '格式', '，', '处理', '颜色', '通道', '和', 'gamma', '校正', '。']"
127,127,stbi__skip,void,"void stbi__skip(stbi__context * s, int n)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'n', 'type': 'int'}]",跳过指定字节数，处理缓冲和IO操作,"static void stbi__skip(stbi__context *s, int n)
{
   if (n == 0) return;  // already there!
   if (n < 0) {
      s->img_buffer = s->img_buffer_end;
      return;
   }
   if (s->io.read) {
      int blen = (int) (s->img_buffer_end - s->img_buffer);
      if (blen < n) {
         s->img_buffer = s->img_buffer_end;
         (s->io.skip)(s->io_user_data, n - blen);
         return;
      }
   }
   s->img_buffer += n;
}","{'begin': {'line': 1644, 'column': 1}, 'end': {'line': 1660, 'column': 2}}",play_bmp_sequence.c,"['跳过', '指定', '字节', '节数', '字节数', '，', '处理', '缓冲', '和', 'IO', '操作']"
128,128,stbi__getn,int,"int stbi__getn(stbi__context * s, stbi_uc * buffer, int n)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'buffer', 'type': 'stbi_uc *'}, {'name': 'n', 'type': 'int'}]",从上下文读取指定字节到缓冲区，处理缓冲不足情况,"static int stbi__getn(stbi__context *s, stbi_uc *buffer, int n)
{
   if (s->io.read) {
      int blen = (int) (s->img_buffer_end - s->img_buffer);
      if (blen < n) {
         int res, count;

         memcpy(buffer, s->img_buffer, blen);

         count = (s->io.read)(s->io_user_data, (char*) buffer + blen, n - blen);
         res = (count == (n-blen));
         s->img_buffer = s->img_buffer_end;
         return res;
      }
   }

   if (s->img_buffer+n <= s->img_buffer_end) {
      memcpy(buffer, s->img_buffer, n);
      s->img_buffer += n;
      return 1;
   } else
      return 0;
}","{'begin': {'line': 1666, 'column': 1}, 'end': {'line': 1688, 'column': 2}}",play_bmp_sequence.c,"['从', '上下', '下文', '上下文', '读取', '指定', '字节', '到', '缓冲', '缓冲区', '，', '处理', '缓冲', '不足', '情况']"
129,129,stbi__hdr_to_ldr,stbi_uc *,"stbi_uc * stbi__hdr_to_ldr(float * data, int x, int y, int comp)","[{'name': 'data', 'type': 'float *'}, {'name': 'x', 'type': 'int'}, {'name': 'y', 'type': 'int'}, {'name': 'comp', 'type': 'int'}]",将HDR图像数据转换为LDR格式，应用伽马校正并调整到8位范围,"static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp)
{
   int i,k,n;
   stbi_uc *output;
   if (!data) return NULL;
   output = (stbi_uc *) stbi__malloc_mad3(x, y, comp, 0);
   if (output == NULL) { STBI_FREE(data); return stbi__errpuc(""outofmem"", ""Out of memory""); }
   // compute number of non-alpha components
   if (comp & 1) n = comp; else n = comp-1;
   for (i=0; i < x*y; ++i) {
      for (k=0; k < n; ++k) {
         float z = (float) pow(data[i*comp+k]*stbi__h2l_scale_i, stbi__h2l_gamma_i) * 255 + 0.5f;
         if (z < 0) z = 0;
         if (z > 255) z = 255;
         output[i*comp + k] = (stbi_uc) stbi__float2int(z);
      }
      if (k < comp) {
         float z = data[i*comp+k] * 255 + 0.5f;
         if (z < 0) z = 0;
         if (z > 255) z = 255;
         output[i*comp + k] = (stbi_uc) stbi__float2int(z);
      }
   }
   STBI_FREE(data);
   return output;
}","{'begin': {'line': 1884, 'column': 1}, 'end': {'line': 1909, 'column': 2}}",play_bmp_sequence.c,"['将', 'HDR', '图像', '数据', '转换', '为', 'LDR', '格式', '，', '应用', '伽马', '校正', '并', '调整', '到', '8', '位', '范围']"
130,130,stbi__get16be,int,int stbi__get16be(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",从上下文中读取大端16位整数,"static int stbi__get16be(stbi__context *s)
{
   int z = stbi__get8(s);
   return (z << 8) + stbi__get8(s);
}","{'begin': {'line': 1694, 'column': 1}, 'end': {'line': 1698, 'column': 2}}",play_bmp_sequence.c,"['从', '上下', '下文', '上下文', '中', '读取', '大端', '16', '位', '整数']"
131,131,stbi__get32be,stbi__uint32,stbi__uint32 stbi__get32be(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",以大端序读取32位整数,"static stbi__uint32 stbi__get32be(stbi__context *s)
{
   stbi__uint32 z = stbi__get16be(s);
   return (z << 16) + stbi__get16be(s);
}","{'begin': {'line': 1704, 'column': 1}, 'end': {'line': 1708, 'column': 2}}",play_bmp_sequence.c,"['大端', '以大端序', '读取', '32', '位', '整数']"
132,132,stbi__get16le,int,int stbi__get16le(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",读取小端格式的16位整数,"static int stbi__get16le(stbi__context *s)
{
   int z = stbi__get8(s);
   return z + (stbi__get8(s) << 8);
}","{'begin': {'line': 1714, 'column': 1}, 'end': {'line': 1718, 'column': 2}}",play_bmp_sequence.c,"['读取', '小端', '格式', '的', '16', '位', '整数']"
133,133,stbi__get32le,stbi__uint32,stbi__uint32 stbi__get32le(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",读取32位小端格式的整数,"static stbi__uint32 stbi__get32le(stbi__context *s)
{
   stbi__uint32 z = stbi__get16le(s);
   z += (stbi__uint32)stbi__get16le(s) << 16;
   return z;
}","{'begin': {'line': 1722, 'column': 1}, 'end': {'line': 1727, 'column': 2}}",play_bmp_sequence.c,"['读取', '32', '位小端', '格式', '的', '整数']"
134,134,stbi__compute_y,stbi_uc,"stbi_uc stbi__compute_y(int r, int g, int b)","[{'name': 'r', 'type': 'int'}, {'name': 'g', 'type': 'int'}, {'name': 'b', 'type': 'int'}]","通过加权系数(77,150,29)计算RGB亮度值，结果右移8位返回。","static stbi_uc stbi__compute_y(int r, int g, int b)
{
   return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);
}","{'begin': {'line': 1746, 'column': 1}, 'end': {'line': 1749, 'column': 2}}",play_bmp_sequence.c,"['通过', '加权', '系数', '(', '77', ',', '150', ',', '29', ')', '计算', 'RGB', '亮度', '值', '，', '结果', '右移', '8', '位', '返回', '。']"
135,135,stbi__convert_format,unsigned char *,"unsigned char * stbi__convert_format(unsigned char * data, int img_n, int req_comp, unsigned int x, unsigned int y)","[{'name': 'data', 'type': 'unsigned char *'}, {'name': 'img_n', 'type': 'int'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'x', 'type': 'unsigned int'}, {'name': 'y', 'type': 'unsigned int'}]",转换图像数据通道格式并返回新缓冲区,"static unsigned char *stbi__convert_format(unsigned char *data, int img_n, int req_comp, unsigned int x, unsigned int y)
{
   int i,j;
   unsigned char *good;

   if (req_comp == img_n) return data;
   STBI_ASSERT(req_comp >= 1 && req_comp <= 4);

   good = (unsigned char *) stbi__malloc_mad3(req_comp, x, y, 0);
   if (good == NULL) {
      STBI_FREE(data);
      return stbi__errpuc(""outofmem"", ""Out of memory"");
   }

   for (j=0; j < (int) y; ++j) {
      unsigned char *src  = data + j * x * img_n   ;
      unsigned char *dest = good + j * x * req_comp;

      #define STBI__COMBO(a,b)  ((a)*8+(b))
      #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
      // convert source image with img_n components to one with req_comp components;
      // avoid switch per pixel, so use switch per scanline and massive macros
      switch (STBI__COMBO(img_n, req_comp)) {
         STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=255;                                     } break;
         STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
         STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=255;                     } break;
         STBI__CASE(2,1) { dest[0]=src[0];                                                  } break;
         STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
         STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                  } break;
         STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=255;        } break;
         STBI__CASE(3,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
         STBI__CASE(3,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = 255;    } break;
         STBI__CASE(4,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
         STBI__CASE(4,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = src[3]; } break;
         STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                    } break;
         default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return stbi__errpuc(""unsupported"", ""Unsupported format conversion"");
      }
      #undef STBI__CASE
   }

   STBI_FREE(data);
   return good;
}","{'begin': {'line': 1755, 'column': 1}, 'end': {'line': 1797, 'column': 2}}",play_bmp_sequence.c,"['转换', '图像', '数据', '通道', '数据通', '数据通道', '格式', '并', '返回', '新', '缓冲', '缓冲区']"
136,136,stbi__build_huffman,int,"int stbi__build_huffman(stbi__huffman * h, int * count)","[{'name': 'h', 'type': 'stbi__huffman *'}, {'name': 'count', 'type': 'int *'}]",构建哈夫曼解码表用于JPEG解析,"static int stbi__build_huffman(stbi__huffman *h, int *count)
{
   int i,j,k=0;
   unsigned int code;
   // build size list for each symbol (from JPEG spec)
   for (i=0; i < 16; ++i) {
      for (j=0; j < count[i]; ++j) {
         h->size[k++] = (stbi_uc) (i+1);
         if(k >= 257) return stbi__err(""bad size list"",""Corrupt JPEG"");
      }
   }
   h->size[k] = 0;

   // compute actual symbols (from jpeg spec)
   code = 0;
   k = 0;
   for(j=1; j <= 16; ++j) {
      // compute delta to add to code to compute symbol id
      h->delta[j] = k - code;
      if (h->size[k] == j) {
         while (h->size[k] == j)
            h->code[k++] = (stbi__uint16) (code++);
         if (code-1 >= (1u << j)) return stbi__err(""bad code lengths"",""Corrupt JPEG"");
      }
      // compute largest code + 1 for this size, preshifted as needed later
      h->maxcode[j] = code << (16-j);
      code <<= 1;
   }
   h->maxcode[j] = 0xffffffff;

   // build non-spec acceleration table; 255 is flag for not-accelerated
   memset(h->fast, 255, 1 << FAST_BITS);
   for (i=0; i < k; ++i) {
      int s = h->size[i];
      if (s <= FAST_BITS) {
         int c = h->code[i] << (FAST_BITS-s);
         int m = 1 << (FAST_BITS-s);
         for (j=0; j < m; ++j) {
            h->fast[c+j] = (stbi_uc) i;
         }
      }
   }
   return 1;
}","{'begin': {'line': 2003, 'column': 1}, 'end': {'line': 2046, 'column': 2}}",play_bmp_sequence.c,"['构建', '夫曼', '哈夫曼', '解码', '表', '用于', 'JPEG', '解析']"
137,137,stbi__build_fast_ac,void,"void stbi__build_fast_ac(stbi__int16 * fast_ac, stbi__huffman * h)","[{'name': 'fast_ac', 'type': 'stbi__int16 *'}, {'name': 'h', 'type': 'stbi__huffman *'}]",构建快速霍夫曼AC系数解码表,"static void stbi__build_fast_ac(stbi__int16 *fast_ac, stbi__huffman *h)
{
   int i;
   for (i=0; i < (1 << FAST_BITS); ++i) {
      stbi_uc fast = h->fast[i];
      fast_ac[i] = 0;
      if (fast < 255) {
         int rs = h->values[fast];
         int run = (rs >> 4) & 15;
         int magbits = rs & 15;
         int len = h->size[fast];

         if (magbits && len + magbits <= FAST_BITS) {
            // magnitude code followed by receive_extend code
            int k = ((i << len) & ((1 << FAST_BITS) - 1)) >> (FAST_BITS - magbits);
            int m = 1 << (magbits - 1);
            if (k < m) k += (~0U << magbits) + 1;
            // if the result is small enough, we can fit it in fast_ac table
            if (k >= -128 && k <= 127)
               fast_ac[i] = (stbi__int16) ((k * 256) + (run * 16) + (len + magbits));
         }
      }
   }
}","{'begin': {'line': 2050, 'column': 1}, 'end': {'line': 2073, 'column': 2}}",play_bmp_sequence.c,"['构建', '快速', '夫曼', '霍夫曼', 'AC', '系数', '解码', '表']"
138,138,stbi__grow_buffer_unsafe,void,void stbi__grow_buffer_unsafe(stbi__jpeg * j),"[{'name': 'j', 'type': 'stbi__jpeg *'}]",扩展JPEG解码缓冲区并处理标记字节,"static void stbi__grow_buffer_unsafe(stbi__jpeg *j)
{
   do {
      unsigned int b = j->nomore ? 0 : stbi__get8(j->s);
      if (b == 0xff) {
         int c = stbi__get8(j->s);
         while (c == 0xff) c = stbi__get8(j->s); // consume fill bytes
         if (c != 0) {
            j->marker = (unsigned char) c;
            j->nomore = 1;
            return;
         }
      }
      j->code_buffer |= b << (24 - j->code_bits);
      j->code_bits += 8;
   } while (j->code_bits <= 24);
}","{'begin': {'line': 2075, 'column': 1}, 'end': {'line': 2091, 'column': 2}}",play_bmp_sequence.c,"['扩展', 'JPEG', '解码', '缓冲', '缓冲区', '并', '处理', '标记', '字节']"
139,139,stbi__jpeg_huff_decode,int,"int stbi__jpeg_huff_decode(stbi__jpeg * j, stbi__huffman * h)","[{'name': 'j', 'type': 'stbi__jpeg *'}, {'name': 'h', 'type': 'stbi__huffman *'}]",解码JPEG哈夫曼编码，快速查找失败后逐位匹配,"static int stbi__jpeg_huff_decode(stbi__jpeg *j, stbi__huffman *h)
{
   unsigned int temp;
   int c,k;

   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

   // look at the top FAST_BITS and determine what symbol ID it is,
   // if the code is <= FAST_BITS
   c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
   k = h->fast[c];
   if (k < 255) {
      int s = h->size[k];
      if (s > j->code_bits)
         return -1;
      j->code_buffer <<= s;
      j->code_bits -= s;
      return h->values[k];
   }

   // naive test is to shift the code_buffer down so k bits are
   // valid, then test against maxcode. To speed this up, we've
   // preshifted maxcode left so that it has (16-k) 0s at the
   // end; in other words, regardless of the number of bits, it
   // wants to be compared against something shifted to have 16;
   // that way we don't need to shift inside the loop.
   temp = j->code_buffer >> 16;
   for (k=FAST_BITS+1 ; ; ++k)
      if (temp < h->maxcode[k])
         break;
   if (k == 17) {
      // error! code not found
      j->code_bits -= 16;
      return -1;
   }

   if (k > j->code_bits)
      return -1;

   // convert the huffman code to the symbol id
   c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];
   if(c < 0 || c >= 256) // symbol id out of bounds!
       return -1;
   STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);

   // convert the id to a symbol
   j->code_bits -= k;
   j->code_buffer <<= k;
   return h->values[c];
}","{'begin': {'line': 2097, 'column': 13}, 'end': {'line': 2146, 'column': 2}}",play_bmp_sequence.c,"['解码', 'JPEG', '夫曼', '哈夫曼', '编码', '，', '快速', '查找', '失败', '后', '逐位', '匹配']"
140,140,stbi__compute_y_16,stbi__uint16,"stbi__uint16 stbi__compute_y_16(int r, int g, int b)","[{'name': 'r', 'type': 'int'}, {'name': 'g', 'type': 'int'}, {'name': 'b', 'type': 'int'}]",将RGB分量转换为16位亮度值,"static stbi__uint16 stbi__compute_y_16(int r, int g, int b)
{
   return (stbi__uint16) (((r*77) + (g*150) +  (29*b)) >> 8);
}","{'begin': {'line': 1803, 'column': 1}, 'end': {'line': 1806, 'column': 2}}",play_bmp_sequence.c,"['将', 'RGB', '分量', '转换', '为', '16', '位', '亮度', '值']"
141,141,stbi__convert_format16,stbi__uint16 *,"stbi__uint16 * stbi__convert_format16(stbi__uint16 * data, int img_n, int req_comp, unsigned int x, unsigned int y)","[{'name': 'data', 'type': 'stbi__uint16 *'}, {'name': 'img_n', 'type': 'int'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'x', 'type': 'unsigned int'}, {'name': 'y', 'type': 'unsigned int'}]",转换16位图像数据的通道格式,"static stbi__uint16 *stbi__convert_format16(stbi__uint16 *data, int img_n, int req_comp, unsigned int x, unsigned int y)
{
   int i,j;
   stbi__uint16 *good;

   if (req_comp == img_n) return data;
   STBI_ASSERT(req_comp >= 1 && req_comp <= 4);

   good = (stbi__uint16 *) stbi__malloc(req_comp * x * y * 2);
   if (good == NULL) {
      STBI_FREE(data);
      return (stbi__uint16 *) stbi__errpuc(""outofmem"", ""Out of memory"");
   }

   for (j=0; j < (int) y; ++j) {
      stbi__uint16 *src  = data + j * x * img_n   ;
      stbi__uint16 *dest = good + j * x * req_comp;

      #define STBI__COMBO(a,b)  ((a)*8+(b))
      #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
      // convert source image with img_n components to one with req_comp components;
      // avoid switch per pixel, so use switch per scanline and massive macros
      switch (STBI__COMBO(img_n, req_comp)) {
         STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=0xffff;                                     } break;
         STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
         STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=0xffff;                     } break;
         STBI__CASE(2,1) { dest[0]=src[0];                                                     } break;
         STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
         STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                     } break;
         STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=0xffff;        } break;
         STBI__CASE(3,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
         STBI__CASE(3,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = 0xffff; } break;
         STBI__CASE(4,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
         STBI__CASE(4,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = src[3]; } break;
         STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                       } break;
         default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return (stbi__uint16*) stbi__errpuc(""unsupported"", ""Unsupported format conversion"");
      }
      #undef STBI__CASE
   }

   STBI_FREE(data);
   return good;
}","{'begin': {'line': 1812, 'column': 1}, 'end': {'line': 1854, 'column': 2}}",play_bmp_sequence.c,"['转换', '16', '位', '图像', '数据', '的', '通道', '格式']"
142,142,stbi__extend_receive,int,"int stbi__extend_receive(stbi__jpeg * j, int n)","[{'name': 'j', 'type': 'stbi__jpeg *'}, {'name': 'n', 'type': 'int'}]",接收并扩展n位数据，用于JPEG解码的符号扩展处理,"static int stbi__extend_receive(stbi__jpeg *j, int n)
{
   unsigned int k;
   int sgn;
   if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
   if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing

   sgn = j->code_buffer >> 31; // sign bit always in MSB; 0 if MSB clear (positive), 1 if MSB set (negative)
   k = stbi_lrot(j->code_buffer, n);
   j->code_buffer = k & ~stbi__bmask[n];
   k &= stbi__bmask[n];
   j->code_bits -= n;
   return k + (stbi__jbias[n] & (sgn - 1));
}","{'begin': {'line': 2153, 'column': 13}, 'end': {'line': 2166, 'column': 2}}",play_bmp_sequence.c,"['接收', '并', '扩展', 'n', '位', '数据', '，', '用于', 'JPEG', '解码', '的', '符号', '扩展', '处理']"
143,143,stbi__jpeg_get_bits,int,"int stbi__jpeg_get_bits(stbi__jpeg * j, int n)","[{'name': 'j', 'type': 'stbi__jpeg *'}, {'name': 'n', 'type': 'int'}]",从JPEG数据流中提取指定位数的数据,"static int stbi__jpeg_get_bits(stbi__jpeg *j, int n)
{
   unsigned int k;
   if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
   if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing
   k = stbi_lrot(j->code_buffer, n);
   j->code_buffer = k & ~stbi__bmask[n];
   k &= stbi__bmask[n];
   j->code_bits -= n;
   return k;
}","{'begin': {'line': 2169, 'column': 13}, 'end': {'line': 2179, 'column': 2}}",play_bmp_sequence.c,"['从', 'JPEG', '数据', '数据流', '中', '提取', '指定', '位数', '的', '数据']"
144,144,stbi__jpeg_get_bit,int,int stbi__jpeg_get_bit(stbi__jpeg * j),"[{'name': 'j', 'type': 'stbi__jpeg *'}]",从JPEG数据流中读取一个比特位,"static int stbi__jpeg_get_bit(stbi__jpeg *j)
{
   unsigned int k;
   if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);
   if (j->code_bits < 1) return 0; // ran out of bits from stream, return 0s intead of continuing
   k = j->code_buffer;
   j->code_buffer <<= 1;
   --j->code_bits;
   return k & 0x80000000;
}","{'begin': {'line': 2181, 'column': 13}, 'end': {'line': 2190, 'column': 2}}",play_bmp_sequence.c,"['从', 'JPEG', '数据', '数据流', '中', '读取', '一个', '比特', '位']"
145,145,stbi__jpeg_decode_block,int,"int stbi__jpeg_decode_block(stbi__jpeg * j, short[64] data, stbi__huffman * hdc, stbi__huffman * hac, stbi__int16 * fac, int b, stbi__uint16 * dequant)","[{'name': 'j', 'type': 'stbi__jpeg *'}, {'name': 'data', 'type': 'short[64]'}, {'name': 'hdc', 'type': 'stbi__huffman *'}, {'name': 'hac', 'type': 'stbi__huffman *'}, {'name': 'fac', 'type': 'stbi__int16 *'}, {'name': 'b', 'type': 'int'}, {'name': 'dequant', 'type': 'stbi__uint16 *'}]",解码JPEG图像块，处理DC/AC系数并反量化。,"static int stbi__jpeg_decode_block(stbi__jpeg *j, short data[64], stbi__huffman *hdc, stbi__huffman *hac, stbi__int16 *fac, int b, stbi__uint16 *dequant)
{
   int diff,dc,k;
   int t;

   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
   t = stbi__jpeg_huff_decode(j, hdc);
   if (t < 0 || t > 15) return stbi__err(""bad huffman code"",""Corrupt JPEG"");

   // 0 all the ac values now so we can do it 32-bits at a time
   memset(data,0,64*sizeof(data[0]));

   diff = t ? stbi__extend_receive(j, t) : 0;
   if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err(""bad delta"",""Corrupt JPEG"");
   dc = j->img_comp[b].dc_pred + diff;
   j->img_comp[b].dc_pred = dc;
   if (!stbi__mul2shorts_valid(dc, dequant[0])) return stbi__err(""can't merge dc and ac"", ""Corrupt JPEG"");
   data[0] = (short) (dc * dequant[0]);

   // decode AC components, see JPEG spec
   k = 1;
   do {
      unsigned int zig;
      int c,r,s;
      if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
      c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
      r = fac[c];
      if (r) { // fast-AC path
         k += (r >> 4) & 15; // run
         s = r & 15; // combined length
         if (s > j->code_bits) return stbi__err(""bad huffman code"", ""Combined length longer than code bits available"");
         j->code_buffer <<= s;
         j->code_bits -= s;
         // decode into unzigzag'd location
         zig = stbi__jpeg_dezigzag[k++];
         data[zig] = (short) ((r >> 8) * dequant[zig]);
      } else {
         int rs = stbi__jpeg_huff_decode(j, hac);
         if (rs < 0) return stbi__err(""bad huffman code"",""Corrupt JPEG"");
         s = rs & 15;
         r = rs >> 4;
         if (s == 0) {
            if (rs != 0xf0) break; // end block
            k += 16;
         } else {
            k += r;
            // decode into unzigzag'd location
            zig = stbi__jpeg_dezigzag[k++];
            data[zig] = (short) (stbi__extend_receive(j,s) * dequant[zig]);
         }
      }
   } while (k < 64);
   return 1;
}","{'begin': {'line': 2210, 'column': 1}, 'end': {'line': 2263, 'column': 2}}",play_bmp_sequence.c,"['解码', 'JPEG', '图像', '块', '，', '处理', 'DC', '/', 'AC', '系数', '并', '反', '量化', '。']"
146,146,stbi__jpeg_decode_block_prog_dc,int,"int stbi__jpeg_decode_block_prog_dc(stbi__jpeg * j, short[64] data, stbi__huffman * hdc, int b)","[{'name': 'j', 'type': 'stbi__jpeg *'}, {'name': 'data', 'type': 'short[64]'}, {'name': 'hdc', 'type': 'stbi__huffman *'}, {'name': 'b', 'type': 'int'}]",解码JPEG渐进式DC块，处理预测和细化扫描,"static int stbi__jpeg_decode_block_prog_dc(stbi__jpeg *j, short data[64], stbi__huffman *hdc, int b)
{
   int diff,dc;
   int t;
   if (j->spec_end != 0) return stbi__err(""can't merge dc and ac"", ""Corrupt JPEG"");

   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

   if (j->succ_high == 0) {
      // first scan for DC coefficient, must be first
      memset(data,0,64*sizeof(data[0])); // 0 all the ac values now
      t = stbi__jpeg_huff_decode(j, hdc);
      if (t < 0 || t > 15) return stbi__err(""can't merge dc and ac"", ""Corrupt JPEG"");
      diff = t ? stbi__extend_receive(j, t) : 0;

      if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err(""bad delta"", ""Corrupt JPEG"");
      dc = j->img_comp[b].dc_pred + diff;
      j->img_comp[b].dc_pred = dc;
      if (!stbi__mul2shorts_valid(dc, 1 << j->succ_low)) return stbi__err(""can't merge dc and ac"", ""Corrupt JPEG"");
      data[0] = (short) (dc * (1 << j->succ_low));
   } else {
      // refinement scan for DC coefficient
      if (stbi__jpeg_get_bit(j))
         data[0] += (short) (1 << j->succ_low);
   }
   return 1;
}","{'begin': {'line': 2265, 'column': 1}, 'end': {'line': 2291, 'column': 2}}",play_bmp_sequence.c,"['解码', 'JPEG', '渐进', '渐进式', 'DC', '块', '，', '处理', '预测', '和', '细化', '扫描']"
147,147,stbi__ldr_to_hdr,float *,"float * stbi__ldr_to_hdr(stbi_uc * data, int x, int y, int comp)","[{'name': 'data', 'type': 'stbi_uc *'}, {'name': 'x', 'type': 'int'}, {'name': 'y', 'type': 'int'}, {'name': 'comp', 'type': 'int'}]",将LDR转换为HDR图像数据，并释放原内存,"static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp)
{
   int i,k,n;
   float *output;
   if (!data) return NULL;
   output = (float *) stbi__malloc_mad4(x, y, comp, sizeof(float), 0);
   if (output == NULL) { STBI_FREE(data); return stbi__errpf(""outofmem"", ""Out of memory""); }
   // compute number of non-alpha components
   if (comp & 1) n = comp; else n = comp-1;
   for (i=0; i < x*y; ++i) {
      for (k=0; k < n; ++k) {
         output[i*comp + k] = (float) (pow(data[i*comp+k]/255.0f, stbi__l2h_gamma) * stbi__l2h_scale);
      }
   }
   if (n < comp) {
      for (i=0; i < x*y; ++i) {
         output[i*comp + n] = data[i*comp + n]/255.0f;
      }
   }
   STBI_FREE(data);
   return output;
}","{'begin': {'line': 1858, 'column': 1}, 'end': {'line': 1879, 'column': 2}}",play_bmp_sequence.c,"['将', 'LDR', '转换', '为', 'HDR', '图像', '数据', '，', '并', '释放', '原', '内存']"
148,148,stbi__jpeg_decode_block_prog_ac,int,"int stbi__jpeg_decode_block_prog_ac(stbi__jpeg * j, short[64] data, stbi__huffman * hac, stbi__int16 * fac)","[{'name': 'j', 'type': 'stbi__jpeg *'}, {'name': 'data', 'type': 'short[64]'}, {'name': 'hac', 'type': 'stbi__huffman *'}, {'name': 'fac', 'type': 'stbi__int16 *'}]",解码JPEG渐进式AC块，处理霍夫曼解码及位操作,"static int stbi__jpeg_decode_block_prog_ac(stbi__jpeg *j, short data[64], stbi__huffman *hac, stbi__int16 *fac)
{
   int k;
   if (j->spec_start == 0) return stbi__err(""can't merge dc and ac"", ""Corrupt JPEG"");

   if (j->succ_high == 0) {
      int shift = j->succ_low;

      if (j->eob_run) {
         --j->eob_run;
         return 1;
      }

      k = j->spec_start;
      do {
         unsigned int zig;
         int c,r,s;
         if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
         c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
         r = fac[c];
         if (r) { // fast-AC path
            k += (r >> 4) & 15; // run
            s = r & 15; // combined length
            if (s > j->code_bits) return stbi__err(""bad huffman code"", ""Combined length longer than code bits available"");
            j->code_buffer <<= s;
            j->code_bits -= s;
            zig = stbi__jpeg_dezigzag[k++];
            data[zig] = (short) ((r >> 8) * (1 << shift));
         } else {
            int rs = stbi__jpeg_huff_decode(j, hac);
            if (rs < 0) return stbi__err(""bad huffman code"",""Corrupt JPEG"");
            s = rs & 15;
            r = rs >> 4;
            if (s == 0) {
               if (r < 15) {
                  j->eob_run = (1 << r);
                  if (r)
                     j->eob_run += stbi__jpeg_get_bits(j, r);
                  --j->eob_run;
                  break;
               }
               k += 16;
            } else {
               k += r;
               zig = stbi__jpeg_dezigzag[k++];
               data[zig] = (short) (stbi__extend_receive(j,s) * (1 << shift));
            }
         }
      } while (k <= j->spec_end);
   } else {
      // refinement scan for these AC coefficients

      short bit = (short) (1 << j->succ_low);

      if (j->eob_run) {
         --j->eob_run;
         for (k = j->spec_start; k <= j->spec_end; ++k) {
            short *p = &data[stbi__jpeg_dezigzag[k]];
            if (*p != 0)
               if (stbi__jpeg_get_bit(j))
                  if ((*p & bit)==0) {
                     if (*p > 0)
                        *p += bit;
                     else
                        *p -= bit;
                  }
         }
      } else {
         k = j->spec_start;
         do {
            int r,s;
            int rs = stbi__jpeg_huff_decode(j, hac); // @OPTIMIZE see if we can use the fast path here, advance-by-r is so slow, eh
            if (rs < 0) return stbi__err(""bad huffman code"",""Corrupt JPEG"");
            s = rs & 15;
            r = rs >> 4;
            if (s == 0) {
               if (r < 15) {
                  j->eob_run = (1 << r) - 1;
                  if (r)
                     j->eob_run += stbi__jpeg_get_bits(j, r);
                  r = 64; // force end of block
               } else {
                  // r=15 s=0 should write 16 0s, so we just do
                  // a run of 15 0s and then write s (which is 0),
                  // so we don't have to do anything special here
               }
            } else {
               if (s != 1) return stbi__err(""bad huffman code"", ""Corrupt JPEG"");
               // sign bit
               if (stbi__jpeg_get_bit(j))
                  s = bit;
               else
                  s = -bit;
            }

            // advance by r
            while (k <= j->spec_end) {
               short *p = &data[stbi__jpeg_dezigzag[k++]];
               if (*p != 0) {
                  if (stbi__jpeg_get_bit(j))
                     if ((*p & bit)==0) {
                        if (*p > 0)
                           *p += bit;
                        else
                           *p -= bit;
                     }
               } else {
                  if (r == 0) {
                     *p = (short) s;
                     break;
                  }
                  --r;
               }
            }
         } while (k <= j->spec_end);
      }
   }
   return 1;
}","{'begin': {'line': 2295, 'column': 1}, 'end': {'line': 2413, 'column': 2}}",play_bmp_sequence.c,"['解码', 'JPEG', '渐进', '渐进式', 'AC', '块', '，', '处理', '夫曼', '霍夫曼', '解码', '及', '操作', '位操作']"
149,149,stbi__hdr_to_ldr,stbi_uc *,"stbi_uc * stbi__hdr_to_ldr(float * data, int x, int y, int comp)","[{'name': 'data', 'type': 'float *'}, {'name': 'x', 'type': 'int'}, {'name': 'y', 'type': 'int'}, {'name': 'comp', 'type': 'int'}]",将HDR图像转换为LDR格式，应用gamma校正并输出8位像素,"static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp)
{
   int i,k,n;
   stbi_uc *output;
   if (!data) return NULL;
   output = (stbi_uc *) stbi__malloc_mad3(x, y, comp, 0);
   if (output == NULL) { STBI_FREE(data); return stbi__errpuc(""outofmem"", ""Out of memory""); }
   // compute number of non-alpha components
   if (comp & 1) n = comp; else n = comp-1;
   for (i=0; i < x*y; ++i) {
      for (k=0; k < n; ++k) {
         float z = (float) pow(data[i*comp+k]*stbi__h2l_scale_i, stbi__h2l_gamma_i) * 255 + 0.5f;
         if (z < 0) z = 0;
         if (z > 255) z = 255;
         output[i*comp + k] = (stbi_uc) stbi__float2int(z);
      }
      if (k < comp) {
         float z = data[i*comp+k] * 255 + 0.5f;
         if (z < 0) z = 0;
         if (z > 255) z = 255;
         output[i*comp + k] = (stbi_uc) stbi__float2int(z);
      }
   }
   STBI_FREE(data);
   return output;
}","{'begin': {'line': 1884, 'column': 1}, 'end': {'line': 1909, 'column': 2}}",play_bmp_sequence.c,"['将', 'HDR', '图像', '转换', '为', 'LDR', '格式', '，', '应用', 'gamma', '校正', '并', '输出', '8', '位', '像素']"
150,150,stbi__build_huffman,int,"int stbi__build_huffman(stbi__huffman * h, int * count)","[{'name': 'h', 'type': 'stbi__huffman *'}, {'name': 'count', 'type': 'int *'}]",构建哈夫曼树，用于JPEG解码,"static int stbi__build_huffman(stbi__huffman *h, int *count)
{
   int i,j,k=0;
   unsigned int code;
   // build size list for each symbol (from JPEG spec)
   for (i=0; i < 16; ++i) {
      for (j=0; j < count[i]; ++j) {
         h->size[k++] = (stbi_uc) (i+1);
         if(k >= 257) return stbi__err(""bad size list"",""Corrupt JPEG"");
      }
   }
   h->size[k] = 0;

   // compute actual symbols (from jpeg spec)
   code = 0;
   k = 0;
   for(j=1; j <= 16; ++j) {
      // compute delta to add to code to compute symbol id
      h->delta[j] = k - code;
      if (h->size[k] == j) {
         while (h->size[k] == j)
            h->code[k++] = (stbi__uint16) (code++);
         if (code-1 >= (1u << j)) return stbi__err(""bad code lengths"",""Corrupt JPEG"");
      }
      // compute largest code + 1 for this size, preshifted as needed later
      h->maxcode[j] = code << (16-j);
      code <<= 1;
   }
   h->maxcode[j] = 0xffffffff;

   // build non-spec acceleration table; 255 is flag for not-accelerated
   memset(h->fast, 255, 1 << FAST_BITS);
   for (i=0; i < k; ++i) {
      int s = h->size[i];
      if (s <= FAST_BITS) {
         int c = h->code[i] << (FAST_BITS-s);
         int m = 1 << (FAST_BITS-s);
         for (j=0; j < m; ++j) {
            h->fast[c+j] = (stbi_uc) i;
         }
      }
   }
   return 1;
}","{'begin': {'line': 2003, 'column': 1}, 'end': {'line': 2046, 'column': 2}}",play_bmp_sequence.c,"['构建', '夫曼', '哈夫曼', '树', '，', '用于', 'JPEG', '解码']"
151,151,stbi__clamp,stbi_uc,stbi_uc stbi__clamp(int x),"[{'name': 'x', 'type': 'int'}]",将输入值限制在0-255范围内,"static stbi_uc stbi__clamp(int x)
{
   // trick to use a single test to catch both cases
   if ((unsigned int) x > 255) {
      if (x < 0) return 0;
      if (x > 255) return 255;
   }
   return (stbi_uc) x;
}","{'begin': {'line': 2416, 'column': 13}, 'end': {'line': 2424, 'column': 2}}",play_bmp_sequence.c,"['将', '输入', '值', '限制', '在', '0', '-', '255', '范围', '内']"
152,152,stbi__idct_block,void,"void stbi__idct_block(stbi_uc * out, int out_stride, short[64] data)","[{'name': 'out', 'type': 'stbi_uc *'}, {'name': 'out_stride', 'type': 'int'}, {'name': 'data', 'type': 'short[64]'}]",执行8x8逆DCT转换并输出处理后的图像块。,"static void stbi__idct_block(stbi_uc *out, int out_stride, short data[64])
{
   int i,val[64],*v=val;
   stbi_uc *o;
   short *d = data;

   // columns
   for (i=0; i < 8; ++i,++d, ++v) {
      // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing
      if (d[ 8]==0 && d[16]==0 && d[24]==0 && d[32]==0
           && d[40]==0 && d[48]==0 && d[56]==0) {
         //    no shortcut                 0     seconds
         //    (1|2|3|4|5|6|7)==0          0     seconds
         //    all separate               -0.047 seconds
         //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds
         int dcterm = d[0]*4;
         v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;
      } else {
         STBI__IDCT_1D(d[ 0],d[ 8],d[16],d[24],d[32],d[40],d[48],d[56])
         // constants scaled things up by 1<<12; let's bring them back
         // down, but keep 2 extra bits of precision
         x0 += 512; x1 += 512; x2 += 512; x3 += 512;
         v[ 0] = (x0+t3) >> 10;
         v[56] = (x0-t3) >> 10;
         v[ 8] = (x1+t2) >> 10;
         v[48] = (x1-t2) >> 10;
         v[16] = (x2+t1) >> 10;
         v[40] = (x2-t1) >> 10;
         v[24] = (x3+t0) >> 10;
         v[32] = (x3-t0) >> 10;
      }
   }

   for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {
      // no fast case since the first 1D IDCT spread components out
      STBI__IDCT_1D(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7])
      // constants scaled things up by 1<<12, plus we had 1<<2 from first
      // loop, plus horizontal and vertical each scale by sqrt(8) so together
      // we've got an extra 1<<3, so 1<<17 total we need to remove.
      // so we want to round that, which means adding 0.5 * 1<<17,
      // aka 65536. Also, we'll end up with -128 to 127 that we want
      // to encode as 0..255 by adding 128, so we'll add that before the shift
      x0 += 65536 + (128<<17);
      x1 += 65536 + (128<<17);
      x2 += 65536 + (128<<17);
      x3 += 65536 + (128<<17);
      // tried computing the shifts into temps, or'ing the temps to see
      // if any were out of range, but that was slower
      o[0] = stbi__clamp((x0+t3) >> 17);
      o[7] = stbi__clamp((x0-t3) >> 17);
      o[1] = stbi__clamp((x1+t2) >> 17);
      o[6] = stbi__clamp((x1-t2) >> 17);
      o[2] = stbi__clamp((x2+t1) >> 17);
      o[5] = stbi__clamp((x2-t1) >> 17);
      o[3] = stbi__clamp((x3+t0) >> 17);
      o[4] = stbi__clamp((x3-t0) >> 17);
   }
}","{'begin': {'line': 2467, 'column': 1}, 'end': {'line': 2524, 'column': 2}}",play_bmp_sequence.c,"['执行', '8x8', '逆', 'DCT', '转换', '并', '输出', '处理', '后', '的', '图像', '块', '。']"
153,153,stbi__build_fast_ac,void,"void stbi__build_fast_ac(stbi__int16 * fast_ac, stbi__huffman * h)","[{'name': 'fast_ac', 'type': 'stbi__int16 *'}, {'name': 'h', 'type': 'stbi__huffman *'}]",构建快速AC系数表以加速哈夫曼解码,"static void stbi__build_fast_ac(stbi__int16 *fast_ac, stbi__huffman *h)
{
   int i;
   for (i=0; i < (1 << FAST_BITS); ++i) {
      stbi_uc fast = h->fast[i];
      fast_ac[i] = 0;
      if (fast < 255) {
         int rs = h->values[fast];
         int run = (rs >> 4) & 15;
         int magbits = rs & 15;
         int len = h->size[fast];

         if (magbits && len + magbits <= FAST_BITS) {
            // magnitude code followed by receive_extend code
            int k = ((i << len) & ((1 << FAST_BITS) - 1)) >> (FAST_BITS - magbits);
            int m = 1 << (magbits - 1);
            if (k < m) k += (~0U << magbits) + 1;
            // if the result is small enough, we can fit it in fast_ac table
            if (k >= -128 && k <= 127)
               fast_ac[i] = (stbi__int16) ((k * 256) + (run * 16) + (len + magbits));
         }
      }
   }
}","{'begin': {'line': 2050, 'column': 1}, 'end': {'line': 2073, 'column': 2}}",play_bmp_sequence.c,"['构建', '快速', 'AC', '系数', '表以', '加速', '夫曼', '哈夫曼', '解码']"
154,154,stbi__grow_buffer_unsafe,void,void stbi__grow_buffer_unsafe(stbi__jpeg * j),"[{'name': 'j', 'type': 'stbi__jpeg *'}]",动态扩展JPEG解码缓冲区，处理填充字节和标记,"static void stbi__grow_buffer_unsafe(stbi__jpeg *j)
{
   do {
      unsigned int b = j->nomore ? 0 : stbi__get8(j->s);
      if (b == 0xff) {
         int c = stbi__get8(j->s);
         while (c == 0xff) c = stbi__get8(j->s); // consume fill bytes
         if (c != 0) {
            j->marker = (unsigned char) c;
            j->nomore = 1;
            return;
         }
      }
      j->code_buffer |= b << (24 - j->code_bits);
      j->code_bits += 8;
   } while (j->code_bits <= 24);
}","{'begin': {'line': 2075, 'column': 1}, 'end': {'line': 2091, 'column': 2}}",play_bmp_sequence.c,"['动态', '扩展', 'JPEG', '解码', '缓冲', '缓冲区', '，', '处理', '填充', '字节', '和', '标记']"
155,155,stbi__jpeg_huff_decode,int,"int stbi__jpeg_huff_decode(stbi__jpeg * j, stbi__huffman * h)","[{'name': 'j', 'type': 'stbi__jpeg *'}, {'name': 'h', 'type': 'stbi__huffman *'}]",解码JPEG霍夫曼编码，返回符号或错误。,"static int stbi__jpeg_huff_decode(stbi__jpeg *j, stbi__huffman *h)
{
   unsigned int temp;
   int c,k;

   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

   // look at the top FAST_BITS and determine what symbol ID it is,
   // if the code is <= FAST_BITS
   c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
   k = h->fast[c];
   if (k < 255) {
      int s = h->size[k];
      if (s > j->code_bits)
         return -1;
      j->code_buffer <<= s;
      j->code_bits -= s;
      return h->values[k];
   }

   // naive test is to shift the code_buffer down so k bits are
   // valid, then test against maxcode. To speed this up, we've
   // preshifted maxcode left so that it has (16-k) 0s at the
   // end; in other words, regardless of the number of bits, it
   // wants to be compared against something shifted to have 16;
   // that way we don't need to shift inside the loop.
   temp = j->code_buffer >> 16;
   for (k=FAST_BITS+1 ; ; ++k)
      if (temp < h->maxcode[k])
         break;
   if (k == 17) {
      // error! code not found
      j->code_bits -= 16;
      return -1;
   }

   if (k > j->code_bits)
      return -1;

   // convert the huffman code to the symbol id
   c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];
   if(c < 0 || c >= 256) // symbol id out of bounds!
       return -1;
   STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);

   // convert the id to a symbol
   j->code_bits -= k;
   j->code_buffer <<= k;
   return h->values[c];
}","{'begin': {'line': 2097, 'column': 13}, 'end': {'line': 2146, 'column': 2}}",play_bmp_sequence.c,"['解码', 'JPEG', '夫曼', '霍夫曼', '编码', '，', '返回', '符号', '或', '错误', '。']"
156,156,stbi__extend_receive,int,"int stbi__extend_receive(stbi__jpeg * j, int n)","[{'name': 'j', 'type': 'stbi__jpeg *'}, {'name': 'n', 'type': 'int'}]",从JPEG比特流中接收并扩展n位数据,"static int stbi__extend_receive(stbi__jpeg *j, int n)
{
   unsigned int k;
   int sgn;
   if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
   if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing

   sgn = j->code_buffer >> 31; // sign bit always in MSB; 0 if MSB clear (positive), 1 if MSB set (negative)
   k = stbi_lrot(j->code_buffer, n);
   j->code_buffer = k & ~stbi__bmask[n];
   k &= stbi__bmask[n];
   j->code_bits -= n;
   return k + (stbi__jbias[n] & (sgn - 1));
}","{'begin': {'line': 2153, 'column': 13}, 'end': {'line': 2166, 'column': 2}}",play_bmp_sequence.c,"['从', 'JPEG', '比特', '比特流', '中', '接收', '并', '扩展', 'n', '位', '数据']"
157,157,stbi__jpeg_get_bits,int,"int stbi__jpeg_get_bits(stbi__jpeg * j, int n)","[{'name': 'j', 'type': 'stbi__jpeg *'}, {'name': 'n', 'type': 'int'}]",从JPEG数据流中提取指定位数的比特,"static int stbi__jpeg_get_bits(stbi__jpeg *j, int n)
{
   unsigned int k;
   if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
   if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing
   k = stbi_lrot(j->code_buffer, n);
   j->code_buffer = k & ~stbi__bmask[n];
   k &= stbi__bmask[n];
   j->code_bits -= n;
   return k;
}","{'begin': {'line': 2169, 'column': 13}, 'end': {'line': 2179, 'column': 2}}",play_bmp_sequence.c,"['从', 'JPEG', '数据', '数据流', '中', '提取', '指定', '位数', '的', '比特']"
158,158,stbi__jpeg_get_bit,int,int stbi__jpeg_get_bit(stbi__jpeg * j),"[{'name': 'j', 'type': 'stbi__jpeg *'}]",从JPEG流中提取单个比特位,"static int stbi__jpeg_get_bit(stbi__jpeg *j)
{
   unsigned int k;
   if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);
   if (j->code_bits < 1) return 0; // ran out of bits from stream, return 0s intead of continuing
   k = j->code_buffer;
   j->code_buffer <<= 1;
   --j->code_bits;
   return k & 0x80000000;
}","{'begin': {'line': 2181, 'column': 13}, 'end': {'line': 2190, 'column': 2}}",play_bmp_sequence.c,"['从', 'JPEG', '流中', '提取', '单个', '比特', '位']"
159,159,stbi__idct_simd,void,"void stbi__idct_simd(stbi_uc * out, int out_stride, short[64] data)","[{'name': 'out', 'type': 'stbi_uc *'}, {'name': 'out_stride', 'type': 'int'}, {'name': 'data', 'type': 'short[64]'}]",使用SIMD优化的逆离散余弦变换函数,"static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
{
   // This is constructed to match our regular (generic) integer IDCT exactly.
   __m128i row0, row1, row2, row3, row4, row5, row6, row7;
   __m128i tmp;

   // dot product constant: even elems=x, odd elems=y
   #define dct_const(x,y)  _mm_setr_epi16((x),(y),(x),(y),(x),(y),(x),(y))

   // out(0) = c0[even]*x + c0[odd]*y   (c0, x, y 16-bit, out 32-bit)
   // out(1) = c1[even]*x + c1[odd]*y
   #define dct_rot(out0,out1, x,y,c0,c1) \
      __m128i c0##lo = _mm_unpacklo_epi16((x),(y)); \
      __m128i c0##hi = _mm_unpackhi_epi16((x),(y)); \
      __m128i out0##_l = _mm_madd_epi16(c0##lo, c0); \
      __m128i out0##_h = _mm_madd_epi16(c0##hi, c0); \
      __m128i out1##_l = _mm_madd_epi16(c0##lo, c1); \
      __m128i out1##_h = _mm_madd_epi16(c0##hi, c1)

   // out = in << 12  (in 16-bit, out 32-bit)
   #define dct_widen(out, in) \
      __m128i out##_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (in)), 4); \
      __m128i out##_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (in)), 4)

   // wide add
   #define dct_wadd(out, a, b) \
      __m128i out##_l = _mm_add_epi32(a##_l, b##_l); \
      __m128i out##_h = _mm_add_epi32(a##_h, b##_h)

   // wide sub
   #define dct_wsub(out, a, b) \
      __m128i out##_l = _mm_sub_epi32(a##_l, b##_l); \
      __m128i out##_h = _mm_sub_epi32(a##_h, b##_h)

   // butterfly a/b, add bias, then shift by ""s"" and pack
   #define dct_bfly32o(out0, out1, a,b,bias,s) \
      { \
         __m128i abiased_l = _mm_add_epi32(a##_l, bias); \
         __m128i abiased_h = _mm_add_epi32(a##_h, bias); \
         dct_wadd(sum, abiased, b); \
         dct_wsub(dif, abiased, b); \
         out0 = _mm_packs_epi32(_mm_srai_epi32(sum_l, s), _mm_srai_epi32(sum_h, s)); \
         out1 = _mm_packs_epi32(_mm_srai_epi32(dif_l, s), _mm_srai_epi32(dif_h, s)); \
      }

   // 8-bit interleave step (for transposes)
   #define dct_interleave8(a, b) \
      tmp = a; \
      a = _mm_unpacklo_epi8(a, b); \
      b = _mm_unpackhi_epi8(tmp, b)

   // 16-bit interleave step (for transposes)
   #define dct_interleave16(a, b) \
      tmp = a; \
      a = _mm_unpacklo_epi16(a, b); \
      b = _mm_unpackhi_epi16(tmp, b)

   #define dct_pass(bias,shift) \
      { \
         /* even part */ \
         dct_rot(t2e,t3e, row2,row6, rot0_0,rot0_1); \
         __m128i sum04 = _mm_add_epi16(row0, row4); \
         __m128i dif04 = _mm_sub_epi16(row0, row4); \
         dct_widen(t0e, sum04); \
         dct_widen(t1e, dif04); \
         dct_wadd(x0, t0e, t3e); \
         dct_wsub(x3, t0e, t3e); \
         dct_wadd(x1, t1e, t2e); \
         dct_wsub(x2, t1e, t2e); \
         /* odd part */ \
         dct_rot(y0o,y2o, row7,row3, rot2_0,rot2_1); \
         dct_rot(y1o,y3o, row5,row1, rot3_0,rot3_1); \
         __m128i sum17 = _mm_add_epi16(row1, row7); \
         __m128i sum35 = _mm_add_epi16(row3, row5); \
         dct_rot(y4o,y5o, sum17,sum35, rot1_0,rot1_1); \
         dct_wadd(x4, y0o, y4o); \
         dct_wadd(x5, y1o, y5o); \
         dct_wadd(x6, y2o, y5o); \
         dct_wadd(x7, y3o, y4o); \
         dct_bfly32o(row0,row7, x0,x7,bias,shift); \
         dct_bfly32o(row1,row6, x1,x6,bias,shift); \
         dct_bfly32o(row2,row5, x2,x5,bias,shift); \
         dct_bfly32o(row3,row4, x3,x4,bias,shift); \
      }

   __m128i rot0_0 = dct_const(stbi__f2f(0.5411961f), stbi__f2f(0.5411961f) + stbi__f2f(-1.847759065f));
   __m128i rot0_1 = dct_const(stbi__f2f(0.5411961f) + stbi__f2f( 0.765366865f), stbi__f2f(0.5411961f));
   __m128i rot1_0 = dct_const(stbi__f2f(1.175875602f) + stbi__f2f(-0.899976223f), stbi__f2f(1.175875602f));
   __m128i rot1_1 = dct_const(stbi__f2f(1.175875602f), stbi__f2f(1.175875602f) + stbi__f2f(-2.562915447f));
   __m128i rot2_0 = dct_const(stbi__f2f(-1.961570560f) + stbi__f2f( 0.298631336f), stbi__f2f(-1.961570560f));
   __m128i rot2_1 = dct_const(stbi__f2f(-1.961570560f), stbi__f2f(-1.961570560f) + stbi__f2f( 3.072711026f));
   __m128i rot3_0 = dct_const(stbi__f2f(-0.390180644f) + stbi__f2f( 2.053119869f), stbi__f2f(-0.390180644f));
   __m128i rot3_1 = dct_const(stbi__f2f(-0.390180644f), stbi__f2f(-0.390180644f) + stbi__f2f( 1.501321110f));

   // rounding biases in column/row passes, see stbi__idct_block for explanation.
   __m128i bias_0 = _mm_set1_epi32(512);
   __m128i bias_1 = _mm_set1_epi32(65536 + (128<<17));

   // load
   row0 = _mm_load_si128((const __m128i *) (data + 0*8));
   row1 = _mm_load_si128((const __m128i *) (data + 1*8));
   row2 = _mm_load_si128((const __m128i *) (data + 2*8));
   row3 = _mm_load_si128((const __m128i *) (data + 3*8));
   row4 = _mm_load_si128((const __m128i *) (data + 4*8));
   row5 = _mm_load_si128((const __m128i *) (data + 5*8));
   row6 = _mm_load_si128((const __m128i *) (data + 6*8));
   row7 = _mm_load_si128((const __m128i *) (data + 7*8));

   // column pass
   dct_pass(bias_0, 10);

   {
      // 16bit 8x8 transpose pass 1
      dct_interleave16(row0, row4);
      dct_interleave16(row1, row5);
      dct_interleave16(row2, row6);
      dct_interleave16(row3, row7);

      // transpose pass 2
      dct_interleave16(row0, row2);
      dct_interleave16(row1, row3);
      dct_interleave16(row4, row6);
      dct_interleave16(row5, row7);

      // transpose pass 3
      dct_interleave16(row0, row1);
      dct_interleave16(row2, row3);
      dct_interleave16(row4, row5);
      dct_interleave16(row6, row7);
   }

   // row pass
   dct_pass(bias_1, 17);

   {
      // pack
      __m128i p0 = _mm_packus_epi16(row0, row1); // a0a1a2a3...a7b0b1b2b3...b7
      __m128i p1 = _mm_packus_epi16(row2, row3);
      __m128i p2 = _mm_packus_epi16(row4, row5);
      __m128i p3 = _mm_packus_epi16(row6, row7);

      // 8bit 8x8 transpose pass 1
      dct_interleave8(p0, p2); // a0e0a1e1...
      dct_interleave8(p1, p3); // c0g0c1g1...

      // transpose pass 2
      dct_interleave8(p0, p1); // a0c0e0g0...
      dct_interleave8(p2, p3); // b0d0f0h0...

      // transpose pass 3
      dct_interleave8(p0, p2); // a0b0c0d0...
      dct_interleave8(p1, p3); // a4b4c4d4...

      // store
      _mm_storel_epi64((__m128i *) out, p0); out += out_stride;
      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p0, 0x4e)); out += out_stride;
      _mm_storel_epi64((__m128i *) out, p2); out += out_stride;
      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p2, 0x4e)); out += out_stride;
      _mm_storel_epi64((__m128i *) out, p1); out += out_stride;
      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p1, 0x4e)); out += out_stride;
      _mm_storel_epi64((__m128i *) out, p3); out += out_stride;
      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p3, 0x4e));
   }

#undef dct_const
#undef dct_rot
#undef dct_widen
#undef dct_wadd
#undef dct_wsub
#undef dct_bfly32o
#undef dct_interleave8
#undef dct_interleave16
#undef dct_pass
}","{'begin': {'line': 2530, 'column': 1}, 'end': {'line': 2703, 'column': 2}}",play_bmp_sequence.c,"['使用', 'SIMD', '优化', '的', '逆', '离散', '余弦', '变换', '函数']"
160,160,stbi__get_marker,stbi_uc,stbi_uc stbi__get_marker(stbi__jpeg * j),"[{'name': 'j', 'type': 'stbi__jpeg *'}]",获取JPEG图像的下一个标记字节,"static stbi_uc stbi__get_marker(stbi__jpeg *j)
{
   stbi_uc x;
   if (j->marker != STBI__MARKER_none) { x = j->marker; j->marker = STBI__MARKER_none; return x; }
   x = stbi__get8(j->s);
   if (x != 0xff) return STBI__MARKER_none;
   while (x == 0xff)
      x = stbi__get8(j->s); // consume repeated 0xff fill bytes
   return x;
}","{'begin': {'line': 2919, 'column': 1}, 'end': {'line': 2928, 'column': 2}}",play_bmp_sequence.c,"['获取', 'JPEG', '图像', '的', '下', '一个', '标记', '字节']"
161,161,stbi__jpeg_decode_block,int,"int stbi__jpeg_decode_block(stbi__jpeg * j, short[64] data, stbi__huffman * hdc, stbi__huffman * hac, stbi__int16 * fac, int b, stbi__uint16 * dequant)","[{'name': 'j', 'type': 'stbi__jpeg *'}, {'name': 'data', 'type': 'short[64]'}, {'name': 'hdc', 'type': 'stbi__huffman *'}, {'name': 'hac', 'type': 'stbi__huffman *'}, {'name': 'fac', 'type': 'stbi__int16 *'}, {'name': 'b', 'type': 'int'}, {'name': 'dequant', 'type': 'stbi__uint16 *'}]",解码JPEG图像块，应用霍夫曼解码和反量化。,"static int stbi__jpeg_decode_block(stbi__jpeg *j, short data[64], stbi__huffman *hdc, stbi__huffman *hac, stbi__int16 *fac, int b, stbi__uint16 *dequant)
{
   int diff,dc,k;
   int t;

   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
   t = stbi__jpeg_huff_decode(j, hdc);
   if (t < 0 || t > 15) return stbi__err(""bad huffman code"",""Corrupt JPEG"");

   // 0 all the ac values now so we can do it 32-bits at a time
   memset(data,0,64*sizeof(data[0]));

   diff = t ? stbi__extend_receive(j, t) : 0;
   if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err(""bad delta"",""Corrupt JPEG"");
   dc = j->img_comp[b].dc_pred + diff;
   j->img_comp[b].dc_pred = dc;
   if (!stbi__mul2shorts_valid(dc, dequant[0])) return stbi__err(""can't merge dc and ac"", ""Corrupt JPEG"");
   data[0] = (short) (dc * dequant[0]);

   // decode AC components, see JPEG spec
   k = 1;
   do {
      unsigned int zig;
      int c,r,s;
      if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
      c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
      r = fac[c];
      if (r) { // fast-AC path
         k += (r >> 4) & 15; // run
         s = r & 15; // combined length
         if (s > j->code_bits) return stbi__err(""bad huffman code"", ""Combined length longer than code bits available"");
         j->code_buffer <<= s;
         j->code_bits -= s;
         // decode into unzigzag'd location
         zig = stbi__jpeg_dezigzag[k++];
         data[zig] = (short) ((r >> 8) * dequant[zig]);
      } else {
         int rs = stbi__jpeg_huff_decode(j, hac);
         if (rs < 0) return stbi__err(""bad huffman code"",""Corrupt JPEG"");
         s = rs & 15;
         r = rs >> 4;
         if (s == 0) {
            if (rs != 0xf0) break; // end block
            k += 16;
         } else {
            k += r;
            // decode into unzigzag'd location
            zig = stbi__jpeg_dezigzag[k++];
            data[zig] = (short) (stbi__extend_receive(j,s) * dequant[zig]);
         }
      }
   } while (k < 64);
   return 1;
}","{'begin': {'line': 2210, 'column': 1}, 'end': {'line': 2263, 'column': 2}}",play_bmp_sequence.c,"['解码', 'JPEG', '图像', '块', '，', '应用', '夫曼', '霍夫曼', '解码', '和', '反', '量化', '。']"
162,162,stbi__jpeg_reset,void,void stbi__jpeg_reset(stbi__jpeg * j),"[{'name': 'j', 'type': 'stbi__jpeg *'}]",重置JPEG解码器内部状态变量,"static void stbi__jpeg_reset(stbi__jpeg *j)
{
   j->code_bits = 0;
   j->code_buffer = 0;
   j->nomore = 0;
   j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = j->img_comp[3].dc_pred = 0;
   j->marker = STBI__MARKER_none;
   j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;
   j->eob_run = 0;
   // no more than 1<<31 MCUs if no restart_interal? that's plenty safe,
   // since we don't even allow 1<<30 pixels
}","{'begin': {'line': 2936, 'column': 1}, 'end': {'line': 2947, 'column': 2}}",play_bmp_sequence.c,"['重置', 'JPEG', '解码', '码器', '解码器', '内部', '状态', '变量', '态变量', '状态变量']"
163,163,stbi__parse_entropy_coded_data,int,int stbi__parse_entropy_coded_data(stbi__jpeg * z),"[{'name': 'z', 'type': 'stbi__jpeg *'}]",解析JPEG熵编码数据，处理数据块及重启间隔。,"static int stbi__parse_entropy_coded_data(stbi__jpeg *z)
{
   stbi__jpeg_reset(z);
   if (!z->progressive) {
      if (z->scan_n == 1) {
         int i,j;
         STBI_SIMD_ALIGN(short, data[64]);
         int n = z->order[0];
         // non-interleaved data, we just need to process one block at a time,
         // in trivial scanline order
         // number of blocks to do just depends on how many actual ""pixels"" this
         // component has, independent of interleaved MCU blocking and such
         int w = (z->img_comp[n].x+7) >> 3;
         int h = (z->img_comp[n].y+7) >> 3;
         for (j=0; j < h; ++j) {
            for (i=0; i < w; ++i) {
               int ha = z->img_comp[n].ha;
               if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
               z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
               // every data block is an MCU, so countdown the restart interval
               if (--z->todo <= 0) {
                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
                  // if it's NOT a restart, then just bail, so we get corrupt data
                  // rather than no data
                  if (!STBI__RESTART(z->marker)) return 1;
                  stbi__jpeg_reset(z);
               }
            }
         }
         return 1;
      } else { // interleaved
         int i,j,k,x,y;
         STBI_SIMD_ALIGN(short, data[64]);
         for (j=0; j < z->img_mcu_y; ++j) {
            for (i=0; i < z->img_mcu_x; ++i) {
               // scan an interleaved mcu... process scan_n components in order
               for (k=0; k < z->scan_n; ++k) {
                  int n = z->order[k];
                  // scan out an mcu's worth of this component; that's just determined
                  // by the basic H and V specified for the component
                  for (y=0; y < z->img_comp[n].v; ++y) {
                     for (x=0; x < z->img_comp[n].h; ++x) {
                        int x2 = (i*z->img_comp[n].h + x)*8;
                        int y2 = (j*z->img_comp[n].v + y)*8;
                        int ha = z->img_comp[n].ha;
                        if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
                        z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*y2+x2, z->img_comp[n].w2, data);
                     }
                  }
               }
               // after all interleaved components, that's an interleaved MCU,
               // so now count down the restart interval
               if (--z->todo <= 0) {
                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
                  if (!STBI__RESTART(z->marker)) return 1;
                  stbi__jpeg_reset(z);
               }
            }
         }
         return 1;
      }
   } else {
      if (z->scan_n == 1) {
         int i,j;
         int n = z->order[0];
         // non-interleaved data, we just need to process one block at a time,
         // in trivial scanline order
         // number of blocks to do just depends on how many actual ""pixels"" this
         // component has, independent of interleaved MCU blocking and such
         int w = (z->img_comp[n].x+7) >> 3;
         int h = (z->img_comp[n].y+7) >> 3;
         for (j=0; j < h; ++j) {
            for (i=0; i < w; ++i) {
               short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
               if (z->spec_start == 0) {
                  if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
                     return 0;
               } else {
                  int ha = z->img_comp[n].ha;
                  if (!stbi__jpeg_decode_block_prog_ac(z, data, &z->huff_ac[ha], z->fast_ac[ha]))
                     return 0;
               }
               // every data block is an MCU, so countdown the restart interval
               if (--z->todo <= 0) {
                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
                  if (!STBI__RESTART(z->marker)) return 1;
                  stbi__jpeg_reset(z);
               }
            }
         }
         return 1;
      } else { // interleaved
         int i,j,k,x,y;
         for (j=0; j < z->img_mcu_y; ++j) {
            for (i=0; i < z->img_mcu_x; ++i) {
               // scan an interleaved mcu... process scan_n components in order
               for (k=0; k < z->scan_n; ++k) {
                  int n = z->order[k];
                  // scan out an mcu's worth of this component; that's just determined
                  // by the basic H and V specified for the component
                  for (y=0; y < z->img_comp[n].v; ++y) {
                     for (x=0; x < z->img_comp[n].h; ++x) {
                        int x2 = (i*z->img_comp[n].h + x);
                        int y2 = (j*z->img_comp[n].v + y);
                        short *data = z->img_comp[n].coeff + 64 * (x2 + y2 * z->img_comp[n].coeff_w);
                        if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
                           return 0;
                     }
                  }
               }
               // after all interleaved components, that's an interleaved MCU,
               // so now count down the restart interval
               if (--z->todo <= 0) {
                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
                  if (!STBI__RESTART(z->marker)) return 1;
                  stbi__jpeg_reset(z);
               }
            }
         }
         return 1;
      }
   }
}","{'begin': {'line': 2949, 'column': 1}, 'end': {'line': 3071, 'column': 2}}",play_bmp_sequence.c,"['解析', 'JPEG', '熵', '编码', '码数', '数据', '编码数据', '，', '处理', '数据', '块', '及', '重启', '间隔', '。']"
164,164,stbi__jpeg_decode_block_prog_dc,int,"int stbi__jpeg_decode_block_prog_dc(stbi__jpeg * j, short[64] data, stbi__huffman * hdc, int b)","[{'name': 'j', 'type': 'stbi__jpeg *'}, {'name': 'data', 'type': 'short[64]'}, {'name': 'hdc', 'type': 'stbi__huffman *'}, {'name': 'b', 'type': 'int'}]",解码渐进式JPEG的DC系数块，处理首次及细化扫描,"static int stbi__jpeg_decode_block_prog_dc(stbi__jpeg *j, short data[64], stbi__huffman *hdc, int b)
{
   int diff,dc;
   int t;
   if (j->spec_end != 0) return stbi__err(""can't merge dc and ac"", ""Corrupt JPEG"");

   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

   if (j->succ_high == 0) {
      // first scan for DC coefficient, must be first
      memset(data,0,64*sizeof(data[0])); // 0 all the ac values now
      t = stbi__jpeg_huff_decode(j, hdc);
      if (t < 0 || t > 15) return stbi__err(""can't merge dc and ac"", ""Corrupt JPEG"");
      diff = t ? stbi__extend_receive(j, t) : 0;

      if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err(""bad delta"", ""Corrupt JPEG"");
      dc = j->img_comp[b].dc_pred + diff;
      j->img_comp[b].dc_pred = dc;
      if (!stbi__mul2shorts_valid(dc, 1 << j->succ_low)) return stbi__err(""can't merge dc and ac"", ""Corrupt JPEG"");
      data[0] = (short) (dc * (1 << j->succ_low));
   } else {
      // refinement scan for DC coefficient
      if (stbi__jpeg_get_bit(j))
         data[0] += (short) (1 << j->succ_low);
   }
   return 1;
}","{'begin': {'line': 2265, 'column': 1}, 'end': {'line': 2291, 'column': 2}}",play_bmp_sequence.c,"['解码', '渐进', '渐进式', 'JPEG', '的', 'DC', '系数', '块', '，', '处理', '首次', '及', '细化', '扫描']"
165,165,stbi__jpeg_decode_block_prog_ac,int,"int stbi__jpeg_decode_block_prog_ac(stbi__jpeg * j, short[64] data, stbi__huffman * hac, stbi__int16 * fac)","[{'name': 'j', 'type': 'stbi__jpeg *'}, {'name': 'data', 'type': 'short[64]'}, {'name': 'hac', 'type': 'stbi__huffman *'}, {'name': 'fac', 'type': 'stbi__int16 *'}]",解码JPEG渐进式AC块，处理细化扫描。,"static int stbi__jpeg_decode_block_prog_ac(stbi__jpeg *j, short data[64], stbi__huffman *hac, stbi__int16 *fac)
{
   int k;
   if (j->spec_start == 0) return stbi__err(""can't merge dc and ac"", ""Corrupt JPEG"");

   if (j->succ_high == 0) {
      int shift = j->succ_low;

      if (j->eob_run) {
         --j->eob_run;
         return 1;
      }

      k = j->spec_start;
      do {
         unsigned int zig;
         int c,r,s;
         if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
         c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
         r = fac[c];
         if (r) { // fast-AC path
            k += (r >> 4) & 15; // run
            s = r & 15; // combined length
            if (s > j->code_bits) return stbi__err(""bad huffman code"", ""Combined length longer than code bits available"");
            j->code_buffer <<= s;
            j->code_bits -= s;
            zig = stbi__jpeg_dezigzag[k++];
            data[zig] = (short) ((r >> 8) * (1 << shift));
         } else {
            int rs = stbi__jpeg_huff_decode(j, hac);
            if (rs < 0) return stbi__err(""bad huffman code"",""Corrupt JPEG"");
            s = rs & 15;
            r = rs >> 4;
            if (s == 0) {
               if (r < 15) {
                  j->eob_run = (1 << r);
                  if (r)
                     j->eob_run += stbi__jpeg_get_bits(j, r);
                  --j->eob_run;
                  break;
               }
               k += 16;
            } else {
               k += r;
               zig = stbi__jpeg_dezigzag[k++];
               data[zig] = (short) (stbi__extend_receive(j,s) * (1 << shift));
            }
         }
      } while (k <= j->spec_end);
   } else {
      // refinement scan for these AC coefficients

      short bit = (short) (1 << j->succ_low);

      if (j->eob_run) {
         --j->eob_run;
         for (k = j->spec_start; k <= j->spec_end; ++k) {
            short *p = &data[stbi__jpeg_dezigzag[k]];
            if (*p != 0)
               if (stbi__jpeg_get_bit(j))
                  if ((*p & bit)==0) {
                     if (*p > 0)
                        *p += bit;
                     else
                        *p -= bit;
                  }
         }
      } else {
         k = j->spec_start;
         do {
            int r,s;
            int rs = stbi__jpeg_huff_decode(j, hac); // @OPTIMIZE see if we can use the fast path here, advance-by-r is so slow, eh
            if (rs < 0) return stbi__err(""bad huffman code"",""Corrupt JPEG"");
            s = rs & 15;
            r = rs >> 4;
            if (s == 0) {
               if (r < 15) {
                  j->eob_run = (1 << r) - 1;
                  if (r)
                     j->eob_run += stbi__jpeg_get_bits(j, r);
                  r = 64; // force end of block
               } else {
                  // r=15 s=0 should write 16 0s, so we just do
                  // a run of 15 0s and then write s (which is 0),
                  // so we don't have to do anything special here
               }
            } else {
               if (s != 1) return stbi__err(""bad huffman code"", ""Corrupt JPEG"");
               // sign bit
               if (stbi__jpeg_get_bit(j))
                  s = bit;
               else
                  s = -bit;
            }

            // advance by r
            while (k <= j->spec_end) {
               short *p = &data[stbi__jpeg_dezigzag[k++]];
               if (*p != 0) {
                  if (stbi__jpeg_get_bit(j))
                     if ((*p & bit)==0) {
                        if (*p > 0)
                           *p += bit;
                        else
                           *p -= bit;
                     }
               } else {
                  if (r == 0) {
                     *p = (short) s;
                     break;
                  }
                  --r;
               }
            }
         } while (k <= j->spec_end);
      }
   }
   return 1;
}","{'begin': {'line': 2295, 'column': 1}, 'end': {'line': 2413, 'column': 2}}",play_bmp_sequence.c,"['解码', 'JPEG', '渐进', '渐进式', 'AC', '块', '，', '处理', '细化', '扫描', '。']"
166,166,stbi__jpeg_dequantize,void,"void stbi__jpeg_dequantize(short * data, stbi__uint16 * dequant)","[{'name': 'data', 'type': 'short *'}, {'name': 'dequant', 'type': 'stbi__uint16 *'}]",对JPEG数据块进行反量化处理,"static void stbi__jpeg_dequantize(short *data, stbi__uint16 *dequant)
{
   int i;
   for (i=0; i < 64; ++i)
      data[i] *= dequant[i];
}","{'begin': {'line': 3073, 'column': 1}, 'end': {'line': 3078, 'column': 2}}",play_bmp_sequence.c,"['对', 'JPEG', '数据', '块', '进行', '反', '量化', '处理']"
167,167,stbi__jpeg_finish,void,void stbi__jpeg_finish(stbi__jpeg * z),"[{'name': 'z', 'type': 'stbi__jpeg *'}]",完成渐进式JPEG解码后的反量化和逆DCT处理,"static void stbi__jpeg_finish(stbi__jpeg *z)
{
   if (z->progressive) {
      // dequantize and idct the data
      int i,j,n;
      for (n=0; n < z->s->img_n; ++n) {
         int w = (z->img_comp[n].x+7) >> 3;
         int h = (z->img_comp[n].y+7) >> 3;
         for (j=0; j < h; ++j) {
            for (i=0; i < w; ++i) {
               short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
               stbi__jpeg_dequantize(data, z->dequant[z->img_comp[n].tq]);
               z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
            }
         }
      }
   }
}","{'begin': {'line': 3080, 'column': 1}, 'end': {'line': 3097, 'column': 2}}",play_bmp_sequence.c,"['完成', '渐进', '渐进式', 'JPEG', '解码', '后', '的', '反', '量化', '和', '逆', 'DCT', '处理']"
168,168,stbi__clamp,stbi_uc,stbi_uc stbi__clamp(int x),"[{'name': 'x', 'type': 'int'}]",将输入值钳位到0-255范围内,"static stbi_uc stbi__clamp(int x)
{
   // trick to use a single test to catch both cases
   if ((unsigned int) x > 255) {
      if (x < 0) return 0;
      if (x > 255) return 255;
   }
   return (stbi_uc) x;
}","{'begin': {'line': 2416, 'column': 13}, 'end': {'line': 2424, 'column': 2}}",play_bmp_sequence.c,"['将', '输入', '值', '钳位', '到', '0', '-', '255', '范围', '内']"
169,169,stbi__process_marker,int,"int stbi__process_marker(stbi__jpeg * z, int m)","[{'name': 'z', 'type': 'stbi__jpeg *'}, {'name': 'm', 'type': 'int'}]",处理JPEG标记并验证数据有效性,"static int stbi__process_marker(stbi__jpeg *z, int m)
{
   int L;
   switch (m) {
      case STBI__MARKER_none: // no marker found
         return stbi__err(""expected marker"",""Corrupt JPEG"");

      case 0xDD: // DRI - specify restart interval
         if (stbi__get16be(z->s) != 4) return stbi__err(""bad DRI len"",""Corrupt JPEG"");
         z->restart_interval = stbi__get16be(z->s);
         return 1;

      case 0xDB: // DQT - define quantization table
         L = stbi__get16be(z->s)-2;
         while (L > 0) {
            int q = stbi__get8(z->s);
            int p = q >> 4, sixteen = (p != 0);
            int t = q & 15,i;
            if (p != 0 && p != 1) return stbi__err(""bad DQT type"",""Corrupt JPEG"");
            if (t > 3) return stbi__err(""bad DQT table"",""Corrupt JPEG"");

            for (i=0; i < 64; ++i)
               z->dequant[t][stbi__jpeg_dezigzag[i]] = (stbi__uint16)(sixteen ? stbi__get16be(z->s) : stbi__get8(z->s));
            L -= (sixteen ? 129 : 65);
         }
         return L==0;

      case 0xC4: // DHT - define huffman table
         L = stbi__get16be(z->s)-2;
         while (L > 0) {
            stbi_uc *v;
            int sizes[16],i,n=0;
            int q = stbi__get8(z->s);
            int tc = q >> 4;
            int th = q & 15;
            if (tc > 1 || th > 3) return stbi__err(""bad DHT header"",""Corrupt JPEG"");
            for (i=0; i < 16; ++i) {
               sizes[i] = stbi__get8(z->s);
               n += sizes[i];
            }
            if(n > 256) return stbi__err(""bad DHT header"",""Corrupt JPEG""); // Loop over i < n would write past end of values!
            L -= 17;
            if (tc == 0) {
               if (!stbi__build_huffman(z->huff_dc+th, sizes)) return 0;
               v = z->huff_dc[th].values;
            } else {
               if (!stbi__build_huffman(z->huff_ac+th, sizes)) return 0;
               v = z->huff_ac[th].values;
            }
            for (i=0; i < n; ++i)
               v[i] = stbi__get8(z->s);
            if (tc != 0)
               stbi__build_fast_ac(z->fast_ac[th], z->huff_ac + th);
            L -= n;
         }
         return L==0;
   }

   // check for comment block or APP blocks
   if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {
      L = stbi__get16be(z->s);
      if (L < 2) {
         if (m == 0xFE)
            return stbi__err(""bad COM len"",""Corrupt JPEG"");
         else
            return stbi__err(""bad APP len"",""Corrupt JPEG"");
      }
      L -= 2;

      if (m == 0xE0 && L >= 5) { // JFIF APP0 segment
         static const unsigned char tag[5] = {'J','F','I','F','\0'};
         int ok = 1;
         int i;
         for (i=0; i < 5; ++i)
            if (stbi__get8(z->s) != tag[i])
               ok = 0;
         L -= 5;
         if (ok)
            z->jfif = 1;
      } else if (m == 0xEE && L >= 12) { // Adobe APP14 segment
         static const unsigned char tag[6] = {'A','d','o','b','e','\0'};
         int ok = 1;
         int i;
         for (i=0; i < 6; ++i)
            if (stbi__get8(z->s) != tag[i])
               ok = 0;
         L -= 6;
         if (ok) {
            stbi__get8(z->s); // version
            stbi__get16be(z->s); // flags0
            stbi__get16be(z->s); // flags1
            z->app14_color_transform = stbi__get8(z->s); // color transform
            L -= 6;
         }
      }

      stbi__skip(z->s, L);
      return 1;
   }

   return stbi__err(""unknown marker"",""Corrupt JPEG"");
}","{'begin': {'line': 3099, 'column': 1}, 'end': {'line': 3200, 'column': 2}}",play_bmp_sequence.c,"['处理', 'JPEG', '标记', '并', '验证', '数据', '有效', '有效性']"
170,170,stbi__idct_block,void,"void stbi__idct_block(stbi_uc * out, int out_stride, short[64] data)","[{'name': 'out', 'type': 'stbi_uc *'}, {'name': 'out_stride', 'type': 'int'}, {'name': 'data', 'type': 'short[64]'}]",执行8x8块的逆离散余弦变换，用于JPEG解码。,"static void stbi__idct_block(stbi_uc *out, int out_stride, short data[64])
{
   int i,val[64],*v=val;
   stbi_uc *o;
   short *d = data;

   // columns
   for (i=0; i < 8; ++i,++d, ++v) {
      // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing
      if (d[ 8]==0 && d[16]==0 && d[24]==0 && d[32]==0
           && d[40]==0 && d[48]==0 && d[56]==0) {
         //    no shortcut                 0     seconds
         //    (1|2|3|4|5|6|7)==0          0     seconds
         //    all separate               -0.047 seconds
         //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds
         int dcterm = d[0]*4;
         v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;
      } else {
         STBI__IDCT_1D(d[ 0],d[ 8],d[16],d[24],d[32],d[40],d[48],d[56])
         // constants scaled things up by 1<<12; let's bring them back
         // down, but keep 2 extra bits of precision
         x0 += 512; x1 += 512; x2 += 512; x3 += 512;
         v[ 0] = (x0+t3) >> 10;
         v[56] = (x0-t3) >> 10;
         v[ 8] = (x1+t2) >> 10;
         v[48] = (x1-t2) >> 10;
         v[16] = (x2+t1) >> 10;
         v[40] = (x2-t1) >> 10;
         v[24] = (x3+t0) >> 10;
         v[32] = (x3-t0) >> 10;
      }
   }

   for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {
      // no fast case since the first 1D IDCT spread components out
      STBI__IDCT_1D(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7])
      // constants scaled things up by 1<<12, plus we had 1<<2 from first
      // loop, plus horizontal and vertical each scale by sqrt(8) so together
      // we've got an extra 1<<3, so 1<<17 total we need to remove.
      // so we want to round that, which means adding 0.5 * 1<<17,
      // aka 65536. Also, we'll end up with -128 to 127 that we want
      // to encode as 0..255 by adding 128, so we'll add that before the shift
      x0 += 65536 + (128<<17);
      x1 += 65536 + (128<<17);
      x2 += 65536 + (128<<17);
      x3 += 65536 + (128<<17);
      // tried computing the shifts into temps, or'ing the temps to see
      // if any were out of range, but that was slower
      o[0] = stbi__clamp((x0+t3) >> 17);
      o[7] = stbi__clamp((x0-t3) >> 17);
      o[1] = stbi__clamp((x1+t2) >> 17);
      o[6] = stbi__clamp((x1-t2) >> 17);
      o[2] = stbi__clamp((x2+t1) >> 17);
      o[5] = stbi__clamp((x2-t1) >> 17);
      o[3] = stbi__clamp((x3+t0) >> 17);
      o[4] = stbi__clamp((x3-t0) >> 17);
   }
}","{'begin': {'line': 2467, 'column': 1}, 'end': {'line': 2524, 'column': 2}}",play_bmp_sequence.c,"['执行', '8x8', '块', '的', '逆', '离散', '余弦', '变换', '，', '用于', 'JPEG', '解码', '。']"
171,171,stbi__process_scan_header,int,int stbi__process_scan_header(stbi__jpeg * z),"[{'name': 'z', 'type': 'stbi__jpeg *'}]",解析并验证JPEG扫描头信息,"static int stbi__process_scan_header(stbi__jpeg *z)
{
   int i;
   int Ls = stbi__get16be(z->s);
   z->scan_n = stbi__get8(z->s);
   if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int) z->s->img_n) return stbi__err(""bad SOS component count"",""Corrupt JPEG"");
   if (Ls != 6+2*z->scan_n) return stbi__err(""bad SOS len"",""Corrupt JPEG"");
   for (i=0; i < z->scan_n; ++i) {
      int id = stbi__get8(z->s), which;
      int q = stbi__get8(z->s);
      for (which = 0; which < z->s->img_n; ++which)
         if (z->img_comp[which].id == id)
            break;
      if (which == z->s->img_n) return 0; // no match
      z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return stbi__err(""bad DC huff"",""Corrupt JPEG"");
      z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return stbi__err(""bad AC huff"",""Corrupt JPEG"");
      z->order[i] = which;
   }

   {
      int aa;
      z->spec_start = stbi__get8(z->s);
      z->spec_end   = stbi__get8(z->s); // should be 63, but might be 0
      aa = stbi__get8(z->s);
      z->succ_high = (aa >> 4);
      z->succ_low  = (aa & 15);
      if (z->progressive) {
         if (z->spec_start > 63 || z->spec_end > 63  || z->spec_start > z->spec_end || z->succ_high > 13 || z->succ_low > 13)
            return stbi__err(""bad SOS"", ""Corrupt JPEG"");
      } else {
         if (z->spec_start != 0) return stbi__err(""bad SOS"",""Corrupt JPEG"");
         if (z->succ_high != 0 || z->succ_low != 0) return stbi__err(""bad SOS"",""Corrupt JPEG"");
         z->spec_end = 63;
      }
   }

   return 1;
}","{'begin': {'line': 3203, 'column': 1}, 'end': {'line': 3240, 'column': 2}}",play_bmp_sequence.c,"['解析', '并', '验证', 'JPEG', '扫描', '头', '信息']"
172,172,stbi__free_jpeg_components,int,"int stbi__free_jpeg_components(stbi__jpeg * z, int ncomp, int why)","[{'name': 'z', 'type': 'stbi__jpeg *'}, {'name': 'ncomp', 'type': 'int'}, {'name': 'why', 'type': 'int'}]",释放JPEG组件资源并返回指定值,"static int stbi__free_jpeg_components(stbi__jpeg *z, int ncomp, int why)
{
   int i;
   for (i=0; i < ncomp; ++i) {
      if (z->img_comp[i].raw_data) {
         STBI_FREE(z->img_comp[i].raw_data);
         z->img_comp[i].raw_data = NULL;
         z->img_comp[i].data = NULL;
      }
      if (z->img_comp[i].raw_coeff) {
         STBI_FREE(z->img_comp[i].raw_coeff);
         z->img_comp[i].raw_coeff = 0;
         z->img_comp[i].coeff = 0;
      }
      if (z->img_comp[i].linebuf) {
         STBI_FREE(z->img_comp[i].linebuf);
         z->img_comp[i].linebuf = NULL;
      }
   }
   return why;
}","{'begin': {'line': 3242, 'column': 1}, 'end': {'line': 3262, 'column': 2}}",play_bmp_sequence.c,"['释放', 'JPEG', '组件', '资源', '并', '返回', '指定', '值']"
173,173,stbi__process_frame_header,int,"int stbi__process_frame_header(stbi__jpeg * z, int scan)","[{'name': 'z', 'type': 'stbi__jpeg *'}, {'name': 'scan', 'type': 'int'}]",解析JPEG帧头并验证参数及内存分配,"static int stbi__process_frame_header(stbi__jpeg *z, int scan)
{
   stbi__context *s = z->s;
   int Lf,p,i,q, h_max=1,v_max=1,c;
   Lf = stbi__get16be(s);         if (Lf < 11) return stbi__err(""bad SOF len"",""Corrupt JPEG""); // JPEG
   p  = stbi__get8(s);            if (p != 8) return stbi__err(""only 8-bit"",""JPEG format not supported: 8-bit only""); // JPEG baseline
   s->img_y = stbi__get16be(s);   if (s->img_y == 0) return stbi__err(""no header height"", ""JPEG format not supported: delayed height""); // Legal, but we don't handle it--but neither does IJG
   s->img_x = stbi__get16be(s);   if (s->img_x == 0) return stbi__err(""0 width"",""Corrupt JPEG""); // JPEG requires
   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err(""too large"",""Very large image (corrupt?)"");
   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err(""too large"",""Very large image (corrupt?)"");
   c = stbi__get8(s);
   if (c != 3 && c != 1 && c != 4) return stbi__err(""bad component count"",""Corrupt JPEG"");
   s->img_n = c;
   for (i=0; i < c; ++i) {
      z->img_comp[i].data = NULL;
      z->img_comp[i].linebuf = NULL;
   }

   if (Lf != 8+3*s->img_n) return stbi__err(""bad SOF len"",""Corrupt JPEG"");

   z->rgb = 0;
   for (i=0; i < s->img_n; ++i) {
      static const unsigned char rgb[3] = { 'R', 'G', 'B' };
      z->img_comp[i].id = stbi__get8(s);
      if (s->img_n == 3 && z->img_comp[i].id == rgb[i])
         ++z->rgb;
      q = stbi__get8(s);
      z->img_comp[i].h = (q >> 4);  if (!z->img_comp[i].h || z->img_comp[i].h > 4) return stbi__err(""bad H"",""Corrupt JPEG"");
      z->img_comp[i].v = q & 15;    if (!z->img_comp[i].v || z->img_comp[i].v > 4) return stbi__err(""bad V"",""Corrupt JPEG"");
      z->img_comp[i].tq = stbi__get8(s);  if (z->img_comp[i].tq > 3) return stbi__err(""bad TQ"",""Corrupt JPEG"");
   }

   if (scan != STBI__SCAN_load) return 1;

   if (!stbi__mad3sizes_valid(s->img_x, s->img_y, s->img_n, 0)) return stbi__err(""too large"", ""Image too large to decode"");

   for (i=0; i < s->img_n; ++i) {
      if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h;
      if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v;
   }

   // check that plane subsampling factors are integer ratios; our resamplers can't deal with fractional ratios
   // and I've never seen a non-corrupted JPEG file actually use them
   for (i=0; i < s->img_n; ++i) {
      if (h_max % z->img_comp[i].h != 0) return stbi__err(""bad H"",""Corrupt JPEG"");
      if (v_max % z->img_comp[i].v != 0) return stbi__err(""bad V"",""Corrupt JPEG"");
   }

   // compute interleaved mcu info
   z->img_h_max = h_max;
   z->img_v_max = v_max;
   z->img_mcu_w = h_max * 8;
   z->img_mcu_h = v_max * 8;
   // these sizes can't be more than 17 bits
   z->img_mcu_x = (s->img_x + z->img_mcu_w-1) / z->img_mcu_w;
   z->img_mcu_y = (s->img_y + z->img_mcu_h-1) / z->img_mcu_h;

   for (i=0; i < s->img_n; ++i) {
      // number of effective pixels (e.g. for non-interleaved MCU)
      z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max-1) / h_max;
      z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max-1) / v_max;
      // to simplify generation, we'll allocate enough memory to decode
      // the bogus oversized data from using interleaved MCUs and their
      // big blocks (e.g. a 16x16 iMCU on an image of width 33); we won't
      // discard the extra data until colorspace conversion
      //
      // img_mcu_x, img_mcu_y: <=17 bits; comp[i].h and .v are <=4 (checked earlier)
      // so these muls can't overflow with 32-bit ints (which we require)
      z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8;
      z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8;
      z->img_comp[i].coeff = 0;
      z->img_comp[i].raw_coeff = 0;
      z->img_comp[i].linebuf = NULL;
      z->img_comp[i].raw_data = stbi__malloc_mad2(z->img_comp[i].w2, z->img_comp[i].h2, 15);
      if (z->img_comp[i].raw_data == NULL)
         return stbi__free_jpeg_components(z, i+1, stbi__err(""outofmem"", ""Out of memory""));
      // align blocks for idct using mmx/sse
      z->img_comp[i].data = (stbi_uc*) (((size_t) z->img_comp[i].raw_data + 15) & ~15);
      if (z->progressive) {
         // w2, h2 are multiples of 8 (see above)
         z->img_comp[i].coeff_w = z->img_comp[i].w2 / 8;
         z->img_comp[i].coeff_h = z->img_comp[i].h2 / 8;
         z->img_comp[i].raw_coeff = stbi__malloc_mad3(z->img_comp[i].w2, z->img_comp[i].h2, sizeof(short), 15);
         if (z->img_comp[i].raw_coeff == NULL)
            return stbi__free_jpeg_components(z, i+1, stbi__err(""outofmem"", ""Out of memory""));
         z->img_comp[i].coeff = (short*) (((size_t) z->img_comp[i].raw_coeff + 15) & ~15);
      }
   }

   return 1;
}","{'begin': {'line': 3264, 'column': 1}, 'end': {'line': 3354, 'column': 2}}",play_bmp_sequence.c,"['解析', 'JPEG', '帧', '头', '并', '验证', '参数', '及', '内存', '分配']"
174,174,stbi__idct_simd,void,"void stbi__idct_simd(stbi_uc * out, int out_stride, short[64] data)","[{'name': 'out', 'type': 'stbi_uc *'}, {'name': 'out_stride', 'type': 'int'}, {'name': 'data', 'type': 'short[64]'}]",使用SIMD指令集优化的整数IDCT变换实现,"static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
{
   // This is constructed to match our regular (generic) integer IDCT exactly.
   __m128i row0, row1, row2, row3, row4, row5, row6, row7;
   __m128i tmp;

   // dot product constant: even elems=x, odd elems=y
   #define dct_const(x,y)  _mm_setr_epi16((x),(y),(x),(y),(x),(y),(x),(y))

   // out(0) = c0[even]*x + c0[odd]*y   (c0, x, y 16-bit, out 32-bit)
   // out(1) = c1[even]*x + c1[odd]*y
   #define dct_rot(out0,out1, x,y,c0,c1) \
      __m128i c0##lo = _mm_unpacklo_epi16((x),(y)); \
      __m128i c0##hi = _mm_unpackhi_epi16((x),(y)); \
      __m128i out0##_l = _mm_madd_epi16(c0##lo, c0); \
      __m128i out0##_h = _mm_madd_epi16(c0##hi, c0); \
      __m128i out1##_l = _mm_madd_epi16(c0##lo, c1); \
      __m128i out1##_h = _mm_madd_epi16(c0##hi, c1)

   // out = in << 12  (in 16-bit, out 32-bit)
   #define dct_widen(out, in) \
      __m128i out##_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (in)), 4); \
      __m128i out##_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (in)), 4)

   // wide add
   #define dct_wadd(out, a, b) \
      __m128i out##_l = _mm_add_epi32(a##_l, b##_l); \
      __m128i out##_h = _mm_add_epi32(a##_h, b##_h)

   // wide sub
   #define dct_wsub(out, a, b) \
      __m128i out##_l = _mm_sub_epi32(a##_l, b##_l); \
      __m128i out##_h = _mm_sub_epi32(a##_h, b##_h)

   // butterfly a/b, add bias, then shift by ""s"" and pack
   #define dct_bfly32o(out0, out1, a,b,bias,s) \
      { \
         __m128i abiased_l = _mm_add_epi32(a##_l, bias); \
         __m128i abiased_h = _mm_add_epi32(a##_h, bias); \
         dct_wadd(sum, abiased, b); \
         dct_wsub(dif, abiased, b); \
         out0 = _mm_packs_epi32(_mm_srai_epi32(sum_l, s), _mm_srai_epi32(sum_h, s)); \
         out1 = _mm_packs_epi32(_mm_srai_epi32(dif_l, s), _mm_srai_epi32(dif_h, s)); \
      }

   // 8-bit interleave step (for transposes)
   #define dct_interleave8(a, b) \
      tmp = a; \
      a = _mm_unpacklo_epi8(a, b); \
      b = _mm_unpackhi_epi8(tmp, b)

   // 16-bit interleave step (for transposes)
   #define dct_interleave16(a, b) \
      tmp = a; \
      a = _mm_unpacklo_epi16(a, b); \
      b = _mm_unpackhi_epi16(tmp, b)

   #define dct_pass(bias,shift) \
      { \
         /* even part */ \
         dct_rot(t2e,t3e, row2,row6, rot0_0,rot0_1); \
         __m128i sum04 = _mm_add_epi16(row0, row4); \
         __m128i dif04 = _mm_sub_epi16(row0, row4); \
         dct_widen(t0e, sum04); \
         dct_widen(t1e, dif04); \
         dct_wadd(x0, t0e, t3e); \
         dct_wsub(x3, t0e, t3e); \
         dct_wadd(x1, t1e, t2e); \
         dct_wsub(x2, t1e, t2e); \
         /* odd part */ \
         dct_rot(y0o,y2o, row7,row3, rot2_0,rot2_1); \
         dct_rot(y1o,y3o, row5,row1, rot3_0,rot3_1); \
         __m128i sum17 = _mm_add_epi16(row1, row7); \
         __m128i sum35 = _mm_add_epi16(row3, row5); \
         dct_rot(y4o,y5o, sum17,sum35, rot1_0,rot1_1); \
         dct_wadd(x4, y0o, y4o); \
         dct_wadd(x5, y1o, y5o); \
         dct_wadd(x6, y2o, y5o); \
         dct_wadd(x7, y3o, y4o); \
         dct_bfly32o(row0,row7, x0,x7,bias,shift); \
         dct_bfly32o(row1,row6, x1,x6,bias,shift); \
         dct_bfly32o(row2,row5, x2,x5,bias,shift); \
         dct_bfly32o(row3,row4, x3,x4,bias,shift); \
      }

   __m128i rot0_0 = dct_const(stbi__f2f(0.5411961f), stbi__f2f(0.5411961f) + stbi__f2f(-1.847759065f));
   __m128i rot0_1 = dct_const(stbi__f2f(0.5411961f) + stbi__f2f( 0.765366865f), stbi__f2f(0.5411961f));
   __m128i rot1_0 = dct_const(stbi__f2f(1.175875602f) + stbi__f2f(-0.899976223f), stbi__f2f(1.175875602f));
   __m128i rot1_1 = dct_const(stbi__f2f(1.175875602f), stbi__f2f(1.175875602f) + stbi__f2f(-2.562915447f));
   __m128i rot2_0 = dct_const(stbi__f2f(-1.961570560f) + stbi__f2f( 0.298631336f), stbi__f2f(-1.961570560f));
   __m128i rot2_1 = dct_const(stbi__f2f(-1.961570560f), stbi__f2f(-1.961570560f) + stbi__f2f( 3.072711026f));
   __m128i rot3_0 = dct_const(stbi__f2f(-0.390180644f) + stbi__f2f( 2.053119869f), stbi__f2f(-0.390180644f));
   __m128i rot3_1 = dct_const(stbi__f2f(-0.390180644f), stbi__f2f(-0.390180644f) + stbi__f2f( 1.501321110f));

   // rounding biases in column/row passes, see stbi__idct_block for explanation.
   __m128i bias_0 = _mm_set1_epi32(512);
   __m128i bias_1 = _mm_set1_epi32(65536 + (128<<17));

   // load
   row0 = _mm_load_si128((const __m128i *) (data + 0*8));
   row1 = _mm_load_si128((const __m128i *) (data + 1*8));
   row2 = _mm_load_si128((const __m128i *) (data + 2*8));
   row3 = _mm_load_si128((const __m128i *) (data + 3*8));
   row4 = _mm_load_si128((const __m128i *) (data + 4*8));
   row5 = _mm_load_si128((const __m128i *) (data + 5*8));
   row6 = _mm_load_si128((const __m128i *) (data + 6*8));
   row7 = _mm_load_si128((const __m128i *) (data + 7*8));

   // column pass
   dct_pass(bias_0, 10);

   {
      // 16bit 8x8 transpose pass 1
      dct_interleave16(row0, row4);
      dct_interleave16(row1, row5);
      dct_interleave16(row2, row6);
      dct_interleave16(row3, row7);

      // transpose pass 2
      dct_interleave16(row0, row2);
      dct_interleave16(row1, row3);
      dct_interleave16(row4, row6);
      dct_interleave16(row5, row7);

      // transpose pass 3
      dct_interleave16(row0, row1);
      dct_interleave16(row2, row3);
      dct_interleave16(row4, row5);
      dct_interleave16(row6, row7);
   }

   // row pass
   dct_pass(bias_1, 17);

   {
      // pack
      __m128i p0 = _mm_packus_epi16(row0, row1); // a0a1a2a3...a7b0b1b2b3...b7
      __m128i p1 = _mm_packus_epi16(row2, row3);
      __m128i p2 = _mm_packus_epi16(row4, row5);
      __m128i p3 = _mm_packus_epi16(row6, row7);

      // 8bit 8x8 transpose pass 1
      dct_interleave8(p0, p2); // a0e0a1e1...
      dct_interleave8(p1, p3); // c0g0c1g1...

      // transpose pass 2
      dct_interleave8(p0, p1); // a0c0e0g0...
      dct_interleave8(p2, p3); // b0d0f0h0...

      // transpose pass 3
      dct_interleave8(p0, p2); // a0b0c0d0...
      dct_interleave8(p1, p3); // a4b4c4d4...

      // store
      _mm_storel_epi64((__m128i *) out, p0); out += out_stride;
      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p0, 0x4e)); out += out_stride;
      _mm_storel_epi64((__m128i *) out, p2); out += out_stride;
      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p2, 0x4e)); out += out_stride;
      _mm_storel_epi64((__m128i *) out, p1); out += out_stride;
      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p1, 0x4e)); out += out_stride;
      _mm_storel_epi64((__m128i *) out, p3); out += out_stride;
      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p3, 0x4e));
   }

#undef dct_const
#undef dct_rot
#undef dct_widen
#undef dct_wadd
#undef dct_wsub
#undef dct_bfly32o
#undef dct_interleave8
#undef dct_interleave16
#undef dct_pass
}","{'begin': {'line': 2530, 'column': 1}, 'end': {'line': 2703, 'column': 2}}",play_bmp_sequence.c,"['使用', 'SIMD', '指令', '指令集', '优化', '的', '整数', 'IDCT', '变换', '实现']"
175,175,stbi__get_marker,stbi_uc,stbi_uc stbi__get_marker(stbi__jpeg * j),"[{'name': 'j', 'type': 'stbi__jpeg *'}]",获取下一个JPEG标记，跳过填充字节,"static stbi_uc stbi__get_marker(stbi__jpeg *j)
{
   stbi_uc x;
   if (j->marker != STBI__MARKER_none) { x = j->marker; j->marker = STBI__MARKER_none; return x; }
   x = stbi__get8(j->s);
   if (x != 0xff) return STBI__MARKER_none;
   while (x == 0xff)
      x = stbi__get8(j->s); // consume repeated 0xff fill bytes
   return x;
}","{'begin': {'line': 2919, 'column': 1}, 'end': {'line': 2928, 'column': 2}}",play_bmp_sequence.c,"['获取', '下', '一个', 'JPEG', '标记', '，', '跳过', '填充', '字节']"
176,176,stbi__jpeg_reset,void,void stbi__jpeg_reset(stbi__jpeg * j),"[{'name': 'j', 'type': 'stbi__jpeg *'}]",重置JPEG解码器的内部状态,"static void stbi__jpeg_reset(stbi__jpeg *j)
{
   j->code_bits = 0;
   j->code_buffer = 0;
   j->nomore = 0;
   j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = j->img_comp[3].dc_pred = 0;
   j->marker = STBI__MARKER_none;
   j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;
   j->eob_run = 0;
   // no more than 1<<31 MCUs if no restart_interal? that's plenty safe,
   // since we don't even allow 1<<30 pixels
}","{'begin': {'line': 2936, 'column': 1}, 'end': {'line': 2947, 'column': 2}}",play_bmp_sequence.c,"['重置', 'JPEG', '解码', '码器', '解码器', '的', '内部', '状态']"
177,177,stbi__parse_entropy_coded_data,int,int stbi__parse_entropy_coded_data(stbi__jpeg * z),"[{'name': 'z', 'type': 'stbi__jpeg *'}]",解析JPEG熵编码数据，处理渐进与非渐进模式。,"static int stbi__parse_entropy_coded_data(stbi__jpeg *z)
{
   stbi__jpeg_reset(z);
   if (!z->progressive) {
      if (z->scan_n == 1) {
         int i,j;
         STBI_SIMD_ALIGN(short, data[64]);
         int n = z->order[0];
         // non-interleaved data, we just need to process one block at a time,
         // in trivial scanline order
         // number of blocks to do just depends on how many actual ""pixels"" this
         // component has, independent of interleaved MCU blocking and such
         int w = (z->img_comp[n].x+7) >> 3;
         int h = (z->img_comp[n].y+7) >> 3;
         for (j=0; j < h; ++j) {
            for (i=0; i < w; ++i) {
               int ha = z->img_comp[n].ha;
               if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
               z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
               // every data block is an MCU, so countdown the restart interval
               if (--z->todo <= 0) {
                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
                  // if it's NOT a restart, then just bail, so we get corrupt data
                  // rather than no data
                  if (!STBI__RESTART(z->marker)) return 1;
                  stbi__jpeg_reset(z);
               }
            }
         }
         return 1;
      } else { // interleaved
         int i,j,k,x,y;
         STBI_SIMD_ALIGN(short, data[64]);
         for (j=0; j < z->img_mcu_y; ++j) {
            for (i=0; i < z->img_mcu_x; ++i) {
               // scan an interleaved mcu... process scan_n components in order
               for (k=0; k < z->scan_n; ++k) {
                  int n = z->order[k];
                  // scan out an mcu's worth of this component; that's just determined
                  // by the basic H and V specified for the component
                  for (y=0; y < z->img_comp[n].v; ++y) {
                     for (x=0; x < z->img_comp[n].h; ++x) {
                        int x2 = (i*z->img_comp[n].h + x)*8;
                        int y2 = (j*z->img_comp[n].v + y)*8;
                        int ha = z->img_comp[n].ha;
                        if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
                        z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*y2+x2, z->img_comp[n].w2, data);
                     }
                  }
               }
               // after all interleaved components, that's an interleaved MCU,
               // so now count down the restart interval
               if (--z->todo <= 0) {
                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
                  if (!STBI__RESTART(z->marker)) return 1;
                  stbi__jpeg_reset(z);
               }
            }
         }
         return 1;
      }
   } else {
      if (z->scan_n == 1) {
         int i,j;
         int n = z->order[0];
         // non-interleaved data, we just need to process one block at a time,
         // in trivial scanline order
         // number of blocks to do just depends on how many actual ""pixels"" this
         // component has, independent of interleaved MCU blocking and such
         int w = (z->img_comp[n].x+7) >> 3;
         int h = (z->img_comp[n].y+7) >> 3;
         for (j=0; j < h; ++j) {
            for (i=0; i < w; ++i) {
               short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
               if (z->spec_start == 0) {
                  if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
                     return 0;
               } else {
                  int ha = z->img_comp[n].ha;
                  if (!stbi__jpeg_decode_block_prog_ac(z, data, &z->huff_ac[ha], z->fast_ac[ha]))
                     return 0;
               }
               // every data block is an MCU, so countdown the restart interval
               if (--z->todo <= 0) {
                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
                  if (!STBI__RESTART(z->marker)) return 1;
                  stbi__jpeg_reset(z);
               }
            }
         }
         return 1;
      } else { // interleaved
         int i,j,k,x,y;
         for (j=0; j < z->img_mcu_y; ++j) {
            for (i=0; i < z->img_mcu_x; ++i) {
               // scan an interleaved mcu... process scan_n components in order
               for (k=0; k < z->scan_n; ++k) {
                  int n = z->order[k];
                  // scan out an mcu's worth of this component; that's just determined
                  // by the basic H and V specified for the component
                  for (y=0; y < z->img_comp[n].v; ++y) {
                     for (x=0; x < z->img_comp[n].h; ++x) {
                        int x2 = (i*z->img_comp[n].h + x);
                        int y2 = (j*z->img_comp[n].v + y);
                        short *data = z->img_comp[n].coeff + 64 * (x2 + y2 * z->img_comp[n].coeff_w);
                        if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
                           return 0;
                     }
                  }
               }
               // after all interleaved components, that's an interleaved MCU,
               // so now count down the restart interval
               if (--z->todo <= 0) {
                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
                  if (!STBI__RESTART(z->marker)) return 1;
                  stbi__jpeg_reset(z);
               }
            }
         }
         return 1;
      }
   }
}","{'begin': {'line': 2949, 'column': 1}, 'end': {'line': 3071, 'column': 2}}",play_bmp_sequence.c,"['解析', 'JPEG', '熵', '编码', '码数', '数据', '编码数据', '，', '处理', '渐进', '与非', '渐进', '模式', '。']"
178,178,stbi__decode_jpeg_header,int,"int stbi__decode_jpeg_header(stbi__jpeg * z, int scan)","[{'name': 'z', 'type': 'stbi__jpeg *'}, {'name': 'scan', 'type': 'int'}]",解析JPEG头部信息，验证结构并处理标记。,"static int stbi__decode_jpeg_header(stbi__jpeg *z, int scan)
{
   int m;
   z->jfif = 0;
   z->app14_color_transform = -1; // valid values are 0,1,2
   z->marker = STBI__MARKER_none; // initialize cached marker to empty
   m = stbi__get_marker(z);
   if (!stbi__SOI(m)) return stbi__err(""no SOI"",""Corrupt JPEG"");
   if (scan == STBI__SCAN_type) return 1;
   m = stbi__get_marker(z);
   while (!stbi__SOF(m)) {
      if (!stbi__process_marker(z,m)) return 0;
      m = stbi__get_marker(z);
      while (m == STBI__MARKER_none) {
         // some files have extra padding after their blocks, so ok, we'll scan
         if (stbi__at_eof(z->s)) return stbi__err(""no SOF"", ""Corrupt JPEG"");
         m = stbi__get_marker(z);
      }
   }
   z->progressive = stbi__SOF_progressive(m);
   if (!stbi__process_frame_header(z, scan)) return 0;
   return 1;
}","{'begin': {'line': 3365, 'column': 1}, 'end': {'line': 3387, 'column': 2}}",play_bmp_sequence.c,"['解析', 'JPEG', '头部', '信息', '，', '验证', '结构', '并', '处理', '标记', '。']"
179,179,stbi__skip_jpeg_junk_at_end,stbi_uc,stbi_uc stbi__skip_jpeg_junk_at_end(stbi__jpeg * j),"[{'name': 'j', 'type': 'stbi__jpeg *'}]",跳过JPEG末尾无效数据，寻找有效标记,"static stbi_uc stbi__skip_jpeg_junk_at_end(stbi__jpeg *j)
{
   // some JPEGs have junk at end, skip over it but if we find what looks
   // like a valid marker, resume there
   while (!stbi__at_eof(j->s)) {
      stbi_uc x = stbi__get8(j->s);
      while (x == 0xff) { // might be a marker
         if (stbi__at_eof(j->s)) return STBI__MARKER_none;
         x = stbi__get8(j->s);
         if (x != 0x00 && x != 0xff) {
            // not a stuffed zero or lead-in to another marker, looks
            // like an actual marker, return it
            return x;
         }
         // stuffed zero has x=0 now which ends the loop, meaning we go
         // back to regular scan loop.
         // repeated 0xff keeps trying to read the next byte of the marker.
      }
   }
   return STBI__MARKER_none;
}","{'begin': {'line': 3389, 'column': 1}, 'end': {'line': 3409, 'column': 2}}",play_bmp_sequence.c,"['跳过', 'JPEG', '末尾', '无效', '数据', '，', '寻找', '有效', '标记']"
180,180,stbi__decode_jpeg_image,int,int stbi__decode_jpeg_image(stbi__jpeg * j),"[{'name': 'j', 'type': 'stbi__jpeg *'}]",解码JPEG图像数据，处理头信息及扫描数据,"static int stbi__decode_jpeg_image(stbi__jpeg *j)
{
   int m;
   for (m = 0; m < 4; m++) {
      j->img_comp[m].raw_data = NULL;
      j->img_comp[m].raw_coeff = NULL;
   }
   j->restart_interval = 0;
   if (!stbi__decode_jpeg_header(j, STBI__SCAN_load)) return 0;
   m = stbi__get_marker(j);
   while (!stbi__EOI(m)) {
      if (stbi__SOS(m)) {
         if (!stbi__process_scan_header(j)) return 0;
         if (!stbi__parse_entropy_coded_data(j)) return 0;
         if (j->marker == STBI__MARKER_none ) {
         j->marker = stbi__skip_jpeg_junk_at_end(j);
            // if we reach eof without hitting a marker, stbi__get_marker() below will fail and we'll eventually return 0
         }
         m = stbi__get_marker(j);
         if (STBI__RESTART(m))
            m = stbi__get_marker(j);
      } else if (stbi__DNL(m)) {
         int Ld = stbi__get16be(j->s);
         stbi__uint32 NL = stbi__get16be(j->s);
         if (Ld != 4) return stbi__err(""bad DNL len"", ""Corrupt JPEG"");
         if (NL != j->s->img_y) return stbi__err(""bad DNL height"", ""Corrupt JPEG"");
         m = stbi__get_marker(j);
      } else {
         if (!stbi__process_marker(j, m)) return 1;
         m = stbi__get_marker(j);
      }
   }
   if (j->progressive)
      stbi__jpeg_finish(j);
   return 1;
}","{'begin': {'line': 3412, 'column': 1}, 'end': {'line': 3447, 'column': 2}}",play_bmp_sequence.c,"['解码', 'JPEG', '图像', '数据', '，', '处理', '头', '信息', '及', '扫描', '数据']"
181,181,stbi__jpeg_dequantize,void,"void stbi__jpeg_dequantize(short * data, stbi__uint16 * dequant)","[{'name': 'data', 'type': 'short *'}, {'name': 'dequant', 'type': 'stbi__uint16 *'}]",对JPEG数据块执行反量化处理,"static void stbi__jpeg_dequantize(short *data, stbi__uint16 *dequant)
{
   int i;
   for (i=0; i < 64; ++i)
      data[i] *= dequant[i];
}","{'begin': {'line': 3073, 'column': 1}, 'end': {'line': 3078, 'column': 2}}",play_bmp_sequence.c,"['对', 'JPEG', '数据', '块', '执行', '反', '量化', '处理']"
182,182,stbi__jpeg_finish,void,void stbi__jpeg_finish(stbi__jpeg * z),"[{'name': 'z', 'type': 'stbi__jpeg *'}]",完成JPEG渐进式解码的后处理,"static void stbi__jpeg_finish(stbi__jpeg *z)
{
   if (z->progressive) {
      // dequantize and idct the data
      int i,j,n;
      for (n=0; n < z->s->img_n; ++n) {
         int w = (z->img_comp[n].x+7) >> 3;
         int h = (z->img_comp[n].y+7) >> 3;
         for (j=0; j < h; ++j) {
            for (i=0; i < w; ++i) {
               short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
               stbi__jpeg_dequantize(data, z->dequant[z->img_comp[n].tq]);
               z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
            }
         }
      }
   }
}","{'begin': {'line': 3080, 'column': 1}, 'end': {'line': 3097, 'column': 2}}",play_bmp_sequence.c,"['完成', 'JPEG', '渐进', '渐进式', '解码', '的', '处理', '后处理']"
183,183,resample_row_1,stbi_uc *,"stbi_uc * resample_row_1(stbi_uc * out, stbi_uc * in_near, stbi_uc * in_far, int w, int hs)","[{'name': 'out', 'type': 'stbi_uc *'}, {'name': 'in_near', 'type': 'stbi_uc *'}, {'name': 'in_far', 'type': 'stbi_uc *'}, {'name': 'w', 'type': 'int'}, {'name': 'hs', 'type': 'int'}]",直接返回输入in_near，无实际处理,"static stbi_uc *resample_row_1(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   STBI_NOTUSED(out);
   STBI_NOTUSED(in_far);
   STBI_NOTUSED(w);
   STBI_NOTUSED(hs);
   return in_near;
}","{'begin': {'line': 3456, 'column': 1}, 'end': {'line': 3463, 'column': 2}}",play_bmp_sequence.c,"['直接', '返回', '输入', 'in', '_', 'near', '，', '无', '实际', '处理']"
184,184,stbi__resample_row_v_2,stbi_uc *,"stbi_uc * stbi__resample_row_v_2(stbi_uc * out, stbi_uc * in_near, stbi_uc * in_far, int w, int hs)","[{'name': 'out', 'type': 'stbi_uc *'}, {'name': 'in_near', 'type': 'stbi_uc *'}, {'name': 'in_far', 'type': 'stbi_uc *'}, {'name': 'w', 'type': 'int'}, {'name': 'hs', 'type': 'int'}]",垂直双倍重采样行，使用3:1加权平均,"static stbi_uc* stbi__resample_row_v_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // need to generate two samples vertically for every one in input
   int i;
   STBI_NOTUSED(hs);
   for (i=0; i < w; ++i)
      out[i] = stbi__div4(3*in_near[i] + in_far[i] + 2);
   return out;
}","{'begin': {'line': 3465, 'column': 1}, 'end': {'line': 3473, 'column': 2}}",play_bmp_sequence.c,"['垂直', '双倍', '重', '采样', '行', '，', '使用', '3', ':', '1', '加权', '平均']"
185,185,stbi__resample_row_h_2,stbi_uc *,"stbi_uc * stbi__resample_row_h_2(stbi_uc * out, stbi_uc * in_near, stbi_uc * in_far, int w, int hs)","[{'name': 'out', 'type': 'stbi_uc *'}, {'name': 'in_near', 'type': 'stbi_uc *'}, {'name': 'in_far', 'type': 'stbi_uc *'}, {'name': 'w', 'type': 'int'}, {'name': 'hs', 'type': 'int'}]",水平双倍重采样，使用线性插值生成输出。,"static stbi_uc*  stbi__resample_row_h_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // need to generate two samples horizontally for every one in input
   int i;
   stbi_uc *input = in_near;

   if (w == 1) {
      // if only one sample, can't do any interpolation
      out[0] = out[1] = input[0];
      return out;
   }

   out[0] = input[0];
   out[1] = stbi__div4(input[0]*3 + input[1] + 2);
   for (i=1; i < w-1; ++i) {
      int n = 3*input[i]+2;
      out[i*2+0] = stbi__div4(n+input[i-1]);
      out[i*2+1] = stbi__div4(n+input[i+1]);
   }
   out[i*2+0] = stbi__div4(input[w-2]*3 + input[w-1] + 2);
   out[i*2+1] = input[w-1];

   STBI_NOTUSED(in_far);
   STBI_NOTUSED(hs);

   return out;
}","{'begin': {'line': 3475, 'column': 1}, 'end': {'line': 3501, 'column': 2}}",play_bmp_sequence.c,"['水平', '双倍', '重', '采样', '，', '使用', '线性', '插值', '线性插值', '生成', '输出', '。']"
186,186,stbi__process_marker,int,"int stbi__process_marker(stbi__jpeg * z, int m)","[{'name': 'z', 'type': 'stbi__jpeg *'}, {'name': 'm', 'type': 'int'}]",处理JPEG标记，解析DQT/DHT等数据块并验证合法性,"static int stbi__process_marker(stbi__jpeg *z, int m)
{
   int L;
   switch (m) {
      case STBI__MARKER_none: // no marker found
         return stbi__err(""expected marker"",""Corrupt JPEG"");

      case 0xDD: // DRI - specify restart interval
         if (stbi__get16be(z->s) != 4) return stbi__err(""bad DRI len"",""Corrupt JPEG"");
         z->restart_interval = stbi__get16be(z->s);
         return 1;

      case 0xDB: // DQT - define quantization table
         L = stbi__get16be(z->s)-2;
         while (L > 0) {
            int q = stbi__get8(z->s);
            int p = q >> 4, sixteen = (p != 0);
            int t = q & 15,i;
            if (p != 0 && p != 1) return stbi__err(""bad DQT type"",""Corrupt JPEG"");
            if (t > 3) return stbi__err(""bad DQT table"",""Corrupt JPEG"");

            for (i=0; i < 64; ++i)
               z->dequant[t][stbi__jpeg_dezigzag[i]] = (stbi__uint16)(sixteen ? stbi__get16be(z->s) : stbi__get8(z->s));
            L -= (sixteen ? 129 : 65);
         }
         return L==0;

      case 0xC4: // DHT - define huffman table
         L = stbi__get16be(z->s)-2;
         while (L > 0) {
            stbi_uc *v;
            int sizes[16],i,n=0;
            int q = stbi__get8(z->s);
            int tc = q >> 4;
            int th = q & 15;
            if (tc > 1 || th > 3) return stbi__err(""bad DHT header"",""Corrupt JPEG"");
            for (i=0; i < 16; ++i) {
               sizes[i] = stbi__get8(z->s);
               n += sizes[i];
            }
            if(n > 256) return stbi__err(""bad DHT header"",""Corrupt JPEG""); // Loop over i < n would write past end of values!
            L -= 17;
            if (tc == 0) {
               if (!stbi__build_huffman(z->huff_dc+th, sizes)) return 0;
               v = z->huff_dc[th].values;
            } else {
               if (!stbi__build_huffman(z->huff_ac+th, sizes)) return 0;
               v = z->huff_ac[th].values;
            }
            for (i=0; i < n; ++i)
               v[i] = stbi__get8(z->s);
            if (tc != 0)
               stbi__build_fast_ac(z->fast_ac[th], z->huff_ac + th);
            L -= n;
         }
         return L==0;
   }

   // check for comment block or APP blocks
   if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {
      L = stbi__get16be(z->s);
      if (L < 2) {
         if (m == 0xFE)
            return stbi__err(""bad COM len"",""Corrupt JPEG"");
         else
            return stbi__err(""bad APP len"",""Corrupt JPEG"");
      }
      L -= 2;

      if (m == 0xE0 && L >= 5) { // JFIF APP0 segment
         static const unsigned char tag[5] = {'J','F','I','F','\0'};
         int ok = 1;
         int i;
         for (i=0; i < 5; ++i)
            if (stbi__get8(z->s) != tag[i])
               ok = 0;
         L -= 5;
         if (ok)
            z->jfif = 1;
      } else if (m == 0xEE && L >= 12) { // Adobe APP14 segment
         static const unsigned char tag[6] = {'A','d','o','b','e','\0'};
         int ok = 1;
         int i;
         for (i=0; i < 6; ++i)
            if (stbi__get8(z->s) != tag[i])
               ok = 0;
         L -= 6;
         if (ok) {
            stbi__get8(z->s); // version
            stbi__get16be(z->s); // flags0
            stbi__get16be(z->s); // flags1
            z->app14_color_transform = stbi__get8(z->s); // color transform
            L -= 6;
         }
      }

      stbi__skip(z->s, L);
      return 1;
   }

   return stbi__err(""unknown marker"",""Corrupt JPEG"");
}","{'begin': {'line': 3099, 'column': 1}, 'end': {'line': 3200, 'column': 2}}",play_bmp_sequence.c,"['处理', 'JPEG', '标记', '，', '解析', 'DQT', '/', 'DHT', '等', '数据', '块', '并', '验证', '合法', '合法性']"
187,187,stbi__resample_row_hv_2,stbi_uc *,"stbi_uc * stbi__resample_row_hv_2(stbi_uc * out, stbi_uc * in_near, stbi_uc * in_far, int w, int hs)","[{'name': 'out', 'type': 'stbi_uc *'}, {'name': 'in_near', 'type': 'stbi_uc *'}, {'name': 'in_far', 'type': 'stbi_uc *'}, {'name': 'w', 'type': 'int'}, {'name': 'hs', 'type': 'int'}]",双线性插值实现2倍水平和垂直重采样,"static stbi_uc *stbi__resample_row_hv_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // need to generate 2x2 samples for every one in input
   int i,t0,t1;
   if (w == 1) {
      out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);
      return out;
   }

   t1 = 3*in_near[0] + in_far[0];
   out[0] = stbi__div4(t1+2);
   for (i=1; i < w; ++i) {
      t0 = t1;
      t1 = 3*in_near[i]+in_far[i];
      out[i*2-1] = stbi__div16(3*t0 + t1 + 8);
      out[i*2  ] = stbi__div16(3*t1 + t0 + 8);
   }
   out[w*2-1] = stbi__div4(t1+2);

   STBI_NOTUSED(hs);

   return out;
}","{'begin': {'line': 3505, 'column': 1}, 'end': {'line': 3527, 'column': 2}}",play_bmp_sequence.c,"['双', '线性', '插值', '线性插值', '实现', '2', '倍', '水平', '和', '垂直', '重', '采样']"
188,188,stbi__resample_row_hv_2_simd,stbi_uc *,"stbi_uc * stbi__resample_row_hv_2_simd(stbi_uc * out, stbi_uc * in_near, stbi_uc * in_far, int w, int hs)","[{'name': 'out', 'type': 'stbi_uc *'}, {'name': 'in_near', 'type': 'stbi_uc *'}, {'name': 'in_far', 'type': 'stbi_uc *'}, {'name': 'w', 'type': 'int'}, {'name': 'hs', 'type': 'int'}]",使用SIMD实现双倍水平和垂直重采样,"static stbi_uc *stbi__resample_row_hv_2_simd(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // need to generate 2x2 samples for every one in input
   int i=0,t0,t1;

   if (w == 1) {
      out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);
      return out;
   }

   t1 = 3*in_near[0] + in_far[0];
   // process groups of 8 pixels for as long as we can.
   // note we can't handle the last pixel in a row in this loop
   // because we need to handle the filter boundary conditions.
   for (; i < ((w-1) & ~7); i += 8) {
#if defined(STBI_SSE2)
      // load and perform the vertical filtering pass
      // this uses 3*x + y = 4*x + (y - x)
      __m128i zero  = _mm_setzero_si128();
      __m128i farb  = _mm_loadl_epi64((__m128i *) (in_far + i));
      __m128i nearb = _mm_loadl_epi64((__m128i *) (in_near + i));
      __m128i farw  = _mm_unpacklo_epi8(farb, zero);
      __m128i nearw = _mm_unpacklo_epi8(nearb, zero);
      __m128i diff  = _mm_sub_epi16(farw, nearw);
      __m128i nears = _mm_slli_epi16(nearw, 2);
      __m128i curr  = _mm_add_epi16(nears, diff); // current row

      // horizontal filter works the same based on shifted vers of current
      // row. ""prev"" is current row shifted right by 1 pixel; we need to
      // insert the previous pixel value (from t1).
      // ""next"" is current row shifted left by 1 pixel, with first pixel
      // of next block of 8 pixels added in.
      __m128i prv0 = _mm_slli_si128(curr, 2);
      __m128i nxt0 = _mm_srli_si128(curr, 2);
      __m128i prev = _mm_insert_epi16(prv0, t1, 0);
      __m128i next = _mm_insert_epi16(nxt0, 3*in_near[i+8] + in_far[i+8], 7);

      // horizontal filter, polyphase implementation since it's convenient:
      // even pixels = 3*cur + prev = cur*4 + (prev - cur)
      // odd  pixels = 3*cur + next = cur*4 + (next - cur)
      // note the shared term.
      __m128i bias  = _mm_set1_epi16(8);
      __m128i curs = _mm_slli_epi16(curr, 2);
      __m128i prvd = _mm_sub_epi16(prev, curr);
      __m128i nxtd = _mm_sub_epi16(next, curr);
      __m128i curb = _mm_add_epi16(curs, bias);
      __m128i even = _mm_add_epi16(prvd, curb);
      __m128i odd  = _mm_add_epi16(nxtd, curb);

      // interleave even and odd pixels, then undo scaling.
      __m128i int0 = _mm_unpacklo_epi16(even, odd);
      __m128i int1 = _mm_unpackhi_epi16(even, odd);
      __m128i de0  = _mm_srli_epi16(int0, 4);
      __m128i de1  = _mm_srli_epi16(int1, 4);

      // pack and write output
      __m128i outv = _mm_packus_epi16(de0, de1);
      _mm_storeu_si128((__m128i *) (out + i*2), outv);
#elif defined(STBI_NEON)
      // load and perform the vertical filtering pass
      // this uses 3*x + y = 4*x + (y - x)
      uint8x8_t farb  = vld1_u8(in_far + i);
      uint8x8_t nearb = vld1_u8(in_near + i);
      int16x8_t diff  = vreinterpretq_s16_u16(vsubl_u8(farb, nearb));
      int16x8_t nears = vreinterpretq_s16_u16(vshll_n_u8(nearb, 2));
      int16x8_t curr  = vaddq_s16(nears, diff); // current row

      // horizontal filter works the same based on shifted vers of current
      // row. ""prev"" is current row shifted right by 1 pixel; we need to
      // insert the previous pixel value (from t1).
      // ""next"" is current row shifted left by 1 pixel, with first pixel
      // of next block of 8 pixels added in.
      int16x8_t prv0 = vextq_s16(curr, curr, 7);
      int16x8_t nxt0 = vextq_s16(curr, curr, 1);
      int16x8_t prev = vsetq_lane_s16(t1, prv0, 0);
      int16x8_t next = vsetq_lane_s16(3*in_near[i+8] + in_far[i+8], nxt0, 7);

      // horizontal filter, polyphase implementation since it's convenient:
      // even pixels = 3*cur + prev = cur*4 + (prev - cur)
      // odd  pixels = 3*cur + next = cur*4 + (next - cur)
      // note the shared term.
      int16x8_t curs = vshlq_n_s16(curr, 2);
      int16x8_t prvd = vsubq_s16(prev, curr);
      int16x8_t nxtd = vsubq_s16(next, curr);
      int16x8_t even = vaddq_s16(curs, prvd);
      int16x8_t odd  = vaddq_s16(curs, nxtd);

      // undo scaling and round, then store with even/odd phases interleaved
      uint8x8x2_t o;
      o.val[0] = vqrshrun_n_s16(even, 4);
      o.val[1] = vqrshrun_n_s16(odd,  4);
      vst2_u8(out + i*2, o);
#endif

      // ""previous"" value for next iter
      t1 = 3*in_near[i+7] + in_far[i+7];
   }

   t0 = t1;
   t1 = 3*in_near[i] + in_far[i];
   out[i*2] = stbi__div16(3*t1 + t0 + 8);

   for (++i; i < w; ++i) {
      t0 = t1;
      t1 = 3*in_near[i]+in_far[i];
      out[i*2-1] = stbi__div16(3*t0 + t1 + 8);
      out[i*2  ] = stbi__div16(3*t1 + t0 + 8);
   }
   out[w*2-1] = stbi__div4(t1+2);

   STBI_NOTUSED(hs);

   return out;
}","{'begin': {'line': 3530, 'column': 1}, 'end': {'line': 3643, 'column': 2}}",play_bmp_sequence.c,"['使用', 'SIMD', '实现', '双倍', '水平', '和', '垂直', '重', '采样']"
189,189,stbi__process_scan_header,int,int stbi__process_scan_header(stbi__jpeg * z),"[{'name': 'z', 'type': 'stbi__jpeg *'}]",解析JPEG扫描头并验证参数有效性,"static int stbi__process_scan_header(stbi__jpeg *z)
{
   int i;
   int Ls = stbi__get16be(z->s);
   z->scan_n = stbi__get8(z->s);
   if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int) z->s->img_n) return stbi__err(""bad SOS component count"",""Corrupt JPEG"");
   if (Ls != 6+2*z->scan_n) return stbi__err(""bad SOS len"",""Corrupt JPEG"");
   for (i=0; i < z->scan_n; ++i) {
      int id = stbi__get8(z->s), which;
      int q = stbi__get8(z->s);
      for (which = 0; which < z->s->img_n; ++which)
         if (z->img_comp[which].id == id)
            break;
      if (which == z->s->img_n) return 0; // no match
      z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return stbi__err(""bad DC huff"",""Corrupt JPEG"");
      z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return stbi__err(""bad AC huff"",""Corrupt JPEG"");
      z->order[i] = which;
   }

   {
      int aa;
      z->spec_start = stbi__get8(z->s);
      z->spec_end   = stbi__get8(z->s); // should be 63, but might be 0
      aa = stbi__get8(z->s);
      z->succ_high = (aa >> 4);
      z->succ_low  = (aa & 15);
      if (z->progressive) {
         if (z->spec_start > 63 || z->spec_end > 63  || z->spec_start > z->spec_end || z->succ_high > 13 || z->succ_low > 13)
            return stbi__err(""bad SOS"", ""Corrupt JPEG"");
      } else {
         if (z->spec_start != 0) return stbi__err(""bad SOS"",""Corrupt JPEG"");
         if (z->succ_high != 0 || z->succ_low != 0) return stbi__err(""bad SOS"",""Corrupt JPEG"");
         z->spec_end = 63;
      }
   }

   return 1;
}","{'begin': {'line': 3203, 'column': 1}, 'end': {'line': 3240, 'column': 2}}",play_bmp_sequence.c,"['解析', 'JPEG', '扫描', '头', '并', '验证', '参数', '有效', '有效性']"
190,190,stbi__resample_row_generic,stbi_uc *,"stbi_uc * stbi__resample_row_generic(stbi_uc * out, stbi_uc * in_near, stbi_uc * in_far, int w, int hs)","[{'name': 'out', 'type': 'stbi_uc *'}, {'name': 'in_near', 'type': 'stbi_uc *'}, {'name': 'in_far', 'type': 'stbi_uc *'}, {'name': 'w', 'type': 'int'}, {'name': 'hs', 'type': 'int'}]",使用最近邻插值对行进行重采样,"static stbi_uc *stbi__resample_row_generic(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // resample with nearest-neighbor
   int i,j;
   STBI_NOTUSED(in_far);
   for (i=0; i < w; ++i)
      for (j=0; j < hs; ++j)
         out[i*hs+j] = in_near[i];
   return out;
}","{'begin': {'line': 3646, 'column': 1}, 'end': {'line': 3655, 'column': 2}}",play_bmp_sequence.c,"['使用', '最近', '邻', '插值', '对行', '进行', '重', '采样']"
191,191,stbi__YCbCr_to_RGB_row,void,"void stbi__YCbCr_to_RGB_row(stbi_uc * out, const stbi_uc * y, const stbi_uc * pcb, const stbi_uc * pcr, int count, int step)","[{'name': 'out', 'type': 'stbi_uc *'}, {'name': 'y', 'type': 'const stbi_uc *'}, {'name': 'pcb', 'type': 'const stbi_uc *'}, {'name': 'pcr', 'type': 'const stbi_uc *'}, {'name': 'count', 'type': 'int'}, {'name': 'step', 'type': 'int'}]",将YCbCr颜色数据转换为RGB格式行,"static void stbi__YCbCr_to_RGB_row(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step)
{
   int i;
   for (i=0; i < count; ++i) {
      int y_fixed = (y[i] << 20) + (1<<19); // rounding
      int r,g,b;
      int cr = pcr[i] - 128;
      int cb = pcb[i] - 128;
      r = y_fixed +  cr* stbi__float2fixed(1.40200f);
      g = y_fixed + (cr*-stbi__float2fixed(0.71414f)) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);
      b = y_fixed                                     +   cb* stbi__float2fixed(1.77200f);
      r >>= 20;
      g >>= 20;
      b >>= 20;
      if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }
      if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }
      if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }
      out[0] = (stbi_uc)r;
      out[1] = (stbi_uc)g;
      out[2] = (stbi_uc)b;
      out[3] = 255;
      out += step;
   }
}","{'begin': {'line': 3660, 'column': 1}, 'end': {'line': 3683, 'column': 2}}",play_bmp_sequence.c,"['将', 'YCbCr', '颜色', '数据', '转换', '为', 'RGB', '格式', '行']"
192,192,stbi__free_jpeg_components,int,"int stbi__free_jpeg_components(stbi__jpeg * z, int ncomp, int why)","[{'name': 'z', 'type': 'stbi__jpeg *'}, {'name': 'ncomp', 'type': 'int'}, {'name': 'why', 'type': 'int'}]",释放JPEG组件的内存资源,"static int stbi__free_jpeg_components(stbi__jpeg *z, int ncomp, int why)
{
   int i;
   for (i=0; i < ncomp; ++i) {
      if (z->img_comp[i].raw_data) {
         STBI_FREE(z->img_comp[i].raw_data);
         z->img_comp[i].raw_data = NULL;
         z->img_comp[i].data = NULL;
      }
      if (z->img_comp[i].raw_coeff) {
         STBI_FREE(z->img_comp[i].raw_coeff);
         z->img_comp[i].raw_coeff = 0;
         z->img_comp[i].coeff = 0;
      }
      if (z->img_comp[i].linebuf) {
         STBI_FREE(z->img_comp[i].linebuf);
         z->img_comp[i].linebuf = NULL;
      }
   }
   return why;
}","{'begin': {'line': 3242, 'column': 1}, 'end': {'line': 3262, 'column': 2}}",play_bmp_sequence.c,"['释放', 'JPEG', '组件', '的', '内存', '资源']"
193,193,stbi__YCbCr_to_RGB_simd,void,"void stbi__YCbCr_to_RGB_simd(stbi_uc * out, const stbi_uc * y, const stbi_uc * pcb, const stbi_uc * pcr, int count, int step)","[{'name': 'out', 'type': 'stbi_uc *'}, {'name': 'y', 'type': 'const stbi_uc *'}, {'name': 'pcb', 'type': 'const stbi_uc *'}, {'name': 'pcr', 'type': 'const stbi_uc *'}, {'name': 'count', 'type': 'int'}, {'name': 'step', 'type': 'int'}]",使用SIMD指令加速将YCbCr转换为RGB，支持批量处理。,"static void stbi__YCbCr_to_RGB_simd(stbi_uc *out, stbi_uc const *y, stbi_uc const *pcb, stbi_uc const *pcr, int count, int step)
{
   int i = 0;

#ifdef STBI_SSE2
   // step == 3 is pretty ugly on the final interleave, and i'm not convinced
   // it's useful in practice (you wouldn't use it for textures, for example).
   // so just accelerate step == 4 case.
   if (step == 4) {
      // this is a fairly straightforward implementation and not super-optimized.
      __m128i signflip  = _mm_set1_epi8(-0x80);
      __m128i cr_const0 = _mm_set1_epi16(   (short) ( 1.40200f*4096.0f+0.5f));
      __m128i cr_const1 = _mm_set1_epi16( - (short) ( 0.71414f*4096.0f+0.5f));
      __m128i cb_const0 = _mm_set1_epi16( - (short) ( 0.34414f*4096.0f+0.5f));
      __m128i cb_const1 = _mm_set1_epi16(   (short) ( 1.77200f*4096.0f+0.5f));
      __m128i y_bias = _mm_set1_epi8((char) (unsigned char) 128);
      __m128i xw = _mm_set1_epi16(255); // alpha channel

      for (; i+7 < count; i += 8) {
         // load
         __m128i y_bytes = _mm_loadl_epi64((__m128i *) (y+i));
         __m128i cr_bytes = _mm_loadl_epi64((__m128i *) (pcr+i));
         __m128i cb_bytes = _mm_loadl_epi64((__m128i *) (pcb+i));
         __m128i cr_biased = _mm_xor_si128(cr_bytes, signflip); // -128
         __m128i cb_biased = _mm_xor_si128(cb_bytes, signflip); // -128

         // unpack to short (and left-shift cr, cb by 8)
         __m128i yw  = _mm_unpacklo_epi8(y_bias, y_bytes);
         __m128i crw = _mm_unpacklo_epi8(_mm_setzero_si128(), cr_biased);
         __m128i cbw = _mm_unpacklo_epi8(_mm_setzero_si128(), cb_biased);

         // color transform
         __m128i yws = _mm_srli_epi16(yw, 4);
         __m128i cr0 = _mm_mulhi_epi16(cr_const0, crw);
         __m128i cb0 = _mm_mulhi_epi16(cb_const0, cbw);
         __m128i cb1 = _mm_mulhi_epi16(cbw, cb_const1);
         __m128i cr1 = _mm_mulhi_epi16(crw, cr_const1);
         __m128i rws = _mm_add_epi16(cr0, yws);
         __m128i gwt = _mm_add_epi16(cb0, yws);
         __m128i bws = _mm_add_epi16(yws, cb1);
         __m128i gws = _mm_add_epi16(gwt, cr1);

         // descale
         __m128i rw = _mm_srai_epi16(rws, 4);
         __m128i bw = _mm_srai_epi16(bws, 4);
         __m128i gw = _mm_srai_epi16(gws, 4);

         // back to byte, set up for transpose
         __m128i brb = _mm_packus_epi16(rw, bw);
         __m128i gxb = _mm_packus_epi16(gw, xw);

         // transpose to interleave channels
         __m128i t0 = _mm_unpacklo_epi8(brb, gxb);
         __m128i t1 = _mm_unpackhi_epi8(brb, gxb);
         __m128i o0 = _mm_unpacklo_epi16(t0, t1);
         __m128i o1 = _mm_unpackhi_epi16(t0, t1);

         // store
         _mm_storeu_si128((__m128i *) (out + 0), o0);
         _mm_storeu_si128((__m128i *) (out + 16), o1);
         out += 32;
      }
   }
#endif

#ifdef STBI_NEON
   // in this version, step=3 support would be easy to add. but is there demand?
   if (step == 4) {
      // this is a fairly straightforward implementation and not super-optimized.
      uint8x8_t signflip = vdup_n_u8(0x80);
      int16x8_t cr_const0 = vdupq_n_s16(   (short) ( 1.40200f*4096.0f+0.5f));
      int16x8_t cr_const1 = vdupq_n_s16( - (short) ( 0.71414f*4096.0f+0.5f));
      int16x8_t cb_const0 = vdupq_n_s16( - (short) ( 0.34414f*4096.0f+0.5f));
      int16x8_t cb_const1 = vdupq_n_s16(   (short) ( 1.77200f*4096.0f+0.5f));

      for (; i+7 < count; i += 8) {
         // load
         uint8x8_t y_bytes  = vld1_u8(y + i);
         uint8x8_t cr_bytes = vld1_u8(pcr + i);
         uint8x8_t cb_bytes = vld1_u8(pcb + i);
         int8x8_t cr_biased = vreinterpret_s8_u8(vsub_u8(cr_bytes, signflip));
         int8x8_t cb_biased = vreinterpret_s8_u8(vsub_u8(cb_bytes, signflip));

         // expand to s16
         int16x8_t yws = vreinterpretq_s16_u16(vshll_n_u8(y_bytes, 4));
         int16x8_t crw = vshll_n_s8(cr_biased, 7);
         int16x8_t cbw = vshll_n_s8(cb_biased, 7);

         // color transform
         int16x8_t cr0 = vqdmulhq_s16(crw, cr_const0);
         int16x8_t cb0 = vqdmulhq_s16(cbw, cb_const0);
         int16x8_t cr1 = vqdmulhq_s16(crw, cr_const1);
         int16x8_t cb1 = vqdmulhq_s16(cbw, cb_const1);
         int16x8_t rws = vaddq_s16(yws, cr0);
         int16x8_t gws = vaddq_s16(vaddq_s16(yws, cb0), cr1);
         int16x8_t bws = vaddq_s16(yws, cb1);

         // undo scaling, round, convert to byte
         uint8x8x4_t o;
         o.val[0] = vqrshrun_n_s16(rws, 4);
         o.val[1] = vqrshrun_n_s16(gws, 4);
         o.val[2] = vqrshrun_n_s16(bws, 4);
         o.val[3] = vdup_n_u8(255);

         // store, interleaving r/g/b/a
         vst4_u8(out, o);
         out += 8*4;
      }
   }
#endif

   for (; i < count; ++i) {
      int y_fixed = (y[i] << 20) + (1<<19); // rounding
      int r,g,b;
      int cr = pcr[i] - 128;
      int cb = pcb[i] - 128;
      r = y_fixed + cr* stbi__float2fixed(1.40200f);
      g = y_fixed + cr*-stbi__float2fixed(0.71414f) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);
      b = y_fixed                                   +   cb* stbi__float2fixed(1.77200f);
      r >>= 20;
      g >>= 20;
      b >>= 20;
      if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }
      if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }
      if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }
      out[0] = (stbi_uc)r;
      out[1] = (stbi_uc)g;
      out[2] = (stbi_uc)b;
      out[3] = 255;
      out += step;
   }
}","{'begin': {'line': 3686, 'column': 1}, 'end': {'line': 3817, 'column': 2}}",play_bmp_sequence.c,"['使用', 'SIMD', '指令', '加速', '将', 'YCbCr', '转换', '为', 'RGB', '，', '支持', '批量', '处理', '。']"
194,194,stbi__process_frame_header,int,"int stbi__process_frame_header(stbi__jpeg * z, int scan)","[{'name': 'z', 'type': 'stbi__jpeg *'}, {'name': 'scan', 'type': 'int'}]",解析JPEG帧头并校验参数，初始化组件数据,"static int stbi__process_frame_header(stbi__jpeg *z, int scan)
{
   stbi__context *s = z->s;
   int Lf,p,i,q, h_max=1,v_max=1,c;
   Lf = stbi__get16be(s);         if (Lf < 11) return stbi__err(""bad SOF len"",""Corrupt JPEG""); // JPEG
   p  = stbi__get8(s);            if (p != 8) return stbi__err(""only 8-bit"",""JPEG format not supported: 8-bit only""); // JPEG baseline
   s->img_y = stbi__get16be(s);   if (s->img_y == 0) return stbi__err(""no header height"", ""JPEG format not supported: delayed height""); // Legal, but we don't handle it--but neither does IJG
   s->img_x = stbi__get16be(s);   if (s->img_x == 0) return stbi__err(""0 width"",""Corrupt JPEG""); // JPEG requires
   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err(""too large"",""Very large image (corrupt?)"");
   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err(""too large"",""Very large image (corrupt?)"");
   c = stbi__get8(s);
   if (c != 3 && c != 1 && c != 4) return stbi__err(""bad component count"",""Corrupt JPEG"");
   s->img_n = c;
   for (i=0; i < c; ++i) {
      z->img_comp[i].data = NULL;
      z->img_comp[i].linebuf = NULL;
   }

   if (Lf != 8+3*s->img_n) return stbi__err(""bad SOF len"",""Corrupt JPEG"");

   z->rgb = 0;
   for (i=0; i < s->img_n; ++i) {
      static const unsigned char rgb[3] = { 'R', 'G', 'B' };
      z->img_comp[i].id = stbi__get8(s);
      if (s->img_n == 3 && z->img_comp[i].id == rgb[i])
         ++z->rgb;
      q = stbi__get8(s);
      z->img_comp[i].h = (q >> 4);  if (!z->img_comp[i].h || z->img_comp[i].h > 4) return stbi__err(""bad H"",""Corrupt JPEG"");
      z->img_comp[i].v = q & 15;    if (!z->img_comp[i].v || z->img_comp[i].v > 4) return stbi__err(""bad V"",""Corrupt JPEG"");
      z->img_comp[i].tq = stbi__get8(s);  if (z->img_comp[i].tq > 3) return stbi__err(""bad TQ"",""Corrupt JPEG"");
   }

   if (scan != STBI__SCAN_load) return 1;

   if (!stbi__mad3sizes_valid(s->img_x, s->img_y, s->img_n, 0)) return stbi__err(""too large"", ""Image too large to decode"");

   for (i=0; i < s->img_n; ++i) {
      if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h;
      if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v;
   }

   // check that plane subsampling factors are integer ratios; our resamplers can't deal with fractional ratios
   // and I've never seen a non-corrupted JPEG file actually use them
   for (i=0; i < s->img_n; ++i) {
      if (h_max % z->img_comp[i].h != 0) return stbi__err(""bad H"",""Corrupt JPEG"");
      if (v_max % z->img_comp[i].v != 0) return stbi__err(""bad V"",""Corrupt JPEG"");
   }

   // compute interleaved mcu info
   z->img_h_max = h_max;
   z->img_v_max = v_max;
   z->img_mcu_w = h_max * 8;
   z->img_mcu_h = v_max * 8;
   // these sizes can't be more than 17 bits
   z->img_mcu_x = (s->img_x + z->img_mcu_w-1) / z->img_mcu_w;
   z->img_mcu_y = (s->img_y + z->img_mcu_h-1) / z->img_mcu_h;

   for (i=0; i < s->img_n; ++i) {
      // number of effective pixels (e.g. for non-interleaved MCU)
      z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max-1) / h_max;
      z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max-1) / v_max;
      // to simplify generation, we'll allocate enough memory to decode
      // the bogus oversized data from using interleaved MCUs and their
      // big blocks (e.g. a 16x16 iMCU on an image of width 33); we won't
      // discard the extra data until colorspace conversion
      //
      // img_mcu_x, img_mcu_y: <=17 bits; comp[i].h and .v are <=4 (checked earlier)
      // so these muls can't overflow with 32-bit ints (which we require)
      z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8;
      z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8;
      z->img_comp[i].coeff = 0;
      z->img_comp[i].raw_coeff = 0;
      z->img_comp[i].linebuf = NULL;
      z->img_comp[i].raw_data = stbi__malloc_mad2(z->img_comp[i].w2, z->img_comp[i].h2, 15);
      if (z->img_comp[i].raw_data == NULL)
         return stbi__free_jpeg_components(z, i+1, stbi__err(""outofmem"", ""Out of memory""));
      // align blocks for idct using mmx/sse
      z->img_comp[i].data = (stbi_uc*) (((size_t) z->img_comp[i].raw_data + 15) & ~15);
      if (z->progressive) {
         // w2, h2 are multiples of 8 (see above)
         z->img_comp[i].coeff_w = z->img_comp[i].w2 / 8;
         z->img_comp[i].coeff_h = z->img_comp[i].h2 / 8;
         z->img_comp[i].raw_coeff = stbi__malloc_mad3(z->img_comp[i].w2, z->img_comp[i].h2, sizeof(short), 15);
         if (z->img_comp[i].raw_coeff == NULL)
            return stbi__free_jpeg_components(z, i+1, stbi__err(""outofmem"", ""Out of memory""));
         z->img_comp[i].coeff = (short*) (((size_t) z->img_comp[i].raw_coeff + 15) & ~15);
      }
   }

   return 1;
}","{'begin': {'line': 3264, 'column': 1}, 'end': {'line': 3354, 'column': 2}}",play_bmp_sequence.c,"['解析', 'JPEG', '帧', '头', '并', '校验', '参数', '，', '初始', '初始化', '组件', '数据']"
195,195,stbi__setup_jpeg,void,void stbi__setup_jpeg(stbi__jpeg * j),"[{'name': 'j', 'type': 'stbi__jpeg *'}]",配置JPEG解码器的函数指针，支持SIMD优化,"static void stbi__setup_jpeg(stbi__jpeg *j)
{
   j->idct_block_kernel = stbi__idct_block;
   j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_row;
   j->resample_row_hv_2_kernel = stbi__resample_row_hv_2;

#ifdef STBI_SSE2
   if (stbi__sse2_available()) {
      j->idct_block_kernel = stbi__idct_simd;
      j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
      j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
   }
#endif

#ifdef STBI_NEON
   j->idct_block_kernel = stbi__idct_simd;
   j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
   j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
#endif
}","{'begin': {'line': 3821, 'column': 1}, 'end': {'line': 3840, 'column': 2}}",play_bmp_sequence.c,"['配置', 'JPEG', '解码', '码器', '解码器', '的', '函数', '指针', '函数指针', '，', '支持', 'SIMD', '优化']"
196,196,stbi__cleanup_jpeg,void,void stbi__cleanup_jpeg(stbi__jpeg * j),"[{'name': 'j', 'type': 'stbi__jpeg *'}]",清理JPEG组件并释放内存,"static void stbi__cleanup_jpeg(stbi__jpeg *j)
{
   stbi__free_jpeg_components(j, j->s->img_n, 0);
}","{'begin': {'line': 3843, 'column': 1}, 'end': {'line': 3846, 'column': 2}}",play_bmp_sequence.c,"['清理', 'JPEG', '组件', '并', '释放', '内存']"
197,197,stbi__blinn_8x8,stbi_uc,"stbi_uc stbi__blinn_8x8(stbi_uc x, stbi_uc y)","[{'name': 'x', 'type': 'stbi_uc'}, {'name': 'y', 'type': 'stbi_uc'}]",基于Blinn算法实现8位颜色混合计算,"static stbi_uc stbi__blinn_8x8(stbi_uc x, stbi_uc y)
{
   unsigned int t = x*y + 128;
   return (stbi_uc) ((t + (t >>8)) >> 8);
}","{'begin': {'line': 3859, 'column': 1}, 'end': {'line': 3863, 'column': 2}}",play_bmp_sequence.c,"['基于', 'Blinn', '算法', '实现', '8', '位', '颜色', '混合', '颜色混合', '计算']"
198,198,load_jpeg_image,stbi_uc *,"stbi_uc * load_jpeg_image(stbi__jpeg * z, int * out_x, int * out_y, int * comp, int req_comp)","[{'name': 'z', 'type': 'stbi__jpeg *'}, {'name': 'out_x', 'type': 'int *'}, {'name': 'out_y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",解码JPEG图像并处理颜色转换与重采样,"static stbi_uc *load_jpeg_image(stbi__jpeg *z, int *out_x, int *out_y, int *comp, int req_comp)
{
   int n, decode_n, is_rgb;
   z->s->img_n = 0; // make stbi__cleanup_jpeg safe

   // validate req_comp
   if (req_comp < 0 || req_comp > 4) return stbi__errpuc(""bad req_comp"", ""Internal error"");

   // load a jpeg image from whichever source, but leave in YCbCr format
   if (!stbi__decode_jpeg_image(z)) { stbi__cleanup_jpeg(z); return NULL; }

   // determine actual number of components to generate
   n = req_comp ? req_comp : z->s->img_n >= 3 ? 3 : 1;

   is_rgb = z->s->img_n == 3 && (z->rgb == 3 || (z->app14_color_transform == 0 && !z->jfif));

   if (z->s->img_n == 3 && n < 3 && !is_rgb)
      decode_n = 1;
   else
      decode_n = z->s->img_n;

   // nothing to do if no components requested; check this now to avoid
   // accessing uninitialized coutput[0] later
   if (decode_n <= 0) { stbi__cleanup_jpeg(z); return NULL; }

   // resample and color-convert
   {
      int k;
      unsigned int i,j;
      stbi_uc *output;
      stbi_uc *coutput[4] = { NULL, NULL, NULL, NULL };

      stbi__resample res_comp[4];

      for (k=0; k < decode_n; ++k) {
         stbi__resample *r = &res_comp[k];

         // allocate line buffer big enough for upsampling off the edges
         // with upsample factor of 4
         z->img_comp[k].linebuf = (stbi_uc *) stbi__malloc(z->s->img_x + 3);
         if (!z->img_comp[k].linebuf) { stbi__cleanup_jpeg(z); return stbi__errpuc(""outofmem"", ""Out of memory""); }

         r->hs      = z->img_h_max / z->img_comp[k].h;
         r->vs      = z->img_v_max / z->img_comp[k].v;
         r->ystep   = r->vs >> 1;
         r->w_lores = (z->s->img_x + r->hs-1) / r->hs;
         r->ypos    = 0;
         r->line0   = r->line1 = z->img_comp[k].data;

         if      (r->hs == 1 && r->vs == 1) r->resample = resample_row_1;
         else if (r->hs == 1 && r->vs == 2) r->resample = stbi__resample_row_v_2;
         else if (r->hs == 2 && r->vs == 1) r->resample = stbi__resample_row_h_2;
         else if (r->hs == 2 && r->vs == 2) r->resample = z->resample_row_hv_2_kernel;
         else                               r->resample = stbi__resample_row_generic;
      }

      // can't error after this so, this is safe
      output = (stbi_uc *) stbi__malloc_mad3(n, z->s->img_x, z->s->img_y, 1);
      if (!output) { stbi__cleanup_jpeg(z); return stbi__errpuc(""outofmem"", ""Out of memory""); }

      // now go ahead and resample
      for (j=0; j < z->s->img_y; ++j) {
         stbi_uc *out = output + n * z->s->img_x * j;
         for (k=0; k < decode_n; ++k) {
            stbi__resample *r = &res_comp[k];
            int y_bot = r->ystep >= (r->vs >> 1);
            coutput[k] = r->resample(z->img_comp[k].linebuf,
                                     y_bot ? r->line1 : r->line0,
                                     y_bot ? r->line0 : r->line1,
                                     r->w_lores, r->hs);
            if (++r->ystep >= r->vs) {
               r->ystep = 0;
               r->line0 = r->line1;
               if (++r->ypos < z->img_comp[k].y)
                  r->line1 += z->img_comp[k].w2;
            }
         }
         if (n >= 3) {
            stbi_uc *y = coutput[0];
            if (z->s->img_n == 3) {
               if (is_rgb) {
                  for (i=0; i < z->s->img_x; ++i) {
                     out[0] = y[i];
                     out[1] = coutput[1][i];
                     out[2] = coutput[2][i];
                     out[3] = 255;
                     out += n;
                  }
               } else {
                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
               }
            } else if (z->s->img_n == 4) {
               if (z->app14_color_transform == 0) { // CMYK
                  for (i=0; i < z->s->img_x; ++i) {
                     stbi_uc m = coutput[3][i];
                     out[0] = stbi__blinn_8x8(coutput[0][i], m);
                     out[1] = stbi__blinn_8x8(coutput[1][i], m);
                     out[2] = stbi__blinn_8x8(coutput[2][i], m);
                     out[3] = 255;
                     out += n;
                  }
               } else if (z->app14_color_transform == 2) { // YCCK
                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
                  for (i=0; i < z->s->img_x; ++i) {
                     stbi_uc m = coutput[3][i];
                     out[0] = stbi__blinn_8x8(255 - out[0], m);
                     out[1] = stbi__blinn_8x8(255 - out[1], m);
                     out[2] = stbi__blinn_8x8(255 - out[2], m);
                     out += n;
                  }
               } else { // YCbCr + alpha?  Ignore the fourth channel for now
                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
               }
            } else
               for (i=0; i < z->s->img_x; ++i) {
                  out[0] = out[1] = out[2] = y[i];
                  out[3] = 255; // not used if n==3
                  out += n;
               }
         } else {
            if (is_rgb) {
               if (n == 1)
                  for (i=0; i < z->s->img_x; ++i)
                     *out++ = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
               else {
                  for (i=0; i < z->s->img_x; ++i, out += 2) {
                     out[0] = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
                     out[1] = 255;
                  }
               }
            } else if (z->s->img_n == 4 && z->app14_color_transform == 0) {
               for (i=0; i < z->s->img_x; ++i) {
                  stbi_uc m = coutput[3][i];
                  stbi_uc r = stbi__blinn_8x8(coutput[0][i], m);
                  stbi_uc g = stbi__blinn_8x8(coutput[1][i], m);
                  stbi_uc b = stbi__blinn_8x8(coutput[2][i], m);
                  out[0] = stbi__compute_y(r, g, b);
                  out[1] = 255;
                  out += n;
               }
            } else if (z->s->img_n == 4 && z->app14_color_transform == 2) {
               for (i=0; i < z->s->img_x; ++i) {
                  out[0] = stbi__blinn_8x8(255 - coutput[0][i], coutput[3][i]);
                  out[1] = 255;
                  out += n;
               }
            } else {
               stbi_uc *y = coutput[0];
               if (n == 1)
                  for (i=0; i < z->s->img_x; ++i) out[i] = y[i];
               else
                  for (i=0; i < z->s->img_x; ++i) { *out++ = y[i]; *out++ = 255; }
            }
         }
      }
      stbi__cleanup_jpeg(z);
      *out_x = z->s->img_x;
      *out_y = z->s->img_y;
      if (comp) *comp = z->s->img_n >= 3 ? 3 : 1; // report original components, not output
      return output;
   }
}","{'begin': {'line': 3865, 'column': 1}, 'end': {'line': 4026, 'column': 2}}",play_bmp_sequence.c,"['解码', 'JPEG', '图像', '并', '处理', '颜色', '转换', '与', '重', '采样']"
199,199,stbi__decode_jpeg_header,int,"int stbi__decode_jpeg_header(stbi__jpeg * z, int scan)","[{'name': 'z', 'type': 'stbi__jpeg *'}, {'name': 'scan', 'type': 'int'}]",解析JPEG头部信息，验证并处理标记,"static int stbi__decode_jpeg_header(stbi__jpeg *z, int scan)
{
   int m;
   z->jfif = 0;
   z->app14_color_transform = -1; // valid values are 0,1,2
   z->marker = STBI__MARKER_none; // initialize cached marker to empty
   m = stbi__get_marker(z);
   if (!stbi__SOI(m)) return stbi__err(""no SOI"",""Corrupt JPEG"");
   if (scan == STBI__SCAN_type) return 1;
   m = stbi__get_marker(z);
   while (!stbi__SOF(m)) {
      if (!stbi__process_marker(z,m)) return 0;
      m = stbi__get_marker(z);
      while (m == STBI__MARKER_none) {
         // some files have extra padding after their blocks, so ok, we'll scan
         if (stbi__at_eof(z->s)) return stbi__err(""no SOF"", ""Corrupt JPEG"");
         m = stbi__get_marker(z);
      }
   }
   z->progressive = stbi__SOF_progressive(m);
   if (!stbi__process_frame_header(z, scan)) return 0;
   return 1;
}","{'begin': {'line': 3365, 'column': 1}, 'end': {'line': 3387, 'column': 2}}",play_bmp_sequence.c,"['解析', 'JPEG', '头部', '信息', '，', '验证', '并', '处理', '标记']"
200,200,stbi__skip_jpeg_junk_at_end,stbi_uc,stbi_uc stbi__skip_jpeg_junk_at_end(stbi__jpeg * j),"[{'name': 'j', 'type': 'stbi__jpeg *'}]",跳过JPEG文件末尾无效数据并检测有效标记,"static stbi_uc stbi__skip_jpeg_junk_at_end(stbi__jpeg *j)
{
   // some JPEGs have junk at end, skip over it but if we find what looks
   // like a valid marker, resume there
   while (!stbi__at_eof(j->s)) {
      stbi_uc x = stbi__get8(j->s);
      while (x == 0xff) { // might be a marker
         if (stbi__at_eof(j->s)) return STBI__MARKER_none;
         x = stbi__get8(j->s);
         if (x != 0x00 && x != 0xff) {
            // not a stuffed zero or lead-in to another marker, looks
            // like an actual marker, return it
            return x;
         }
         // stuffed zero has x=0 now which ends the loop, meaning we go
         // back to regular scan loop.
         // repeated 0xff keeps trying to read the next byte of the marker.
      }
   }
   return STBI__MARKER_none;
}","{'begin': {'line': 3389, 'column': 1}, 'end': {'line': 3409, 'column': 2}}",play_bmp_sequence.c,"['跳过', 'JPEG', '文件', '末尾', '无效', '数据', '并', '检测', '有效', '标记']"
201,201,stbi__decode_jpeg_image,int,int stbi__decode_jpeg_image(stbi__jpeg * j),"[{'name': 'j', 'type': 'stbi__jpeg *'}]",解码JPEG图像数据流和处理标记,"static int stbi__decode_jpeg_image(stbi__jpeg *j)
{
   int m;
   for (m = 0; m < 4; m++) {
      j->img_comp[m].raw_data = NULL;
      j->img_comp[m].raw_coeff = NULL;
   }
   j->restart_interval = 0;
   if (!stbi__decode_jpeg_header(j, STBI__SCAN_load)) return 0;
   m = stbi__get_marker(j);
   while (!stbi__EOI(m)) {
      if (stbi__SOS(m)) {
         if (!stbi__process_scan_header(j)) return 0;
         if (!stbi__parse_entropy_coded_data(j)) return 0;
         if (j->marker == STBI__MARKER_none ) {
         j->marker = stbi__skip_jpeg_junk_at_end(j);
            // if we reach eof without hitting a marker, stbi__get_marker() below will fail and we'll eventually return 0
         }
         m = stbi__get_marker(j);
         if (STBI__RESTART(m))
            m = stbi__get_marker(j);
      } else if (stbi__DNL(m)) {
         int Ld = stbi__get16be(j->s);
         stbi__uint32 NL = stbi__get16be(j->s);
         if (Ld != 4) return stbi__err(""bad DNL len"", ""Corrupt JPEG"");
         if (NL != j->s->img_y) return stbi__err(""bad DNL height"", ""Corrupt JPEG"");
         m = stbi__get_marker(j);
      } else {
         if (!stbi__process_marker(j, m)) return 1;
         m = stbi__get_marker(j);
      }
   }
   if (j->progressive)
      stbi__jpeg_finish(j);
   return 1;
}","{'begin': {'line': 3412, 'column': 1}, 'end': {'line': 3447, 'column': 2}}",play_bmp_sequence.c,"['解码', 'JPEG', '图像', '数据', '数据流', '和', '处理', '标记']"
202,202,resample_row_1,stbi_uc *,"stbi_uc * resample_row_1(stbi_uc * out, stbi_uc * in_near, stbi_uc * in_far, int w, int hs)","[{'name': 'out', 'type': 'stbi_uc *'}, {'name': 'in_near', 'type': 'stbi_uc *'}, {'name': 'in_far', 'type': 'stbi_uc *'}, {'name': 'w', 'type': 'int'}, {'name': 'hs', 'type': 'int'}]",直接返回输入数据，不进行重采样处理,"static stbi_uc *resample_row_1(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   STBI_NOTUSED(out);
   STBI_NOTUSED(in_far);
   STBI_NOTUSED(w);
   STBI_NOTUSED(hs);
   return in_near;
}","{'begin': {'line': 3456, 'column': 1}, 'end': {'line': 3463, 'column': 2}}",play_bmp_sequence.c,"['直接', '返回', '输入', '数据', '，', '不', '进行', '重', '采样', '处理']"
203,203,stbi__resample_row_v_2,stbi_uc *,"stbi_uc * stbi__resample_row_v_2(stbi_uc * out, stbi_uc * in_near, stbi_uc * in_far, int w, int hs)","[{'name': 'out', 'type': 'stbi_uc *'}, {'name': 'in_near', 'type': 'stbi_uc *'}, {'name': 'in_far', 'type': 'stbi_uc *'}, {'name': 'w', 'type': 'int'}, {'name': 'hs', 'type': 'int'}]",垂直方向双倍重采样，使用加权平均算法,"static stbi_uc* stbi__resample_row_v_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // need to generate two samples vertically for every one in input
   int i;
   STBI_NOTUSED(hs);
   for (i=0; i < w; ++i)
      out[i] = stbi__div4(3*in_near[i] + in_far[i] + 2);
   return out;
}","{'begin': {'line': 3465, 'column': 1}, 'end': {'line': 3473, 'column': 2}}",play_bmp_sequence.c,"['垂直', '方向', '双倍', '重', '采样', '，', '使用', '加权', '平均', '算法']"
204,204,stbi__resample_row_h_2,stbi_uc *,"stbi_uc * stbi__resample_row_h_2(stbi_uc * out, stbi_uc * in_near, stbi_uc * in_far, int w, int hs)","[{'name': 'out', 'type': 'stbi_uc *'}, {'name': 'in_near', 'type': 'stbi_uc *'}, {'name': 'in_far', 'type': 'stbi_uc *'}, {'name': 'w', 'type': 'int'}, {'name': 'hs', 'type': 'int'}]",水平双倍线性重采样函数,"static stbi_uc*  stbi__resample_row_h_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // need to generate two samples horizontally for every one in input
   int i;
   stbi_uc *input = in_near;

   if (w == 1) {
      // if only one sample, can't do any interpolation
      out[0] = out[1] = input[0];
      return out;
   }

   out[0] = input[0];
   out[1] = stbi__div4(input[0]*3 + input[1] + 2);
   for (i=1; i < w-1; ++i) {
      int n = 3*input[i]+2;
      out[i*2+0] = stbi__div4(n+input[i-1]);
      out[i*2+1] = stbi__div4(n+input[i+1]);
   }
   out[i*2+0] = stbi__div4(input[w-2]*3 + input[w-1] + 2);
   out[i*2+1] = input[w-1];

   STBI_NOTUSED(in_far);
   STBI_NOTUSED(hs);

   return out;
}","{'begin': {'line': 3475, 'column': 1}, 'end': {'line': 3501, 'column': 2}}",play_bmp_sequence.c,"['水平', '双倍', '线性', '重', '采样', '函数']"
205,205,stbi__jpeg_load,void *,"void * stbi__jpeg_load(stbi__context * s, int * x, int * y, int * comp, int req_comp, stbi__result_info * ri)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'ri', 'type': 'stbi__result_info *'}]",加载JPEG图像数据并分配内存,"static void *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   unsigned char* result;
   stbi__jpeg* j = (stbi__jpeg*) stbi__malloc(sizeof(stbi__jpeg));
   if (!j) return stbi__errpuc(""outofmem"", ""Out of memory"");
   memset(j, 0, sizeof(stbi__jpeg));
   STBI_NOTUSED(ri);
   j->s = s;
   stbi__setup_jpeg(j);
   result = load_jpeg_image(j, x,y,comp,req_comp);
   STBI_FREE(j);
   return result;
}","{'begin': {'line': 4028, 'column': 1}, 'end': {'line': 4040, 'column': 2}}",play_bmp_sequence.c,"['加载', 'JPEG', '图像', '数据', '并', '分配', '内存', '分配内存']"
206,206,stbi__jpeg_test,int,int stbi__jpeg_test(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",检测输入是否为有效JPEG图像,"static int stbi__jpeg_test(stbi__context *s)
{
   int r;
   stbi__jpeg* j = (stbi__jpeg*)stbi__malloc(sizeof(stbi__jpeg));
   if (!j) return stbi__err(""outofmem"", ""Out of memory"");
   memset(j, 0, sizeof(stbi__jpeg));
   j->s = s;
   stbi__setup_jpeg(j);
   r = stbi__decode_jpeg_header(j, STBI__SCAN_type);
   stbi__rewind(s);
   STBI_FREE(j);
   return r;
}","{'begin': {'line': 4042, 'column': 1}, 'end': {'line': 4054, 'column': 2}}",play_bmp_sequence.c,"['检测', '输入', '是否', '为', '有效', 'JPEG', '图像']"
207,207,stbi__resample_row_hv_2,stbi_uc *,"stbi_uc * stbi__resample_row_hv_2(stbi_uc * out, stbi_uc * in_near, stbi_uc * in_far, int w, int hs)","[{'name': 'out', 'type': 'stbi_uc *'}, {'name': 'in_near', 'type': 'stbi_uc *'}, {'name': 'in_far', 'type': 'stbi_uc *'}, {'name': 'w', 'type': 'int'}, {'name': 'hs', 'type': 'int'}]",双线性插值实现图像2倍水平/垂直重采样,"static stbi_uc *stbi__resample_row_hv_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // need to generate 2x2 samples for every one in input
   int i,t0,t1;
   if (w == 1) {
      out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);
      return out;
   }

   t1 = 3*in_near[0] + in_far[0];
   out[0] = stbi__div4(t1+2);
   for (i=1; i < w; ++i) {
      t0 = t1;
      t1 = 3*in_near[i]+in_far[i];
      out[i*2-1] = stbi__div16(3*t0 + t1 + 8);
      out[i*2  ] = stbi__div16(3*t1 + t0 + 8);
   }
   out[w*2-1] = stbi__div4(t1+2);

   STBI_NOTUSED(hs);

   return out;
}","{'begin': {'line': 3505, 'column': 1}, 'end': {'line': 3527, 'column': 2}}",play_bmp_sequence.c,"['双', '线性', '插值', '线性插值', '实现', '图像', '2', '倍', '水平', '/', '垂直', '重', '采样']"
208,208,stbi__jpeg_info_raw,int,"int stbi__jpeg_info_raw(stbi__jpeg * j, int * x, int * y, int * comp)","[{'name': 'j', 'type': 'stbi__jpeg *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",解析JPEG图像信息并返回宽、高及通道数,"static int stbi__jpeg_info_raw(stbi__jpeg *j, int *x, int *y, int *comp)
{
   if (!stbi__decode_jpeg_header(j, STBI__SCAN_header)) {
      stbi__rewind( j->s );
      return 0;
   }
   if (x) *x = j->s->img_x;
   if (y) *y = j->s->img_y;
   if (comp) *comp = j->s->img_n >= 3 ? 3 : 1;
   return 1;
}","{'begin': {'line': 4056, 'column': 1}, 'end': {'line': 4066, 'column': 2}}",play_bmp_sequence.c,"['解析', 'JPEG', '图像', '信息', '并', '返回', '宽', '、', '高及', '通道', '数']"
209,209,stbi__jpeg_info,int,"int stbi__jpeg_info(stbi__context * s, int * x, int * y, int * comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",获取JPEG图像的尺寸和通道信息,"static int stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp)
{
   int result;
   stbi__jpeg* j = (stbi__jpeg*) (stbi__malloc(sizeof(stbi__jpeg)));
   if (!j) return stbi__err(""outofmem"", ""Out of memory"");
   memset(j, 0, sizeof(stbi__jpeg));
   j->s = s;
   result = stbi__jpeg_info_raw(j, x, y, comp);
   STBI_FREE(j);
   return result;
}","{'begin': {'line': 4068, 'column': 1}, 'end': {'line': 4078, 'column': 2}}",play_bmp_sequence.c,"['获取', 'JPEG', '图像', '的', '尺寸', '和', '通道', '信息']"
210,210,stbi__resample_row_hv_2_simd,stbi_uc *,"stbi_uc * stbi__resample_row_hv_2_simd(stbi_uc * out, stbi_uc * in_near, stbi_uc * in_far, int w, int hs)","[{'name': 'out', 'type': 'stbi_uc *'}, {'name': 'in_near', 'type': 'stbi_uc *'}, {'name': 'in_far', 'type': 'stbi_uc *'}, {'name': 'w', 'type': 'int'}, {'name': 'hs', 'type': 'int'}]",使用SIMD对图像行进行水平和垂直双倍重采样,"static stbi_uc *stbi__resample_row_hv_2_simd(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // need to generate 2x2 samples for every one in input
   int i=0,t0,t1;

   if (w == 1) {
      out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);
      return out;
   }

   t1 = 3*in_near[0] + in_far[0];
   // process groups of 8 pixels for as long as we can.
   // note we can't handle the last pixel in a row in this loop
   // because we need to handle the filter boundary conditions.
   for (; i < ((w-1) & ~7); i += 8) {
#if defined(STBI_SSE2)
      // load and perform the vertical filtering pass
      // this uses 3*x + y = 4*x + (y - x)
      __m128i zero  = _mm_setzero_si128();
      __m128i farb  = _mm_loadl_epi64((__m128i *) (in_far + i));
      __m128i nearb = _mm_loadl_epi64((__m128i *) (in_near + i));
      __m128i farw  = _mm_unpacklo_epi8(farb, zero);
      __m128i nearw = _mm_unpacklo_epi8(nearb, zero);
      __m128i diff  = _mm_sub_epi16(farw, nearw);
      __m128i nears = _mm_slli_epi16(nearw, 2);
      __m128i curr  = _mm_add_epi16(nears, diff); // current row

      // horizontal filter works the same based on shifted vers of current
      // row. ""prev"" is current row shifted right by 1 pixel; we need to
      // insert the previous pixel value (from t1).
      // ""next"" is current row shifted left by 1 pixel, with first pixel
      // of next block of 8 pixels added in.
      __m128i prv0 = _mm_slli_si128(curr, 2);
      __m128i nxt0 = _mm_srli_si128(curr, 2);
      __m128i prev = _mm_insert_epi16(prv0, t1, 0);
      __m128i next = _mm_insert_epi16(nxt0, 3*in_near[i+8] + in_far[i+8], 7);

      // horizontal filter, polyphase implementation since it's convenient:
      // even pixels = 3*cur + prev = cur*4 + (prev - cur)
      // odd  pixels = 3*cur + next = cur*4 + (next - cur)
      // note the shared term.
      __m128i bias  = _mm_set1_epi16(8);
      __m128i curs = _mm_slli_epi16(curr, 2);
      __m128i prvd = _mm_sub_epi16(prev, curr);
      __m128i nxtd = _mm_sub_epi16(next, curr);
      __m128i curb = _mm_add_epi16(curs, bias);
      __m128i even = _mm_add_epi16(prvd, curb);
      __m128i odd  = _mm_add_epi16(nxtd, curb);

      // interleave even and odd pixels, then undo scaling.
      __m128i int0 = _mm_unpacklo_epi16(even, odd);
      __m128i int1 = _mm_unpackhi_epi16(even, odd);
      __m128i de0  = _mm_srli_epi16(int0, 4);
      __m128i de1  = _mm_srli_epi16(int1, 4);

      // pack and write output
      __m128i outv = _mm_packus_epi16(de0, de1);
      _mm_storeu_si128((__m128i *) (out + i*2), outv);
#elif defined(STBI_NEON)
      // load and perform the vertical filtering pass
      // this uses 3*x + y = 4*x + (y - x)
      uint8x8_t farb  = vld1_u8(in_far + i);
      uint8x8_t nearb = vld1_u8(in_near + i);
      int16x8_t diff  = vreinterpretq_s16_u16(vsubl_u8(farb, nearb));
      int16x8_t nears = vreinterpretq_s16_u16(vshll_n_u8(nearb, 2));
      int16x8_t curr  = vaddq_s16(nears, diff); // current row

      // horizontal filter works the same based on shifted vers of current
      // row. ""prev"" is current row shifted right by 1 pixel; we need to
      // insert the previous pixel value (from t1).
      // ""next"" is current row shifted left by 1 pixel, with first pixel
      // of next block of 8 pixels added in.
      int16x8_t prv0 = vextq_s16(curr, curr, 7);
      int16x8_t nxt0 = vextq_s16(curr, curr, 1);
      int16x8_t prev = vsetq_lane_s16(t1, prv0, 0);
      int16x8_t next = vsetq_lane_s16(3*in_near[i+8] + in_far[i+8], nxt0, 7);

      // horizontal filter, polyphase implementation since it's convenient:
      // even pixels = 3*cur + prev = cur*4 + (prev - cur)
      // odd  pixels = 3*cur + next = cur*4 + (next - cur)
      // note the shared term.
      int16x8_t curs = vshlq_n_s16(curr, 2);
      int16x8_t prvd = vsubq_s16(prev, curr);
      int16x8_t nxtd = vsubq_s16(next, curr);
      int16x8_t even = vaddq_s16(curs, prvd);
      int16x8_t odd  = vaddq_s16(curs, nxtd);

      // undo scaling and round, then store with even/odd phases interleaved
      uint8x8x2_t o;
      o.val[0] = vqrshrun_n_s16(even, 4);
      o.val[1] = vqrshrun_n_s16(odd,  4);
      vst2_u8(out + i*2, o);
#endif

      // ""previous"" value for next iter
      t1 = 3*in_near[i+7] + in_far[i+7];
   }

   t0 = t1;
   t1 = 3*in_near[i] + in_far[i];
   out[i*2] = stbi__div16(3*t1 + t0 + 8);

   for (++i; i < w; ++i) {
      t0 = t1;
      t1 = 3*in_near[i]+in_far[i];
      out[i*2-1] = stbi__div16(3*t0 + t1 + 8);
      out[i*2  ] = stbi__div16(3*t1 + t0 + 8);
   }
   out[w*2-1] = stbi__div4(t1+2);

   STBI_NOTUSED(hs);

   return out;
}","{'begin': {'line': 3530, 'column': 1}, 'end': {'line': 3643, 'column': 2}}",play_bmp_sequence.c,"['使用', 'SIMD', '对', '图像', '行', '进行', '水平', '和', '垂直', '双倍', '重', '采样']"
211,211,stbi__bitreverse16,int,int stbi__bitreverse16(int n),"[{'name': 'n', 'type': 'int'}]",反转16位整数的所有位顺序,"static int stbi__bitreverse16(int n)
{
  n = ((n & 0xAAAA) >>  1) | ((n & 0x5555) << 1);
  n = ((n & 0xCCCC) >>  2) | ((n & 0x3333) << 2);
  n = ((n & 0xF0F0) >>  4) | ((n & 0x0F0F) << 4);
  n = ((n & 0xFF00) >>  8) | ((n & 0x00FF) << 8);
  return n;
}","{'begin': {'line': 4107, 'column': 13}, 'end': {'line': 4114, 'column': 2}}",play_bmp_sequence.c,"['反转', '16', '位', '整数', '的', '所有', '位', '顺序']"
212,212,stbi__bit_reverse,int,"int stbi__bit_reverse(int v, int bits)","[{'name': 'v', 'type': 'int'}, {'name': 'bits', 'type': 'int'}]",按指定位数反转整数比特,"static int stbi__bit_reverse(int v, int bits)
{
   STBI_ASSERT(bits <= 16);
   // to bit reverse n bits, reverse 16 and shift
   // e.g. 11 bits, bit reverse and shift away 5
   return stbi__bitreverse16(v) >> (16-bits);
}","{'begin': {'line': 4116, 'column': 13}, 'end': {'line': 4122, 'column': 2}}",play_bmp_sequence.c,"['按', '指定', '位数', '反转', '整数', '比特']"
213,213,stbi__zbuild_huffman,int,"int stbi__zbuild_huffman(stbi__zhuffman * z, const stbi_uc * sizelist, int num)","[{'name': 'z', 'type': 'stbi__zhuffman *'}, {'name': 'sizelist', 'type': 'const stbi_uc *'}, {'name': 'num', 'type': 'int'}]",构建哈夫曼树，处理压缩数据，生成快速查找表,"static int stbi__zbuild_huffman(stbi__zhuffman *z, const stbi_uc *sizelist, int num)
{
   int i,k=0;
   int code, next_code[16], sizes[17];

   // DEFLATE spec for generating codes
   memset(sizes, 0, sizeof(sizes));
   memset(z->fast, 0, sizeof(z->fast));
   for (i=0; i < num; ++i)
      ++sizes[sizelist[i]];
   sizes[0] = 0;
   for (i=1; i < 16; ++i)
      if (sizes[i] > (1 << i))
         return stbi__err(""bad sizes"", ""Corrupt PNG"");
   code = 0;
   for (i=1; i < 16; ++i) {
      next_code[i] = code;
      z->firstcode[i] = (stbi__uint16) code;
      z->firstsymbol[i] = (stbi__uint16) k;
      code = (code + sizes[i]);
      if (sizes[i])
         if (code-1 >= (1 << i)) return stbi__err(""bad codelengths"",""Corrupt PNG"");
      z->maxcode[i] = code << (16-i); // preshift for inner loop
      code <<= 1;
      k += sizes[i];
   }
   z->maxcode[16] = 0x10000; // sentinel
   for (i=0; i < num; ++i) {
      int s = sizelist[i];
      if (s) {
         int c = next_code[s] - z->firstcode[s] + z->firstsymbol[s];
         stbi__uint16 fastv = (stbi__uint16) ((s << 9) | i);
         z->size [c] = (stbi_uc     ) s;
         z->value[c] = (stbi__uint16) i;
         if (s <= STBI__ZFAST_BITS) {
            int j = stbi__bit_reverse(next_code[s],s);
            while (j < (1 << STBI__ZFAST_BITS)) {
               z->fast[j] = fastv;
               j += (1 << s);
            }
         }
         ++next_code[s];
      }
   }
   return 1;
}","{'begin': {'line': 4124, 'column': 1}, 'end': {'line': 4169, 'column': 2}}",play_bmp_sequence.c,"['构建', '夫曼', '哈夫曼', '树', '，', '处理', '压缩', '数据', '，', '生成', '快速', '查找', '表']"
214,214,stbi__resample_row_generic,stbi_uc *,"stbi_uc * stbi__resample_row_generic(stbi_uc * out, stbi_uc * in_near, stbi_uc * in_far, int w, int hs)","[{'name': 'out', 'type': 'stbi_uc *'}, {'name': 'in_near', 'type': 'stbi_uc *'}, {'name': 'in_far', 'type': 'stbi_uc *'}, {'name': 'w', 'type': 'int'}, {'name': 'hs', 'type': 'int'}]",使用邻近插值算法对图像行进行重采样，逐像素复制至目标宽度。,"static stbi_uc *stbi__resample_row_generic(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // resample with nearest-neighbor
   int i,j;
   STBI_NOTUSED(in_far);
   for (i=0; i < w; ++i)
      for (j=0; j < hs; ++j)
         out[i*hs+j] = in_near[i];
   return out;
}","{'begin': {'line': 3646, 'column': 1}, 'end': {'line': 3655, 'column': 2}}",play_bmp_sequence.c,"['使用', '邻近', '插值', '算法', '对', '图像', '行', '进行', '重', '采样', '，', '逐', '像素', '复制', '至', '目标', '宽度', '。']"
215,215,stbi__YCbCr_to_RGB_row,void,"void stbi__YCbCr_to_RGB_row(stbi_uc * out, const stbi_uc * y, const stbi_uc * pcb, const stbi_uc * pcr, int count, int step)","[{'name': 'out', 'type': 'stbi_uc *'}, {'name': 'y', 'type': 'const stbi_uc *'}, {'name': 'pcb', 'type': 'const stbi_uc *'}, {'name': 'pcr', 'type': 'const stbi_uc *'}, {'name': 'count', 'type': 'int'}, {'name': 'step', 'type': 'int'}]",将YCbCr转换为RGB行数据并进行溢出处理,"static void stbi__YCbCr_to_RGB_row(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step)
{
   int i;
   for (i=0; i < count; ++i) {
      int y_fixed = (y[i] << 20) + (1<<19); // rounding
      int r,g,b;
      int cr = pcr[i] - 128;
      int cb = pcb[i] - 128;
      r = y_fixed +  cr* stbi__float2fixed(1.40200f);
      g = y_fixed + (cr*-stbi__float2fixed(0.71414f)) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);
      b = y_fixed                                     +   cb* stbi__float2fixed(1.77200f);
      r >>= 20;
      g >>= 20;
      b >>= 20;
      if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }
      if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }
      if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }
      out[0] = (stbi_uc)r;
      out[1] = (stbi_uc)g;
      out[2] = (stbi_uc)b;
      out[3] = 255;
      out += step;
   }
}","{'begin': {'line': 3660, 'column': 1}, 'end': {'line': 3683, 'column': 2}}",play_bmp_sequence.c,"['将', 'YCbCr', '转换', '为', 'RGB', '行', '数据', '并', '进行', '溢出', '处理']"
216,216,stbi__zeof,int,int stbi__zeof(stbi__zbuf * z),"[{'name': 'z', 'type': 'stbi__zbuf *'}]",检测压缩数据缓冲区是否读取完毕,"static int stbi__zeof(stbi__zbuf *z)
{
   return (z->zbuffer >= z->zbuffer_end);
}","{'begin': {'line': 4192, 'column': 13}, 'end': {'line': 4195, 'column': 2}}",play_bmp_sequence.c,"['检测', '压缩', '数据', '缓冲', '缓冲区', '是否', '读取', '完毕']"
217,217,stbi__zget8,stbi_uc,stbi_uc stbi__zget8(stbi__zbuf * z),"[{'name': 'z', 'type': 'stbi__zbuf *'}]",从压缩缓冲区读取下一个字节，若结束返回0,"static stbi_uc stbi__zget8(stbi__zbuf *z)
{
   return stbi__zeof(z) ? 0 : *z->zbuffer++;
}","{'begin': {'line': 4197, 'column': 13}, 'end': {'line': 4200, 'column': 2}}",play_bmp_sequence.c,"['从', '压缩', '缓冲', '缓冲区', '读取', '下', '一个', '字节', '，', '若', '结束', '返回', '0']"
218,218,stbi__YCbCr_to_RGB_simd,void,"void stbi__YCbCr_to_RGB_simd(stbi_uc * out, const stbi_uc * y, const stbi_uc * pcb, const stbi_uc * pcr, int count, int step)","[{'name': 'out', 'type': 'stbi_uc *'}, {'name': 'y', 'type': 'const stbi_uc *'}, {'name': 'pcb', 'type': 'const stbi_uc *'}, {'name': 'pcr', 'type': 'const stbi_uc *'}, {'name': 'count', 'type': 'int'}, {'name': 'step', 'type': 'int'}]",使用SIMD优化将YCbCr转换为RGB，适用于步长为4的批量处理,"static void stbi__YCbCr_to_RGB_simd(stbi_uc *out, stbi_uc const *y, stbi_uc const *pcb, stbi_uc const *pcr, int count, int step)
{
   int i = 0;

#ifdef STBI_SSE2
   // step == 3 is pretty ugly on the final interleave, and i'm not convinced
   // it's useful in practice (you wouldn't use it for textures, for example).
   // so just accelerate step == 4 case.
   if (step == 4) {
      // this is a fairly straightforward implementation and not super-optimized.
      __m128i signflip  = _mm_set1_epi8(-0x80);
      __m128i cr_const0 = _mm_set1_epi16(   (short) ( 1.40200f*4096.0f+0.5f));
      __m128i cr_const1 = _mm_set1_epi16( - (short) ( 0.71414f*4096.0f+0.5f));
      __m128i cb_const0 = _mm_set1_epi16( - (short) ( 0.34414f*4096.0f+0.5f));
      __m128i cb_const1 = _mm_set1_epi16(   (short) ( 1.77200f*4096.0f+0.5f));
      __m128i y_bias = _mm_set1_epi8((char) (unsigned char) 128);
      __m128i xw = _mm_set1_epi16(255); // alpha channel

      for (; i+7 < count; i += 8) {
         // load
         __m128i y_bytes = _mm_loadl_epi64((__m128i *) (y+i));
         __m128i cr_bytes = _mm_loadl_epi64((__m128i *) (pcr+i));
         __m128i cb_bytes = _mm_loadl_epi64((__m128i *) (pcb+i));
         __m128i cr_biased = _mm_xor_si128(cr_bytes, signflip); // -128
         __m128i cb_biased = _mm_xor_si128(cb_bytes, signflip); // -128

         // unpack to short (and left-shift cr, cb by 8)
         __m128i yw  = _mm_unpacklo_epi8(y_bias, y_bytes);
         __m128i crw = _mm_unpacklo_epi8(_mm_setzero_si128(), cr_biased);
         __m128i cbw = _mm_unpacklo_epi8(_mm_setzero_si128(), cb_biased);

         // color transform
         __m128i yws = _mm_srli_epi16(yw, 4);
         __m128i cr0 = _mm_mulhi_epi16(cr_const0, crw);
         __m128i cb0 = _mm_mulhi_epi16(cb_const0, cbw);
         __m128i cb1 = _mm_mulhi_epi16(cbw, cb_const1);
         __m128i cr1 = _mm_mulhi_epi16(crw, cr_const1);
         __m128i rws = _mm_add_epi16(cr0, yws);
         __m128i gwt = _mm_add_epi16(cb0, yws);
         __m128i bws = _mm_add_epi16(yws, cb1);
         __m128i gws = _mm_add_epi16(gwt, cr1);

         // descale
         __m128i rw = _mm_srai_epi16(rws, 4);
         __m128i bw = _mm_srai_epi16(bws, 4);
         __m128i gw = _mm_srai_epi16(gws, 4);

         // back to byte, set up for transpose
         __m128i brb = _mm_packus_epi16(rw, bw);
         __m128i gxb = _mm_packus_epi16(gw, xw);

         // transpose to interleave channels
         __m128i t0 = _mm_unpacklo_epi8(brb, gxb);
         __m128i t1 = _mm_unpackhi_epi8(brb, gxb);
         __m128i o0 = _mm_unpacklo_epi16(t0, t1);
         __m128i o1 = _mm_unpackhi_epi16(t0, t1);

         // store
         _mm_storeu_si128((__m128i *) (out + 0), o0);
         _mm_storeu_si128((__m128i *) (out + 16), o1);
         out += 32;
      }
   }
#endif

#ifdef STBI_NEON
   // in this version, step=3 support would be easy to add. but is there demand?
   if (step == 4) {
      // this is a fairly straightforward implementation and not super-optimized.
      uint8x8_t signflip = vdup_n_u8(0x80);
      int16x8_t cr_const0 = vdupq_n_s16(   (short) ( 1.40200f*4096.0f+0.5f));
      int16x8_t cr_const1 = vdupq_n_s16( - (short) ( 0.71414f*4096.0f+0.5f));
      int16x8_t cb_const0 = vdupq_n_s16( - (short) ( 0.34414f*4096.0f+0.5f));
      int16x8_t cb_const1 = vdupq_n_s16(   (short) ( 1.77200f*4096.0f+0.5f));

      for (; i+7 < count; i += 8) {
         // load
         uint8x8_t y_bytes  = vld1_u8(y + i);
         uint8x8_t cr_bytes = vld1_u8(pcr + i);
         uint8x8_t cb_bytes = vld1_u8(pcb + i);
         int8x8_t cr_biased = vreinterpret_s8_u8(vsub_u8(cr_bytes, signflip));
         int8x8_t cb_biased = vreinterpret_s8_u8(vsub_u8(cb_bytes, signflip));

         // expand to s16
         int16x8_t yws = vreinterpretq_s16_u16(vshll_n_u8(y_bytes, 4));
         int16x8_t crw = vshll_n_s8(cr_biased, 7);
         int16x8_t cbw = vshll_n_s8(cb_biased, 7);

         // color transform
         int16x8_t cr0 = vqdmulhq_s16(crw, cr_const0);
         int16x8_t cb0 = vqdmulhq_s16(cbw, cb_const0);
         int16x8_t cr1 = vqdmulhq_s16(crw, cr_const1);
         int16x8_t cb1 = vqdmulhq_s16(cbw, cb_const1);
         int16x8_t rws = vaddq_s16(yws, cr0);
         int16x8_t gws = vaddq_s16(vaddq_s16(yws, cb0), cr1);
         int16x8_t bws = vaddq_s16(yws, cb1);

         // undo scaling, round, convert to byte
         uint8x8x4_t o;
         o.val[0] = vqrshrun_n_s16(rws, 4);
         o.val[1] = vqrshrun_n_s16(gws, 4);
         o.val[2] = vqrshrun_n_s16(bws, 4);
         o.val[3] = vdup_n_u8(255);

         // store, interleaving r/g/b/a
         vst4_u8(out, o);
         out += 8*4;
      }
   }
#endif

   for (; i < count; ++i) {
      int y_fixed = (y[i] << 20) + (1<<19); // rounding
      int r,g,b;
      int cr = pcr[i] - 128;
      int cb = pcb[i] - 128;
      r = y_fixed + cr* stbi__float2fixed(1.40200f);
      g = y_fixed + cr*-stbi__float2fixed(0.71414f) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);
      b = y_fixed                                   +   cb* stbi__float2fixed(1.77200f);
      r >>= 20;
      g >>= 20;
      b >>= 20;
      if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }
      if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }
      if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }
      out[0] = (stbi_uc)r;
      out[1] = (stbi_uc)g;
      out[2] = (stbi_uc)b;
      out[3] = 255;
      out += step;
   }
}","{'begin': {'line': 3686, 'column': 1}, 'end': {'line': 3817, 'column': 2}}",play_bmp_sequence.c,"['使用', 'SIMD', '优化', '将', 'YCbCr', '转换', '为', 'RGB', '，', '适用', '于', '步长', '为', '4', '的', '批量', '处理']"
219,219,stbi__fill_bits,void,void stbi__fill_bits(stbi__zbuf * z),"[{'name': 'z', 'type': 'stbi__zbuf *'}]",填充位缓冲区至足够位数供解码使用,"static void stbi__fill_bits(stbi__zbuf *z)
{
   do {
      if (z->code_buffer >= (1U << z->num_bits)) {
        z->zbuffer = z->zbuffer_end;  /* treat this as EOF so we fail. */
        return;
      }
      z->code_buffer |= (unsigned int) stbi__zget8(z) << z->num_bits;
      z->num_bits += 8;
   } while (z->num_bits <= 24);
}","{'begin': {'line': 4202, 'column': 1}, 'end': {'line': 4212, 'column': 2}}",play_bmp_sequence.c,"['填充', '位', '缓冲', '缓冲区', '至', '足够', '位数', '供', '解码', '使用']"
220,220,stbi__zreceive,unsigned int,"unsigned int stbi__zreceive(stbi__zbuf * z, int n)","[{'name': 'z', 'type': 'stbi__zbuf *'}, {'name': 'n', 'type': 'int'}]",从压缩缓冲区接收指定位数数据,"static unsigned int stbi__zreceive(stbi__zbuf *z, int n)
{
   unsigned int k;
   if (z->num_bits < n) stbi__fill_bits(z);
   k = z->code_buffer & ((1 << n) - 1);
   z->code_buffer >>= n;
   z->num_bits -= n;
   return k;
}","{'begin': {'line': 4214, 'column': 13}, 'end': {'line': 4222, 'column': 2}}",play_bmp_sequence.c,"['从', '压缩', '缓冲', '缓冲区', '接收', '指定', '位数', '数据']"
221,221,stbi__zhuffman_decode_slowpath,int,"int stbi__zhuffman_decode_slowpath(stbi__zbuf * a, stbi__zhuffman * z)","[{'name': 'a', 'type': 'stbi__zbuf *'}, {'name': 'z', 'type': 'stbi__zhuffman *'}]",通过慢速路径解码霍夫曼编码，处理复杂位反转匹配,"static int stbi__zhuffman_decode_slowpath(stbi__zbuf *a, stbi__zhuffman *z)
{
   int b,s,k;
   // not resolved by fast table, so compute it the slow way
   // use jpeg approach, which requires MSbits at top
   k = stbi__bit_reverse(a->code_buffer, 16);
   for (s=STBI__ZFAST_BITS+1; ; ++s)
      if (k < z->maxcode[s])
         break;
   if (s >= 16) return -1; // invalid code!
   // code size is s, so:
   b = (k >> (16-s)) - z->firstcode[s] + z->firstsymbol[s];
   if (b >= STBI__ZNSYMS) return -1; // some data was corrupt somewhere!
   if (z->size[b] != s) return -1;  // was originally an assert, but report failure instead.
   a->code_buffer >>= s;
   a->num_bits -= s;
   return z->value[b];
}","{'begin': {'line': 4224, 'column': 1}, 'end': {'line': 4241, 'column': 2}}",play_bmp_sequence.c,"['通过', '慢速', '路径', '解码', '夫曼', '霍夫曼', '编码', '，', '处理', '复杂', '位', '反转', '匹配']"
222,222,stbi__setup_jpeg,void,void stbi__setup_jpeg(stbi__jpeg * j),"[{'name': 'j', 'type': 'stbi__jpeg *'}]",配置JPEG解码器函数指针，支持SIMD优化,"static void stbi__setup_jpeg(stbi__jpeg *j)
{
   j->idct_block_kernel = stbi__idct_block;
   j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_row;
   j->resample_row_hv_2_kernel = stbi__resample_row_hv_2;

#ifdef STBI_SSE2
   if (stbi__sse2_available()) {
      j->idct_block_kernel = stbi__idct_simd;
      j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
      j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
   }
#endif

#ifdef STBI_NEON
   j->idct_block_kernel = stbi__idct_simd;
   j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
   j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
#endif
}","{'begin': {'line': 3821, 'column': 1}, 'end': {'line': 3840, 'column': 2}}",play_bmp_sequence.c,"['配置', 'JPEG', '解码', '码器', '解码器', '函数', '指针', '函数指针', '，', '支持', 'SIMD', '优化']"
223,223,stbi__zhuffman_decode,int,"int stbi__zhuffman_decode(stbi__zbuf * a, stbi__zhuffman * z)","[{'name': 'a', 'type': 'stbi__zbuf *'}, {'name': 'z', 'type': 'stbi__zhuffman *'}]",使用快速表解码霍夫曼编码数据，若失败则进入慢速路径,"static int stbi__zhuffman_decode(stbi__zbuf *a, stbi__zhuffman *z)
{
   int b,s;
   if (a->num_bits < 16) {
      if (stbi__zeof(a)) {
         if (!a->hit_zeof_once) {
            // This is the first time we hit eof, insert 16 extra padding btis
            // to allow us to keep going; if we actually consume any of them
            // though, that is invalid data. This is caught later.
            a->hit_zeof_once = 1;
            a->num_bits += 16; // add 16 implicit zero bits
         } else {
            // We already inserted our extra 16 padding bits and are again
            // out, this stream is actually prematurely terminated.
            return -1;
         }
      } else {
         stbi__fill_bits(a);
      }
   }
   b = z->fast[a->code_buffer & STBI__ZFAST_MASK];
   if (b) {
      s = b >> 9;
      a->code_buffer >>= s;
      a->num_bits -= s;
      return b & 511;
   }
   return stbi__zhuffman_decode_slowpath(a, z);
}","{'begin': {'line': 4243, 'column': 13}, 'end': {'line': 4271, 'column': 2}}",play_bmp_sequence.c,"['使用', '快速', '表', '解码', '夫曼', '霍夫曼', '编码', '码数', '数据', '编码数据', '，', '若', '失败', '则', '进入', '慢速', '路径']"
224,224,stbi__cleanup_jpeg,void,void stbi__cleanup_jpeg(stbi__jpeg * j),"[{'name': 'j', 'type': 'stbi__jpeg *'}]",释放JPEG解码后的资源,"static void stbi__cleanup_jpeg(stbi__jpeg *j)
{
   stbi__free_jpeg_components(j, j->s->img_n, 0);
}","{'begin': {'line': 3843, 'column': 1}, 'end': {'line': 3846, 'column': 2}}",play_bmp_sequence.c,"['释放', 'JPEG', '解码', '后', '的', '资源']"
225,225,stbi__blinn_8x8,stbi_uc,"stbi_uc stbi__blinn_8x8(stbi_uc x, stbi_uc y)","[{'name': 'x', 'type': 'stbi_uc'}, {'name': 'y', 'type': 'stbi_uc'}]",对两个8位值进行布林式近似乘法运算并调整,"static stbi_uc stbi__blinn_8x8(stbi_uc x, stbi_uc y)
{
   unsigned int t = x*y + 128;
   return (stbi_uc) ((t + (t >>8)) >> 8);
}","{'begin': {'line': 3859, 'column': 1}, 'end': {'line': 3863, 'column': 2}}",play_bmp_sequence.c,"['对', '两个', '8', '位值', '进行', '布林式', '近似', '乘法', '运算', '并', '调整']"
226,226,load_jpeg_image,stbi_uc *,"stbi_uc * load_jpeg_image(stbi__jpeg * z, int * out_x, int * out_y, int * comp, int req_comp)","[{'name': 'z', 'type': 'stbi__jpeg *'}, {'name': 'out_x', 'type': 'int *'}, {'name': 'out_y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",解码JPEG图像并处理颜色空间转换及重采样,"static stbi_uc *load_jpeg_image(stbi__jpeg *z, int *out_x, int *out_y, int *comp, int req_comp)
{
   int n, decode_n, is_rgb;
   z->s->img_n = 0; // make stbi__cleanup_jpeg safe

   // validate req_comp
   if (req_comp < 0 || req_comp > 4) return stbi__errpuc(""bad req_comp"", ""Internal error"");

   // load a jpeg image from whichever source, but leave in YCbCr format
   if (!stbi__decode_jpeg_image(z)) { stbi__cleanup_jpeg(z); return NULL; }

   // determine actual number of components to generate
   n = req_comp ? req_comp : z->s->img_n >= 3 ? 3 : 1;

   is_rgb = z->s->img_n == 3 && (z->rgb == 3 || (z->app14_color_transform == 0 && !z->jfif));

   if (z->s->img_n == 3 && n < 3 && !is_rgb)
      decode_n = 1;
   else
      decode_n = z->s->img_n;

   // nothing to do if no components requested; check this now to avoid
   // accessing uninitialized coutput[0] later
   if (decode_n <= 0) { stbi__cleanup_jpeg(z); return NULL; }

   // resample and color-convert
   {
      int k;
      unsigned int i,j;
      stbi_uc *output;
      stbi_uc *coutput[4] = { NULL, NULL, NULL, NULL };

      stbi__resample res_comp[4];

      for (k=0; k < decode_n; ++k) {
         stbi__resample *r = &res_comp[k];

         // allocate line buffer big enough for upsampling off the edges
         // with upsample factor of 4
         z->img_comp[k].linebuf = (stbi_uc *) stbi__malloc(z->s->img_x + 3);
         if (!z->img_comp[k].linebuf) { stbi__cleanup_jpeg(z); return stbi__errpuc(""outofmem"", ""Out of memory""); }

         r->hs      = z->img_h_max / z->img_comp[k].h;
         r->vs      = z->img_v_max / z->img_comp[k].v;
         r->ystep   = r->vs >> 1;
         r->w_lores = (z->s->img_x + r->hs-1) / r->hs;
         r->ypos    = 0;
         r->line0   = r->line1 = z->img_comp[k].data;

         if      (r->hs == 1 && r->vs == 1) r->resample = resample_row_1;
         else if (r->hs == 1 && r->vs == 2) r->resample = stbi__resample_row_v_2;
         else if (r->hs == 2 && r->vs == 1) r->resample = stbi__resample_row_h_2;
         else if (r->hs == 2 && r->vs == 2) r->resample = z->resample_row_hv_2_kernel;
         else                               r->resample = stbi__resample_row_generic;
      }

      // can't error after this so, this is safe
      output = (stbi_uc *) stbi__malloc_mad3(n, z->s->img_x, z->s->img_y, 1);
      if (!output) { stbi__cleanup_jpeg(z); return stbi__errpuc(""outofmem"", ""Out of memory""); }

      // now go ahead and resample
      for (j=0; j < z->s->img_y; ++j) {
         stbi_uc *out = output + n * z->s->img_x * j;
         for (k=0; k < decode_n; ++k) {
            stbi__resample *r = &res_comp[k];
            int y_bot = r->ystep >= (r->vs >> 1);
            coutput[k] = r->resample(z->img_comp[k].linebuf,
                                     y_bot ? r->line1 : r->line0,
                                     y_bot ? r->line0 : r->line1,
                                     r->w_lores, r->hs);
            if (++r->ystep >= r->vs) {
               r->ystep = 0;
               r->line0 = r->line1;
               if (++r->ypos < z->img_comp[k].y)
                  r->line1 += z->img_comp[k].w2;
            }
         }
         if (n >= 3) {
            stbi_uc *y = coutput[0];
            if (z->s->img_n == 3) {
               if (is_rgb) {
                  for (i=0; i < z->s->img_x; ++i) {
                     out[0] = y[i];
                     out[1] = coutput[1][i];
                     out[2] = coutput[2][i];
                     out[3] = 255;
                     out += n;
                  }
               } else {
                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
               }
            } else if (z->s->img_n == 4) {
               if (z->app14_color_transform == 0) { // CMYK
                  for (i=0; i < z->s->img_x; ++i) {
                     stbi_uc m = coutput[3][i];
                     out[0] = stbi__blinn_8x8(coutput[0][i], m);
                     out[1] = stbi__blinn_8x8(coutput[1][i], m);
                     out[2] = stbi__blinn_8x8(coutput[2][i], m);
                     out[3] = 255;
                     out += n;
                  }
               } else if (z->app14_color_transform == 2) { // YCCK
                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
                  for (i=0; i < z->s->img_x; ++i) {
                     stbi_uc m = coutput[3][i];
                     out[0] = stbi__blinn_8x8(255 - out[0], m);
                     out[1] = stbi__blinn_8x8(255 - out[1], m);
                     out[2] = stbi__blinn_8x8(255 - out[2], m);
                     out += n;
                  }
               } else { // YCbCr + alpha?  Ignore the fourth channel for now
                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
               }
            } else
               for (i=0; i < z->s->img_x; ++i) {
                  out[0] = out[1] = out[2] = y[i];
                  out[3] = 255; // not used if n==3
                  out += n;
               }
         } else {
            if (is_rgb) {
               if (n == 1)
                  for (i=0; i < z->s->img_x; ++i)
                     *out++ = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
               else {
                  for (i=0; i < z->s->img_x; ++i, out += 2) {
                     out[0] = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
                     out[1] = 255;
                  }
               }
            } else if (z->s->img_n == 4 && z->app14_color_transform == 0) {
               for (i=0; i < z->s->img_x; ++i) {
                  stbi_uc m = coutput[3][i];
                  stbi_uc r = stbi__blinn_8x8(coutput[0][i], m);
                  stbi_uc g = stbi__blinn_8x8(coutput[1][i], m);
                  stbi_uc b = stbi__blinn_8x8(coutput[2][i], m);
                  out[0] = stbi__compute_y(r, g, b);
                  out[1] = 255;
                  out += n;
               }
            } else if (z->s->img_n == 4 && z->app14_color_transform == 2) {
               for (i=0; i < z->s->img_x; ++i) {
                  out[0] = stbi__blinn_8x8(255 - coutput[0][i], coutput[3][i]);
                  out[1] = 255;
                  out += n;
               }
            } else {
               stbi_uc *y = coutput[0];
               if (n == 1)
                  for (i=0; i < z->s->img_x; ++i) out[i] = y[i];
               else
                  for (i=0; i < z->s->img_x; ++i) { *out++ = y[i]; *out++ = 255; }
            }
         }
      }
      stbi__cleanup_jpeg(z);
      *out_x = z->s->img_x;
      *out_y = z->s->img_y;
      if (comp) *comp = z->s->img_n >= 3 ? 3 : 1; // report original components, not output
      return output;
   }
}","{'begin': {'line': 3865, 'column': 1}, 'end': {'line': 4026, 'column': 2}}",play_bmp_sequence.c,"['解码', 'JPEG', '图像', '并', '处理', '颜色', '空间', '转换', '及重', '采样']"
227,227,stbi__zexpand,int,"int stbi__zexpand(stbi__zbuf * z, char * zout, int n)","[{'name': 'z', 'type': 'stbi__zbuf *'}, {'name': 'zout', 'type': 'char *'}, {'name': 'n', 'type': 'int'}]",动态扩展输出缓冲区以容纳n字节数据,"static int stbi__zexpand(stbi__zbuf *z, char *zout, int n)  // need to make room for n bytes
{
   char *q;
   unsigned int cur, limit, old_limit;
   z->zout = zout;
   if (!z->z_expandable) return stbi__err(""output buffer limit"",""Corrupt PNG"");
   cur   = (unsigned int) (z->zout - z->zout_start);
   limit = old_limit = (unsigned) (z->zout_end - z->zout_start);
   if (UINT_MAX - cur < (unsigned) n) return stbi__err(""outofmem"", ""Out of memory"");
   while (cur + n > limit) {
      if(limit > UINT_MAX / 2) return stbi__err(""outofmem"", ""Out of memory"");
      limit *= 2;
   }
   q = (char *) STBI_REALLOC_SIZED(z->zout_start, old_limit, limit);
   STBI_NOTUSED(old_limit);
   if (q == NULL) return stbi__err(""outofmem"", ""Out of memory"");
   z->zout_start = q;
   z->zout       = q + cur;
   z->zout_end   = q + limit;
   return 1;
}","{'begin': {'line': 4273, 'column': 1}, 'end': {'line': 4293, 'column': 2}}",play_bmp_sequence.c,"['动态', '扩展', '输出', '缓冲', '缓冲区', '以', '容纳', 'n', '字节', '数据']"
228,228,stbi__parse_huffman_block,int,int stbi__parse_huffman_block(stbi__zbuf * a),"[{'name': 'a', 'type': 'stbi__zbuf *'}]",解析霍夫曼编码块，处理压缩数据及错误检查,"static int stbi__parse_huffman_block(stbi__zbuf *a)
{
   char *zout = a->zout;
   for(;;) {
      int z = stbi__zhuffman_decode(a, &a->z_length);
      if (z < 256) {
         if (z < 0) return stbi__err(""bad huffman code"",""Corrupt PNG""); // error in huffman codes
         if (zout >= a->zout_end) {
            if (!stbi__zexpand(a, zout, 1)) return 0;
            zout = a->zout;
         }
         *zout++ = (char) z;
      } else {
         stbi_uc *p;
         int len,dist;
         if (z == 256) {
            a->zout = zout;
            if (a->hit_zeof_once && a->num_bits < 16) {
               // The first time we hit zeof, we inserted 16 extra zero bits into our bit
               // buffer so the decoder can just do its speculative decoding. But if we
               // actually consumed any of those bits (which is the case when num_bits < 16),
               // the stream actually read past the end so it is malformed.
               return stbi__err(""unexpected end"",""Corrupt PNG"");
            }
            return 1;
         }
         if (z >= 286) return stbi__err(""bad huffman code"",""Corrupt PNG""); // per DEFLATE, length codes 286 and 287 must not appear in compressed data
         z -= 257;
         len = stbi__zlength_base[z];
         if (stbi__zlength_extra[z]) len += stbi__zreceive(a, stbi__zlength_extra[z]);
         z = stbi__zhuffman_decode(a, &a->z_distance);
         if (z < 0 || z >= 30) return stbi__err(""bad huffman code"",""Corrupt PNG""); // per DEFLATE, distance codes 30 and 31 must not appear in compressed data
         dist = stbi__zdist_base[z];
         if (stbi__zdist_extra[z]) dist += stbi__zreceive(a, stbi__zdist_extra[z]);
         if (zout - a->zout_start < dist) return stbi__err(""bad dist"",""Corrupt PNG"");
         if (len > a->zout_end - zout) {
            if (!stbi__zexpand(a, zout, len)) return 0;
            zout = a->zout;
         }
         p = (stbi_uc *) (zout - dist);
         if (dist == 1) { // run of one byte; common in images.
            stbi_uc v = *p;
            if (len) { do *zout++ = v; while (--len); }
         } else {
            if (len) { do *zout++ = *p++; while (--len); }
         }
      }
   }
}","{'begin': {'line': 4309, 'column': 1}, 'end': {'line': 4357, 'column': 2}}",play_bmp_sequence.c,"['解析', '夫曼', '霍夫曼', '编码', '块', '，', '处理', '压缩', '数据', '及', '错误', '检查']"
229,229,stbi__compute_huffman_codes,int,int stbi__compute_huffman_codes(stbi__zbuf * a),"[{'name': 'a', 'type': 'stbi__zbuf *'}]",解析并构建霍夫曼编码表，用于解压缩数据。,"static int stbi__compute_huffman_codes(stbi__zbuf *a)
{
   static const stbi_uc length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };
   stbi__zhuffman z_codelength;
   stbi_uc lencodes[286+32+137];//padding for maximum single op
   stbi_uc codelength_sizes[19];
   int i,n;

   int hlit  = stbi__zreceive(a,5) + 257;
   int hdist = stbi__zreceive(a,5) + 1;
   int hclen = stbi__zreceive(a,4) + 4;
   int ntot  = hlit + hdist;

   memset(codelength_sizes, 0, sizeof(codelength_sizes));
   for (i=0; i < hclen; ++i) {
      int s = stbi__zreceive(a,3);
      codelength_sizes[length_dezigzag[i]] = (stbi_uc) s;
   }
   if (!stbi__zbuild_huffman(&z_codelength, codelength_sizes, 19)) return 0;

   n = 0;
   while (n < ntot) {
      int c = stbi__zhuffman_decode(a, &z_codelength);
      if (c < 0 || c >= 19) return stbi__err(""bad codelengths"", ""Corrupt PNG"");
      if (c < 16)
         lencodes[n++] = (stbi_uc) c;
      else {
         stbi_uc fill = 0;
         if (c == 16) {
            c = stbi__zreceive(a,2)+3;
            if (n == 0) return stbi__err(""bad codelengths"", ""Corrupt PNG"");
            fill = lencodes[n-1];
         } else if (c == 17) {
            c = stbi__zreceive(a,3)+3;
         } else if (c == 18) {
            c = stbi__zreceive(a,7)+11;
         } else {
            return stbi__err(""bad codelengths"", ""Corrupt PNG"");
         }
         if (ntot - n < c) return stbi__err(""bad codelengths"", ""Corrupt PNG"");
         memset(lencodes+n, fill, c);
         n += c;
      }
   }
   if (n != ntot) return stbi__err(""bad codelengths"",""Corrupt PNG"");
   if (!stbi__zbuild_huffman(&a->z_length, lencodes, hlit)) return 0;
   if (!stbi__zbuild_huffman(&a->z_distance, lencodes+hlit, hdist)) return 0;
   return 1;
}","{'begin': {'line': 4359, 'column': 1}, 'end': {'line': 4407, 'column': 2}}",play_bmp_sequence.c,"['解析', '并', '构建', '夫曼', '霍夫曼', '编码', '表', '，', '用于', '解压', '压缩', '解压缩', '数据', '。']"
230,230,stbi__parse_uncompressed_block,int,int stbi__parse_uncompressed_block(stbi__zbuf * a),"[{'name': 'a', 'type': 'stbi__zbuf *'}]",解析并验证未压缩的Zlib数据块,"static int stbi__parse_uncompressed_block(stbi__zbuf *a)
{
   stbi_uc header[4];
   int len,nlen,k;
   if (a->num_bits & 7)
      stbi__zreceive(a, a->num_bits & 7); // discard
   // drain the bit-packed data into header
   k = 0;
   while (a->num_bits > 0) {
      header[k++] = (stbi_uc) (a->code_buffer & 255); // suppress MSVC run-time check
      a->code_buffer >>= 8;
      a->num_bits -= 8;
   }
   if (a->num_bits < 0) return stbi__err(""zlib corrupt"",""Corrupt PNG"");
   // now fill header the normal way
   while (k < 4)
      header[k++] = stbi__zget8(a);
   len  = header[1] * 256 + header[0];
   nlen = header[3] * 256 + header[2];
   if (nlen != (len ^ 0xffff)) return stbi__err(""zlib corrupt"",""Corrupt PNG"");
   if (a->zbuffer + len > a->zbuffer_end) return stbi__err(""read past buffer"",""Corrupt PNG"");
   if (a->zout + len > a->zout_end)
      if (!stbi__zexpand(a, a->zout, len)) return 0;
   memcpy(a->zout, a->zbuffer, len);
   a->zbuffer += len;
   a->zout += len;
   return 1;
}","{'begin': {'line': 4409, 'column': 1}, 'end': {'line': 4436, 'column': 2}}",play_bmp_sequence.c,"['解析', '并', '验证', '未', '压缩', '的', 'Zlib', '数据', '块']"
231,231,stbi__parse_zlib_header,int,int stbi__parse_zlib_header(stbi__zbuf * a),"[{'name': 'a', 'type': 'stbi__zbuf *'}]",解析并验证zlib头是否符合PNG规范,"static int stbi__parse_zlib_header(stbi__zbuf *a)
{
   int cmf   = stbi__zget8(a);
   int cm    = cmf & 15;
   /* int cinfo = cmf >> 4; */
   int flg   = stbi__zget8(a);
   if (stbi__zeof(a)) return stbi__err(""bad zlib header"",""Corrupt PNG""); // zlib spec
   if ((cmf*256+flg) % 31 != 0) return stbi__err(""bad zlib header"",""Corrupt PNG""); // zlib spec
   if (flg & 32) return stbi__err(""no preset dict"",""Corrupt PNG""); // preset dictionary not allowed in png
   if (cm != 8) return stbi__err(""bad compression"",""Corrupt PNG""); // DEFLATE required for png
   // window = 1 << (8 + cinfo)... but who cares, we fully buffer output
   return 1;
}","{'begin': {'line': 4438, 'column': 1}, 'end': {'line': 4450, 'column': 2}}",play_bmp_sequence.c,"['解析', '并', '验证', 'zlib', '头', '是否', '符合', 'PNG', '规范']"
232,232,stbi__jpeg_load,void *,"void * stbi__jpeg_load(stbi__context * s, int * x, int * y, int * comp, int req_comp, stbi__result_info * ri)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'ri', 'type': 'stbi__result_info *'}]",从上下文加载JPEG图像并处理内存分配,"static void *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   unsigned char* result;
   stbi__jpeg* j = (stbi__jpeg*) stbi__malloc(sizeof(stbi__jpeg));
   if (!j) return stbi__errpuc(""outofmem"", ""Out of memory"");
   memset(j, 0, sizeof(stbi__jpeg));
   STBI_NOTUSED(ri);
   j->s = s;
   stbi__setup_jpeg(j);
   result = load_jpeg_image(j, x,y,comp,req_comp);
   STBI_FREE(j);
   return result;
}","{'begin': {'line': 4028, 'column': 1}, 'end': {'line': 4040, 'column': 2}}",play_bmp_sequence.c,"['从', '上下', '下文', '上下文', '加载', 'JPEG', '图像', '并', '处理', '内存', '分配']"
233,233,stbi__jpeg_test,int,int stbi__jpeg_test(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",检测JPEG文件头有效性并返回结果,"static int stbi__jpeg_test(stbi__context *s)
{
   int r;
   stbi__jpeg* j = (stbi__jpeg*)stbi__malloc(sizeof(stbi__jpeg));
   if (!j) return stbi__err(""outofmem"", ""Out of memory"");
   memset(j, 0, sizeof(stbi__jpeg));
   j->s = s;
   stbi__setup_jpeg(j);
   r = stbi__decode_jpeg_header(j, STBI__SCAN_type);
   stbi__rewind(s);
   STBI_FREE(j);
   return r;
}","{'begin': {'line': 4042, 'column': 1}, 'end': {'line': 4054, 'column': 2}}",play_bmp_sequence.c,"['检测', 'JPEG', '文件', '头', '有效', '有效性', '并', '返回', '结果']"
234,234,stbi__jpeg_info_raw,int,"int stbi__jpeg_info_raw(stbi__jpeg * j, int * x, int * y, int * comp)","[{'name': 'j', 'type': 'stbi__jpeg *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",获取JPEG图像的尺寸和通道数,"static int stbi__jpeg_info_raw(stbi__jpeg *j, int *x, int *y, int *comp)
{
   if (!stbi__decode_jpeg_header(j, STBI__SCAN_header)) {
      stbi__rewind( j->s );
      return 0;
   }
   if (x) *x = j->s->img_x;
   if (y) *y = j->s->img_y;
   if (comp) *comp = j->s->img_n >= 3 ? 3 : 1;
   return 1;
}","{'begin': {'line': 4056, 'column': 1}, 'end': {'line': 4066, 'column': 2}}",play_bmp_sequence.c,"['获取', 'JPEG', '图像', '的', '尺寸', '和', '通道', '数']"
235,235,stbi__jpeg_info,int,"int stbi__jpeg_info(stbi__context * s, int * x, int * y, int * comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",获取JPEG图像尺寸和通道数,"static int stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp)
{
   int result;
   stbi__jpeg* j = (stbi__jpeg*) (stbi__malloc(sizeof(stbi__jpeg)));
   if (!j) return stbi__err(""outofmem"", ""Out of memory"");
   memset(j, 0, sizeof(stbi__jpeg));
   j->s = s;
   result = stbi__jpeg_info_raw(j, x, y, comp);
   STBI_FREE(j);
   return result;
}","{'begin': {'line': 4068, 'column': 1}, 'end': {'line': 4078, 'column': 2}}",play_bmp_sequence.c,"['获取', 'JPEG', '图像', '尺寸', '和', '通道', '数']"
236,236,stbi__bitreverse16,int,int stbi__bitreverse16(int n),"[{'name': 'n', 'type': 'int'}]",反转16位整数的位顺序,"static int stbi__bitreverse16(int n)
{
  n = ((n & 0xAAAA) >>  1) | ((n & 0x5555) << 1);
  n = ((n & 0xCCCC) >>  2) | ((n & 0x3333) << 2);
  n = ((n & 0xF0F0) >>  4) | ((n & 0x0F0F) << 4);
  n = ((n & 0xFF00) >>  8) | ((n & 0x00FF) << 8);
  return n;
}","{'begin': {'line': 4107, 'column': 13}, 'end': {'line': 4114, 'column': 2}}",play_bmp_sequence.c,"['反转', '16', '位', '整数', '的', '位', '顺序']"
237,237,stbi__bit_reverse,int,"int stbi__bit_reverse(int v, int bits)","[{'name': 'v', 'type': 'int'}, {'name': 'bits', 'type': 'int'}]",按指定位数反转整数比特值,"static int stbi__bit_reverse(int v, int bits)
{
   STBI_ASSERT(bits <= 16);
   // to bit reverse n bits, reverse 16 and shift
   // e.g. 11 bits, bit reverse and shift away 5
   return stbi__bitreverse16(v) >> (16-bits);
}","{'begin': {'line': 4116, 'column': 13}, 'end': {'line': 4122, 'column': 2}}",play_bmp_sequence.c,"['按', '指定', '位数', '反转', '整数', '比特', '值']"
238,238,stbi__parse_zlib,int,"int stbi__parse_zlib(stbi__zbuf * a, int parse_header)","[{'name': 'a', 'type': 'stbi__zbuf *'}, {'name': 'parse_header', 'type': 'int'}]",解析Zlib数据流，处理压缩块和头部信息,"static int stbi__parse_zlib(stbi__zbuf *a, int parse_header)
{
   int final, type;
   if (parse_header)
      if (!stbi__parse_zlib_header(a)) return 0;
   a->num_bits = 0;
   a->code_buffer = 0;
   a->hit_zeof_once = 0;
   do {
      final = stbi__zreceive(a,1);
      type = stbi__zreceive(a,2);
      if (type == 0) {
         if (!stbi__parse_uncompressed_block(a)) return 0;
      } else if (type == 3) {
         return 0;
      } else {
         if (type == 1) {
            // use fixed code lengths
            if (!stbi__zbuild_huffman(&a->z_length  , stbi__zdefault_length  , STBI__ZNSYMS)) return 0;
            if (!stbi__zbuild_huffman(&a->z_distance, stbi__zdefault_distance,  32)) return 0;
         } else {
            if (!stbi__compute_huffman_codes(a)) return 0;
         }
         if (!stbi__parse_huffman_block(a)) return 0;
      }
   } while (!final);
   return 1;
}","{'begin': {'line': 4481, 'column': 1}, 'end': {'line': 4508, 'column': 2}}",play_bmp_sequence.c,"['解析', 'Zlib', '数据', '数据流', '，', '处理', '压缩', '块', '和', '头部', '信息']"
239,239,stbi__zbuild_huffman,int,"int stbi__zbuild_huffman(stbi__zhuffman * z, const stbi_uc * sizelist, int num)","[{'name': 'z', 'type': 'stbi__zhuffman *'}, {'name': 'sizelist', 'type': 'const stbi_uc *'}, {'name': 'num', 'type': 'int'}]",根据长度列表构建哈夫曼解码表,"static int stbi__zbuild_huffman(stbi__zhuffman *z, const stbi_uc *sizelist, int num)
{
   int i,k=0;
   int code, next_code[16], sizes[17];

   // DEFLATE spec for generating codes
   memset(sizes, 0, sizeof(sizes));
   memset(z->fast, 0, sizeof(z->fast));
   for (i=0; i < num; ++i)
      ++sizes[sizelist[i]];
   sizes[0] = 0;
   for (i=1; i < 16; ++i)
      if (sizes[i] > (1 << i))
         return stbi__err(""bad sizes"", ""Corrupt PNG"");
   code = 0;
   for (i=1; i < 16; ++i) {
      next_code[i] = code;
      z->firstcode[i] = (stbi__uint16) code;
      z->firstsymbol[i] = (stbi__uint16) k;
      code = (code + sizes[i]);
      if (sizes[i])
         if (code-1 >= (1 << i)) return stbi__err(""bad codelengths"",""Corrupt PNG"");
      z->maxcode[i] = code << (16-i); // preshift for inner loop
      code <<= 1;
      k += sizes[i];
   }
   z->maxcode[16] = 0x10000; // sentinel
   for (i=0; i < num; ++i) {
      int s = sizelist[i];
      if (s) {
         int c = next_code[s] - z->firstcode[s] + z->firstsymbol[s];
         stbi__uint16 fastv = (stbi__uint16) ((s << 9) | i);
         z->size [c] = (stbi_uc     ) s;
         z->value[c] = (stbi__uint16) i;
         if (s <= STBI__ZFAST_BITS) {
            int j = stbi__bit_reverse(next_code[s],s);
            while (j < (1 << STBI__ZFAST_BITS)) {
               z->fast[j] = fastv;
               j += (1 << s);
            }
         }
         ++next_code[s];
      }
   }
   return 1;
}","{'begin': {'line': 4124, 'column': 1}, 'end': {'line': 4169, 'column': 2}}",play_bmp_sequence.c,"['根据', '长度', '列表', '构建', '夫曼', '哈夫曼', '解码', '表']"
240,240,stbi__do_zlib,int,"int stbi__do_zlib(stbi__zbuf * a, char * obuf, int olen, int exp, int parse_header)","[{'name': 'a', 'type': 'stbi__zbuf *'}, {'name': 'obuf', 'type': 'char *'}, {'name': 'olen', 'type': 'int'}, {'name': 'exp', 'type': 'int'}, {'name': 'parse_header', 'type': 'int'}]",初始化zlib解析参数并执行解压缩,"static int stbi__do_zlib(stbi__zbuf *a, char *obuf, int olen, int exp, int parse_header)
{
   a->zout_start = obuf;
   a->zout       = obuf;
   a->zout_end   = obuf + olen;
   a->z_expandable = exp;

   return stbi__parse_zlib(a, parse_header);
}","{'begin': {'line': 4510, 'column': 1}, 'end': {'line': 4518, 'column': 2}}",play_bmp_sequence.c,"['初始', '初始化', 'zlib', '解析', '参数', '并', '执行', '解压', '压缩', '解压缩']"
241,241,stbi_zlib_decode_malloc_guesssize,char *,"char * stbi_zlib_decode_malloc_guesssize(const char * buffer, int len, int initial_size, int * outlen)","[{'name': 'buffer', 'type': 'const char *'}, {'name': 'len', 'type': 'int'}, {'name': 'initial_size', 'type': 'int'}, {'name': 'outlen', 'type': 'int *'}]",动态分配内存解压zlib数据，返回结果及长度,"STBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen)
{
   stbi__zbuf a;
   char *p = (char *) stbi__malloc(initial_size);
   if (p == NULL) return NULL;
   a.zbuffer = (stbi_uc *) buffer;
   a.zbuffer_end = (stbi_uc *) buffer + len;
   if (stbi__do_zlib(&a, p, initial_size, 1, 1)) {
      if (outlen) *outlen = (int) (a.zout - a.zout_start);
      return a.zout_start;
   } else {
      STBI_FREE(a.zout_start);
      return NULL;
   }
}","{'begin': {'line': 4520, 'column': 1}, 'end': {'line': 4534, 'column': 2}}",play_bmp_sequence.c,"['动态', '分配', '内存', '分配内存', '解压', 'zlib', '数据', '，', '返回', '结果', '及', '长度']"
242,242,stbi_zlib_decode_malloc,char *,"char * stbi_zlib_decode_malloc(const char * buffer, int len, int * outlen)","[{'name': 'buffer', 'type': 'const char *'}, {'name': 'len', 'type': 'int'}, {'name': 'outlen', 'type': 'int *'}]",解压zlib数据并分配内存,"STBIDEF char *stbi_zlib_decode_malloc(char const *buffer, int len, int *outlen)
{
   return stbi_zlib_decode_malloc_guesssize(buffer, len, 16384, outlen);
}","{'begin': {'line': 4536, 'column': 1}, 'end': {'line': 4539, 'column': 2}}",play_bmp_sequence.c,"['解压', 'zlib', '数据', '并', '分配', '内存', '分配内存']"
243,243,stbi_zlib_decode_malloc_guesssize_headerflag,char *,"char * stbi_zlib_decode_malloc_guesssize_headerflag(const char * buffer, int len, int initial_size, int * outlen, int parse_header)","[{'name': 'buffer', 'type': 'const char *'}, {'name': 'len', 'type': 'int'}, {'name': 'initial_size', 'type': 'int'}, {'name': 'outlen', 'type': 'int *'}, {'name': 'parse_header', 'type': 'int'}]",使用猜测初始尺寸解码zlib数据，可选解析头信息,"STBIDEF char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header)
{
   stbi__zbuf a;
   char *p = (char *) stbi__malloc(initial_size);
   if (p == NULL) return NULL;
   a.zbuffer = (stbi_uc *) buffer;
   a.zbuffer_end = (stbi_uc *) buffer + len;
   if (stbi__do_zlib(&a, p, initial_size, 1, parse_header)) {
      if (outlen) *outlen = (int) (a.zout - a.zout_start);
      return a.zout_start;
   } else {
      STBI_FREE(a.zout_start);
      return NULL;
   }
}","{'begin': {'line': 4541, 'column': 1}, 'end': {'line': 4555, 'column': 2}}",play_bmp_sequence.c,"['使用', '猜测', '初始', '尺寸', '解码', 'zlib', '数据', '，', '可', '选', '解析', '头', '信息']"
244,244,stbi__zeof,int,int stbi__zeof(stbi__zbuf * z),"[{'name': 'z', 'type': 'stbi__zbuf *'}]",检查缓冲区是否读取完毕,"static int stbi__zeof(stbi__zbuf *z)
{
   return (z->zbuffer >= z->zbuffer_end);
}","{'begin': {'line': 4192, 'column': 13}, 'end': {'line': 4195, 'column': 2}}",play_bmp_sequence.c,"['检查', '缓冲', '缓冲区', '是否', '读取', '完毕']"
245,245,stbi__zget8,stbi_uc,stbi_uc stbi__zget8(stbi__zbuf * z),"[{'name': 'z', 'type': 'stbi__zbuf *'}]",从缓冲区读取下一个字节，到达末尾时返回0,"static stbi_uc stbi__zget8(stbi__zbuf *z)
{
   return stbi__zeof(z) ? 0 : *z->zbuffer++;
}","{'begin': {'line': 4197, 'column': 13}, 'end': {'line': 4200, 'column': 2}}",play_bmp_sequence.c,"['从', '缓冲', '缓冲区', '读取', '下', '一个', '字节', '，', '到达', '末尾', '时', '返回', '0']"
246,246,stbi__fill_bits,void,void stbi__fill_bits(stbi__zbuf * z),"[{'name': 'z', 'type': 'stbi__zbuf *'}]",填充位缓冲区以确保足够解码位数,"static void stbi__fill_bits(stbi__zbuf *z)
{
   do {
      if (z->code_buffer >= (1U << z->num_bits)) {
        z->zbuffer = z->zbuffer_end;  /* treat this as EOF so we fail. */
        return;
      }
      z->code_buffer |= (unsigned int) stbi__zget8(z) << z->num_bits;
      z->num_bits += 8;
   } while (z->num_bits <= 24);
}","{'begin': {'line': 4202, 'column': 1}, 'end': {'line': 4212, 'column': 2}}",play_bmp_sequence.c,"['填充', '位', '缓冲', '缓冲区', '以', '确保', '足够', '解码', '位数']"
247,247,stbi_zlib_decode_buffer,int,"int stbi_zlib_decode_buffer(char * obuffer, int olen, const char * ibuffer, int ilen)","[{'name': 'obuffer', 'type': 'char *'}, {'name': 'olen', 'type': 'int'}, {'name': 'ibuffer', 'type': 'const char *'}, {'name': 'ilen', 'type': 'int'}]",解码zlib压缩数据到缓冲区，返回解压后长度或-1,"STBIDEF int stbi_zlib_decode_buffer(char *obuffer, int olen, char const *ibuffer, int ilen)
{
   stbi__zbuf a;
   a.zbuffer = (stbi_uc *) ibuffer;
   a.zbuffer_end = (stbi_uc *) ibuffer + ilen;
   if (stbi__do_zlib(&a, obuffer, olen, 0, 1))
      return (int) (a.zout - a.zout_start);
   else
      return -1;
}","{'begin': {'line': 4557, 'column': 1}, 'end': {'line': 4566, 'column': 2}}",play_bmp_sequence.c,"['解码', 'zlib', '压缩', '数据', '到', '缓冲', '缓冲区', '，', '返回', '解压', '后', '长度', '或', '-', '1']"
248,248,stbi__zreceive,unsigned int,"unsigned int stbi__zreceive(stbi__zbuf * z, int n)","[{'name': 'z', 'type': 'stbi__zbuf *'}, {'name': 'n', 'type': 'int'}]",从压缩缓冲区接收n位数据,"static unsigned int stbi__zreceive(stbi__zbuf *z, int n)
{
   unsigned int k;
   if (z->num_bits < n) stbi__fill_bits(z);
   k = z->code_buffer & ((1 << n) - 1);
   z->code_buffer >>= n;
   z->num_bits -= n;
   return k;
}","{'begin': {'line': 4214, 'column': 13}, 'end': {'line': 4222, 'column': 2}}",play_bmp_sequence.c,"['从', '压缩', '缓冲', '缓冲区', '接收', 'n', '位', '数据']"
249,249,stbi_zlib_decode_noheader_malloc,char *,"char * stbi_zlib_decode_noheader_malloc(const char * buffer, int len, int * outlen)","[{'name': 'buffer', 'type': 'const char *'}, {'name': 'len', 'type': 'int'}, {'name': 'outlen', 'type': 'int *'}]",无头zlib解压至动态分配内存,"STBIDEF char *stbi_zlib_decode_noheader_malloc(char const *buffer, int len, int *outlen)
{
   stbi__zbuf a;
   char *p = (char *) stbi__malloc(16384);
   if (p == NULL) return NULL;
   a.zbuffer = (stbi_uc *) buffer;
   a.zbuffer_end = (stbi_uc *) buffer+len;
   if (stbi__do_zlib(&a, p, 16384, 1, 0)) {
      if (outlen) *outlen = (int) (a.zout - a.zout_start);
      return a.zout_start;
   } else {
      STBI_FREE(a.zout_start);
      return NULL;
   }
}","{'begin': {'line': 4568, 'column': 1}, 'end': {'line': 4582, 'column': 2}}",play_bmp_sequence.c,"['无头', 'zlib', '解压', '至', '动态', '分配', '内存', '分配内存']"
250,250,stbi__zhuffman_decode_slowpath,int,"int stbi__zhuffman_decode_slowpath(stbi__zbuf * a, stbi__zhuffman * z)","[{'name': 'a', 'type': 'stbi__zbuf *'}, {'name': 'z', 'type': 'stbi__zhuffman *'}]",处理霍夫曼解码慢速路径,"static int stbi__zhuffman_decode_slowpath(stbi__zbuf *a, stbi__zhuffman *z)
{
   int b,s,k;
   // not resolved by fast table, so compute it the slow way
   // use jpeg approach, which requires MSbits at top
   k = stbi__bit_reverse(a->code_buffer, 16);
   for (s=STBI__ZFAST_BITS+1; ; ++s)
      if (k < z->maxcode[s])
         break;
   if (s >= 16) return -1; // invalid code!
   // code size is s, so:
   b = (k >> (16-s)) - z->firstcode[s] + z->firstsymbol[s];
   if (b >= STBI__ZNSYMS) return -1; // some data was corrupt somewhere!
   if (z->size[b] != s) return -1;  // was originally an assert, but report failure instead.
   a->code_buffer >>= s;
   a->num_bits -= s;
   return z->value[b];
}","{'begin': {'line': 4224, 'column': 1}, 'end': {'line': 4241, 'column': 2}}",play_bmp_sequence.c,"['处理', '夫曼', '霍夫曼', '解码', '慢速', '路径']"
251,251,stbi_zlib_decode_noheader_buffer,int,"int stbi_zlib_decode_noheader_buffer(char * obuffer, int olen, const char * ibuffer, int ilen)","[{'name': 'obuffer', 'type': 'char *'}, {'name': 'olen', 'type': 'int'}, {'name': 'ibuffer', 'type': 'const char *'}, {'name': 'ilen', 'type': 'int'}]",解压无头zlib数据，返回解压后长度或错误,"STBIDEF int stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen)
{
   stbi__zbuf a;
   a.zbuffer = (stbi_uc *) ibuffer;
   a.zbuffer_end = (stbi_uc *) ibuffer + ilen;
   if (stbi__do_zlib(&a, obuffer, olen, 0, 0))
      return (int) (a.zout - a.zout_start);
   else
      return -1;
}","{'begin': {'line': 4584, 'column': 1}, 'end': {'line': 4593, 'column': 2}}",play_bmp_sequence.c,"['解压', '无头', 'zlib', '数据', '，', '返回', '解压', '后', '长度', '或', '错误']"
252,252,stbi__get_chunk_header,stbi__pngchunk,stbi__pngchunk stbi__get_chunk_header(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",读取PNG文件的块头部信息（长度和类型）,"static stbi__pngchunk stbi__get_chunk_header(stbi__context *s)
{
   stbi__pngchunk c;
   c.length = stbi__get32be(s);
   c.type   = stbi__get32be(s);
   return c;
}","{'begin': {'line': 4613, 'column': 1}, 'end': {'line': 4619, 'column': 2}}",play_bmp_sequence.c,"['读取', 'PNG', '文件', '的', '块', '头部', '信息', '（', '长度', '和', '类型', '）']"
253,253,stbi__zhuffman_decode,int,"int stbi__zhuffman_decode(stbi__zbuf * a, stbi__zhuffman * z)","[{'name': 'a', 'type': 'stbi__zbuf *'}, {'name': 'z', 'type': 'stbi__zhuffman *'}]",使用快速查表解码霍夫曼编码，不足时调用慢路径处理,"static int stbi__zhuffman_decode(stbi__zbuf *a, stbi__zhuffman *z)
{
   int b,s;
   if (a->num_bits < 16) {
      if (stbi__zeof(a)) {
         if (!a->hit_zeof_once) {
            // This is the first time we hit eof, insert 16 extra padding btis
            // to allow us to keep going; if we actually consume any of them
            // though, that is invalid data. This is caught later.
            a->hit_zeof_once = 1;
            a->num_bits += 16; // add 16 implicit zero bits
         } else {
            // We already inserted our extra 16 padding bits and are again
            // out, this stream is actually prematurely terminated.
            return -1;
         }
      } else {
         stbi__fill_bits(a);
      }
   }
   b = z->fast[a->code_buffer & STBI__ZFAST_MASK];
   if (b) {
      s = b >> 9;
      a->code_buffer >>= s;
      a->num_bits -= s;
      return b & 511;
   }
   return stbi__zhuffman_decode_slowpath(a, z);
}","{'begin': {'line': 4243, 'column': 13}, 'end': {'line': 4271, 'column': 2}}",play_bmp_sequence.c,"['使用', '快', '速查', '查表', '速查表', '解码', '夫曼', '霍夫曼', '编码', '，', '不足', '时', '调用', '慢', '路径', '处理']"
254,254,stbi__check_png_header,int,int stbi__check_png_header(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",验证输入流是否为有效的PNG文件头,"static int stbi__check_png_header(stbi__context *s)
{
   static const stbi_uc png_sig[8] = { 137,80,78,71,13,10,26,10 };
   int i;
   for (i=0; i < 8; ++i)
      if (stbi__get8(s) != png_sig[i]) return stbi__err(""bad png sig"",""Not a PNG"");
   return 1;
}","{'begin': {'line': 4621, 'column': 1}, 'end': {'line': 4628, 'column': 2}}",play_bmp_sequence.c,"['验证', '输入', '流', '是否', '为', '有效', '的', 'PNG', '文件', '头']"
255,255,stbi__paeth,int,"int stbi__paeth(int a, int b, int c)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}, {'name': 'c', 'type': 'int'}]",实现优化的Paeth预测器算法,"static int stbi__paeth(int a, int b, int c)
{
   // This formulation looks very different from the reference in the PNG spec, but is
   // actually equivalent and has favorable data dependencies and admits straightforward
   // generation of branch-free code, which helps performance significantly.
   int thresh = c*3 - (a + b);
   int lo = a < b ? a : b;
   int hi = a < b ? b : a;
   int t0 = (hi <= thresh) ? lo : c;
   int t1 = (thresh <= lo) ? hi : t0;
   return t1;
}","{'begin': {'line': 4657, 'column': 1}, 'end': {'line': 4668, 'column': 2}}",play_bmp_sequence.c,"['实现', '优化', '的', 'Paeth', '预测', '测器', '预测器', '算法']"
256,256,stbi__zexpand,int,"int stbi__zexpand(stbi__zbuf * z, char * zout, int n)","[{'name': 'z', 'type': 'stbi__zbuf *'}, {'name': 'zout', 'type': 'char *'}, {'name': 'n', 'type': 'int'}]",动态扩展输出缓冲区以适应n字节需求,"static int stbi__zexpand(stbi__zbuf *z, char *zout, int n)  // need to make room for n bytes
{
   char *q;
   unsigned int cur, limit, old_limit;
   z->zout = zout;
   if (!z->z_expandable) return stbi__err(""output buffer limit"",""Corrupt PNG"");
   cur   = (unsigned int) (z->zout - z->zout_start);
   limit = old_limit = (unsigned) (z->zout_end - z->zout_start);
   if (UINT_MAX - cur < (unsigned) n) return stbi__err(""outofmem"", ""Out of memory"");
   while (cur + n > limit) {
      if(limit > UINT_MAX / 2) return stbi__err(""outofmem"", ""Out of memory"");
      limit *= 2;
   }
   q = (char *) STBI_REALLOC_SIZED(z->zout_start, old_limit, limit);
   STBI_NOTUSED(old_limit);
   if (q == NULL) return stbi__err(""outofmem"", ""Out of memory"");
   z->zout_start = q;
   z->zout       = q + cur;
   z->zout_end   = q + limit;
   return 1;
}","{'begin': {'line': 4273, 'column': 1}, 'end': {'line': 4293, 'column': 2}}",play_bmp_sequence.c,"['动态', '扩展', '输出', '缓冲', '缓冲区', '以', '适应', 'n', '字节', '需求']"
257,257,stbi__create_png_alpha_expand8,void,"void stbi__create_png_alpha_expand8(stbi_uc * dest, stbi_uc * src, stbi__uint32 x, int img_n)","[{'name': 'dest', 'type': 'stbi_uc *'}, {'name': 'src', 'type': 'stbi_uc *'}, {'name': 'x', 'type': 'stbi__uint32'}, {'name': 'img_n', 'type': 'int'}]",根据输入通道数扩展像素数据并添加全透明Alpha通道,"static void stbi__create_png_alpha_expand8(stbi_uc *dest, stbi_uc *src, stbi__uint32 x, int img_n)
{
   int i;
   // must process data backwards since we allow dest==src
   if (img_n == 1) {
      for (i=x-1; i >= 0; --i) {
         dest[i*2+1] = 255;
         dest[i*2+0] = src[i];
      }
   } else {
      STBI_ASSERT(img_n == 3);
      for (i=x-1; i >= 0; --i) {
         dest[i*4+3] = 255;
         dest[i*4+2] = src[i*3+2];
         dest[i*4+1] = src[i*3+1];
         dest[i*4+0] = src[i*3+0];
      }
   }
}","{'begin': {'line': 4675, 'column': 1}, 'end': {'line': 4693, 'column': 2}}",play_bmp_sequence.c,"['根据', '输入', '通道', '数', '扩展', '像素', '数据', '并', '添加', '透明', '全透明', 'Alpha', '通道']"
258,258,stbi__parse_huffman_block,int,int stbi__parse_huffman_block(stbi__zbuf * a),"[{'name': 'a', 'type': 'stbi__zbuf *'}]",解析Huffman压缩块数据并处理错误,"static int stbi__parse_huffman_block(stbi__zbuf *a)
{
   char *zout = a->zout;
   for(;;) {
      int z = stbi__zhuffman_decode(a, &a->z_length);
      if (z < 256) {
         if (z < 0) return stbi__err(""bad huffman code"",""Corrupt PNG""); // error in huffman codes
         if (zout >= a->zout_end) {
            if (!stbi__zexpand(a, zout, 1)) return 0;
            zout = a->zout;
         }
         *zout++ = (char) z;
      } else {
         stbi_uc *p;
         int len,dist;
         if (z == 256) {
            a->zout = zout;
            if (a->hit_zeof_once && a->num_bits < 16) {
               // The first time we hit zeof, we inserted 16 extra zero bits into our bit
               // buffer so the decoder can just do its speculative decoding. But if we
               // actually consumed any of those bits (which is the case when num_bits < 16),
               // the stream actually read past the end so it is malformed.
               return stbi__err(""unexpected end"",""Corrupt PNG"");
            }
            return 1;
         }
         if (z >= 286) return stbi__err(""bad huffman code"",""Corrupt PNG""); // per DEFLATE, length codes 286 and 287 must not appear in compressed data
         z -= 257;
         len = stbi__zlength_base[z];
         if (stbi__zlength_extra[z]) len += stbi__zreceive(a, stbi__zlength_extra[z]);
         z = stbi__zhuffman_decode(a, &a->z_distance);
         if (z < 0 || z >= 30) return stbi__err(""bad huffman code"",""Corrupt PNG""); // per DEFLATE, distance codes 30 and 31 must not appear in compressed data
         dist = stbi__zdist_base[z];
         if (stbi__zdist_extra[z]) dist += stbi__zreceive(a, stbi__zdist_extra[z]);
         if (zout - a->zout_start < dist) return stbi__err(""bad dist"",""Corrupt PNG"");
         if (len > a->zout_end - zout) {
            if (!stbi__zexpand(a, zout, len)) return 0;
            zout = a->zout;
         }
         p = (stbi_uc *) (zout - dist);
         if (dist == 1) { // run of one byte; common in images.
            stbi_uc v = *p;
            if (len) { do *zout++ = v; while (--len); }
         } else {
            if (len) { do *zout++ = *p++; while (--len); }
         }
      }
   }
}","{'begin': {'line': 4309, 'column': 1}, 'end': {'line': 4357, 'column': 2}}",play_bmp_sequence.c,"['解析', 'Huffman', '压缩', '块', '数据', '并', '处理', '错误', '处理错误']"
259,259,stbi__create_png_image_raw,int,"int stbi__create_png_image_raw(stbi__png * a, stbi_uc * raw, stbi__uint32 raw_len, int out_n, stbi__uint32 x, stbi__uint32 y, int depth, int color)","[{'name': 'a', 'type': 'stbi__png *'}, {'name': 'raw', 'type': 'stbi_uc *'}, {'name': 'raw_len', 'type': 'stbi__uint32'}, {'name': 'out_n', 'type': 'int'}, {'name': 'x', 'type': 'stbi__uint32'}, {'name': 'y', 'type': 'stbi__uint32'}, {'name': 'depth', 'type': 'int'}, {'name': 'color', 'type': 'int'}]",解码PNG原始数据，应用过滤处理,"static int stbi__create_png_image_raw(stbi__png *a, stbi_uc *raw, stbi__uint32 raw_len, int out_n, stbi__uint32 x, stbi__uint32 y, int depth, int color)
{
   int bytes = (depth == 16 ? 2 : 1);
   stbi__context *s = a->s;
   stbi__uint32 i,j,stride = x*out_n*bytes;
   stbi__uint32 img_len, img_width_bytes;
   stbi_uc *filter_buf;
   int all_ok = 1;
   int k;
   int img_n = s->img_n; // copy it into a local for later

   int output_bytes = out_n*bytes;
   int filter_bytes = img_n*bytes;
   int width = x;

   STBI_ASSERT(out_n == s->img_n || out_n == s->img_n+1);
   a->out = (stbi_uc *) stbi__malloc_mad3(x, y, output_bytes, 0); // extra bytes to write off the end into
   if (!a->out) return stbi__err(""outofmem"", ""Out of memory"");

   // note: error exits here don't need to clean up a->out individually,
   // stbi__do_png always does on error.
   if (!stbi__mad3sizes_valid(img_n, x, depth, 7)) return stbi__err(""too large"", ""Corrupt PNG"");
   img_width_bytes = (((img_n * x * depth) + 7) >> 3);
   if (!stbi__mad2sizes_valid(img_width_bytes, y, img_width_bytes)) return stbi__err(""too large"", ""Corrupt PNG"");
   img_len = (img_width_bytes + 1) * y;

   // we used to check for exact match between raw_len and img_len on non-interlaced PNGs,
   // but issue #276 reported a PNG in the wild that had extra data at the end (all zeros),
   // so just check for raw_len < img_len always.
   if (raw_len < img_len) return stbi__err(""not enough pixels"",""Corrupt PNG"");

   // Allocate two scan lines worth of filter workspace buffer.
   filter_buf = (stbi_uc *) stbi__malloc_mad2(img_width_bytes, 2, 0);
   if (!filter_buf) return stbi__err(""outofmem"", ""Out of memory"");

   // Filtering for low-bit-depth images
   if (depth < 8) {
      filter_bytes = 1;
      width = img_width_bytes;
   }

   for (j=0; j < y; ++j) {
      // cur/prior filter buffers alternate
      stbi_uc *cur = filter_buf + (j & 1)*img_width_bytes;
      stbi_uc *prior = filter_buf + (~j & 1)*img_width_bytes;
      stbi_uc *dest = a->out + stride*j;
      int nk = width * filter_bytes;
      int filter = *raw++;

      // check filter type
      if (filter > 4) {
         all_ok = stbi__err(""invalid filter"",""Corrupt PNG"");
         break;
      }

      // if first row, use special filter that doesn't sample previous row
      if (j == 0) filter = first_row_filter[filter];

      // perform actual filtering
      switch (filter) {
      case STBI__F_none:
         memcpy(cur, raw, nk);
         break;
      case STBI__F_sub:
         memcpy(cur, raw, filter_bytes);
         for (k = filter_bytes; k < nk; ++k)
            cur[k] = STBI__BYTECAST(raw[k] + cur[k-filter_bytes]);
         break;
      case STBI__F_up:
         for (k = 0; k < nk; ++k)
            cur[k] = STBI__BYTECAST(raw[k] + prior[k]);
         break;
      case STBI__F_avg:
         for (k = 0; k < filter_bytes; ++k)
            cur[k] = STBI__BYTECAST(raw[k] + (prior[k]>>1));
         for (k = filter_bytes; k < nk; ++k)
            cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k-filter_bytes])>>1));
         break;
      case STBI__F_paeth:
         for (k = 0; k < filter_bytes; ++k)
            cur[k] = STBI__BYTECAST(raw[k] + prior[k]); // prior[k] == stbi__paeth(0,prior[k],0)
         for (k = filter_bytes; k < nk; ++k)
            cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes], prior[k], prior[k-filter_bytes]));
         break;
      case STBI__F_avg_first:
         memcpy(cur, raw, filter_bytes);
         for (k = filter_bytes; k < nk; ++k)
            cur[k] = STBI__BYTECAST(raw[k] + (cur[k-filter_bytes] >> 1));
         break;
      }

      raw += nk;

      // expand decoded bits in cur to dest, also adding an extra alpha channel if desired
      if (depth < 8) {
         stbi_uc scale = (color == 0) ? stbi__depth_scale_table[depth] : 1; // scale grayscale values to 0..255 range
         stbi_uc *in = cur;
         stbi_uc *out = dest;
         stbi_uc inb = 0;
         stbi__uint32 nsmp = x*img_n;

         // expand bits to bytes first
         if (depth == 4) {
            for (i=0; i < nsmp; ++i) {
               if ((i & 1) == 0) inb = *in++;
               *out++ = scale * (inb >> 4);
               inb <<= 4;
            }
         } else if (depth == 2) {
            for (i=0; i < nsmp; ++i) {
               if ((i & 3) == 0) inb = *in++;
               *out++ = scale * (inb >> 6);
               inb <<= 2;
            }
         } else {
            STBI_ASSERT(depth == 1);
            for (i=0; i < nsmp; ++i) {
               if ((i & 7) == 0) inb = *in++;
               *out++ = scale * (inb >> 7);
               inb <<= 1;
            }
         }

         // insert alpha=255 values if desired
         if (img_n != out_n)
            stbi__create_png_alpha_expand8(dest, dest, x, img_n);
      } else if (depth == 8) {
         if (img_n == out_n)
            memcpy(dest, cur, x*img_n);
         else
            stbi__create_png_alpha_expand8(dest, cur, x, img_n);
      } else if (depth == 16) {
         // convert the image data from big-endian to platform-native
         stbi__uint16 *dest16 = (stbi__uint16*)dest;
         stbi__uint32 nsmp = x*img_n;

         if (img_n == out_n) {
            for (i = 0; i < nsmp; ++i, ++dest16, cur += 2)
               *dest16 = (cur[0] << 8) | cur[1];
         } else {
            STBI_ASSERT(img_n+1 == out_n);
            if (img_n == 1) {
               for (i = 0; i < x; ++i, dest16 += 2, cur += 2) {
                  dest16[0] = (cur[0] << 8) | cur[1];
                  dest16[1] = 0xffff;
               }
            } else {
               STBI_ASSERT(img_n == 3);
               for (i = 0; i < x; ++i, dest16 += 4, cur += 6) {
                  dest16[0] = (cur[0] << 8) | cur[1];
                  dest16[1] = (cur[2] << 8) | cur[3];
                  dest16[2] = (cur[4] << 8) | cur[5];
                  dest16[3] = 0xffff;
               }
            }
         }
      }
   }

   STBI_FREE(filter_buf);
   if (!all_ok) return 0;

   return 1;
}","{'begin': {'line': 4696, 'column': 1}, 'end': {'line': 4859, 'column': 2}}",play_bmp_sequence.c,"['解码', 'PNG', '原始', '数据', '原始数据', '，', '应用', '过滤', '处理']"
260,260,stbi__compute_huffman_codes,int,int stbi__compute_huffman_codes(stbi__zbuf * a),"[{'name': 'a', 'type': 'stbi__zbuf *'}]",解码并构建哈夫曼编码表，用于压缩数据解析,"static int stbi__compute_huffman_codes(stbi__zbuf *a)
{
   static const stbi_uc length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };
   stbi__zhuffman z_codelength;
   stbi_uc lencodes[286+32+137];//padding for maximum single op
   stbi_uc codelength_sizes[19];
   int i,n;

   int hlit  = stbi__zreceive(a,5) + 257;
   int hdist = stbi__zreceive(a,5) + 1;
   int hclen = stbi__zreceive(a,4) + 4;
   int ntot  = hlit + hdist;

   memset(codelength_sizes, 0, sizeof(codelength_sizes));
   for (i=0; i < hclen; ++i) {
      int s = stbi__zreceive(a,3);
      codelength_sizes[length_dezigzag[i]] = (stbi_uc) s;
   }
   if (!stbi__zbuild_huffman(&z_codelength, codelength_sizes, 19)) return 0;

   n = 0;
   while (n < ntot) {
      int c = stbi__zhuffman_decode(a, &z_codelength);
      if (c < 0 || c >= 19) return stbi__err(""bad codelengths"", ""Corrupt PNG"");
      if (c < 16)
         lencodes[n++] = (stbi_uc) c;
      else {
         stbi_uc fill = 0;
         if (c == 16) {
            c = stbi__zreceive(a,2)+3;
            if (n == 0) return stbi__err(""bad codelengths"", ""Corrupt PNG"");
            fill = lencodes[n-1];
         } else if (c == 17) {
            c = stbi__zreceive(a,3)+3;
         } else if (c == 18) {
            c = stbi__zreceive(a,7)+11;
         } else {
            return stbi__err(""bad codelengths"", ""Corrupt PNG"");
         }
         if (ntot - n < c) return stbi__err(""bad codelengths"", ""Corrupt PNG"");
         memset(lencodes+n, fill, c);
         n += c;
      }
   }
   if (n != ntot) return stbi__err(""bad codelengths"",""Corrupt PNG"");
   if (!stbi__zbuild_huffman(&a->z_length, lencodes, hlit)) return 0;
   if (!stbi__zbuild_huffman(&a->z_distance, lencodes+hlit, hdist)) return 0;
   return 1;
}","{'begin': {'line': 4359, 'column': 1}, 'end': {'line': 4407, 'column': 2}}",play_bmp_sequence.c,"['解码', '并', '构建', '夫曼', '哈夫曼', '编码', '表', '，', '用于', '压缩', '数据', '解析']"
261,261,stbi__parse_uncompressed_block,int,int stbi__parse_uncompressed_block(stbi__zbuf * a),"[{'name': 'a', 'type': 'stbi__zbuf *'}]",解析未压缩的Zlib数据块并验证长度,"static int stbi__parse_uncompressed_block(stbi__zbuf *a)
{
   stbi_uc header[4];
   int len,nlen,k;
   if (a->num_bits & 7)
      stbi__zreceive(a, a->num_bits & 7); // discard
   // drain the bit-packed data into header
   k = 0;
   while (a->num_bits > 0) {
      header[k++] = (stbi_uc) (a->code_buffer & 255); // suppress MSVC run-time check
      a->code_buffer >>= 8;
      a->num_bits -= 8;
   }
   if (a->num_bits < 0) return stbi__err(""zlib corrupt"",""Corrupt PNG"");
   // now fill header the normal way
   while (k < 4)
      header[k++] = stbi__zget8(a);
   len  = header[1] * 256 + header[0];
   nlen = header[3] * 256 + header[2];
   if (nlen != (len ^ 0xffff)) return stbi__err(""zlib corrupt"",""Corrupt PNG"");
   if (a->zbuffer + len > a->zbuffer_end) return stbi__err(""read past buffer"",""Corrupt PNG"");
   if (a->zout + len > a->zout_end)
      if (!stbi__zexpand(a, a->zout, len)) return 0;
   memcpy(a->zout, a->zbuffer, len);
   a->zbuffer += len;
   a->zout += len;
   return 1;
}","{'begin': {'line': 4409, 'column': 1}, 'end': {'line': 4436, 'column': 2}}",play_bmp_sequence.c,"['解析', '未', '压缩', '的', 'Zlib', '数据', '块', '并', '验证', '长度']"
262,262,stbi__parse_zlib_header,int,int stbi__parse_zlib_header(stbi__zbuf * a),"[{'name': 'a', 'type': 'stbi__zbuf *'}]",解析并验证zlib头部有效性，用于PNG处理,"static int stbi__parse_zlib_header(stbi__zbuf *a)
{
   int cmf   = stbi__zget8(a);
   int cm    = cmf & 15;
   /* int cinfo = cmf >> 4; */
   int flg   = stbi__zget8(a);
   if (stbi__zeof(a)) return stbi__err(""bad zlib header"",""Corrupt PNG""); // zlib spec
   if ((cmf*256+flg) % 31 != 0) return stbi__err(""bad zlib header"",""Corrupt PNG""); // zlib spec
   if (flg & 32) return stbi__err(""no preset dict"",""Corrupt PNG""); // preset dictionary not allowed in png
   if (cm != 8) return stbi__err(""bad compression"",""Corrupt PNG""); // DEFLATE required for png
   // window = 1 << (8 + cinfo)... but who cares, we fully buffer output
   return 1;
}","{'begin': {'line': 4438, 'column': 1}, 'end': {'line': 4450, 'column': 2}}",play_bmp_sequence.c,"['解析', '并', '验证', 'zlib', '头部', '有效', '有效性', '，', '用于', 'PNG', '处理']"
263,263,stbi__create_png_image,int,"int stbi__create_png_image(stbi__png * a, stbi_uc * image_data, stbi__uint32 image_data_len, int out_n, int depth, int color, int interlaced)","[{'name': 'a', 'type': 'stbi__png *'}, {'name': 'image_data', 'type': 'stbi_uc *'}, {'name': 'image_data_len', 'type': 'stbi__uint32'}, {'name': 'out_n', 'type': 'int'}, {'name': 'depth', 'type': 'int'}, {'name': 'color', 'type': 'int'}, {'name': 'interlaced', 'type': 'int'}]",生成PNG图像数据，处理隔行扫描解码,"static int stbi__create_png_image(stbi__png *a, stbi_uc *image_data, stbi__uint32 image_data_len, int out_n, int depth, int color, int interlaced)
{
   int bytes = (depth == 16 ? 2 : 1);
   int out_bytes = out_n * bytes;
   stbi_uc *final;
   int p;
   if (!interlaced)
      return stbi__create_png_image_raw(a, image_data, image_data_len, out_n, a->s->img_x, a->s->img_y, depth, color);

   // de-interlacing
   final = (stbi_uc *) stbi__malloc_mad3(a->s->img_x, a->s->img_y, out_bytes, 0);
   if (!final) return stbi__err(""outofmem"", ""Out of memory"");
   for (p=0; p < 7; ++p) {
      int xorig[] = { 0,4,0,2,0,1,0 };
      int yorig[] = { 0,0,4,0,2,0,1 };
      int xspc[]  = { 8,8,4,4,2,2,1 };
      int yspc[]  = { 8,8,8,4,4,2,2 };
      int i,j,x,y;
      // pass1_x[4] = 0, pass1_x[5] = 1, pass1_x[12] = 1
      x = (a->s->img_x - xorig[p] + xspc[p]-1) / xspc[p];
      y = (a->s->img_y - yorig[p] + yspc[p]-1) / yspc[p];
      if (x && y) {
         stbi__uint32 img_len = ((((a->s->img_n * x * depth) + 7) >> 3) + 1) * y;
         if (!stbi__create_png_image_raw(a, image_data, image_data_len, out_n, x, y, depth, color)) {
            STBI_FREE(final);
            return 0;
         }
         for (j=0; j < y; ++j) {
            for (i=0; i < x; ++i) {
               int out_y = j*yspc[p]+yorig[p];
               int out_x = i*xspc[p]+xorig[p];
               memcpy(final + out_y*a->s->img_x*out_bytes + out_x*out_bytes,
                      a->out + (j*x+i)*out_bytes, out_bytes);
            }
         }
         STBI_FREE(a->out);
         image_data += img_len;
         image_data_len -= img_len;
      }
   }
   a->out = final;

   return 1;
}","{'begin': {'line': 4861, 'column': 1}, 'end': {'line': 4904, 'column': 2}}",play_bmp_sequence.c,"['生成', 'PNG', '图像', '数据', '，', '处理', '隔行', '扫描', '隔行扫描', '解码']"
264,264,stbi__parse_zlib,int,"int stbi__parse_zlib(stbi__zbuf * a, int parse_header)","[{'name': 'a', 'type': 'stbi__zbuf *'}, {'name': 'parse_header', 'type': 'int'}]",解析zlib数据流，处理头部和压缩块,"static int stbi__parse_zlib(stbi__zbuf *a, int parse_header)
{
   int final, type;
   if (parse_header)
      if (!stbi__parse_zlib_header(a)) return 0;
   a->num_bits = 0;
   a->code_buffer = 0;
   a->hit_zeof_once = 0;
   do {
      final = stbi__zreceive(a,1);
      type = stbi__zreceive(a,2);
      if (type == 0) {
         if (!stbi__parse_uncompressed_block(a)) return 0;
      } else if (type == 3) {
         return 0;
      } else {
         if (type == 1) {
            // use fixed code lengths
            if (!stbi__zbuild_huffman(&a->z_length  , stbi__zdefault_length  , STBI__ZNSYMS)) return 0;
            if (!stbi__zbuild_huffman(&a->z_distance, stbi__zdefault_distance,  32)) return 0;
         } else {
            if (!stbi__compute_huffman_codes(a)) return 0;
         }
         if (!stbi__parse_huffman_block(a)) return 0;
      }
   } while (!final);
   return 1;
}","{'begin': {'line': 4481, 'column': 1}, 'end': {'line': 4508, 'column': 2}}",play_bmp_sequence.c,"['解析', 'zlib', '数据', '数据流', '，', '处理', '头部', '和', '压缩', '块']"
265,265,stbi__compute_transparency,int,"int stbi__compute_transparency(stbi__png * z, stbi_uc[3] tc, int out_n)","[{'name': 'z', 'type': 'stbi__png *'}, {'name': 'tc', 'type': 'stbi_uc[3]'}, {'name': 'out_n', 'type': 'int'}]",根据颜色值计算并设置图像透明通道,"static int stbi__compute_transparency(stbi__png *z, stbi_uc tc[3], int out_n)
{
   stbi__context *s = z->s;
   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
   stbi_uc *p = z->out;

   // compute color-based transparency, assuming we've
   // already got 255 as the alpha value in the output
   STBI_ASSERT(out_n == 2 || out_n == 4);

   if (out_n == 2) {
      for (i=0; i < pixel_count; ++i) {
         p[1] = (p[0] == tc[0] ? 0 : 255);
         p += 2;
      }
   } else {
      for (i=0; i < pixel_count; ++i) {
         if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
            p[3] = 0;
         p += 4;
      }
   }
   return 1;
}","{'begin': {'line': 4906, 'column': 1}, 'end': {'line': 4929, 'column': 2}}",play_bmp_sequence.c,"['根据', '颜色', '值', '计算', '并', '设置', '图像', '透明', '通道']"
266,266,stbi__do_zlib,int,"int stbi__do_zlib(stbi__zbuf * a, char * obuf, int olen, int exp, int parse_header)","[{'name': 'a', 'type': 'stbi__zbuf *'}, {'name': 'obuf', 'type': 'char *'}, {'name': 'olen', 'type': 'int'}, {'name': 'exp', 'type': 'int'}, {'name': 'parse_header', 'type': 'int'}]",初始化zlib解压缓冲区并调用解析函数,"static int stbi__do_zlib(stbi__zbuf *a, char *obuf, int olen, int exp, int parse_header)
{
   a->zout_start = obuf;
   a->zout       = obuf;
   a->zout_end   = obuf + olen;
   a->z_expandable = exp;

   return stbi__parse_zlib(a, parse_header);
}","{'begin': {'line': 4510, 'column': 1}, 'end': {'line': 4518, 'column': 2}}",play_bmp_sequence.c,"['初始', '初始化', 'zlib', '解压', '缓冲', '缓冲区', '并', '调用', '解析', '函数']"
267,267,stbi_zlib_decode_malloc_guesssize,char *,"char * stbi_zlib_decode_malloc_guesssize(const char * buffer, int len, int initial_size, int * outlen)","[{'name': 'buffer', 'type': 'const char *'}, {'name': 'len', 'type': 'int'}, {'name': 'initial_size', 'type': 'int'}, {'name': 'outlen', 'type': 'int *'}]",使用猜测初始大小动态分配内存进行zlib解码,"STBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen)
{
   stbi__zbuf a;
   char *p = (char *) stbi__malloc(initial_size);
   if (p == NULL) return NULL;
   a.zbuffer = (stbi_uc *) buffer;
   a.zbuffer_end = (stbi_uc *) buffer + len;
   if (stbi__do_zlib(&a, p, initial_size, 1, 1)) {
      if (outlen) *outlen = (int) (a.zout - a.zout_start);
      return a.zout_start;
   } else {
      STBI_FREE(a.zout_start);
      return NULL;
   }
}","{'begin': {'line': 4520, 'column': 1}, 'end': {'line': 4534, 'column': 2}}",play_bmp_sequence.c,"['使用', '猜测', '初始', '大小', '动态', '分配', '内存', '分配内存', '进行', 'zlib', '解码']"
268,268,stbi__compute_transparency16,int,"int stbi__compute_transparency16(stbi__png * z, stbi__uint16[3] tc, int out_n)","[{'name': 'z', 'type': 'stbi__png *'}, {'name': 'tc', 'type': 'stbi__uint16[3]'}, {'name': 'out_n', 'type': 'int'}]",计算并设置16位图像的透明通道,"static int stbi__compute_transparency16(stbi__png *z, stbi__uint16 tc[3], int out_n)
{
   stbi__context *s = z->s;
   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
   stbi__uint16 *p = (stbi__uint16*) z->out;

   // compute color-based transparency, assuming we've
   // already got 65535 as the alpha value in the output
   STBI_ASSERT(out_n == 2 || out_n == 4);

   if (out_n == 2) {
      for (i = 0; i < pixel_count; ++i) {
         p[1] = (p[0] == tc[0] ? 0 : 65535);
         p += 2;
      }
   } else {
      for (i = 0; i < pixel_count; ++i) {
         if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
            p[3] = 0;
         p += 4;
      }
   }
   return 1;
}","{'begin': {'line': 4931, 'column': 1}, 'end': {'line': 4954, 'column': 2}}",play_bmp_sequence.c,"['计算', '并', '设置', '16', '位', '图像', '的', '透明', '通道']"
269,269,stbi_zlib_decode_malloc,char *,"char * stbi_zlib_decode_malloc(const char * buffer, int len, int * outlen)","[{'name': 'buffer', 'type': 'const char *'}, {'name': 'len', 'type': 'int'}, {'name': 'outlen', 'type': 'int *'}]",解码zlib数据并分配内存缓冲区,"STBIDEF char *stbi_zlib_decode_malloc(char const *buffer, int len, int *outlen)
{
   return stbi_zlib_decode_malloc_guesssize(buffer, len, 16384, outlen);
}","{'begin': {'line': 4536, 'column': 1}, 'end': {'line': 4539, 'column': 2}}",play_bmp_sequence.c,"['解码', 'zlib', '数据', '并', '分配', '内存', '分配内存', '缓冲', '缓冲区']"
270,270,stbi_zlib_decode_malloc_guesssize_headerflag,char *,"char * stbi_zlib_decode_malloc_guesssize_headerflag(const char * buffer, int len, int initial_size, int * outlen, int parse_header)","[{'name': 'buffer', 'type': 'const char *'}, {'name': 'len', 'type': 'int'}, {'name': 'initial_size', 'type': 'int'}, {'name': 'outlen', 'type': 'int *'}, {'name': 'parse_header', 'type': 'int'}]",动态分配内存解压zlib数据，支持头部解析控制,"STBIDEF char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header)
{
   stbi__zbuf a;
   char *p = (char *) stbi__malloc(initial_size);
   if (p == NULL) return NULL;
   a.zbuffer = (stbi_uc *) buffer;
   a.zbuffer_end = (stbi_uc *) buffer + len;
   if (stbi__do_zlib(&a, p, initial_size, 1, parse_header)) {
      if (outlen) *outlen = (int) (a.zout - a.zout_start);
      return a.zout_start;
   } else {
      STBI_FREE(a.zout_start);
      return NULL;
   }
}","{'begin': {'line': 4541, 'column': 1}, 'end': {'line': 4555, 'column': 2}}",play_bmp_sequence.c,"['动态', '分配', '内存', '分配内存', '解压', 'zlib', '数据', '，', '支持', '头部', '解析', '控制']"
271,271,stbi_zlib_decode_buffer,int,"int stbi_zlib_decode_buffer(char * obuffer, int olen, const char * ibuffer, int ilen)","[{'name': 'obuffer', 'type': 'char *'}, {'name': 'olen', 'type': 'int'}, {'name': 'ibuffer', 'type': 'const char *'}, {'name': 'ilen', 'type': 'int'}]",解码zlib压缩数据到指定缓冲区,"STBIDEF int stbi_zlib_decode_buffer(char *obuffer, int olen, char const *ibuffer, int ilen)
{
   stbi__zbuf a;
   a.zbuffer = (stbi_uc *) ibuffer;
   a.zbuffer_end = (stbi_uc *) ibuffer + ilen;
   if (stbi__do_zlib(&a, obuffer, olen, 0, 1))
      return (int) (a.zout - a.zout_start);
   else
      return -1;
}","{'begin': {'line': 4557, 'column': 1}, 'end': {'line': 4566, 'column': 2}}",play_bmp_sequence.c,"['解码', 'zlib', '压缩', '数据', '到', '指定', '缓冲', '缓冲区']"
272,272,stbi__expand_png_palette,int,"int stbi__expand_png_palette(stbi__png * a, stbi_uc * palette, int len, int pal_img_n)","[{'name': 'a', 'type': 'stbi__png *'}, {'name': 'palette', 'type': 'stbi_uc *'}, {'name': 'len', 'type': 'int'}, {'name': 'pal_img_n', 'type': 'int'}]",将PNG调色板索引扩展为RGB/RGBA图像数据,"static int stbi__expand_png_palette(stbi__png *a, stbi_uc *palette, int len, int pal_img_n)
{
   stbi__uint32 i, pixel_count = a->s->img_x * a->s->img_y;
   stbi_uc *p, *temp_out, *orig = a->out;

   p = (stbi_uc *) stbi__malloc_mad2(pixel_count, pal_img_n, 0);
   if (p == NULL) return stbi__err(""outofmem"", ""Out of memory"");

   // between here and free(out) below, exitting would leak
   temp_out = p;

   if (pal_img_n == 3) {
      for (i=0; i < pixel_count; ++i) {
         int n = orig[i]*4;
         p[0] = palette[n  ];
         p[1] = palette[n+1];
         p[2] = palette[n+2];
         p += 3;
      }
   } else {
      for (i=0; i < pixel_count; ++i) {
         int n = orig[i]*4;
         p[0] = palette[n  ];
         p[1] = palette[n+1];
         p[2] = palette[n+2];
         p[3] = palette[n+3];
         p += 4;
      }
   }
   STBI_FREE(a->out);
   a->out = temp_out;

   STBI_NOTUSED(len);

   return 1;
}","{'begin': {'line': 4956, 'column': 1}, 'end': {'line': 4991, 'column': 2}}",play_bmp_sequence.c,"['将', 'PNG', '调色', '调色板', '索引', '扩展', '为', 'RGB', '/', 'RGBA', '图像', '数据']"
273,273,stbi_zlib_decode_noheader_malloc,char *,"char * stbi_zlib_decode_noheader_malloc(const char * buffer, int len, int * outlen)","[{'name': 'buffer', 'type': 'const char *'}, {'name': 'len', 'type': 'int'}, {'name': 'outlen', 'type': 'int *'}]",解码无头zlib数据，返回分配的内存结果,"STBIDEF char *stbi_zlib_decode_noheader_malloc(char const *buffer, int len, int *outlen)
{
   stbi__zbuf a;
   char *p = (char *) stbi__malloc(16384);
   if (p == NULL) return NULL;
   a.zbuffer = (stbi_uc *) buffer;
   a.zbuffer_end = (stbi_uc *) buffer+len;
   if (stbi__do_zlib(&a, p, 16384, 1, 0)) {
      if (outlen) *outlen = (int) (a.zout - a.zout_start);
      return a.zout_start;
   } else {
      STBI_FREE(a.zout_start);
      return NULL;
   }
}","{'begin': {'line': 4568, 'column': 1}, 'end': {'line': 4582, 'column': 2}}",play_bmp_sequence.c,"['解码', '无头', 'zlib', '数据', '，', '返回', '分配', '的', '内存', '结果']"
274,274,stbi_zlib_decode_noheader_buffer,int,"int stbi_zlib_decode_noheader_buffer(char * obuffer, int olen, const char * ibuffer, int ilen)","[{'name': 'obuffer', 'type': 'char *'}, {'name': 'olen', 'type': 'int'}, {'name': 'ibuffer', 'type': 'const char *'}, {'name': 'ilen', 'type': 'int'}]",解码zlib压缩数据，不处理头部信息,"STBIDEF int stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen)
{
   stbi__zbuf a;
   a.zbuffer = (stbi_uc *) ibuffer;
   a.zbuffer_end = (stbi_uc *) ibuffer + ilen;
   if (stbi__do_zlib(&a, obuffer, olen, 0, 0))
      return (int) (a.zout - a.zout_start);
   else
      return -1;
}","{'begin': {'line': 4584, 'column': 1}, 'end': {'line': 4593, 'column': 2}}",play_bmp_sequence.c,"['解码', 'zlib', '压缩', '数据', '，', '不', '处理', '头部', '信息']"
275,275,stbi__get_chunk_header,stbi__pngchunk,stbi__pngchunk stbi__get_chunk_header(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",读取并返回PNG块的头部信息,"static stbi__pngchunk stbi__get_chunk_header(stbi__context *s)
{
   stbi__pngchunk c;
   c.length = stbi__get32be(s);
   c.type   = stbi__get32be(s);
   return c;
}","{'begin': {'line': 4613, 'column': 1}, 'end': {'line': 4619, 'column': 2}}",play_bmp_sequence.c,"['读取', '并', '返回', 'PNG', '块', '的', '头部', '信息']"
276,276,stbi_set_unpremultiply_on_load,void,void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply),"[{'name': 'flag_true_if_should_unpremultiply', 'type': 'int'}]",设置加载时取消预乘的全局标志,"STBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply)
{
   stbi__unpremultiply_on_load_global = flag_true_if_should_unpremultiply;
}","{'begin': {'line': 4996, 'column': 1}, 'end': {'line': 4999, 'column': 2}}",play_bmp_sequence.c,"['设置', '加载', '时', '取消', '预乘', '的', '全局', '标志']"
277,277,stbi_convert_iphone_png_to_rgb,void,void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert),"[{'name': 'flag_true_if_should_convert', 'type': 'int'}]",设置iPhone PNG转RGB的全局标志,"STBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert)
{
   stbi__de_iphone_flag_global = flag_true_if_should_convert;
}","{'begin': {'line': 5001, 'column': 1}, 'end': {'line': 5004, 'column': 2}}",play_bmp_sequence.c,"['设置', 'iPhone', ' ', 'PNG', '转', 'RGB', '的', '全局', '标志']"
278,278,stbi__check_png_header,int,int stbi__check_png_header(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",验证输入是否为有效的PNG文件头,"static int stbi__check_png_header(stbi__context *s)
{
   static const stbi_uc png_sig[8] = { 137,80,78,71,13,10,26,10 };
   int i;
   for (i=0; i < 8; ++i)
      if (stbi__get8(s) != png_sig[i]) return stbi__err(""bad png sig"",""Not a PNG"");
   return 1;
}","{'begin': {'line': 4621, 'column': 1}, 'end': {'line': 4628, 'column': 2}}",play_bmp_sequence.c,"['验证', '输入', '是否', '为', '有效', '的', 'PNG', '文件', '头']"
279,279,stbi_set_unpremultiply_on_load_thread,void,void stbi_set_unpremultiply_on_load_thread(int flag_true_if_should_unpremultiply),"[{'name': 'flag_true_if_should_unpremultiply', 'type': 'int'}]",设置加载时取消预乘的线程标志,"STBIDEF void stbi_set_unpremultiply_on_load_thread(int flag_true_if_should_unpremultiply)
{
   stbi__unpremultiply_on_load_local = flag_true_if_should_unpremultiply;
   stbi__unpremultiply_on_load_set = 1;
}","{'begin': {'line': 5013, 'column': 1}, 'end': {'line': 5017, 'column': 2}}",play_bmp_sequence.c,"['设置', '加载', '时', '取消', '预乘', '的', '线程', '标志']"
280,280,stbi_convert_iphone_png_to_rgb_thread,void,void stbi_convert_iphone_png_to_rgb_thread(int flag_true_if_should_convert),"[{'name': 'flag_true_if_should_convert', 'type': 'int'}]",设置iPhone PNG转RGB的线程标志,"STBIDEF void stbi_convert_iphone_png_to_rgb_thread(int flag_true_if_should_convert)
{
   stbi__de_iphone_flag_local = flag_true_if_should_convert;
   stbi__de_iphone_flag_set = 1;
}","{'begin': {'line': 5019, 'column': 1}, 'end': {'line': 5023, 'column': 2}}",play_bmp_sequence.c,"['设置', 'iPhone', ' ', 'PNG', '转', 'RGB', '的', '线程', '标志']"
281,281,stbi__de_iphone,void,void stbi__de_iphone(stbi__png * z),"[{'name': 'z', 'type': 'stbi__png *'}]",转换BGR为RGB并处理预乘,"static void stbi__de_iphone(stbi__png *z)
{
   stbi__context *s = z->s;
   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
   stbi_uc *p = z->out;

   if (s->img_out_n == 3) {  // convert bgr to rgb
      for (i=0; i < pixel_count; ++i) {
         stbi_uc t = p[0];
         p[0] = p[2];
         p[2] = t;
         p += 3;
      }
   } else {
      STBI_ASSERT(s->img_out_n == 4);
      if (stbi__unpremultiply_on_load) {
         // convert bgr to rgb and unpremultiply
         for (i=0; i < pixel_count; ++i) {
            stbi_uc a = p[3];
            stbi_uc t = p[0];
            if (a) {
               stbi_uc half = a / 2;
               p[0] = (p[2] * 255 + half) / a;
               p[1] = (p[1] * 255 + half) / a;
               p[2] = ( t   * 255 + half) / a;
            } else {
               p[0] = p[2];
               p[2] = t;
            }
            p += 4;
         }
      } else {
         // convert bgr to rgb
         for (i=0; i < pixel_count; ++i) {
            stbi_uc t = p[0];
            p[0] = p[2];
            p[2] = t;
            p += 4;
         }
      }
   }
}","{'begin': {'line': 5033, 'column': 1}, 'end': {'line': 5074, 'column': 2}}",play_bmp_sequence.c,"['转换', 'BGR', '为', 'RGB', '并', '处理', '预乘']"
282,282,stbi__paeth,int,"int stbi__paeth(int a, int b, int c)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}, {'name': 'c', 'type': 'int'}]",实现Paeth预测器优化图像处理,"static int stbi__paeth(int a, int b, int c)
{
   // This formulation looks very different from the reference in the PNG spec, but is
   // actually equivalent and has favorable data dependencies and admits straightforward
   // generation of branch-free code, which helps performance significantly.
   int thresh = c*3 - (a + b);
   int lo = a < b ? a : b;
   int hi = a < b ? b : a;
   int t0 = (hi <= thresh) ? lo : c;
   int t1 = (thresh <= lo) ? hi : t0;
   return t1;
}","{'begin': {'line': 4657, 'column': 1}, 'end': {'line': 4668, 'column': 2}}",play_bmp_sequence.c,"['实现', 'Paeth', '预测', '测器', '预测器', '优化', '图像', '处理', '图像处理']"
283,283,stbi__create_png_alpha_expand8,void,"void stbi__create_png_alpha_expand8(stbi_uc * dest, stbi_uc * src, stbi__uint32 x, int img_n)","[{'name': 'dest', 'type': 'stbi_uc *'}, {'name': 'src', 'type': 'stbi_uc *'}, {'name': 'x', 'type': 'stbi__uint32'}, {'name': 'img_n', 'type': 'int'}]",为1或3通道图像数据添加不透明alpha通道,"static void stbi__create_png_alpha_expand8(stbi_uc *dest, stbi_uc *src, stbi__uint32 x, int img_n)
{
   int i;
   // must process data backwards since we allow dest==src
   if (img_n == 1) {
      for (i=x-1; i >= 0; --i) {
         dest[i*2+1] = 255;
         dest[i*2+0] = src[i];
      }
   } else {
      STBI_ASSERT(img_n == 3);
      for (i=x-1; i >= 0; --i) {
         dest[i*4+3] = 255;
         dest[i*4+2] = src[i*3+2];
         dest[i*4+1] = src[i*3+1];
         dest[i*4+0] = src[i*3+0];
      }
   }
}","{'begin': {'line': 4675, 'column': 1}, 'end': {'line': 4693, 'column': 2}}",play_bmp_sequence.c,"['为', '1', '或', '3', '通道', '图像', '数据', '添加', '不', '透明', 'alpha', '通道']"
284,284,stbi__parse_png_file,int,"int stbi__parse_png_file(stbi__png * z, int scan, int req_comp)","[{'name': 'z', 'type': 'stbi__png *'}, {'name': 'scan', 'type': 'int'}, {'name': 'req_comp', 'type': 'int'}]",解析PNG文件数据块并解码图像内容,"static int stbi__parse_png_file(stbi__png *z, int scan, int req_comp)
{
   stbi_uc palette[1024], pal_img_n=0;
   stbi_uc has_trans=0, tc[3]={0};
   stbi__uint16 tc16[3];
   stbi__uint32 ioff=0, idata_limit=0, i, pal_len=0;
   int first=1,k,interlace=0, color=0, is_iphone=0;
   stbi__context *s = z->s;

   z->expanded = NULL;
   z->idata = NULL;
   z->out = NULL;

   if (!stbi__check_png_header(s)) return 0;

   if (scan == STBI__SCAN_type) return 1;

   for (;;) {
      stbi__pngchunk c = stbi__get_chunk_header(s);
      switch (c.type) {
         case STBI__PNG_TYPE('C','g','B','I'):
            is_iphone = 1;
            stbi__skip(s, c.length);
            break;
         case STBI__PNG_TYPE('I','H','D','R'): {
            int comp,filter;
            if (!first) return stbi__err(""multiple IHDR"",""Corrupt PNG"");
            first = 0;
            if (c.length != 13) return stbi__err(""bad IHDR len"",""Corrupt PNG"");
            s->img_x = stbi__get32be(s);
            s->img_y = stbi__get32be(s);
            if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err(""too large"",""Very large image (corrupt?)"");
            if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err(""too large"",""Very large image (corrupt?)"");
            z->depth = stbi__get8(s);  if (z->depth != 1 && z->depth != 2 && z->depth != 4 && z->depth != 8 && z->depth != 16)  return stbi__err(""1/2/4/8/16-bit only"",""PNG not supported: 1/2/4/8/16-bit only"");
            color = stbi__get8(s);  if (color > 6)         return stbi__err(""bad ctype"",""Corrupt PNG"");
            if (color == 3 && z->depth == 16)                  return stbi__err(""bad ctype"",""Corrupt PNG"");
            if (color == 3) pal_img_n = 3; else if (color & 1) return stbi__err(""bad ctype"",""Corrupt PNG"");
            comp  = stbi__get8(s);  if (comp) return stbi__err(""bad comp method"",""Corrupt PNG"");
            filter= stbi__get8(s);  if (filter) return stbi__err(""bad filter method"",""Corrupt PNG"");
            interlace = stbi__get8(s); if (interlace>1) return stbi__err(""bad interlace method"",""Corrupt PNG"");
            if (!s->img_x || !s->img_y) return stbi__err(""0-pixel image"",""Corrupt PNG"");
            if (!pal_img_n) {
               s->img_n = (color & 2 ? 3 : 1) + (color & 4 ? 1 : 0);
               if ((1 << 30) / s->img_x / s->img_n < s->img_y) return stbi__err(""too large"", ""Image too large to decode"");
            } else {
               // if paletted, then pal_n is our final components, and
               // img_n is # components to decompress/filter.
               s->img_n = 1;
               if ((1 << 30) / s->img_x / 4 < s->img_y) return stbi__err(""too large"",""Corrupt PNG"");
            }
            // even with SCAN_header, have to scan to see if we have a tRNS
            break;
         }

         case STBI__PNG_TYPE('P','L','T','E'):  {
            if (first) return stbi__err(""first not IHDR"", ""Corrupt PNG"");
            if (c.length > 256*3) return stbi__err(""invalid PLTE"",""Corrupt PNG"");
            pal_len = c.length / 3;
            if (pal_len * 3 != c.length) return stbi__err(""invalid PLTE"",""Corrupt PNG"");
            for (i=0; i < pal_len; ++i) {
               palette[i*4+0] = stbi__get8(s);
               palette[i*4+1] = stbi__get8(s);
               palette[i*4+2] = stbi__get8(s);
               palette[i*4+3] = 255;
            }
            break;
         }

         case STBI__PNG_TYPE('t','R','N','S'): {
            if (first) return stbi__err(""first not IHDR"", ""Corrupt PNG"");
            if (z->idata) return stbi__err(""tRNS after IDAT"",""Corrupt PNG"");
            if (pal_img_n) {
               if (scan == STBI__SCAN_header) { s->img_n = 4; return 1; }
               if (pal_len == 0) return stbi__err(""tRNS before PLTE"",""Corrupt PNG"");
               if (c.length > pal_len) return stbi__err(""bad tRNS len"",""Corrupt PNG"");
               pal_img_n = 4;
               for (i=0; i < c.length; ++i)
                  palette[i*4+3] = stbi__get8(s);
            } else {
               if (!(s->img_n & 1)) return stbi__err(""tRNS with alpha"",""Corrupt PNG"");
               if (c.length != (stbi__uint32) s->img_n*2) return stbi__err(""bad tRNS len"",""Corrupt PNG"");
               has_trans = 1;
               // non-paletted with tRNS = constant alpha. if header-scanning, we can stop now.
               if (scan == STBI__SCAN_header) { ++s->img_n; return 1; }
               if (z->depth == 16) {
                  for (k = 0; k < s->img_n && k < 3; ++k) // extra loop test to suppress false GCC warning
                     tc16[k] = (stbi__uint16)stbi__get16be(s); // copy the values as-is
               } else {
                  for (k = 0; k < s->img_n && k < 3; ++k)
                     tc[k] = (stbi_uc)(stbi__get16be(s) & 255) * stbi__depth_scale_table[z->depth]; // non 8-bit images will be larger
               }
            }
            break;
         }

         case STBI__PNG_TYPE('I','D','A','T'): {
            if (first) return stbi__err(""first not IHDR"", ""Corrupt PNG"");
            if (pal_img_n && !pal_len) return stbi__err(""no PLTE"",""Corrupt PNG"");
            if (scan == STBI__SCAN_header) {
               // header scan definitely stops at first IDAT
               if (pal_img_n)
                  s->img_n = pal_img_n;
               return 1;
            }
            if (c.length > (1u << 30)) return stbi__err(""IDAT size limit"", ""IDAT section larger than 2^30 bytes"");
            if ((int)(ioff + c.length) < (int)ioff) return 0;
            if (ioff + c.length > idata_limit) {
               stbi__uint32 idata_limit_old = idata_limit;
               stbi_uc *p;
               if (idata_limit == 0) idata_limit = c.length > 4096 ? c.length : 4096;
               while (ioff + c.length > idata_limit)
                  idata_limit *= 2;
               STBI_NOTUSED(idata_limit_old);
               p = (stbi_uc *) STBI_REALLOC_SIZED(z->idata, idata_limit_old, idata_limit); if (p == NULL) return stbi__err(""outofmem"", ""Out of memory"");
               z->idata = p;
            }
            if (!stbi__getn(s, z->idata+ioff,c.length)) return stbi__err(""outofdata"",""Corrupt PNG"");
            ioff += c.length;
            break;
         }

         case STBI__PNG_TYPE('I','E','N','D'): {
            stbi__uint32 raw_len, bpl;
            if (first) return stbi__err(""first not IHDR"", ""Corrupt PNG"");
            if (scan != STBI__SCAN_load) return 1;
            if (z->idata == NULL) return stbi__err(""no IDAT"",""Corrupt PNG"");
            // initial guess for decoded data size to avoid unnecessary reallocs
            bpl = (s->img_x * z->depth + 7) / 8; // bytes per line, per component
            raw_len = bpl * s->img_y * s->img_n /* pixels */ + s->img_y /* filter mode per row */;
            z->expanded = (stbi_uc *) stbi_zlib_decode_malloc_guesssize_headerflag((char *) z->idata, ioff, raw_len, (int *) &raw_len, !is_iphone);
            if (z->expanded == NULL) return 0; // zlib should set error
            STBI_FREE(z->idata); z->idata = NULL;
            if ((req_comp == s->img_n+1 && req_comp != 3 && !pal_img_n) || has_trans)
               s->img_out_n = s->img_n+1;
            else
               s->img_out_n = s->img_n;
            if (!stbi__create_png_image(z, z->expanded, raw_len, s->img_out_n, z->depth, color, interlace)) return 0;
            if (has_trans) {
               if (z->depth == 16) {
                  if (!stbi__compute_transparency16(z, tc16, s->img_out_n)) return 0;
               } else {
                  if (!stbi__compute_transparency(z, tc, s->img_out_n)) return 0;
               }
            }
            if (is_iphone && stbi__de_iphone_flag && s->img_out_n > 2)
               stbi__de_iphone(z);
            if (pal_img_n) {
               // pal_img_n == 3 or 4
               s->img_n = pal_img_n; // record the actual colors we had
               s->img_out_n = pal_img_n;
               if (req_comp >= 3) s->img_out_n = req_comp;
               if (!stbi__expand_png_palette(z, palette, pal_len, s->img_out_n))
                  return 0;
            } else if (has_trans) {
               // non-paletted image with tRNS -> source image has (constant) alpha
               ++s->img_n;
            }
            STBI_FREE(z->expanded); z->expanded = NULL;
            // end of PNG chunk, read and skip CRC
            stbi__get32be(s);
            return 1;
         }

         default:
            // if critical, fail
            if (first) return stbi__err(""first not IHDR"", ""Corrupt PNG"");
            if ((c.type & (1 << 29)) == 0) {
               #ifndef STBI_NO_FAILURE_STRINGS
               // not threadsafe
               static char invalid_chunk[] = ""XXXX PNG chunk not known"";
               invalid_chunk[0] = STBI__BYTECAST(c.type >> 24);
               invalid_chunk[1] = STBI__BYTECAST(c.type >> 16);
               invalid_chunk[2] = STBI__BYTECAST(c.type >>  8);
               invalid_chunk[3] = STBI__BYTECAST(c.type >>  0);
               #endif
               return stbi__err(invalid_chunk, ""PNG not supported: unknown PNG chunk type"");
            }
            stbi__skip(s, c.length);
            break;
      }
      // end of PNG chunk, read and skip CRC
      stbi__get32be(s);
   }
}","{'begin': {'line': 5078, 'column': 1}, 'end': {'line': 5261, 'column': 2}}",play_bmp_sequence.c,"['解析', 'PNG', '文件', '数据', '块', '并', '解码', '图像', '内容']"
285,285,stbi__create_png_image_raw,int,"int stbi__create_png_image_raw(stbi__png * a, stbi_uc * raw, stbi__uint32 raw_len, int out_n, stbi__uint32 x, stbi__uint32 y, int depth, int color)","[{'name': 'a', 'type': 'stbi__png *'}, {'name': 'raw', 'type': 'stbi_uc *'}, {'name': 'raw_len', 'type': 'stbi__uint32'}, {'name': 'out_n', 'type': 'int'}, {'name': 'x', 'type': 'stbi__uint32'}, {'name': 'y', 'type': 'stbi__uint32'}, {'name': 'depth', 'type': 'int'}, {'name': 'color', 'type': 'int'}]",解码PNG原始数据并处理过滤器生成图像,"static int stbi__create_png_image_raw(stbi__png *a, stbi_uc *raw, stbi__uint32 raw_len, int out_n, stbi__uint32 x, stbi__uint32 y, int depth, int color)
{
   int bytes = (depth == 16 ? 2 : 1);
   stbi__context *s = a->s;
   stbi__uint32 i,j,stride = x*out_n*bytes;
   stbi__uint32 img_len, img_width_bytes;
   stbi_uc *filter_buf;
   int all_ok = 1;
   int k;
   int img_n = s->img_n; // copy it into a local for later

   int output_bytes = out_n*bytes;
   int filter_bytes = img_n*bytes;
   int width = x;

   STBI_ASSERT(out_n == s->img_n || out_n == s->img_n+1);
   a->out = (stbi_uc *) stbi__malloc_mad3(x, y, output_bytes, 0); // extra bytes to write off the end into
   if (!a->out) return stbi__err(""outofmem"", ""Out of memory"");

   // note: error exits here don't need to clean up a->out individually,
   // stbi__do_png always does on error.
   if (!stbi__mad3sizes_valid(img_n, x, depth, 7)) return stbi__err(""too large"", ""Corrupt PNG"");
   img_width_bytes = (((img_n * x * depth) + 7) >> 3);
   if (!stbi__mad2sizes_valid(img_width_bytes, y, img_width_bytes)) return stbi__err(""too large"", ""Corrupt PNG"");
   img_len = (img_width_bytes + 1) * y;

   // we used to check for exact match between raw_len and img_len on non-interlaced PNGs,
   // but issue #276 reported a PNG in the wild that had extra data at the end (all zeros),
   // so just check for raw_len < img_len always.
   if (raw_len < img_len) return stbi__err(""not enough pixels"",""Corrupt PNG"");

   // Allocate two scan lines worth of filter workspace buffer.
   filter_buf = (stbi_uc *) stbi__malloc_mad2(img_width_bytes, 2, 0);
   if (!filter_buf) return stbi__err(""outofmem"", ""Out of memory"");

   // Filtering for low-bit-depth images
   if (depth < 8) {
      filter_bytes = 1;
      width = img_width_bytes;
   }

   for (j=0; j < y; ++j) {
      // cur/prior filter buffers alternate
      stbi_uc *cur = filter_buf + (j & 1)*img_width_bytes;
      stbi_uc *prior = filter_buf + (~j & 1)*img_width_bytes;
      stbi_uc *dest = a->out + stride*j;
      int nk = width * filter_bytes;
      int filter = *raw++;

      // check filter type
      if (filter > 4) {
         all_ok = stbi__err(""invalid filter"",""Corrupt PNG"");
         break;
      }

      // if first row, use special filter that doesn't sample previous row
      if (j == 0) filter = first_row_filter[filter];

      // perform actual filtering
      switch (filter) {
      case STBI__F_none:
         memcpy(cur, raw, nk);
         break;
      case STBI__F_sub:
         memcpy(cur, raw, filter_bytes);
         for (k = filter_bytes; k < nk; ++k)
            cur[k] = STBI__BYTECAST(raw[k] + cur[k-filter_bytes]);
         break;
      case STBI__F_up:
         for (k = 0; k < nk; ++k)
            cur[k] = STBI__BYTECAST(raw[k] + prior[k]);
         break;
      case STBI__F_avg:
         for (k = 0; k < filter_bytes; ++k)
            cur[k] = STBI__BYTECAST(raw[k] + (prior[k]>>1));
         for (k = filter_bytes; k < nk; ++k)
            cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k-filter_bytes])>>1));
         break;
      case STBI__F_paeth:
         for (k = 0; k < filter_bytes; ++k)
            cur[k] = STBI__BYTECAST(raw[k] + prior[k]); // prior[k] == stbi__paeth(0,prior[k],0)
         for (k = filter_bytes; k < nk; ++k)
            cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes], prior[k], prior[k-filter_bytes]));
         break;
      case STBI__F_avg_first:
         memcpy(cur, raw, filter_bytes);
         for (k = filter_bytes; k < nk; ++k)
            cur[k] = STBI__BYTECAST(raw[k] + (cur[k-filter_bytes] >> 1));
         break;
      }

      raw += nk;

      // expand decoded bits in cur to dest, also adding an extra alpha channel if desired
      if (depth < 8) {
         stbi_uc scale = (color == 0) ? stbi__depth_scale_table[depth] : 1; // scale grayscale values to 0..255 range
         stbi_uc *in = cur;
         stbi_uc *out = dest;
         stbi_uc inb = 0;
         stbi__uint32 nsmp = x*img_n;

         // expand bits to bytes first
         if (depth == 4) {
            for (i=0; i < nsmp; ++i) {
               if ((i & 1) == 0) inb = *in++;
               *out++ = scale * (inb >> 4);
               inb <<= 4;
            }
         } else if (depth == 2) {
            for (i=0; i < nsmp; ++i) {
               if ((i & 3) == 0) inb = *in++;
               *out++ = scale * (inb >> 6);
               inb <<= 2;
            }
         } else {
            STBI_ASSERT(depth == 1);
            for (i=0; i < nsmp; ++i) {
               if ((i & 7) == 0) inb = *in++;
               *out++ = scale * (inb >> 7);
               inb <<= 1;
            }
         }

         // insert alpha=255 values if desired
         if (img_n != out_n)
            stbi__create_png_alpha_expand8(dest, dest, x, img_n);
      } else if (depth == 8) {
         if (img_n == out_n)
            memcpy(dest, cur, x*img_n);
         else
            stbi__create_png_alpha_expand8(dest, cur, x, img_n);
      } else if (depth == 16) {
         // convert the image data from big-endian to platform-native
         stbi__uint16 *dest16 = (stbi__uint16*)dest;
         stbi__uint32 nsmp = x*img_n;

         if (img_n == out_n) {
            for (i = 0; i < nsmp; ++i, ++dest16, cur += 2)
               *dest16 = (cur[0] << 8) | cur[1];
         } else {
            STBI_ASSERT(img_n+1 == out_n);
            if (img_n == 1) {
               for (i = 0; i < x; ++i, dest16 += 2, cur += 2) {
                  dest16[0] = (cur[0] << 8) | cur[1];
                  dest16[1] = 0xffff;
               }
            } else {
               STBI_ASSERT(img_n == 3);
               for (i = 0; i < x; ++i, dest16 += 4, cur += 6) {
                  dest16[0] = (cur[0] << 8) | cur[1];
                  dest16[1] = (cur[2] << 8) | cur[3];
                  dest16[2] = (cur[4] << 8) | cur[5];
                  dest16[3] = 0xffff;
               }
            }
         }
      }
   }

   STBI_FREE(filter_buf);
   if (!all_ok) return 0;

   return 1;
}","{'begin': {'line': 4696, 'column': 1}, 'end': {'line': 4859, 'column': 2}}",play_bmp_sequence.c,"['解码', 'PNG', '原始', '数据', '原始数据', '并', '处理', '过滤', '滤器', '过滤器', '生成', '图像']"
286,286,stbi__do_png,void *,"void * stbi__do_png(stbi__png * p, int * x, int * y, int * n, int req_comp, stbi__result_info * ri)","[{'name': 'p', 'type': 'stbi__png *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'n', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'ri', 'type': 'stbi__result_info *'}]",解析PNG图像，处理颜色通道及深度，返回图像数据。,"static void *stbi__do_png(stbi__png *p, int *x, int *y, int *n, int req_comp, stbi__result_info *ri)
{
   void *result=NULL;
   if (req_comp < 0 || req_comp > 4) return stbi__errpuc(""bad req_comp"", ""Internal error"");
   if (stbi__parse_png_file(p, STBI__SCAN_load, req_comp)) {
      if (p->depth <= 8)
         ri->bits_per_channel = 8;
      else if (p->depth == 16)
         ri->bits_per_channel = 16;
      else
         return stbi__errpuc(""bad bits_per_channel"", ""PNG not supported: unsupported color depth"");
      result = p->out;
      p->out = NULL;
      if (req_comp && req_comp != p->s->img_out_n) {
         if (ri->bits_per_channel == 8)
            result = stbi__convert_format((unsigned char *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
         else
            result = stbi__convert_format16((stbi__uint16 *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
         p->s->img_out_n = req_comp;
         if (result == NULL) return result;
      }
      *x = p->s->img_x;
      *y = p->s->img_y;
      if (n) *n = p->s->img_n;
   }
   STBI_FREE(p->out);      p->out      = NULL;
   STBI_FREE(p->expanded); p->expanded = NULL;
   STBI_FREE(p->idata);    p->idata    = NULL;

   return result;
}","{'begin': {'line': 5263, 'column': 1}, 'end': {'line': 5293, 'column': 2}}",play_bmp_sequence.c,"['解析', 'PNG', '图像', '，', '处理', '颜色', '通道', '及', '深度', '，', '返回', '图像', '数据', '。']"
287,287,stbi__create_png_image,int,"int stbi__create_png_image(stbi__png * a, stbi_uc * image_data, stbi__uint32 image_data_len, int out_n, int depth, int color, int interlaced)","[{'name': 'a', 'type': 'stbi__png *'}, {'name': 'image_data', 'type': 'stbi_uc *'}, {'name': 'image_data_len', 'type': 'stbi__uint32'}, {'name': 'out_n', 'type': 'int'}, {'name': 'depth', 'type': 'int'}, {'name': 'color', 'type': 'int'}, {'name': 'interlaced', 'type': 'int'}]",生成PNG图像数据，处理隔行扫描解码,"static int stbi__create_png_image(stbi__png *a, stbi_uc *image_data, stbi__uint32 image_data_len, int out_n, int depth, int color, int interlaced)
{
   int bytes = (depth == 16 ? 2 : 1);
   int out_bytes = out_n * bytes;
   stbi_uc *final;
   int p;
   if (!interlaced)
      return stbi__create_png_image_raw(a, image_data, image_data_len, out_n, a->s->img_x, a->s->img_y, depth, color);

   // de-interlacing
   final = (stbi_uc *) stbi__malloc_mad3(a->s->img_x, a->s->img_y, out_bytes, 0);
   if (!final) return stbi__err(""outofmem"", ""Out of memory"");
   for (p=0; p < 7; ++p) {
      int xorig[] = { 0,4,0,2,0,1,0 };
      int yorig[] = { 0,0,4,0,2,0,1 };
      int xspc[]  = { 8,8,4,4,2,2,1 };
      int yspc[]  = { 8,8,8,4,4,2,2 };
      int i,j,x,y;
      // pass1_x[4] = 0, pass1_x[5] = 1, pass1_x[12] = 1
      x = (a->s->img_x - xorig[p] + xspc[p]-1) / xspc[p];
      y = (a->s->img_y - yorig[p] + yspc[p]-1) / yspc[p];
      if (x && y) {
         stbi__uint32 img_len = ((((a->s->img_n * x * depth) + 7) >> 3) + 1) * y;
         if (!stbi__create_png_image_raw(a, image_data, image_data_len, out_n, x, y, depth, color)) {
            STBI_FREE(final);
            return 0;
         }
         for (j=0; j < y; ++j) {
            for (i=0; i < x; ++i) {
               int out_y = j*yspc[p]+yorig[p];
               int out_x = i*xspc[p]+xorig[p];
               memcpy(final + out_y*a->s->img_x*out_bytes + out_x*out_bytes,
                      a->out + (j*x+i)*out_bytes, out_bytes);
            }
         }
         STBI_FREE(a->out);
         image_data += img_len;
         image_data_len -= img_len;
      }
   }
   a->out = final;

   return 1;
}","{'begin': {'line': 4861, 'column': 1}, 'end': {'line': 4904, 'column': 2}}",play_bmp_sequence.c,"['生成', 'PNG', '图像', '数据', '，', '处理', '隔行', '扫描', '隔行扫描', '解码']"
288,288,stbi__png_load,void *,"void * stbi__png_load(stbi__context * s, int * x, int * y, int * comp, int req_comp, stbi__result_info * ri)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'ri', 'type': 'stbi__result_info *'}]",加载并处理PNG图像数据,"static void *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   stbi__png p;
   p.s = s;
   return stbi__do_png(&p, x,y,comp,req_comp, ri);
}","{'begin': {'line': 5295, 'column': 1}, 'end': {'line': 5300, 'column': 2}}",play_bmp_sequence.c,"['加载', '并', '处理', 'PNG', '图像', '数据']"
289,289,stbi__png_test,int,int stbi__png_test(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",检测输入流是否为PNG格式,"static int stbi__png_test(stbi__context *s)
{
   int r;
   r = stbi__check_png_header(s);
   stbi__rewind(s);
   return r;
}","{'begin': {'line': 5302, 'column': 1}, 'end': {'line': 5308, 'column': 2}}",play_bmp_sequence.c,"['检测', '输入', '流', '是否', '为', 'PNG', '格式']"
290,290,stbi__png_info_raw,int,"int stbi__png_info_raw(stbi__png * p, int * x, int * y, int * comp)","[{'name': 'p', 'type': 'stbi__png *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",获取PNG图像的宽高及通道数信息,"static int stbi__png_info_raw(stbi__png *p, int *x, int *y, int *comp)
{
   if (!stbi__parse_png_file(p, STBI__SCAN_header, 0)) {
      stbi__rewind( p->s );
      return 0;
   }
   if (x) *x = p->s->img_x;
   if (y) *y = p->s->img_y;
   if (comp) *comp = p->s->img_n;
   return 1;
}","{'begin': {'line': 5310, 'column': 1}, 'end': {'line': 5320, 'column': 2}}",play_bmp_sequence.c,"['获取', 'PNG', '图像', '的', '宽', '高及', '通道', '数', '信息']"
291,291,stbi__png_info,int,"int stbi__png_info(stbi__context * s, int * x, int * y, int * comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",读取PNG图像尺寸和通道信息,"static int stbi__png_info(stbi__context *s, int *x, int *y, int *comp)
{
   stbi__png p;
   p.s = s;
   return stbi__png_info_raw(&p, x, y, comp);
}","{'begin': {'line': 5322, 'column': 1}, 'end': {'line': 5327, 'column': 2}}",play_bmp_sequence.c,"['读取', 'PNG', '图像', '尺寸', '和', '通道', '信息']"
292,292,stbi__png_is16,int,int stbi__png_is16(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",检测PNG图像是否为16位深度,"static int stbi__png_is16(stbi__context *s)
{
   stbi__png p;
   p.s = s;
   if (!stbi__png_info_raw(&p, NULL, NULL, NULL))
	   return 0;
   if (p.depth != 16) {
      stbi__rewind(p.s);
      return 0;
   }
   return 1;
}","{'begin': {'line': 5329, 'column': 1}, 'end': {'line': 5340, 'column': 2}}",play_bmp_sequence.c,"['检测', 'PNG', '图像', '是否', '为', '16', '位', '深度']"
293,293,stbi__bmp_test_raw,int,int stbi__bmp_test_raw(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",检测输入是否为有效BMP文件,"static int stbi__bmp_test_raw(stbi__context *s)
{
   int r;
   int sz;
   if (stbi__get8(s) != 'B') return 0;
   if (stbi__get8(s) != 'M') return 0;
   stbi__get32le(s); // discard filesize
   stbi__get16le(s); // discard reserved
   stbi__get16le(s); // discard reserved
   stbi__get32le(s); // discard data offset
   sz = stbi__get32le(s);
   r = (sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124);
   return r;
}","{'begin': {'line': 5346, 'column': 1}, 'end': {'line': 5359, 'column': 2}}",play_bmp_sequence.c,"['检测', '输入', '是否', '为', '有效', 'BMP', '文件']"
294,294,stbi__compute_transparency,int,"int stbi__compute_transparency(stbi__png * z, stbi_uc[3] tc, int out_n)","[{'name': 'z', 'type': 'stbi__png *'}, {'name': 'tc', 'type': 'stbi_uc[3]'}, {'name': 'out_n', 'type': 'int'}]",根据指定颜色值计算并设置图像透明度通道,"static int stbi__compute_transparency(stbi__png *z, stbi_uc tc[3], int out_n)
{
   stbi__context *s = z->s;
   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
   stbi_uc *p = z->out;

   // compute color-based transparency, assuming we've
   // already got 255 as the alpha value in the output
   STBI_ASSERT(out_n == 2 || out_n == 4);

   if (out_n == 2) {
      for (i=0; i < pixel_count; ++i) {
         p[1] = (p[0] == tc[0] ? 0 : 255);
         p += 2;
      }
   } else {
      for (i=0; i < pixel_count; ++i) {
         if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
            p[3] = 0;
         p += 4;
      }
   }
   return 1;
}","{'begin': {'line': 4906, 'column': 1}, 'end': {'line': 4929, 'column': 2}}",play_bmp_sequence.c,"['根据', '指定', '颜色', '值', '计算', '并', '设置', '图像', '透明', '明度', '透明度', '通道']"
295,295,stbi__bmp_test,int,int stbi__bmp_test(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",测试BMP格式并重置流位置,"static int stbi__bmp_test(stbi__context *s)
{
   int r = stbi__bmp_test_raw(s);
   stbi__rewind(s);
   return r;
}","{'begin': {'line': 5361, 'column': 1}, 'end': {'line': 5366, 'column': 2}}",play_bmp_sequence.c,"['测试', 'BMP', '格式', '并', '重置', '流', '位置']"
296,296,stbi__high_bit,int,int stbi__high_bit(unsigned int z),"[{'name': 'z', 'type': 'unsigned int'}]",计算无符号整数最高有效位的位数,"static int stbi__high_bit(unsigned int z)
{
   int n=0;
   if (z == 0) return -1;
   if (z >= 0x10000) { n += 16; z >>= 16; }
   if (z >= 0x00100) { n +=  8; z >>=  8; }
   if (z >= 0x00010) { n +=  4; z >>=  4; }
   if (z >= 0x00004) { n +=  2; z >>=  2; }
   if (z >= 0x00002) { n +=  1;/* >>=  1;*/ }
   return n;
}","{'begin': {'line': 5370, 'column': 1}, 'end': {'line': 5380, 'column': 2}}",play_bmp_sequence.c,"['计算', '无', '符号', '整数', '最高', '有效', '位', '的', '位数']"
297,297,stbi__bitcount,int,int stbi__bitcount(unsigned int a),"[{'name': 'a', 'type': 'unsigned int'}]",计算无符号整数二进制中1的位数,"static int stbi__bitcount(unsigned int a)
{
   a = (a & 0x55555555) + ((a >>  1) & 0x55555555); // max 2
   a = (a & 0x33333333) + ((a >>  2) & 0x33333333); // max 4
   a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits
   a = (a + (a >> 8)); // max 16 per 8 bits
   a = (a + (a >> 16)); // max 32 per 8 bits
   return a & 0xff;
}","{'begin': {'line': 5382, 'column': 1}, 'end': {'line': 5390, 'column': 2}}",play_bmp_sequence.c,"['计算', '无', '符号', '整数', '进制', '二进制', '中', '1', '的', '位数']"
298,298,stbi__compute_transparency16,int,"int stbi__compute_transparency16(stbi__png * z, stbi__uint16[3] tc, int out_n)","[{'name': 'z', 'type': 'stbi__png *'}, {'name': 'tc', 'type': 'stbi__uint16[3]'}, {'name': 'out_n', 'type': 'int'}]",根据指定颜色设置16位图像的透明度通道,"static int stbi__compute_transparency16(stbi__png *z, stbi__uint16 tc[3], int out_n)
{
   stbi__context *s = z->s;
   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
   stbi__uint16 *p = (stbi__uint16*) z->out;

   // compute color-based transparency, assuming we've
   // already got 65535 as the alpha value in the output
   STBI_ASSERT(out_n == 2 || out_n == 4);

   if (out_n == 2) {
      for (i = 0; i < pixel_count; ++i) {
         p[1] = (p[0] == tc[0] ? 0 : 65535);
         p += 2;
      }
   } else {
      for (i = 0; i < pixel_count; ++i) {
         if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
            p[3] = 0;
         p += 4;
      }
   }
   return 1;
}","{'begin': {'line': 4931, 'column': 1}, 'end': {'line': 4954, 'column': 2}}",play_bmp_sequence.c,"['根据', '指定', '颜色', '设置', '16', '位', '图像', '的', '透明', '明度', '透明度', '通道']"
299,299,stbi__shiftsigned,int,"int stbi__shiftsigned(unsigned int v, int shift, int bits)","[{'name': 'v', 'type': 'unsigned int'}, {'name': 'shift', 'type': 'int'}, {'name': 'bits', 'type': 'int'}]",通过位移和乘法表转换无符号整数,"static int stbi__shiftsigned(unsigned int v, int shift, int bits)
{
   static unsigned int mul_table[9] = {
      0,
      0xff/*0b11111111*/, 0x55/*0b01010101*/, 0x49/*0b01001001*/, 0x11/*0b00010001*/,
      0x21/*0b00100001*/, 0x41/*0b01000001*/, 0x81/*0b10000001*/, 0x01/*0b00000001*/,
   };
   static unsigned int shift_table[9] = {
      0, 0,0,1,0,2,4,6,0,
   };
   if (shift < 0)
      v <<= -shift;
   else
      v >>= shift;
   STBI_ASSERT(v < 256);
   v >>= (8-bits);
   STBI_ASSERT(bits >= 0 && bits <= 8);
   return (int) ((unsigned) v * mul_table[bits]) >> shift_table[bits];
}","{'begin': {'line': 5395, 'column': 1}, 'end': {'line': 5413, 'column': 2}}",play_bmp_sequence.c,"['通过', '位移', '和', '乘法', '乘法表', '转换', '无', '符号', '整数']"
300,300,stbi__expand_png_palette,int,"int stbi__expand_png_palette(stbi__png * a, stbi_uc * palette, int len, int pal_img_n)","[{'name': 'a', 'type': 'stbi__png *'}, {'name': 'palette', 'type': 'stbi_uc *'}, {'name': 'len', 'type': 'int'}, {'name': 'pal_img_n', 'type': 'int'}]",将PNG调色板索引扩展为RGB/RGBA图像,"static int stbi__expand_png_palette(stbi__png *a, stbi_uc *palette, int len, int pal_img_n)
{
   stbi__uint32 i, pixel_count = a->s->img_x * a->s->img_y;
   stbi_uc *p, *temp_out, *orig = a->out;

   p = (stbi_uc *) stbi__malloc_mad2(pixel_count, pal_img_n, 0);
   if (p == NULL) return stbi__err(""outofmem"", ""Out of memory"");

   // between here and free(out) below, exitting would leak
   temp_out = p;

   if (pal_img_n == 3) {
      for (i=0; i < pixel_count; ++i) {
         int n = orig[i]*4;
         p[0] = palette[n  ];
         p[1] = palette[n+1];
         p[2] = palette[n+2];
         p += 3;
      }
   } else {
      for (i=0; i < pixel_count; ++i) {
         int n = orig[i]*4;
         p[0] = palette[n  ];
         p[1] = palette[n+1];
         p[2] = palette[n+2];
         p[3] = palette[n+3];
         p += 4;
      }
   }
   STBI_FREE(a->out);
   a->out = temp_out;

   STBI_NOTUSED(len);

   return 1;
}","{'begin': {'line': 4956, 'column': 1}, 'end': {'line': 4991, 'column': 2}}",play_bmp_sequence.c,"['将', 'PNG', '调色', '调色板', '索引', '扩展', '为', 'RGB', '/', 'RGBA', '图像']"
301,301,stbi__bmp_set_mask_defaults,int,"int stbi__bmp_set_mask_defaults(stbi__bmp_data * info, int compress)","[{'name': 'info', 'type': 'stbi__bmp_data *'}, {'name': 'compress', 'type': 'int'}]",根据压缩类型和位深设置BMP颜色掩码默认值,"static int stbi__bmp_set_mask_defaults(stbi__bmp_data *info, int compress)
{
   // BI_BITFIELDS specifies masks explicitly, don't override
   if (compress == 3)
      return 1;

   if (compress == 0) {
      if (info->bpp == 16) {
         info->mr = 31u << 10;
         info->mg = 31u <<  5;
         info->mb = 31u <<  0;
      } else if (info->bpp == 32) {
         info->mr = 0xffu << 16;
         info->mg = 0xffu <<  8;
         info->mb = 0xffu <<  0;
         info->ma = 0xffu << 24;
         info->all_a = 0; // if all_a is 0 at end, then we loaded alpha channel but it was all 0
      } else {
         // otherwise, use defaults, which is all-0
         info->mr = info->mg = info->mb = info->ma = 0;
      }
      return 1;
   }
   return 0; // error
}","{'begin': {'line': 5422, 'column': 1}, 'end': {'line': 5446, 'column': 2}}",play_bmp_sequence.c,"['根据', '压缩', '类型', '和', '位深', '设置', 'BMP', '颜色', '掩码', '默认', '默认值']"
302,302,stbi_set_unpremultiply_on_load,void,void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply),"[{'name': 'flag_true_if_should_unpremultiply', 'type': 'int'}]",设置加载时是否取消预乘的全局标志,"STBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply)
{
   stbi__unpremultiply_on_load_global = flag_true_if_should_unpremultiply;
}","{'begin': {'line': 4996, 'column': 1}, 'end': {'line': 4999, 'column': 2}}",play_bmp_sequence.c,"['设置', '加载', '时', '是否', '取消', '预乘', '的', '全局', '标志']"
303,303,stbi_convert_iphone_png_to_rgb,void,void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert),"[{'name': 'flag_true_if_should_convert', 'type': 'int'}]",设置iPhone PNG到RGB的转换标志,"STBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert)
{
   stbi__de_iphone_flag_global = flag_true_if_should_convert;
}","{'begin': {'line': 5001, 'column': 1}, 'end': {'line': 5004, 'column': 2}}",play_bmp_sequence.c,"['设置', 'iPhone', ' ', 'PNG', '到', 'RGB', '的', '转换', '标志']"
304,304,stbi__bmp_parse_header,void *,"void * stbi__bmp_parse_header(stbi__context * s, stbi__bmp_data * info)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'info', 'type': 'stbi__bmp_data *'}]",解析BMP文件头，验证格式并提取信息,"static void *stbi__bmp_parse_header(stbi__context *s, stbi__bmp_data *info)
{
   int hsz;
   if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') return stbi__errpuc(""not BMP"", ""Corrupt BMP"");
   stbi__get32le(s); // discard filesize
   stbi__get16le(s); // discard reserved
   stbi__get16le(s); // discard reserved
   info->offset = stbi__get32le(s);
   info->hsz = hsz = stbi__get32le(s);
   info->mr = info->mg = info->mb = info->ma = 0;
   info->extra_read = 14;

   if (info->offset < 0) return stbi__errpuc(""bad BMP"", ""bad BMP"");

   if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108 && hsz != 124) return stbi__errpuc(""unknown BMP"", ""BMP type not supported: unknown"");
   if (hsz == 12) {
      s->img_x = stbi__get16le(s);
      s->img_y = stbi__get16le(s);
   } else {
      s->img_x = stbi__get32le(s);
      s->img_y = stbi__get32le(s);
   }
   if (stbi__get16le(s) != 1) return stbi__errpuc(""bad BMP"", ""bad BMP"");
   info->bpp = stbi__get16le(s);
   if (hsz != 12) {
      int compress = stbi__get32le(s);
      if (compress == 1 || compress == 2) return stbi__errpuc(""BMP RLE"", ""BMP type not supported: RLE"");
      if (compress >= 4) return stbi__errpuc(""BMP JPEG/PNG"", ""BMP type not supported: unsupported compression""); // this includes PNG/JPEG modes
      if (compress == 3 && info->bpp != 16 && info->bpp != 32) return stbi__errpuc(""bad BMP"", ""bad BMP""); // bitfields requires 16 or 32 bits/pixel
      stbi__get32le(s); // discard sizeof
      stbi__get32le(s); // discard hres
      stbi__get32le(s); // discard vres
      stbi__get32le(s); // discard colorsused
      stbi__get32le(s); // discard max important
      if (hsz == 40 || hsz == 56) {
         if (hsz == 56) {
            stbi__get32le(s);
            stbi__get32le(s);
            stbi__get32le(s);
            stbi__get32le(s);
         }
         if (info->bpp == 16 || info->bpp == 32) {
            if (compress == 0) {
               stbi__bmp_set_mask_defaults(info, compress);
            } else if (compress == 3) {
               info->mr = stbi__get32le(s);
               info->mg = stbi__get32le(s);
               info->mb = stbi__get32le(s);
               info->extra_read += 12;
               // not documented, but generated by photoshop and handled by mspaint
               if (info->mr == info->mg && info->mg == info->mb) {
                  // ?!?!?
                  return stbi__errpuc(""bad BMP"", ""bad BMP"");
               }
            } else
               return stbi__errpuc(""bad BMP"", ""bad BMP"");
         }
      } else {
         // V4/V5 header
         int i;
         if (hsz != 108 && hsz != 124)
            return stbi__errpuc(""bad BMP"", ""bad BMP"");
         info->mr = stbi__get32le(s);
         info->mg = stbi__get32le(s);
         info->mb = stbi__get32le(s);
         info->ma = stbi__get32le(s);
         if (compress != 3) // override mr/mg/mb unless in BI_BITFIELDS mode, as per docs
            stbi__bmp_set_mask_defaults(info, compress);
         stbi__get32le(s); // discard color space
         for (i=0; i < 12; ++i)
            stbi__get32le(s); // discard color space parameters
         if (hsz == 124) {
            stbi__get32le(s); // discard rendering intent
            stbi__get32le(s); // discard offset of profile data
            stbi__get32le(s); // discard size of profile data
            stbi__get32le(s); // discard reserved
         }
      }
   }
   return (void *) 1;
}","{'begin': {'line': 5448, 'column': 1}, 'end': {'line': 5528, 'column': 2}}",play_bmp_sequence.c,"['解析', 'BMP', '文件', '头', '，', '验证', '格式', '并', '提取', '信息']"
305,305,stbi_set_unpremultiply_on_load_thread,void,void stbi_set_unpremultiply_on_load_thread(int flag_true_if_should_unpremultiply),"[{'name': 'flag_true_if_should_unpremultiply', 'type': 'int'}]",设置线程加载时取消预乘处理标志,"STBIDEF void stbi_set_unpremultiply_on_load_thread(int flag_true_if_should_unpremultiply)
{
   stbi__unpremultiply_on_load_local = flag_true_if_should_unpremultiply;
   stbi__unpremultiply_on_load_set = 1;
}","{'begin': {'line': 5013, 'column': 1}, 'end': {'line': 5017, 'column': 2}}",play_bmp_sequence.c,"['设置', '线程', '加载', '时', '取消', '预乘', '处理', '标志']"
306,306,stbi_convert_iphone_png_to_rgb_thread,void,void stbi_convert_iphone_png_to_rgb_thread(int flag_true_if_should_convert),"[{'name': 'flag_true_if_should_convert', 'type': 'int'}]",设置iPhone PNG转RGB的线程标志,"STBIDEF void stbi_convert_iphone_png_to_rgb_thread(int flag_true_if_should_convert)
{
   stbi__de_iphone_flag_local = flag_true_if_should_convert;
   stbi__de_iphone_flag_set = 1;
}","{'begin': {'line': 5019, 'column': 1}, 'end': {'line': 5023, 'column': 2}}",play_bmp_sequence.c,"['设置', 'iPhone', ' ', 'PNG', '转', 'RGB', '的', '线程', '标志']"
307,307,stbi__de_iphone,void,void stbi__de_iphone(stbi__png * z),"[{'name': 'z', 'type': 'stbi__png *'}]",转换BGR至RGB并处理预乘Alpha通道,"static void stbi__de_iphone(stbi__png *z)
{
   stbi__context *s = z->s;
   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
   stbi_uc *p = z->out;

   if (s->img_out_n == 3) {  // convert bgr to rgb
      for (i=0; i < pixel_count; ++i) {
         stbi_uc t = p[0];
         p[0] = p[2];
         p[2] = t;
         p += 3;
      }
   } else {
      STBI_ASSERT(s->img_out_n == 4);
      if (stbi__unpremultiply_on_load) {
         // convert bgr to rgb and unpremultiply
         for (i=0; i < pixel_count; ++i) {
            stbi_uc a = p[3];
            stbi_uc t = p[0];
            if (a) {
               stbi_uc half = a / 2;
               p[0] = (p[2] * 255 + half) / a;
               p[1] = (p[1] * 255 + half) / a;
               p[2] = ( t   * 255 + half) / a;
            } else {
               p[0] = p[2];
               p[2] = t;
            }
            p += 4;
         }
      } else {
         // convert bgr to rgb
         for (i=0; i < pixel_count; ++i) {
            stbi_uc t = p[0];
            p[0] = p[2];
            p[2] = t;
            p += 4;
         }
      }
   }
}","{'begin': {'line': 5033, 'column': 1}, 'end': {'line': 5074, 'column': 2}}",play_bmp_sequence.c,"['转换', 'BGR', '至', 'RGB', '并', '处理', '预乘', 'Alpha', '通道']"
308,308,stbi__parse_png_file,int,"int stbi__parse_png_file(stbi__png * z, int scan, int req_comp)","[{'name': 'z', 'type': 'stbi__png *'}, {'name': 'scan', 'type': 'int'}, {'name': 'req_comp', 'type': 'int'}]",解析PNG文件结构并加载图像数据,"static int stbi__parse_png_file(stbi__png *z, int scan, int req_comp)
{
   stbi_uc palette[1024], pal_img_n=0;
   stbi_uc has_trans=0, tc[3]={0};
   stbi__uint16 tc16[3];
   stbi__uint32 ioff=0, idata_limit=0, i, pal_len=0;
   int first=1,k,interlace=0, color=0, is_iphone=0;
   stbi__context *s = z->s;

   z->expanded = NULL;
   z->idata = NULL;
   z->out = NULL;

   if (!stbi__check_png_header(s)) return 0;

   if (scan == STBI__SCAN_type) return 1;

   for (;;) {
      stbi__pngchunk c = stbi__get_chunk_header(s);
      switch (c.type) {
         case STBI__PNG_TYPE('C','g','B','I'):
            is_iphone = 1;
            stbi__skip(s, c.length);
            break;
         case STBI__PNG_TYPE('I','H','D','R'): {
            int comp,filter;
            if (!first) return stbi__err(""multiple IHDR"",""Corrupt PNG"");
            first = 0;
            if (c.length != 13) return stbi__err(""bad IHDR len"",""Corrupt PNG"");
            s->img_x = stbi__get32be(s);
            s->img_y = stbi__get32be(s);
            if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err(""too large"",""Very large image (corrupt?)"");
            if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err(""too large"",""Very large image (corrupt?)"");
            z->depth = stbi__get8(s);  if (z->depth != 1 && z->depth != 2 && z->depth != 4 && z->depth != 8 && z->depth != 16)  return stbi__err(""1/2/4/8/16-bit only"",""PNG not supported: 1/2/4/8/16-bit only"");
            color = stbi__get8(s);  if (color > 6)         return stbi__err(""bad ctype"",""Corrupt PNG"");
            if (color == 3 && z->depth == 16)                  return stbi__err(""bad ctype"",""Corrupt PNG"");
            if (color == 3) pal_img_n = 3; else if (color & 1) return stbi__err(""bad ctype"",""Corrupt PNG"");
            comp  = stbi__get8(s);  if (comp) return stbi__err(""bad comp method"",""Corrupt PNG"");
            filter= stbi__get8(s);  if (filter) return stbi__err(""bad filter method"",""Corrupt PNG"");
            interlace = stbi__get8(s); if (interlace>1) return stbi__err(""bad interlace method"",""Corrupt PNG"");
            if (!s->img_x || !s->img_y) return stbi__err(""0-pixel image"",""Corrupt PNG"");
            if (!pal_img_n) {
               s->img_n = (color & 2 ? 3 : 1) + (color & 4 ? 1 : 0);
               if ((1 << 30) / s->img_x / s->img_n < s->img_y) return stbi__err(""too large"", ""Image too large to decode"");
            } else {
               // if paletted, then pal_n is our final components, and
               // img_n is # components to decompress/filter.
               s->img_n = 1;
               if ((1 << 30) / s->img_x / 4 < s->img_y) return stbi__err(""too large"",""Corrupt PNG"");
            }
            // even with SCAN_header, have to scan to see if we have a tRNS
            break;
         }

         case STBI__PNG_TYPE('P','L','T','E'):  {
            if (first) return stbi__err(""first not IHDR"", ""Corrupt PNG"");
            if (c.length > 256*3) return stbi__err(""invalid PLTE"",""Corrupt PNG"");
            pal_len = c.length / 3;
            if (pal_len * 3 != c.length) return stbi__err(""invalid PLTE"",""Corrupt PNG"");
            for (i=0; i < pal_len; ++i) {
               palette[i*4+0] = stbi__get8(s);
               palette[i*4+1] = stbi__get8(s);
               palette[i*4+2] = stbi__get8(s);
               palette[i*4+3] = 255;
            }
            break;
         }

         case STBI__PNG_TYPE('t','R','N','S'): {
            if (first) return stbi__err(""first not IHDR"", ""Corrupt PNG"");
            if (z->idata) return stbi__err(""tRNS after IDAT"",""Corrupt PNG"");
            if (pal_img_n) {
               if (scan == STBI__SCAN_header) { s->img_n = 4; return 1; }
               if (pal_len == 0) return stbi__err(""tRNS before PLTE"",""Corrupt PNG"");
               if (c.length > pal_len) return stbi__err(""bad tRNS len"",""Corrupt PNG"");
               pal_img_n = 4;
               for (i=0; i < c.length; ++i)
                  palette[i*4+3] = stbi__get8(s);
            } else {
               if (!(s->img_n & 1)) return stbi__err(""tRNS with alpha"",""Corrupt PNG"");
               if (c.length != (stbi__uint32) s->img_n*2) return stbi__err(""bad tRNS len"",""Corrupt PNG"");
               has_trans = 1;
               // non-paletted with tRNS = constant alpha. if header-scanning, we can stop now.
               if (scan == STBI__SCAN_header) { ++s->img_n; return 1; }
               if (z->depth == 16) {
                  for (k = 0; k < s->img_n && k < 3; ++k) // extra loop test to suppress false GCC warning
                     tc16[k] = (stbi__uint16)stbi__get16be(s); // copy the values as-is
               } else {
                  for (k = 0; k < s->img_n && k < 3; ++k)
                     tc[k] = (stbi_uc)(stbi__get16be(s) & 255) * stbi__depth_scale_table[z->depth]; // non 8-bit images will be larger
               }
            }
            break;
         }

         case STBI__PNG_TYPE('I','D','A','T'): {
            if (first) return stbi__err(""first not IHDR"", ""Corrupt PNG"");
            if (pal_img_n && !pal_len) return stbi__err(""no PLTE"",""Corrupt PNG"");
            if (scan == STBI__SCAN_header) {
               // header scan definitely stops at first IDAT
               if (pal_img_n)
                  s->img_n = pal_img_n;
               return 1;
            }
            if (c.length > (1u << 30)) return stbi__err(""IDAT size limit"", ""IDAT section larger than 2^30 bytes"");
            if ((int)(ioff + c.length) < (int)ioff) return 0;
            if (ioff + c.length > idata_limit) {
               stbi__uint32 idata_limit_old = idata_limit;
               stbi_uc *p;
               if (idata_limit == 0) idata_limit = c.length > 4096 ? c.length : 4096;
               while (ioff + c.length > idata_limit)
                  idata_limit *= 2;
               STBI_NOTUSED(idata_limit_old);
               p = (stbi_uc *) STBI_REALLOC_SIZED(z->idata, idata_limit_old, idata_limit); if (p == NULL) return stbi__err(""outofmem"", ""Out of memory"");
               z->idata = p;
            }
            if (!stbi__getn(s, z->idata+ioff,c.length)) return stbi__err(""outofdata"",""Corrupt PNG"");
            ioff += c.length;
            break;
         }

         case STBI__PNG_TYPE('I','E','N','D'): {
            stbi__uint32 raw_len, bpl;
            if (first) return stbi__err(""first not IHDR"", ""Corrupt PNG"");
            if (scan != STBI__SCAN_load) return 1;
            if (z->idata == NULL) return stbi__err(""no IDAT"",""Corrupt PNG"");
            // initial guess for decoded data size to avoid unnecessary reallocs
            bpl = (s->img_x * z->depth + 7) / 8; // bytes per line, per component
            raw_len = bpl * s->img_y * s->img_n /* pixels */ + s->img_y /* filter mode per row */;
            z->expanded = (stbi_uc *) stbi_zlib_decode_malloc_guesssize_headerflag((char *) z->idata, ioff, raw_len, (int *) &raw_len, !is_iphone);
            if (z->expanded == NULL) return 0; // zlib should set error
            STBI_FREE(z->idata); z->idata = NULL;
            if ((req_comp == s->img_n+1 && req_comp != 3 && !pal_img_n) || has_trans)
               s->img_out_n = s->img_n+1;
            else
               s->img_out_n = s->img_n;
            if (!stbi__create_png_image(z, z->expanded, raw_len, s->img_out_n, z->depth, color, interlace)) return 0;
            if (has_trans) {
               if (z->depth == 16) {
                  if (!stbi__compute_transparency16(z, tc16, s->img_out_n)) return 0;
               } else {
                  if (!stbi__compute_transparency(z, tc, s->img_out_n)) return 0;
               }
            }
            if (is_iphone && stbi__de_iphone_flag && s->img_out_n > 2)
               stbi__de_iphone(z);
            if (pal_img_n) {
               // pal_img_n == 3 or 4
               s->img_n = pal_img_n; // record the actual colors we had
               s->img_out_n = pal_img_n;
               if (req_comp >= 3) s->img_out_n = req_comp;
               if (!stbi__expand_png_palette(z, palette, pal_len, s->img_out_n))
                  return 0;
            } else if (has_trans) {
               // non-paletted image with tRNS -> source image has (constant) alpha
               ++s->img_n;
            }
            STBI_FREE(z->expanded); z->expanded = NULL;
            // end of PNG chunk, read and skip CRC
            stbi__get32be(s);
            return 1;
         }

         default:
            // if critical, fail
            if (first) return stbi__err(""first not IHDR"", ""Corrupt PNG"");
            if ((c.type & (1 << 29)) == 0) {
               #ifndef STBI_NO_FAILURE_STRINGS
               // not threadsafe
               static char invalid_chunk[] = ""XXXX PNG chunk not known"";
               invalid_chunk[0] = STBI__BYTECAST(c.type >> 24);
               invalid_chunk[1] = STBI__BYTECAST(c.type >> 16);
               invalid_chunk[2] = STBI__BYTECAST(c.type >>  8);
               invalid_chunk[3] = STBI__BYTECAST(c.type >>  0);
               #endif
               return stbi__err(invalid_chunk, ""PNG not supported: unknown PNG chunk type"");
            }
            stbi__skip(s, c.length);
            break;
      }
      // end of PNG chunk, read and skip CRC
      stbi__get32be(s);
   }
}","{'begin': {'line': 5078, 'column': 1}, 'end': {'line': 5261, 'column': 2}}",play_bmp_sequence.c,"['解析', 'PNG', '文件', '结构', '并', '加载', '图像', '数据']"
309,309,stbi__bmp_load,void *,"void * stbi__bmp_load(stbi__context * s, int * x, int * y, int * comp, int req_comp, stbi__result_info * ri)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'ri', 'type': 'stbi__result_info *'}]",加载BMP图像，处理颜色通道及格式转换。,"static void *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   stbi_uc *out;
   unsigned int mr=0,mg=0,mb=0,ma=0, all_a;
   stbi_uc pal[256][4];
   int psize=0,i,j,width;
   int flip_vertically, pad, target;
   stbi__bmp_data info;
   STBI_NOTUSED(ri);

   info.all_a = 255;
   if (stbi__bmp_parse_header(s, &info) == NULL)
      return NULL; // error code already set

   flip_vertically = ((int) s->img_y) > 0;
   s->img_y = abs((int) s->img_y);

   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc(""too large"",""Very large image (corrupt?)"");
   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc(""too large"",""Very large image (corrupt?)"");

   mr = info.mr;
   mg = info.mg;
   mb = info.mb;
   ma = info.ma;
   all_a = info.all_a;

   if (info.hsz == 12) {
      if (info.bpp < 24)
         psize = (info.offset - info.extra_read - 24) / 3;
   } else {
      if (info.bpp < 16)
         psize = (info.offset - info.extra_read - info.hsz) >> 2;
   }
   if (psize == 0) {
      // accept some number of extra bytes after the header, but if the offset points either to before
      // the header ends or implies a large amount of extra data, reject the file as malformed
      int bytes_read_so_far = s->callback_already_read + (int)(s->img_buffer - s->img_buffer_original);
      int header_limit = 1024; // max we actually read is below 256 bytes currently.
      int extra_data_limit = 256*4; // what ordinarily goes here is a palette; 256 entries*4 bytes is its max size.
      if (bytes_read_so_far <= 0 || bytes_read_so_far > header_limit) {
         return stbi__errpuc(""bad header"", ""Corrupt BMP"");
      }
      // we established that bytes_read_so_far is positive and sensible.
      // the first half of this test rejects offsets that are either too small positives, or
      // negative, and guarantees that info.offset >= bytes_read_so_far > 0. this in turn
      // ensures the number computed in the second half of the test can't overflow.
      if (info.offset < bytes_read_so_far || info.offset - bytes_read_so_far > extra_data_limit) {
         return stbi__errpuc(""bad offset"", ""Corrupt BMP"");
      } else {
         stbi__skip(s, info.offset - bytes_read_so_far);
      }
   }

   if (info.bpp == 24 && ma == 0xff000000)
      s->img_n = 3;
   else
      s->img_n = ma ? 4 : 3;
   if (req_comp && req_comp >= 3) // we can directly decode 3 or 4
      target = req_comp;
   else
      target = s->img_n; // if they want monochrome, we'll post-convert

   // sanity-check size
   if (!stbi__mad3sizes_valid(target, s->img_x, s->img_y, 0))
      return stbi__errpuc(""too large"", ""Corrupt BMP"");

   out = (stbi_uc *) stbi__malloc_mad3(target, s->img_x, s->img_y, 0);
   if (!out) return stbi__errpuc(""outofmem"", ""Out of memory"");
   if (info.bpp < 16) {
      int z=0;
      if (psize == 0 || psize > 256) { STBI_FREE(out); return stbi__errpuc(""invalid"", ""Corrupt BMP""); }
      for (i=0; i < psize; ++i) {
         pal[i][2] = stbi__get8(s);
         pal[i][1] = stbi__get8(s);
         pal[i][0] = stbi__get8(s);
         if (info.hsz != 12) stbi__get8(s);
         pal[i][3] = 255;
      }
      stbi__skip(s, info.offset - info.extra_read - info.hsz - psize * (info.hsz == 12 ? 3 : 4));
      if (info.bpp == 1) width = (s->img_x + 7) >> 3;
      else if (info.bpp == 4) width = (s->img_x + 1) >> 1;
      else if (info.bpp == 8) width = s->img_x;
      else { STBI_FREE(out); return stbi__errpuc(""bad bpp"", ""Corrupt BMP""); }
      pad = (-width)&3;
      if (info.bpp == 1) {
         for (j=0; j < (int) s->img_y; ++j) {
            int bit_offset = 7, v = stbi__get8(s);
            for (i=0; i < (int) s->img_x; ++i) {
               int color = (v>>bit_offset)&0x1;
               out[z++] = pal[color][0];
               out[z++] = pal[color][1];
               out[z++] = pal[color][2];
               if (target == 4) out[z++] = 255;
               if (i+1 == (int) s->img_x) break;
               if((--bit_offset) < 0) {
                  bit_offset = 7;
                  v = stbi__get8(s);
               }
            }
            stbi__skip(s, pad);
         }
      } else {
         for (j=0; j < (int) s->img_y; ++j) {
            for (i=0; i < (int) s->img_x; i += 2) {
               int v=stbi__get8(s),v2=0;
               if (info.bpp == 4) {
                  v2 = v & 15;
                  v >>= 4;
               }
               out[z++] = pal[v][0];
               out[z++] = pal[v][1];
               out[z++] = pal[v][2];
               if (target == 4) out[z++] = 255;
               if (i+1 == (int) s->img_x) break;
               v = (info.bpp == 8) ? stbi__get8(s) : v2;
               out[z++] = pal[v][0];
               out[z++] = pal[v][1];
               out[z++] = pal[v][2];
               if (target == 4) out[z++] = 255;
            }
            stbi__skip(s, pad);
         }
      }
   } else {
      int rshift=0,gshift=0,bshift=0,ashift=0,rcount=0,gcount=0,bcount=0,acount=0;
      int z = 0;
      int easy=0;
      stbi__skip(s, info.offset - info.extra_read - info.hsz);
      if (info.bpp == 24) width = 3 * s->img_x;
      else if (info.bpp == 16) width = 2*s->img_x;
      else /* bpp = 32 and pad = 0 */ width=0;
      pad = (-width) & 3;
      if (info.bpp == 24) {
         easy = 1;
      } else if (info.bpp == 32) {
         if (mb == 0xff && mg == 0xff00 && mr == 0x00ff0000 && ma == 0xff000000)
            easy = 2;
      }
      if (!easy) {
         if (!mr || !mg || !mb) { STBI_FREE(out); return stbi__errpuc(""bad masks"", ""Corrupt BMP""); }
         // right shift amt to put high bit in position #7
         rshift = stbi__high_bit(mr)-7; rcount = stbi__bitcount(mr);
         gshift = stbi__high_bit(mg)-7; gcount = stbi__bitcount(mg);
         bshift = stbi__high_bit(mb)-7; bcount = stbi__bitcount(mb);
         ashift = stbi__high_bit(ma)-7; acount = stbi__bitcount(ma);
         if (rcount > 8 || gcount > 8 || bcount > 8 || acount > 8) { STBI_FREE(out); return stbi__errpuc(""bad masks"", ""Corrupt BMP""); }
      }
      for (j=0; j < (int) s->img_y; ++j) {
         if (easy) {
            for (i=0; i < (int) s->img_x; ++i) {
               unsigned char a;
               out[z+2] = stbi__get8(s);
               out[z+1] = stbi__get8(s);
               out[z+0] = stbi__get8(s);
               z += 3;
               a = (easy == 2 ? stbi__get8(s) : 255);
               all_a |= a;
               if (target == 4) out[z++] = a;
            }
         } else {
            int bpp = info.bpp;
            for (i=0; i < (int) s->img_x; ++i) {
               stbi__uint32 v = (bpp == 16 ? (stbi__uint32) stbi__get16le(s) : stbi__get32le(s));
               unsigned int a;
               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mr, rshift, rcount));
               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mg, gshift, gcount));
               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mb, bshift, bcount));
               a = (ma ? stbi__shiftsigned(v & ma, ashift, acount) : 255);
               all_a |= a;
               if (target == 4) out[z++] = STBI__BYTECAST(a);
            }
         }
         stbi__skip(s, pad);
      }
   }

   // if alpha channel is all 0s, replace with all 255s
   if (target == 4 && all_a == 0)
      for (i=4*s->img_x*s->img_y-1; i >= 0; i -= 4)
         out[i] = 255;

   if (flip_vertically) {
      stbi_uc t;
      for (j=0; j < (int) s->img_y>>1; ++j) {
         stbi_uc *p1 = out +      j     *s->img_x*target;
         stbi_uc *p2 = out + (s->img_y-1-j)*s->img_x*target;
         for (i=0; i < (int) s->img_x*target; ++i) {
            t = p1[i]; p1[i] = p2[i]; p2[i] = t;
         }
      }
   }

   if (req_comp && req_comp != target) {
      out = stbi__convert_format(out, target, req_comp, s->img_x, s->img_y);
      if (out == NULL) return out; // stbi__convert_format frees input on failure
   }

   *x = s->img_x;
   *y = s->img_y;
   if (comp) *comp = s->img_n;
   return out;
}","{'begin': {'line': 5531, 'column': 1}, 'end': {'line': 5732, 'column': 2}}",play_bmp_sequence.c,"['加载', 'BMP', '图像', '，', '处理', '颜色', '通道', '及', '格式', '转换', '。']"
310,310,stbi__tga_get_comp,int,"int stbi__tga_get_comp(int bits_per_pixel, int is_grey, int * is_rgb16)","[{'name': 'bits_per_pixel', 'type': 'int'}, {'name': 'is_grey', 'type': 'int'}, {'name': 'is_rgb16', 'type': 'int *'}]",根据像素位数和灰度标识确定TGA图像组件类型,"static int stbi__tga_get_comp(int bits_per_pixel, int is_grey, int* is_rgb16)
{
   // only RGB or RGBA (incl. 16bit) or grey allowed
   if (is_rgb16) *is_rgb16 = 0;
   switch(bits_per_pixel) {
      case 8:  return STBI_grey;
      case 16: if(is_grey) return STBI_grey_alpha;
               // fallthrough
      case 15: if(is_rgb16) *is_rgb16 = 1;
               return STBI_rgb;
      case 24: // fallthrough
      case 32: return bits_per_pixel/8;
      default: return 0;
   }
}","{'begin': {'line': 5739, 'column': 1}, 'end': {'line': 5753, 'column': 2}}",play_bmp_sequence.c,"['根据', '像素', '位数', '和', '灰度', '标识', '确定', 'TGA', '图像', '组件', '类型']"
311,311,stbi__tga_info,int,"int stbi__tga_info(stbi__context * s, int * x, int * y, int * comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",解析TGA图像头信息并验证有效性,"static int stbi__tga_info(stbi__context *s, int *x, int *y, int *comp)
{
    int tga_w, tga_h, tga_comp, tga_image_type, tga_bits_per_pixel, tga_colormap_bpp;
    int sz, tga_colormap_type;
    stbi__get8(s);                   // discard Offset
    tga_colormap_type = stbi__get8(s); // colormap type
    if( tga_colormap_type > 1 ) {
        stbi__rewind(s);
        return 0;      // only RGB or indexed allowed
    }
    tga_image_type = stbi__get8(s); // image type
    if ( tga_colormap_type == 1 ) { // colormapped (paletted) image
        if (tga_image_type != 1 && tga_image_type != 9) {
            stbi__rewind(s);
            return 0;
        }
        stbi__skip(s,4);       // skip index of first colormap entry and number of entries
        sz = stbi__get8(s);    //   check bits per palette color entry
        if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) {
            stbi__rewind(s);
            return 0;
        }
        stbi__skip(s,4);       // skip image x and y origin
        tga_colormap_bpp = sz;
    } else { // ""normal"" image w/o colormap - only RGB or grey allowed, +/- RLE
        if ( (tga_image_type != 2) && (tga_image_type != 3) && (tga_image_type != 10) && (tga_image_type != 11) ) {
            stbi__rewind(s);
            return 0; // only RGB or grey allowed, +/- RLE
        }
        stbi__skip(s,9); // skip colormap specification and image x/y origin
        tga_colormap_bpp = 0;
    }
    tga_w = stbi__get16le(s);
    if( tga_w < 1 ) {
        stbi__rewind(s);
        return 0;   // test width
    }
    tga_h = stbi__get16le(s);
    if( tga_h < 1 ) {
        stbi__rewind(s);
        return 0;   // test height
    }
    tga_bits_per_pixel = stbi__get8(s); // bits per pixel
    stbi__get8(s); // ignore alpha bits
    if (tga_colormap_bpp != 0) {
        if((tga_bits_per_pixel != 8) && (tga_bits_per_pixel != 16)) {
            // when using a colormap, tga_bits_per_pixel is the size of the indexes
            // I don't think anything but 8 or 16bit indexes makes sense
            stbi__rewind(s);
            return 0;
        }
        tga_comp = stbi__tga_get_comp(tga_colormap_bpp, 0, NULL);
    } else {
        tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3) || (tga_image_type == 11), NULL);
    }
    if(!tga_comp) {
      stbi__rewind(s);
      return 0;
    }
    if (x) *x = tga_w;
    if (y) *y = tga_h;
    if (comp) *comp = tga_comp;
    return 1;                   // seems to have passed everything
}","{'begin': {'line': 5755, 'column': 1}, 'end': {'line': 5818, 'column': 2}}",play_bmp_sequence.c,"['解析', 'TGA', '图像', '头', '信息', '并', '验证', '有效', '有效性']"
312,312,stbi__do_png,void *,"void * stbi__do_png(stbi__png * p, int * x, int * y, int * n, int req_comp, stbi__result_info * ri)","[{'name': 'p', 'type': 'stbi__png *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'n', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'ri', 'type': 'stbi__result_info *'}]",解析PNG图像并转换输出格式,"static void *stbi__do_png(stbi__png *p, int *x, int *y, int *n, int req_comp, stbi__result_info *ri)
{
   void *result=NULL;
   if (req_comp < 0 || req_comp > 4) return stbi__errpuc(""bad req_comp"", ""Internal error"");
   if (stbi__parse_png_file(p, STBI__SCAN_load, req_comp)) {
      if (p->depth <= 8)
         ri->bits_per_channel = 8;
      else if (p->depth == 16)
         ri->bits_per_channel = 16;
      else
         return stbi__errpuc(""bad bits_per_channel"", ""PNG not supported: unsupported color depth"");
      result = p->out;
      p->out = NULL;
      if (req_comp && req_comp != p->s->img_out_n) {
         if (ri->bits_per_channel == 8)
            result = stbi__convert_format((unsigned char *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
         else
            result = stbi__convert_format16((stbi__uint16 *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
         p->s->img_out_n = req_comp;
         if (result == NULL) return result;
      }
      *x = p->s->img_x;
      *y = p->s->img_y;
      if (n) *n = p->s->img_n;
   }
   STBI_FREE(p->out);      p->out      = NULL;
   STBI_FREE(p->expanded); p->expanded = NULL;
   STBI_FREE(p->idata);    p->idata    = NULL;

   return result;
}","{'begin': {'line': 5263, 'column': 1}, 'end': {'line': 5293, 'column': 2}}",play_bmp_sequence.c,"['解析', 'PNG', '图像', '并', '转换', '输出', '格式']"
313,313,stbi__tga_test,int,int stbi__tga_test(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",检测输入流是否为有效的TGA图像格式,"static int stbi__tga_test(stbi__context *s)
{
   int res = 0;
   int sz, tga_color_type;
   stbi__get8(s);      //   discard Offset
   tga_color_type = stbi__get8(s);   //   color type
   if ( tga_color_type > 1 ) goto errorEnd;   //   only RGB or indexed allowed
   sz = stbi__get8(s);   //   image type
   if ( tga_color_type == 1 ) { // colormapped (paletted) image
      if (sz != 1 && sz != 9) goto errorEnd; // colortype 1 demands image type 1 or 9
      stbi__skip(s,4);       // skip index of first colormap entry and number of entries
      sz = stbi__get8(s);    //   check bits per palette color entry
      if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;
      stbi__skip(s,4);       // skip image x and y origin
   } else { // ""normal"" image w/o colormap
      if ( (sz != 2) && (sz != 3) && (sz != 10) && (sz != 11) ) goto errorEnd; // only RGB or grey allowed, +/- RLE
      stbi__skip(s,9); // skip colormap specification and image x/y origin
   }
   if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test width
   if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test height
   sz = stbi__get8(s);   //   bits per pixel
   if ( (tga_color_type == 1) && (sz != 8) && (sz != 16) ) goto errorEnd; // for colormapped images, bpp is size of an index
   if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;

   res = 1; // if we got this far, everything's good and we can return 1 instead of 0

errorEnd:
   stbi__rewind(s);
   return res;
}","{'begin': {'line': 5820, 'column': 1}, 'end': {'line': 5849, 'column': 2}}",play_bmp_sequence.c,"['检测', '输入', '流', '是否', '为', '有效', '的', 'TGA', '图像', '格式', '图像格式']"
314,314,stbi__png_load,void *,"void * stbi__png_load(stbi__context * s, int * x, int * y, int * comp, int req_comp, stbi__result_info * ri)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'ri', 'type': 'stbi__result_info *'}]",加载并解析PNG图像数据，返回处理结果,"static void *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   stbi__png p;
   p.s = s;
   return stbi__do_png(&p, x,y,comp,req_comp, ri);
}","{'begin': {'line': 5295, 'column': 1}, 'end': {'line': 5300, 'column': 2}}",play_bmp_sequence.c,"['加载', '并', '解析', 'PNG', '图像', '数据', '，', '返回', '处理', '结果', '处理结果']"
315,315,stbi__png_test,int,int stbi__png_test(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",检查输入流是否为PNG格式图像,"static int stbi__png_test(stbi__context *s)
{
   int r;
   r = stbi__check_png_header(s);
   stbi__rewind(s);
   return r;
}","{'begin': {'line': 5302, 'column': 1}, 'end': {'line': 5308, 'column': 2}}",play_bmp_sequence.c,"['检查', '输入', '流', '是否', '为', 'PNG', '格式', '图像']"
316,316,stbi__png_info_raw,int,"int stbi__png_info_raw(stbi__png * p, int * x, int * y, int * comp)","[{'name': 'p', 'type': 'stbi__png *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",解析PNG图像头部信息，获取尺寸和通道数,"static int stbi__png_info_raw(stbi__png *p, int *x, int *y, int *comp)
{
   if (!stbi__parse_png_file(p, STBI__SCAN_header, 0)) {
      stbi__rewind( p->s );
      return 0;
   }
   if (x) *x = p->s->img_x;
   if (y) *y = p->s->img_y;
   if (comp) *comp = p->s->img_n;
   return 1;
}","{'begin': {'line': 5310, 'column': 1}, 'end': {'line': 5320, 'column': 2}}",play_bmp_sequence.c,"['解析', 'PNG', '图像', '头部', '信息', '，', '获取', '尺寸', '和', '通道', '数']"
317,317,stbi__tga_read_rgb16,void,"void stbi__tga_read_rgb16(stbi__context * s, stbi_uc * out)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'out', 'type': 'stbi_uc *'}]",读取16位TGA RGB数据并转换为24位格式,"static void stbi__tga_read_rgb16(stbi__context *s, stbi_uc* out)
{
   stbi__uint16 px = (stbi__uint16)stbi__get16le(s);
   stbi__uint16 fiveBitMask = 31;
   // we have 3 channels with 5bits each
   int r = (px >> 10) & fiveBitMask;
   int g = (px >> 5) & fiveBitMask;
   int b = px & fiveBitMask;
   // Note that this saves the data in RGB(A) order, so it doesn't need to be swapped later
   out[0] = (stbi_uc)((r * 255)/31);
   out[1] = (stbi_uc)((g * 255)/31);
   out[2] = (stbi_uc)((b * 255)/31);

   // some people claim that the most significant bit might be used for alpha
   // (possibly if an alpha-bit is set in the ""image descriptor byte"")
   // but that only made 16bit test images completely translucent..
   // so let's treat all 15 and 16bit TGAs as RGB with no alpha.
}","{'begin': {'line': 5852, 'column': 1}, 'end': {'line': 5869, 'column': 2}}",play_bmp_sequence.c,"['读取', '16', '位', 'TGA', ' ', 'RGB', '数据', '并', '转换', '为', '24', '位', '格式']"
318,318,stbi__png_info,int,"int stbi__png_info(stbi__context * s, int * x, int * y, int * comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",获取PNG图像信息（宽、高、通道数）,"static int stbi__png_info(stbi__context *s, int *x, int *y, int *comp)
{
   stbi__png p;
   p.s = s;
   return stbi__png_info_raw(&p, x, y, comp);
}","{'begin': {'line': 5322, 'column': 1}, 'end': {'line': 5327, 'column': 2}}",play_bmp_sequence.c,"['获取', 'PNG', '图像', '信息', '（', '宽', '、', '高', '、', '通道', '数', '）']"
319,319,stbi__png_is16,int,int stbi__png_is16(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",检查PNG图像是否为16位深度,"static int stbi__png_is16(stbi__context *s)
{
   stbi__png p;
   p.s = s;
   if (!stbi__png_info_raw(&p, NULL, NULL, NULL))
	   return 0;
   if (p.depth != 16) {
      stbi__rewind(p.s);
      return 0;
   }
   return 1;
}","{'begin': {'line': 5329, 'column': 1}, 'end': {'line': 5340, 'column': 2}}",play_bmp_sequence.c,"['检查', 'PNG', '图像', '是否', '为', '16', '位', '深度']"
320,320,stbi__bmp_test_raw,int,int stbi__bmp_test_raw(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",验证BMP文件头及版本是否有效,"static int stbi__bmp_test_raw(stbi__context *s)
{
   int r;
   int sz;
   if (stbi__get8(s) != 'B') return 0;
   if (stbi__get8(s) != 'M') return 0;
   stbi__get32le(s); // discard filesize
   stbi__get16le(s); // discard reserved
   stbi__get16le(s); // discard reserved
   stbi__get32le(s); // discard data offset
   sz = stbi__get32le(s);
   r = (sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124);
   return r;
}","{'begin': {'line': 5346, 'column': 1}, 'end': {'line': 5359, 'column': 2}}",play_bmp_sequence.c,"['验证', 'BMP', '文件', '头及', '版本', '是否', '有效']"
321,321,stbi__tga_load,void *,"void * stbi__tga_load(stbi__context * s, int * x, int * y, int * comp, int req_comp, stbi__result_info * ri)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'ri', 'type': 'stbi__result_info *'}]",加载并解码TGA图像数据，支持调色板和RLE压缩。,"static void *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   //   read in the TGA header stuff
   int tga_offset = stbi__get8(s);
   int tga_indexed = stbi__get8(s);
   int tga_image_type = stbi__get8(s);
   int tga_is_RLE = 0;
   int tga_palette_start = stbi__get16le(s);
   int tga_palette_len = stbi__get16le(s);
   int tga_palette_bits = stbi__get8(s);
   int tga_x_origin = stbi__get16le(s);
   int tga_y_origin = stbi__get16le(s);
   int tga_width = stbi__get16le(s);
   int tga_height = stbi__get16le(s);
   int tga_bits_per_pixel = stbi__get8(s);
   int tga_comp, tga_rgb16=0;
   int tga_inverted = stbi__get8(s);
   // int tga_alpha_bits = tga_inverted & 15; // the 4 lowest bits - unused (useless?)
   //   image data
   unsigned char *tga_data;
   unsigned char *tga_palette = NULL;
   int i, j;
   unsigned char raw_data[4] = {0};
   int RLE_count = 0;
   int RLE_repeating = 0;
   int read_next_pixel = 1;
   STBI_NOTUSED(ri);
   STBI_NOTUSED(tga_x_origin); // @TODO
   STBI_NOTUSED(tga_y_origin); // @TODO

   if (tga_height > STBI_MAX_DIMENSIONS) return stbi__errpuc(""too large"",""Very large image (corrupt?)"");
   if (tga_width > STBI_MAX_DIMENSIONS) return stbi__errpuc(""too large"",""Very large image (corrupt?)"");

   //   do a tiny bit of precessing
   if ( tga_image_type >= 8 )
   {
      tga_image_type -= 8;
      tga_is_RLE = 1;
   }
   tga_inverted = 1 - ((tga_inverted >> 5) & 1);

   //   If I'm paletted, then I'll use the number of bits from the palette
   if ( tga_indexed ) tga_comp = stbi__tga_get_comp(tga_palette_bits, 0, &tga_rgb16);
   else tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3), &tga_rgb16);

   if(!tga_comp) // shouldn't really happen, stbi__tga_test() should have ensured basic consistency
      return stbi__errpuc(""bad format"", ""Can't find out TGA pixelformat"");

   //   tga info
   *x = tga_width;
   *y = tga_height;
   if (comp) *comp = tga_comp;

   if (!stbi__mad3sizes_valid(tga_width, tga_height, tga_comp, 0))
      return stbi__errpuc(""too large"", ""Corrupt TGA"");

   tga_data = (unsigned char*)stbi__malloc_mad3(tga_width, tga_height, tga_comp, 0);
   if (!tga_data) return stbi__errpuc(""outofmem"", ""Out of memory"");

   // skip to the data's starting position (offset usually = 0)
   stbi__skip(s, tga_offset );

   if ( !tga_indexed && !tga_is_RLE && !tga_rgb16 ) {
      for (i=0; i < tga_height; ++i) {
         int row = tga_inverted ? tga_height -i - 1 : i;
         stbi_uc *tga_row = tga_data + row*tga_width*tga_comp;
         stbi__getn(s, tga_row, tga_width * tga_comp);
      }
   } else  {
      //   do I need to load a palette?
      if ( tga_indexed)
      {
         if (tga_palette_len == 0) {  /* you have to have at least one entry! */
            STBI_FREE(tga_data);
            return stbi__errpuc(""bad palette"", ""Corrupt TGA"");
         }

         //   any data to skip? (offset usually = 0)
         stbi__skip(s, tga_palette_start );
         //   load the palette
         tga_palette = (unsigned char*)stbi__malloc_mad2(tga_palette_len, tga_comp, 0);
         if (!tga_palette) {
            STBI_FREE(tga_data);
            return stbi__errpuc(""outofmem"", ""Out of memory"");
         }
         if (tga_rgb16) {
            stbi_uc *pal_entry = tga_palette;
            STBI_ASSERT(tga_comp == STBI_rgb);
            for (i=0; i < tga_palette_len; ++i) {
               stbi__tga_read_rgb16(s, pal_entry);
               pal_entry += tga_comp;
            }
         } else if (!stbi__getn(s, tga_palette, tga_palette_len * tga_comp)) {
               STBI_FREE(tga_data);
               STBI_FREE(tga_palette);
               return stbi__errpuc(""bad palette"", ""Corrupt TGA"");
         }
      }
      //   load the data
      for (i=0; i < tga_width * tga_height; ++i)
      {
         //   if I'm in RLE mode, do I need to get a RLE stbi__pngchunk?
         if ( tga_is_RLE )
         {
            if ( RLE_count == 0 )
            {
               //   yep, get the next byte as a RLE command
               int RLE_cmd = stbi__get8(s);
               RLE_count = 1 + (RLE_cmd & 127);
               RLE_repeating = RLE_cmd >> 7;
               read_next_pixel = 1;
            } else if ( !RLE_repeating )
            {
               read_next_pixel = 1;
            }
         } else
         {
            read_next_pixel = 1;
         }
         //   OK, if I need to read a pixel, do it now
         if ( read_next_pixel )
         {
            //   load however much data we did have
            if ( tga_indexed )
            {
               // read in index, then perform the lookup
               int pal_idx = (tga_bits_per_pixel == 8) ? stbi__get8(s) : stbi__get16le(s);
               if ( pal_idx >= tga_palette_len ) {
                  // invalid index
                  pal_idx = 0;
               }
               pal_idx *= tga_comp;
               for (j = 0; j < tga_comp; ++j) {
                  raw_data[j] = tga_palette[pal_idx+j];
               }
            } else if(tga_rgb16) {
               STBI_ASSERT(tga_comp == STBI_rgb);
               stbi__tga_read_rgb16(s, raw_data);
            } else {
               //   read in the data raw
               for (j = 0; j < tga_comp; ++j) {
                  raw_data[j] = stbi__get8(s);
               }
            }
            //   clear the reading flag for the next pixel
            read_next_pixel = 0;
         } // end of reading a pixel

         // copy data
         for (j = 0; j < tga_comp; ++j)
           tga_data[i*tga_comp+j] = raw_data[j];

         //   in case we're in RLE mode, keep counting down
         --RLE_count;
      }
      //   do I need to invert the image?
      if ( tga_inverted )
      {
         for (j = 0; j*2 < tga_height; ++j)
         {
            int index1 = j * tga_width * tga_comp;
            int index2 = (tga_height - 1 - j) * tga_width * tga_comp;
            for (i = tga_width * tga_comp; i > 0; --i)
            {
               unsigned char temp = tga_data[index1];
               tga_data[index1] = tga_data[index2];
               tga_data[index2] = temp;
               ++index1;
               ++index2;
            }
         }
      }
      //   clear my palette, if I had one
      if ( tga_palette != NULL )
      {
         STBI_FREE( tga_palette );
      }
   }

   // swap RGB - if the source data was RGB16, it already is in the right order
   if (tga_comp >= 3 && !tga_rgb16)
   {
      unsigned char* tga_pixel = tga_data;
      for (i=0; i < tga_width * tga_height; ++i)
      {
         unsigned char temp = tga_pixel[0];
         tga_pixel[0] = tga_pixel[2];
         tga_pixel[2] = temp;
         tga_pixel += tga_comp;
      }
   }

   // convert to target component count
   if (req_comp && req_comp != tga_comp)
      tga_data = stbi__convert_format(tga_data, tga_comp, req_comp, tga_width, tga_height);

   //   the things I do to get rid of an error message, and yet keep
   //   Microsoft's C compilers happy... [8^(
   tga_palette_start = tga_palette_len = tga_palette_bits =
         tga_x_origin = tga_y_origin = 0;
   STBI_NOTUSED(tga_palette_start);
   //   OK, done
   return tga_data;
}","{'begin': {'line': 5871, 'column': 1}, 'end': {'line': 6074, 'column': 2}}",play_bmp_sequence.c,"['加载', '并', '解码', 'TGA', '图像', '数据', '，', '支持', '调色', '调色板', '和', 'RLE', '压缩', '。']"
322,322,stbi__bmp_test,int,int stbi__bmp_test(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",检测是否为BMP格式并重置流位置,"static int stbi__bmp_test(stbi__context *s)
{
   int r = stbi__bmp_test_raw(s);
   stbi__rewind(s);
   return r;
}","{'begin': {'line': 5361, 'column': 1}, 'end': {'line': 5366, 'column': 2}}",play_bmp_sequence.c,"['检测', '是否', '为', 'BMP', '格式', '并', '重置', '流', '位置']"
323,323,stbi__high_bit,int,int stbi__high_bit(unsigned int z),"[{'name': 'z', 'type': 'unsigned int'}]",计算无符号整数的最高有效位位置,"static int stbi__high_bit(unsigned int z)
{
   int n=0;
   if (z == 0) return -1;
   if (z >= 0x10000) { n += 16; z >>= 16; }
   if (z >= 0x00100) { n +=  8; z >>=  8; }
   if (z >= 0x00010) { n +=  4; z >>=  4; }
   if (z >= 0x00004) { n +=  2; z >>=  2; }
   if (z >= 0x00002) { n +=  1;/* >>=  1;*/ }
   return n;
}","{'begin': {'line': 5370, 'column': 1}, 'end': {'line': 5380, 'column': 2}}",play_bmp_sequence.c,"['计算', '无', '符号', '整数', '的', '最高', '有效', '位', '位置']"
324,324,stbi__bitcount,int,int stbi__bitcount(unsigned int a),"[{'name': 'a', 'type': 'unsigned int'}]","嗯，用户之前让我生成一个函数stbi__bitcount的摘要，要求不超过50字，而且不能包含文件地址。我之前给出的回答是“计算无符号整数二进制1的个数”，现在用户再次给出同样的指令，可能是希望进一步优化或者确认。

我需要检查之前的回答是否符合要求。原函数通过位操作分步骤统计二进制中的1的个数，使用位掩码和移位相加的方法。之前的摘要已经简洁地描述了功能，即计算无符号整数二进制中的1的个数，符合50字限制，也没有包含文件路径。用户可能希望更简洁，或者确认是否还有改进空间。但当前摘要已经很精炼，可能用户只是想确认，或者需要再次确认是否满足所有规则。所以保持原回答是合理的。
</think>

{""name"": ""stbi__bitcount"", ""summary"": ""位运算统计无符号整数二进制中1的个数""}","static int stbi__bitcount(unsigned int a)
{
   a = (a & 0x55555555) + ((a >>  1) & 0x55555555); // max 2
   a = (a & 0x33333333) + ((a >>  2) & 0x33333333); // max 4
   a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits
   a = (a + (a >> 8)); // max 16 per 8 bits
   a = (a + (a >> 16)); // max 32 per 8 bits
   return a & 0xff;
}","{'begin': {'line': 5382, 'column': 1}, 'end': {'line': 5390, 'column': 2}}",play_bmp_sequence.c,"['嗯', '，', '用户', '之前', '让', '我', '生成', '一个', '函数', 'stbi', '__', 'bitcount', '的', '摘要', '，', '要求', '不', '超过', '50', '字', '，', '而且', '不能', '包含', '文件', '地址', '。', '我', '之前', '给出', '的', '回答', '是', '“', '计算', '无', '符号', '整数', '进制', '二进制', '1', '的', '个数', '”', '，', '现在', '用户', '再次', '给出', '同样', '的', '指令', '，', '可能', '是', '希望', '一步', '进一步', '优化', '或者', '确认', '。', '\n', '\n', '我', '需要', '检查', '之前', '的', '回答', '是否', '符合', '要求', '符合要求', '。', '函数', '原函数', '通过', '操作', '位操作', '分', '步骤', '统计', '进制', '二进制', '中', '的', '1', '的', '个数', '，', '使用', '位', '掩码', '和', '移位', '相加', '的', '方法', '。', '之前', '的', '摘要', '已经', '简洁', '地', '描述', '了', '功能', '，', '即', '计算', '无', '符号', '整数', '进制', '二进制', '中', '的', '1', '的', '个数', '，', '符合', '50', '字', '限制', '，', '也', '没有', '包含', '文件', '路径', '。', '用户', '可能', '希望', '更', '简洁', '，', '或者', '确认', '是否', '还有', '改进', '空间', '。', '但', '当前', '摘要', '已经', '很', '精炼', '，', '可能', '用户', '只是', '想', '确认', '，', '或者', '需要', '再次', '确认', '是否', '满足', '所有', '规则', '。', '所以', '保持', '原', '回答', '是', '合理', '的', '。', '\n', '<', '/', 'think', '>', '\n', '\n', '{', '""', 'name', '""', ':', ' ', '""', 'stbi', '__', 'bitcount', '""', ',', ' ', '""', 'summary', '""', ':', ' ', '""', '位', '运算', '统计', '无', '符号', '整数', '进制', '二进制', '中', '1', '的', '个数', '""', '}']"
325,325,stbi__shiftsigned,int,"int stbi__shiftsigned(unsigned int v, int shift, int bits)","[{'name': 'v', 'type': 'unsigned int'}, {'name': 'shift', 'type': 'int'}, {'name': 'bits', 'type': 'int'}]",通过位移和乘法表调整数值的位表示,"static int stbi__shiftsigned(unsigned int v, int shift, int bits)
{
   static unsigned int mul_table[9] = {
      0,
      0xff/*0b11111111*/, 0x55/*0b01010101*/, 0x49/*0b01001001*/, 0x11/*0b00010001*/,
      0x21/*0b00100001*/, 0x41/*0b01000001*/, 0x81/*0b10000001*/, 0x01/*0b00000001*/,
   };
   static unsigned int shift_table[9] = {
      0, 0,0,1,0,2,4,6,0,
   };
   if (shift < 0)
      v <<= -shift;
   else
      v >>= shift;
   STBI_ASSERT(v < 256);
   v >>= (8-bits);
   STBI_ASSERT(bits >= 0 && bits <= 8);
   return (int) ((unsigned) v * mul_table[bits]) >> shift_table[bits];
}","{'begin': {'line': 5395, 'column': 1}, 'end': {'line': 5413, 'column': 2}}",play_bmp_sequence.c,"['通过', '位移', '和', '乘法', '乘法表', '调整', '数值', '的', '位', '表示']"
326,326,stbi__bmp_set_mask_defaults,int,"int stbi__bmp_set_mask_defaults(stbi__bmp_data * info, int compress)","[{'name': 'info', 'type': 'stbi__bmp_data *'}, {'name': 'compress', 'type': 'int'}]",根据压缩类型和位深设置BMP颜色掩码默认值,"static int stbi__bmp_set_mask_defaults(stbi__bmp_data *info, int compress)
{
   // BI_BITFIELDS specifies masks explicitly, don't override
   if (compress == 3)
      return 1;

   if (compress == 0) {
      if (info->bpp == 16) {
         info->mr = 31u << 10;
         info->mg = 31u <<  5;
         info->mb = 31u <<  0;
      } else if (info->bpp == 32) {
         info->mr = 0xffu << 16;
         info->mg = 0xffu <<  8;
         info->mb = 0xffu <<  0;
         info->ma = 0xffu << 24;
         info->all_a = 0; // if all_a is 0 at end, then we loaded alpha channel but it was all 0
      } else {
         // otherwise, use defaults, which is all-0
         info->mr = info->mg = info->mb = info->ma = 0;
      }
      return 1;
   }
   return 0; // error
}","{'begin': {'line': 5422, 'column': 1}, 'end': {'line': 5446, 'column': 2}}",play_bmp_sequence.c,"['根据', '压缩', '类型', '和', '位深', '设置', 'BMP', '颜色', '掩码', '默认', '默认值']"
327,327,stbi__psd_test,int,int stbi__psd_test(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",检测输入是否为PSD格式文件,"static int stbi__psd_test(stbi__context *s)
{
   int r = (stbi__get32be(s) == 0x38425053);
   stbi__rewind(s);
   return r;
}","{'begin': {'line': 6081, 'column': 1}, 'end': {'line': 6086, 'column': 2}}",play_bmp_sequence.c,"['检测', '输入', '是否', '为', 'PSD', '格式', '文件', '格式文件']"
328,328,stbi__bmp_parse_header,void *,"void * stbi__bmp_parse_header(stbi__context * s, stbi__bmp_data * info)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'info', 'type': 'stbi__bmp_data *'}]",解析BMP文件头并校验格式有效性,"static void *stbi__bmp_parse_header(stbi__context *s, stbi__bmp_data *info)
{
   int hsz;
   if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') return stbi__errpuc(""not BMP"", ""Corrupt BMP"");
   stbi__get32le(s); // discard filesize
   stbi__get16le(s); // discard reserved
   stbi__get16le(s); // discard reserved
   info->offset = stbi__get32le(s);
   info->hsz = hsz = stbi__get32le(s);
   info->mr = info->mg = info->mb = info->ma = 0;
   info->extra_read = 14;

   if (info->offset < 0) return stbi__errpuc(""bad BMP"", ""bad BMP"");

   if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108 && hsz != 124) return stbi__errpuc(""unknown BMP"", ""BMP type not supported: unknown"");
   if (hsz == 12) {
      s->img_x = stbi__get16le(s);
      s->img_y = stbi__get16le(s);
   } else {
      s->img_x = stbi__get32le(s);
      s->img_y = stbi__get32le(s);
   }
   if (stbi__get16le(s) != 1) return stbi__errpuc(""bad BMP"", ""bad BMP"");
   info->bpp = stbi__get16le(s);
   if (hsz != 12) {
      int compress = stbi__get32le(s);
      if (compress == 1 || compress == 2) return stbi__errpuc(""BMP RLE"", ""BMP type not supported: RLE"");
      if (compress >= 4) return stbi__errpuc(""BMP JPEG/PNG"", ""BMP type not supported: unsupported compression""); // this includes PNG/JPEG modes
      if (compress == 3 && info->bpp != 16 && info->bpp != 32) return stbi__errpuc(""bad BMP"", ""bad BMP""); // bitfields requires 16 or 32 bits/pixel
      stbi__get32le(s); // discard sizeof
      stbi__get32le(s); // discard hres
      stbi__get32le(s); // discard vres
      stbi__get32le(s); // discard colorsused
      stbi__get32le(s); // discard max important
      if (hsz == 40 || hsz == 56) {
         if (hsz == 56) {
            stbi__get32le(s);
            stbi__get32le(s);
            stbi__get32le(s);
            stbi__get32le(s);
         }
         if (info->bpp == 16 || info->bpp == 32) {
            if (compress == 0) {
               stbi__bmp_set_mask_defaults(info, compress);
            } else if (compress == 3) {
               info->mr = stbi__get32le(s);
               info->mg = stbi__get32le(s);
               info->mb = stbi__get32le(s);
               info->extra_read += 12;
               // not documented, but generated by photoshop and handled by mspaint
               if (info->mr == info->mg && info->mg == info->mb) {
                  // ?!?!?
                  return stbi__errpuc(""bad BMP"", ""bad BMP"");
               }
            } else
               return stbi__errpuc(""bad BMP"", ""bad BMP"");
         }
      } else {
         // V4/V5 header
         int i;
         if (hsz != 108 && hsz != 124)
            return stbi__errpuc(""bad BMP"", ""bad BMP"");
         info->mr = stbi__get32le(s);
         info->mg = stbi__get32le(s);
         info->mb = stbi__get32le(s);
         info->ma = stbi__get32le(s);
         if (compress != 3) // override mr/mg/mb unless in BI_BITFIELDS mode, as per docs
            stbi__bmp_set_mask_defaults(info, compress);
         stbi__get32le(s); // discard color space
         for (i=0; i < 12; ++i)
            stbi__get32le(s); // discard color space parameters
         if (hsz == 124) {
            stbi__get32le(s); // discard rendering intent
            stbi__get32le(s); // discard offset of profile data
            stbi__get32le(s); // discard size of profile data
            stbi__get32le(s); // discard reserved
         }
      }
   }
   return (void *) 1;
}","{'begin': {'line': 5448, 'column': 1}, 'end': {'line': 5528, 'column': 2}}",play_bmp_sequence.c,"['解析', 'BMP', '文件', '头', '并', '校验', '格式', '有效', '有效性']"
329,329,stbi__psd_decode_rle,int,"int stbi__psd_decode_rle(stbi__context * s, stbi_uc * p, int pixelCount)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'p', 'type': 'stbi_uc *'}, {'name': 'pixelCount', 'type': 'int'}]",解码PSD格式的RLE压缩像素数据,"static int stbi__psd_decode_rle(stbi__context *s, stbi_uc *p, int pixelCount)
{
   int count, nleft, len;

   count = 0;
   while ((nleft = pixelCount - count) > 0) {
      len = stbi__get8(s);
      if (len == 128) {
         // No-op.
      } else if (len < 128) {
         // Copy next len+1 bytes literally.
         len++;
         if (len > nleft) return 0; // corrupt data
         count += len;
         while (len) {
            *p = stbi__get8(s);
            p += 4;
            len--;
         }
      } else if (len > 128) {
         stbi_uc   val;
         // Next -len+1 bytes in the dest are replicated from next source byte.
         // (Interpret len as a negative 8-bit int.)
         len = 257 - len;
         if (len > nleft) return 0; // corrupt data
         val = stbi__get8(s);
         count += len;
         while (len) {
            *p = val;
            p += 4;
            len--;
         }
      }
   }

   return 1;
}","{'begin': {'line': 6088, 'column': 1}, 'end': {'line': 6124, 'column': 2}}",play_bmp_sequence.c,"['解码', 'PSD', '格式', '的', 'RLE', '压缩', '像素', '数据']"
330,330,stbi__psd_load,void *,"void * stbi__psd_load(stbi__context * s, int * x, int * y, int * comp, int req_comp, stbi__result_info * ri, int bpc)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'ri', 'type': 'stbi__result_info *'}, {'name': 'bpc', 'type': 'int'}]",加载并解析PSD图像，支持RLE压缩及通道调整,"static void *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)
{
   int pixelCount;
   int channelCount, compression;
   int channel, i;
   int bitdepth;
   int w,h;
   stbi_uc *out;
   STBI_NOTUSED(ri);

   // Check identifier
   if (stbi__get32be(s) != 0x38425053)   // ""8BPS""
      return stbi__errpuc(""not PSD"", ""Corrupt PSD image"");

   // Check file type version.
   if (stbi__get16be(s) != 1)
      return stbi__errpuc(""wrong version"", ""Unsupported version of PSD image"");

   // Skip 6 reserved bytes.
   stbi__skip(s, 6 );

   // Read the number of channels (R, G, B, A, etc).
   channelCount = stbi__get16be(s);
   if (channelCount < 0 || channelCount > 16)
      return stbi__errpuc(""wrong channel count"", ""Unsupported number of channels in PSD image"");

   // Read the rows and columns of the image.
   h = stbi__get32be(s);
   w = stbi__get32be(s);

   if (h > STBI_MAX_DIMENSIONS) return stbi__errpuc(""too large"",""Very large image (corrupt?)"");
   if (w > STBI_MAX_DIMENSIONS) return stbi__errpuc(""too large"",""Very large image (corrupt?)"");

   // Make sure the depth is 8 bits.
   bitdepth = stbi__get16be(s);
   if (bitdepth != 8 && bitdepth != 16)
      return stbi__errpuc(""unsupported bit depth"", ""PSD bit depth is not 8 or 16 bit"");

   // Make sure the color mode is RGB.
   // Valid options are:
   //   0: Bitmap
   //   1: Grayscale
   //   2: Indexed color
   //   3: RGB color
   //   4: CMYK color
   //   7: Multichannel
   //   8: Duotone
   //   9: Lab color
   if (stbi__get16be(s) != 3)
      return stbi__errpuc(""wrong color format"", ""PSD is not in RGB color format"");

   // Skip the Mode Data.  (It's the palette for indexed color; other info for other modes.)
   stbi__skip(s,stbi__get32be(s) );

   // Skip the image resources.  (resolution, pen tool paths, etc)
   stbi__skip(s, stbi__get32be(s) );

   // Skip the reserved data.
   stbi__skip(s, stbi__get32be(s) );

   // Find out if the data is compressed.
   // Known values:
   //   0: no compression
   //   1: RLE compressed
   compression = stbi__get16be(s);
   if (compression > 1)
      return stbi__errpuc(""bad compression"", ""PSD has an unknown compression format"");

   // Check size
   if (!stbi__mad3sizes_valid(4, w, h, 0))
      return stbi__errpuc(""too large"", ""Corrupt PSD"");

   // Create the destination image.

   if (!compression && bitdepth == 16 && bpc == 16) {
      out = (stbi_uc *) stbi__malloc_mad3(8, w, h, 0);
      ri->bits_per_channel = 16;
   } else
      out = (stbi_uc *) stbi__malloc(4 * w*h);

   if (!out) return stbi__errpuc(""outofmem"", ""Out of memory"");
   pixelCount = w*h;

   // Initialize the data to zero.
   //memset( out, 0, pixelCount * 4 );

   // Finally, the image data.
   if (compression) {
      // RLE as used by .PSD and .TIFF
      // Loop until you get the number of unpacked bytes you are expecting:
      //     Read the next source byte into n.
      //     If n is between 0 and 127 inclusive, copy the next n+1 bytes literally.
      //     Else if n is between -127 and -1 inclusive, copy the next byte -n+1 times.
      //     Else if n is 128, noop.
      // Endloop

      // The RLE-compressed data is preceded by a 2-byte data count for each row in the data,
      // which we're going to just skip.
      stbi__skip(s, h * channelCount * 2 );

      // Read the RLE data by channel.
      for (channel = 0; channel < 4; channel++) {
         stbi_uc *p;

         p = out+channel;
         if (channel >= channelCount) {
            // Fill this channel with default data.
            for (i = 0; i < pixelCount; i++, p += 4)
               *p = (channel == 3 ? 255 : 0);
         } else {
            // Read the RLE data.
            if (!stbi__psd_decode_rle(s, p, pixelCount)) {
               STBI_FREE(out);
               return stbi__errpuc(""corrupt"", ""bad RLE data"");
            }
         }
      }

   } else {
      // We're at the raw image data.  It's each channel in order (Red, Green, Blue, Alpha, ...)
      // where each channel consists of an 8-bit (or 16-bit) value for each pixel in the image.

      // Read the data by channel.
      for (channel = 0; channel < 4; channel++) {
         if (channel >= channelCount) {
            // Fill this channel with default data.
            if (bitdepth == 16 && bpc == 16) {
               stbi__uint16 *q = ((stbi__uint16 *) out) + channel;
               stbi__uint16 val = channel == 3 ? 65535 : 0;
               for (i = 0; i < pixelCount; i++, q += 4)
                  *q = val;
            } else {
               stbi_uc *p = out+channel;
               stbi_uc val = channel == 3 ? 255 : 0;
               for (i = 0; i < pixelCount; i++, p += 4)
                  *p = val;
            }
         } else {
            if (ri->bits_per_channel == 16) {    // output bpc
               stbi__uint16 *q = ((stbi__uint16 *) out) + channel;
               for (i = 0; i < pixelCount; i++, q += 4)
                  *q = (stbi__uint16) stbi__get16be(s);
            } else {
               stbi_uc *p = out+channel;
               if (bitdepth == 16) {  // input bpc
                  for (i = 0; i < pixelCount; i++, p += 4)
                     *p = (stbi_uc) (stbi__get16be(s) >> 8);
               } else {
                  for (i = 0; i < pixelCount; i++, p += 4)
                     *p = stbi__get8(s);
               }
            }
         }
      }
   }

   // remove weird white matte from PSD
   if (channelCount >= 4) {
      if (ri->bits_per_channel == 16) {
         for (i=0; i < w*h; ++i) {
            stbi__uint16 *pixel = (stbi__uint16 *) out + 4*i;
            if (pixel[3] != 0 && pixel[3] != 65535) {
               float a = pixel[3] / 65535.0f;
               float ra = 1.0f / a;
               float inv_a = 65535.0f * (1 - ra);
               pixel[0] = (stbi__uint16) (pixel[0]*ra + inv_a);
               pixel[1] = (stbi__uint16) (pixel[1]*ra + inv_a);
               pixel[2] = (stbi__uint16) (pixel[2]*ra + inv_a);
            }
         }
      } else {
         for (i=0; i < w*h; ++i) {
            unsigned char *pixel = out + 4*i;
            if (pixel[3] != 0 && pixel[3] != 255) {
               float a = pixel[3] / 255.0f;
               float ra = 1.0f / a;
               float inv_a = 255.0f * (1 - ra);
               pixel[0] = (unsigned char) (pixel[0]*ra + inv_a);
               pixel[1] = (unsigned char) (pixel[1]*ra + inv_a);
               pixel[2] = (unsigned char) (pixel[2]*ra + inv_a);
            }
         }
      }
   }

   // convert to desired output format
   if (req_comp && req_comp != 4) {
      if (ri->bits_per_channel == 16)
         out = (stbi_uc *) stbi__convert_format16((stbi__uint16 *) out, 4, req_comp, w, h);
      else
         out = stbi__convert_format(out, 4, req_comp, w, h);
      if (out == NULL) return out; // stbi__convert_format frees input on failure
   }

   if (comp) *comp = 4;
   *y = h;
   *x = w;

   return out;
}","{'begin': {'line': 6126, 'column': 1}, 'end': {'line': 6325, 'column': 2}}",play_bmp_sequence.c,"['加载', '并', '解析', 'PSD', '图像', '，', '支持', 'RLE', '压缩', '及', '通道', '调整']"
331,331,stbi__bmp_load,void *,"void * stbi__bmp_load(stbi__context * s, int * x, int * y, int * comp, int req_comp, stbi__result_info * ri)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'ri', 'type': 'stbi__result_info *'}]",加载并解码BMP图像数据，支持多种位深和通道转换,"static void *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   stbi_uc *out;
   unsigned int mr=0,mg=0,mb=0,ma=0, all_a;
   stbi_uc pal[256][4];
   int psize=0,i,j,width;
   int flip_vertically, pad, target;
   stbi__bmp_data info;
   STBI_NOTUSED(ri);

   info.all_a = 255;
   if (stbi__bmp_parse_header(s, &info) == NULL)
      return NULL; // error code already set

   flip_vertically = ((int) s->img_y) > 0;
   s->img_y = abs((int) s->img_y);

   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc(""too large"",""Very large image (corrupt?)"");
   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc(""too large"",""Very large image (corrupt?)"");

   mr = info.mr;
   mg = info.mg;
   mb = info.mb;
   ma = info.ma;
   all_a = info.all_a;

   if (info.hsz == 12) {
      if (info.bpp < 24)
         psize = (info.offset - info.extra_read - 24) / 3;
   } else {
      if (info.bpp < 16)
         psize = (info.offset - info.extra_read - info.hsz) >> 2;
   }
   if (psize == 0) {
      // accept some number of extra bytes after the header, but if the offset points either to before
      // the header ends or implies a large amount of extra data, reject the file as malformed
      int bytes_read_so_far = s->callback_already_read + (int)(s->img_buffer - s->img_buffer_original);
      int header_limit = 1024; // max we actually read is below 256 bytes currently.
      int extra_data_limit = 256*4; // what ordinarily goes here is a palette; 256 entries*4 bytes is its max size.
      if (bytes_read_so_far <= 0 || bytes_read_so_far > header_limit) {
         return stbi__errpuc(""bad header"", ""Corrupt BMP"");
      }
      // we established that bytes_read_so_far is positive and sensible.
      // the first half of this test rejects offsets that are either too small positives, or
      // negative, and guarantees that info.offset >= bytes_read_so_far > 0. this in turn
      // ensures the number computed in the second half of the test can't overflow.
      if (info.offset < bytes_read_so_far || info.offset - bytes_read_so_far > extra_data_limit) {
         return stbi__errpuc(""bad offset"", ""Corrupt BMP"");
      } else {
         stbi__skip(s, info.offset - bytes_read_so_far);
      }
   }

   if (info.bpp == 24 && ma == 0xff000000)
      s->img_n = 3;
   else
      s->img_n = ma ? 4 : 3;
   if (req_comp && req_comp >= 3) // we can directly decode 3 or 4
      target = req_comp;
   else
      target = s->img_n; // if they want monochrome, we'll post-convert

   // sanity-check size
   if (!stbi__mad3sizes_valid(target, s->img_x, s->img_y, 0))
      return stbi__errpuc(""too large"", ""Corrupt BMP"");

   out = (stbi_uc *) stbi__malloc_mad3(target, s->img_x, s->img_y, 0);
   if (!out) return stbi__errpuc(""outofmem"", ""Out of memory"");
   if (info.bpp < 16) {
      int z=0;
      if (psize == 0 || psize > 256) { STBI_FREE(out); return stbi__errpuc(""invalid"", ""Corrupt BMP""); }
      for (i=0; i < psize; ++i) {
         pal[i][2] = stbi__get8(s);
         pal[i][1] = stbi__get8(s);
         pal[i][0] = stbi__get8(s);
         if (info.hsz != 12) stbi__get8(s);
         pal[i][3] = 255;
      }
      stbi__skip(s, info.offset - info.extra_read - info.hsz - psize * (info.hsz == 12 ? 3 : 4));
      if (info.bpp == 1) width = (s->img_x + 7) >> 3;
      else if (info.bpp == 4) width = (s->img_x + 1) >> 1;
      else if (info.bpp == 8) width = s->img_x;
      else { STBI_FREE(out); return stbi__errpuc(""bad bpp"", ""Corrupt BMP""); }
      pad = (-width)&3;
      if (info.bpp == 1) {
         for (j=0; j < (int) s->img_y; ++j) {
            int bit_offset = 7, v = stbi__get8(s);
            for (i=0; i < (int) s->img_x; ++i) {
               int color = (v>>bit_offset)&0x1;
               out[z++] = pal[color][0];
               out[z++] = pal[color][1];
               out[z++] = pal[color][2];
               if (target == 4) out[z++] = 255;
               if (i+1 == (int) s->img_x) break;
               if((--bit_offset) < 0) {
                  bit_offset = 7;
                  v = stbi__get8(s);
               }
            }
            stbi__skip(s, pad);
         }
      } else {
         for (j=0; j < (int) s->img_y; ++j) {
            for (i=0; i < (int) s->img_x; i += 2) {
               int v=stbi__get8(s),v2=0;
               if (info.bpp == 4) {
                  v2 = v & 15;
                  v >>= 4;
               }
               out[z++] = pal[v][0];
               out[z++] = pal[v][1];
               out[z++] = pal[v][2];
               if (target == 4) out[z++] = 255;
               if (i+1 == (int) s->img_x) break;
               v = (info.bpp == 8) ? stbi__get8(s) : v2;
               out[z++] = pal[v][0];
               out[z++] = pal[v][1];
               out[z++] = pal[v][2];
               if (target == 4) out[z++] = 255;
            }
            stbi__skip(s, pad);
         }
      }
   } else {
      int rshift=0,gshift=0,bshift=0,ashift=0,rcount=0,gcount=0,bcount=0,acount=0;
      int z = 0;
      int easy=0;
      stbi__skip(s, info.offset - info.extra_read - info.hsz);
      if (info.bpp == 24) width = 3 * s->img_x;
      else if (info.bpp == 16) width = 2*s->img_x;
      else /* bpp = 32 and pad = 0 */ width=0;
      pad = (-width) & 3;
      if (info.bpp == 24) {
         easy = 1;
      } else if (info.bpp == 32) {
         if (mb == 0xff && mg == 0xff00 && mr == 0x00ff0000 && ma == 0xff000000)
            easy = 2;
      }
      if (!easy) {
         if (!mr || !mg || !mb) { STBI_FREE(out); return stbi__errpuc(""bad masks"", ""Corrupt BMP""); }
         // right shift amt to put high bit in position #7
         rshift = stbi__high_bit(mr)-7; rcount = stbi__bitcount(mr);
         gshift = stbi__high_bit(mg)-7; gcount = stbi__bitcount(mg);
         bshift = stbi__high_bit(mb)-7; bcount = stbi__bitcount(mb);
         ashift = stbi__high_bit(ma)-7; acount = stbi__bitcount(ma);
         if (rcount > 8 || gcount > 8 || bcount > 8 || acount > 8) { STBI_FREE(out); return stbi__errpuc(""bad masks"", ""Corrupt BMP""); }
      }
      for (j=0; j < (int) s->img_y; ++j) {
         if (easy) {
            for (i=0; i < (int) s->img_x; ++i) {
               unsigned char a;
               out[z+2] = stbi__get8(s);
               out[z+1] = stbi__get8(s);
               out[z+0] = stbi__get8(s);
               z += 3;
               a = (easy == 2 ? stbi__get8(s) : 255);
               all_a |= a;
               if (target == 4) out[z++] = a;
            }
         } else {
            int bpp = info.bpp;
            for (i=0; i < (int) s->img_x; ++i) {
               stbi__uint32 v = (bpp == 16 ? (stbi__uint32) stbi__get16le(s) : stbi__get32le(s));
               unsigned int a;
               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mr, rshift, rcount));
               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mg, gshift, gcount));
               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mb, bshift, bcount));
               a = (ma ? stbi__shiftsigned(v & ma, ashift, acount) : 255);
               all_a |= a;
               if (target == 4) out[z++] = STBI__BYTECAST(a);
            }
         }
         stbi__skip(s, pad);
      }
   }

   // if alpha channel is all 0s, replace with all 255s
   if (target == 4 && all_a == 0)
      for (i=4*s->img_x*s->img_y-1; i >= 0; i -= 4)
         out[i] = 255;

   if (flip_vertically) {
      stbi_uc t;
      for (j=0; j < (int) s->img_y>>1; ++j) {
         stbi_uc *p1 = out +      j     *s->img_x*target;
         stbi_uc *p2 = out + (s->img_y-1-j)*s->img_x*target;
         for (i=0; i < (int) s->img_x*target; ++i) {
            t = p1[i]; p1[i] = p2[i]; p2[i] = t;
         }
      }
   }

   if (req_comp && req_comp != target) {
      out = stbi__convert_format(out, target, req_comp, s->img_x, s->img_y);
      if (out == NULL) return out; // stbi__convert_format frees input on failure
   }

   *x = s->img_x;
   *y = s->img_y;
   if (comp) *comp = s->img_n;
   return out;
}","{'begin': {'line': 5531, 'column': 1}, 'end': {'line': 5732, 'column': 2}}",play_bmp_sequence.c,"['加载', '并', '解码', 'BMP', '图像', '数据', '，', '支持', '多种', '位深', '和', '通道', '转换']"
332,332,stbi__pic_is4,int,"int stbi__pic_is4(stbi__context * s, const char * str)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'str', 'type': 'const char *'}]",检查输入流前4字节是否匹配指定字符串,"static int stbi__pic_is4(stbi__context *s,const char *str)
{
   int i;
   for (i=0; i<4; ++i)
      if (stbi__get8(s) != (stbi_uc)str[i])
         return 0;

   return 1;
}","{'begin': {'line': 6336, 'column': 1}, 'end': {'line': 6344, 'column': 2}}",play_bmp_sequence.c,"['检查', '输入', '流前', '4', '字节', '是否', '匹配', '指定', '字符', '字符串']"
333,333,stbi__pic_test_core,int,int stbi__pic_test_core(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",验证PIC图片格式的核心检查函数,"static int stbi__pic_test_core(stbi__context *s)
{
   int i;

   if (!stbi__pic_is4(s,""\x53\x80\xF6\x34""))
      return 0;

   for(i=0;i<84;++i)
      stbi__get8(s);

   if (!stbi__pic_is4(s,""PICT""))
      return 0;

   return 1;
}","{'begin': {'line': 6346, 'column': 1}, 'end': {'line': 6360, 'column': 2}}",play_bmp_sequence.c,"['验证', 'PIC', '图片', '格式', '图片格式', '的', '核心', '检查', '函数']"
334,334,stbi__readval,stbi_uc *,"stbi_uc * stbi__readval(stbi__context * s, int channel, stbi_uc * dest)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'channel', 'type': 'int'}, {'name': 'dest', 'type': 'stbi_uc *'}]",根据通道掩码读取最多4字节到目标数组,"static stbi_uc *stbi__readval(stbi__context *s, int channel, stbi_uc *dest)
{
   int mask=0x80, i;

   for (i=0; i<4; ++i, mask>>=1) {
      if (channel & mask) {
         if (stbi__at_eof(s)) return stbi__errpuc(""bad file"",""PIC file too short"");
         dest[i]=stbi__get8(s);
      }
   }

   return dest;
}","{'begin': {'line': 6367, 'column': 1}, 'end': {'line': 6379, 'column': 2}}",play_bmp_sequence.c,"['根据', '通道', '掩码', '读取', '最多', '4', '字节', '到', '目标', '数组']"
335,335,stbi__copyval,void,"void stbi__copyval(int channel, stbi_uc * dest, const stbi_uc * src)","[{'name': 'channel', 'type': 'int'}, {'name': 'dest', 'type': 'stbi_uc *'}, {'name': 'src', 'type': 'const stbi_uc *'}]",根据通道掩码复制指定通道数据,"static void stbi__copyval(int channel,stbi_uc *dest,const stbi_uc *src)
{
   int mask=0x80,i;

   for (i=0;i<4; ++i, mask>>=1)
      if (channel&mask)
         dest[i]=src[i];
}","{'begin': {'line': 6381, 'column': 1}, 'end': {'line': 6388, 'column': 2}}",play_bmp_sequence.c,"['根据', '通道', '掩码', '复制', '指定', '通道', '数据']"
336,336,stbi__pic_load_core,stbi_uc *,"stbi_uc * stbi__pic_load_core(stbi__context * s, int width, int height, int * comp, stbi_uc * result)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'width', 'type': 'int'}, {'name': 'height', 'type': 'int'}, {'name': 'comp', 'type': 'int *'}, {'name': 'result', 'type': 'stbi_uc *'}]",解码PIC图片数据，支持多压缩类型和RGBA通道,"static stbi_uc *stbi__pic_load_core(stbi__context *s,int width,int height,int *comp, stbi_uc *result)
{
   int act_comp=0,num_packets=0,y,chained;
   stbi__pic_packet packets[10];

   // this will (should...) cater for even some bizarre stuff like having data
    // for the same channel in multiple packets.
   do {
      stbi__pic_packet *packet;

      if (num_packets==sizeof(packets)/sizeof(packets[0]))
         return stbi__errpuc(""bad format"",""too many packets"");

      packet = &packets[num_packets++];

      chained = stbi__get8(s);
      packet->size    = stbi__get8(s);
      packet->type    = stbi__get8(s);
      packet->channel = stbi__get8(s);

      act_comp |= packet->channel;

      if (stbi__at_eof(s))          return stbi__errpuc(""bad file"",""file too short (reading packets)"");
      if (packet->size != 8)  return stbi__errpuc(""bad format"",""packet isn't 8bpp"");
   } while (chained);

   *comp = (act_comp & 0x10 ? 4 : 3); // has alpha channel?

   for(y=0; y<height; ++y) {
      int packet_idx;

      for(packet_idx=0; packet_idx < num_packets; ++packet_idx) {
         stbi__pic_packet *packet = &packets[packet_idx];
         stbi_uc *dest = result+y*width*4;

         switch (packet->type) {
            default:
               return stbi__errpuc(""bad format"",""packet has bad compression type"");

            case 0: {//uncompressed
               int x;

               for(x=0;x<width;++x, dest+=4)
                  if (!stbi__readval(s,packet->channel,dest))
                     return 0;
               break;
            }

            case 1://Pure RLE
               {
                  int left=width, i;

                  while (left>0) {
                     stbi_uc count,value[4];

                     count=stbi__get8(s);
                     if (stbi__at_eof(s))   return stbi__errpuc(""bad file"",""file too short (pure read count)"");

                     if (count > left)
                        count = (stbi_uc) left;

                     if (!stbi__readval(s,packet->channel,value))  return 0;

                     for(i=0; i<count; ++i,dest+=4)
                        stbi__copyval(packet->channel,dest,value);
                     left -= count;
                  }
               }
               break;

            case 2: {//Mixed RLE
               int left=width;
               while (left>0) {
                  int count = stbi__get8(s), i;
                  if (stbi__at_eof(s))  return stbi__errpuc(""bad file"",""file too short (mixed read count)"");

                  if (count >= 128) { // Repeated
                     stbi_uc value[4];

                     if (count==128)
                        count = stbi__get16be(s);
                     else
                        count -= 127;
                     if (count > left)
                        return stbi__errpuc(""bad file"",""scanline overrun"");

                     if (!stbi__readval(s,packet->channel,value))
                        return 0;

                     for(i=0;i<count;++i, dest += 4)
                        stbi__copyval(packet->channel,dest,value);
                  } else { // Raw
                     ++count;
                     if (count>left) return stbi__errpuc(""bad file"",""scanline overrun"");

                     for(i=0;i<count;++i, dest+=4)
                        if (!stbi__readval(s,packet->channel,dest))
                           return 0;
                  }
                  left-=count;
               }
               break;
            }
         }
      }
   }

   return result;
}","{'begin': {'line': 6390, 'column': 1}, 'end': {'line': 6498, 'column': 2}}",play_bmp_sequence.c,"['解码', 'PIC', '图片', '数据', '，', '支持', '多', '压缩', '类型', '和', 'RGBA', '通道']"
337,337,stbi__pic_load,void *,"void * stbi__pic_load(stbi__context * s, int * px, int * py, int * comp, int req_comp, stbi__result_info * ri)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'px', 'type': 'int *'}, {'name': 'py', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'ri', 'type': 'stbi__result_info *'}]",加载并解码PIC格式图像，返回像素数据。,"static void *stbi__pic_load(stbi__context *s,int *px,int *py,int *comp,int req_comp, stbi__result_info *ri)
{
   stbi_uc *result;
   int i, x,y, internal_comp;
   STBI_NOTUSED(ri);

   if (!comp) comp = &internal_comp;

   for (i=0; i<92; ++i)
      stbi__get8(s);

   x = stbi__get16be(s);
   y = stbi__get16be(s);

   if (y > STBI_MAX_DIMENSIONS) return stbi__errpuc(""too large"",""Very large image (corrupt?)"");
   if (x > STBI_MAX_DIMENSIONS) return stbi__errpuc(""too large"",""Very large image (corrupt?)"");

   if (stbi__at_eof(s))  return stbi__errpuc(""bad file"",""file too short (pic header)"");
   if (!stbi__mad3sizes_valid(x, y, 4, 0)) return stbi__errpuc(""too large"", ""PIC image too large to decode"");

   stbi__get32be(s); //skip `ratio'
   stbi__get16be(s); //skip `fields'
   stbi__get16be(s); //skip `pad'

   // intermediate buffer is RGBA
   result = (stbi_uc *) stbi__malloc_mad3(x, y, 4, 0);
   if (!result) return stbi__errpuc(""outofmem"", ""Out of memory"");
   memset(result, 0xff, x*y*4);

   if (!stbi__pic_load_core(s,x,y,comp, result)) {
      STBI_FREE(result);
      result=0;
   }
   *px = x;
   *py = y;
   if (req_comp == 0) req_comp = *comp;
   result=stbi__convert_format(result,4,req_comp,x,y);

   return result;
}","{'begin': {'line': 6500, 'column': 1}, 'end': {'line': 6539, 'column': 2}}",play_bmp_sequence.c,"['加载', '并', '解码', 'PIC', '格式', '图像', '，', '返回', '像素', '数据', '。']"
338,338,stbi__pic_test,int,int stbi__pic_test(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",检测PIC格式并重置流指针,"static int stbi__pic_test(stbi__context *s)
{
   int r = stbi__pic_test_core(s);
   stbi__rewind(s);
   return r;
}","{'begin': {'line': 6541, 'column': 1}, 'end': {'line': 6546, 'column': 2}}",play_bmp_sequence.c,"['检测', 'PIC', '格式', '并', '重置', '流', '指针']"
339,339,stbi__gif_test_raw,int,int stbi__gif_test_raw(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",验证GIF文件头是否为87a或89a格式,"static int stbi__gif_test_raw(stbi__context *s)
{
   int sz;
   if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8') return 0;
   sz = stbi__get8(s);
   if (sz != '9' && sz != '7') return 0;
   if (stbi__get8(s) != 'a') return 0;
   return 1;
}","{'begin': {'line': 6580, 'column': 1}, 'end': {'line': 6588, 'column': 2}}",play_bmp_sequence.c,"['验证', 'GIF', '文件', '头', '是否', '为', '87a', '或', '89a', '格式']"
340,340,stbi__tga_get_comp,int,"int stbi__tga_get_comp(int bits_per_pixel, int is_grey, int * is_rgb16)","[{'name': 'bits_per_pixel', 'type': 'int'}, {'name': 'is_grey', 'type': 'int'}, {'name': 'is_rgb16', 'type': 'int *'}]",根据像素位数和参数确定图像格式及RGB16标记,"static int stbi__tga_get_comp(int bits_per_pixel, int is_grey, int* is_rgb16)
{
   // only RGB or RGBA (incl. 16bit) or grey allowed
   if (is_rgb16) *is_rgb16 = 0;
   switch(bits_per_pixel) {
      case 8:  return STBI_grey;
      case 16: if(is_grey) return STBI_grey_alpha;
               // fallthrough
      case 15: if(is_rgb16) *is_rgb16 = 1;
               return STBI_rgb;
      case 24: // fallthrough
      case 32: return bits_per_pixel/8;
      default: return 0;
   }
}","{'begin': {'line': 5739, 'column': 1}, 'end': {'line': 5753, 'column': 2}}",play_bmp_sequence.c,"['根据', '像素', '位数', '和', '参数', '确定', '图像', '格式', '图像格式', '及', 'RGB16', '标记']"
341,341,stbi__gif_test,int,int stbi__gif_test(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",检测GIF格式并重置流指针,"static int stbi__gif_test(stbi__context *s)
{
   int r = stbi__gif_test_raw(s);
   stbi__rewind(s);
   return r;
}","{'begin': {'line': 6590, 'column': 1}, 'end': {'line': 6595, 'column': 2}}",play_bmp_sequence.c,"['检测', 'GIF', '格式', '并', '重置', '流', '指针']"
342,342,stbi__tga_info,int,"int stbi__tga_info(stbi__context * s, int * x, int * y, int * comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",解析TGA图像头信息并验证有效性,"static int stbi__tga_info(stbi__context *s, int *x, int *y, int *comp)
{
    int tga_w, tga_h, tga_comp, tga_image_type, tga_bits_per_pixel, tga_colormap_bpp;
    int sz, tga_colormap_type;
    stbi__get8(s);                   // discard Offset
    tga_colormap_type = stbi__get8(s); // colormap type
    if( tga_colormap_type > 1 ) {
        stbi__rewind(s);
        return 0;      // only RGB or indexed allowed
    }
    tga_image_type = stbi__get8(s); // image type
    if ( tga_colormap_type == 1 ) { // colormapped (paletted) image
        if (tga_image_type != 1 && tga_image_type != 9) {
            stbi__rewind(s);
            return 0;
        }
        stbi__skip(s,4);       // skip index of first colormap entry and number of entries
        sz = stbi__get8(s);    //   check bits per palette color entry
        if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) {
            stbi__rewind(s);
            return 0;
        }
        stbi__skip(s,4);       // skip image x and y origin
        tga_colormap_bpp = sz;
    } else { // ""normal"" image w/o colormap - only RGB or grey allowed, +/- RLE
        if ( (tga_image_type != 2) && (tga_image_type != 3) && (tga_image_type != 10) && (tga_image_type != 11) ) {
            stbi__rewind(s);
            return 0; // only RGB or grey allowed, +/- RLE
        }
        stbi__skip(s,9); // skip colormap specification and image x/y origin
        tga_colormap_bpp = 0;
    }
    tga_w = stbi__get16le(s);
    if( tga_w < 1 ) {
        stbi__rewind(s);
        return 0;   // test width
    }
    tga_h = stbi__get16le(s);
    if( tga_h < 1 ) {
        stbi__rewind(s);
        return 0;   // test height
    }
    tga_bits_per_pixel = stbi__get8(s); // bits per pixel
    stbi__get8(s); // ignore alpha bits
    if (tga_colormap_bpp != 0) {
        if((tga_bits_per_pixel != 8) && (tga_bits_per_pixel != 16)) {
            // when using a colormap, tga_bits_per_pixel is the size of the indexes
            // I don't think anything but 8 or 16bit indexes makes sense
            stbi__rewind(s);
            return 0;
        }
        tga_comp = stbi__tga_get_comp(tga_colormap_bpp, 0, NULL);
    } else {
        tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3) || (tga_image_type == 11), NULL);
    }
    if(!tga_comp) {
      stbi__rewind(s);
      return 0;
    }
    if (x) *x = tga_w;
    if (y) *y = tga_h;
    if (comp) *comp = tga_comp;
    return 1;                   // seems to have passed everything
}","{'begin': {'line': 5755, 'column': 1}, 'end': {'line': 5818, 'column': 2}}",play_bmp_sequence.c,"['解析', 'TGA', '图像', '头', '信息', '并', '验证', '有效', '有效性']"
343,343,stbi__gif_parse_colortable,void,"void stbi__gif_parse_colortable(stbi__context * s, stbi_uc[256][4] pal, int num_entries, int transp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'pal', 'type': 'stbi_uc[256][4]'}, {'name': 'num_entries', 'type': 'int'}, {'name': 'transp', 'type': 'int'}]",解析GIF调色板并设置透明度,"static void stbi__gif_parse_colortable(stbi__context *s, stbi_uc pal[256][4], int num_entries, int transp)
{
   int i;
   for (i=0; i < num_entries; ++i) {
      pal[i][2] = stbi__get8(s);
      pal[i][1] = stbi__get8(s);
      pal[i][0] = stbi__get8(s);
      pal[i][3] = transp == i ? 0 : 255;
   }
}","{'begin': {'line': 6597, 'column': 1}, 'end': {'line': 6606, 'column': 2}}",play_bmp_sequence.c,"['解析', 'GIF', '调色', '调色板', '并', '设置', '透明', '明度', '透明度']"
344,344,stbi__gif_header,int,"int stbi__gif_header(stbi__context * s, stbi__gif * g, int * comp, int is_info)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'g', 'type': 'stbi__gif *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'is_info', 'type': 'int'}]",解析GIF头信息，验证有效性并提取参数,"static int stbi__gif_header(stbi__context *s, stbi__gif *g, int *comp, int is_info)
{
   stbi_uc version;
   if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8')
      return stbi__err(""not GIF"", ""Corrupt GIF"");

   version = stbi__get8(s);
   if (version != '7' && version != '9')    return stbi__err(""not GIF"", ""Corrupt GIF"");
   if (stbi__get8(s) != 'a')                return stbi__err(""not GIF"", ""Corrupt GIF"");

   stbi__g_failure_reason = """";
   g->w = stbi__get16le(s);
   g->h = stbi__get16le(s);
   g->flags = stbi__get8(s);
   g->bgindex = stbi__get8(s);
   g->ratio = stbi__get8(s);
   g->transparent = -1;

   if (g->w > STBI_MAX_DIMENSIONS) return stbi__err(""too large"",""Very large image (corrupt?)"");
   if (g->h > STBI_MAX_DIMENSIONS) return stbi__err(""too large"",""Very large image (corrupt?)"");

   if (comp != 0) *comp = 4;  // can't actually tell whether it's 3 or 4 until we parse the comments

   if (is_info) return 1;

   if (g->flags & 0x80)
      stbi__gif_parse_colortable(s,g->pal, 2 << (g->flags & 7), -1);

   return 1;
}","{'begin': {'line': 6608, 'column': 1}, 'end': {'line': 6637, 'column': 2}}",play_bmp_sequence.c,"['解析', 'GIF', '头', '信息', '，', '验证', '有效', '有效性', '并', '提取', '参数']"
345,345,stbi__tga_test,int,int stbi__tga_test(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",检测输入流是否为有效TGA图像,"static int stbi__tga_test(stbi__context *s)
{
   int res = 0;
   int sz, tga_color_type;
   stbi__get8(s);      //   discard Offset
   tga_color_type = stbi__get8(s);   //   color type
   if ( tga_color_type > 1 ) goto errorEnd;   //   only RGB or indexed allowed
   sz = stbi__get8(s);   //   image type
   if ( tga_color_type == 1 ) { // colormapped (paletted) image
      if (sz != 1 && sz != 9) goto errorEnd; // colortype 1 demands image type 1 or 9
      stbi__skip(s,4);       // skip index of first colormap entry and number of entries
      sz = stbi__get8(s);    //   check bits per palette color entry
      if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;
      stbi__skip(s,4);       // skip image x and y origin
   } else { // ""normal"" image w/o colormap
      if ( (sz != 2) && (sz != 3) && (sz != 10) && (sz != 11) ) goto errorEnd; // only RGB or grey allowed, +/- RLE
      stbi__skip(s,9); // skip colormap specification and image x/y origin
   }
   if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test width
   if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test height
   sz = stbi__get8(s);   //   bits per pixel
   if ( (tga_color_type == 1) && (sz != 8) && (sz != 16) ) goto errorEnd; // for colormapped images, bpp is size of an index
   if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;

   res = 1; // if we got this far, everything's good and we can return 1 instead of 0

errorEnd:
   stbi__rewind(s);
   return res;
}","{'begin': {'line': 5820, 'column': 1}, 'end': {'line': 5849, 'column': 2}}",play_bmp_sequence.c,"['检测', '输入', '流', '是否', '为', '有效', 'TGA', '图像']"
346,346,stbi__gif_info_raw,int,"int stbi__gif_info_raw(stbi__context * s, int * x, int * y, int * comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",解析GIF图片的宽高及通道信息。,"static int stbi__gif_info_raw(stbi__context *s, int *x, int *y, int *comp)
{
   stbi__gif* g = (stbi__gif*) stbi__malloc(sizeof(stbi__gif));
   if (!g) return stbi__err(""outofmem"", ""Out of memory"");
   if (!stbi__gif_header(s, g, comp, 1)) {
      STBI_FREE(g);
      stbi__rewind( s );
      return 0;
   }
   if (x) *x = g->w;
   if (y) *y = g->h;
   STBI_FREE(g);
   return 1;
}","{'begin': {'line': 6639, 'column': 1}, 'end': {'line': 6652, 'column': 2}}",play_bmp_sequence.c,"['解析', 'GIF', '图片', '的', '宽', '高及', '通道', '信息', '。']"
347,347,stbi__out_gif_code,void,"void stbi__out_gif_code(stbi__gif * g, stbi__uint16 code)","[{'name': 'g', 'type': 'stbi__gif *'}, {'name': 'code', 'type': 'stbi__uint16'}]",递归解码GIF LZW编码并填充像素数据,"static void stbi__out_gif_code(stbi__gif *g, stbi__uint16 code)
{
   stbi_uc *p, *c;
   int idx;

   // recurse to decode the prefixes, since the linked-list is backwards,
   // and working backwards through an interleaved image would be nasty
   if (g->codes[code].prefix >= 0)
      stbi__out_gif_code(g, g->codes[code].prefix);

   if (g->cur_y >= g->max_y) return;

   idx = g->cur_x + g->cur_y;
   p = &g->out[idx];
   g->history[idx / 4] = 1;

   c = &g->color_table[g->codes[code].suffix * 4];
   if (c[3] > 128) { // don't render transparent pixels;
      p[0] = c[2];
      p[1] = c[1];
      p[2] = c[0];
      p[3] = c[3];
   }
   g->cur_x += 4;

   if (g->cur_x >= g->max_x) {
      g->cur_x = g->start_x;
      g->cur_y += g->step;

      while (g->cur_y >= g->max_y && g->parse > 0) {
         g->step = (1 << g->parse) * g->line_size;
         g->cur_y = g->start_y + (g->step >> 1);
         --g->parse;
      }
   }
}","{'begin': {'line': 6654, 'column': 1}, 'end': {'line': 6689, 'column': 2}}",play_bmp_sequence.c,"['递归', '解码', 'GIF', ' ', 'LZW', '编码', '并', '填充', '像素', '数据']"
348,348,stbi__tga_read_rgb16,void,"void stbi__tga_read_rgb16(stbi__context * s, stbi_uc * out)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'out', 'type': 'stbi_uc *'}]",读取16位TGA颜色并转换为24位RGB,"static void stbi__tga_read_rgb16(stbi__context *s, stbi_uc* out)
{
   stbi__uint16 px = (stbi__uint16)stbi__get16le(s);
   stbi__uint16 fiveBitMask = 31;
   // we have 3 channels with 5bits each
   int r = (px >> 10) & fiveBitMask;
   int g = (px >> 5) & fiveBitMask;
   int b = px & fiveBitMask;
   // Note that this saves the data in RGB(A) order, so it doesn't need to be swapped later
   out[0] = (stbi_uc)((r * 255)/31);
   out[1] = (stbi_uc)((g * 255)/31);
   out[2] = (stbi_uc)((b * 255)/31);

   // some people claim that the most significant bit might be used for alpha
   // (possibly if an alpha-bit is set in the ""image descriptor byte"")
   // but that only made 16bit test images completely translucent..
   // so let's treat all 15 and 16bit TGAs as RGB with no alpha.
}","{'begin': {'line': 5852, 'column': 1}, 'end': {'line': 5869, 'column': 2}}",play_bmp_sequence.c,"['读取', '16', '位', 'TGA', '颜色', '并', '转换', '为', '24', '位', 'RGB']"
349,349,stbi__tga_load,void *,"void * stbi__tga_load(stbi__context * s, int * x, int * y, int * comp, int req_comp, stbi__result_info * ri)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'ri', 'type': 'stbi__result_info *'}]",加载并解码TGA图像，支持RLE压缩和调色板处理。,"static void *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   //   read in the TGA header stuff
   int tga_offset = stbi__get8(s);
   int tga_indexed = stbi__get8(s);
   int tga_image_type = stbi__get8(s);
   int tga_is_RLE = 0;
   int tga_palette_start = stbi__get16le(s);
   int tga_palette_len = stbi__get16le(s);
   int tga_palette_bits = stbi__get8(s);
   int tga_x_origin = stbi__get16le(s);
   int tga_y_origin = stbi__get16le(s);
   int tga_width = stbi__get16le(s);
   int tga_height = stbi__get16le(s);
   int tga_bits_per_pixel = stbi__get8(s);
   int tga_comp, tga_rgb16=0;
   int tga_inverted = stbi__get8(s);
   // int tga_alpha_bits = tga_inverted & 15; // the 4 lowest bits - unused (useless?)
   //   image data
   unsigned char *tga_data;
   unsigned char *tga_palette = NULL;
   int i, j;
   unsigned char raw_data[4] = {0};
   int RLE_count = 0;
   int RLE_repeating = 0;
   int read_next_pixel = 1;
   STBI_NOTUSED(ri);
   STBI_NOTUSED(tga_x_origin); // @TODO
   STBI_NOTUSED(tga_y_origin); // @TODO

   if (tga_height > STBI_MAX_DIMENSIONS) return stbi__errpuc(""too large"",""Very large image (corrupt?)"");
   if (tga_width > STBI_MAX_DIMENSIONS) return stbi__errpuc(""too large"",""Very large image (corrupt?)"");

   //   do a tiny bit of precessing
   if ( tga_image_type >= 8 )
   {
      tga_image_type -= 8;
      tga_is_RLE = 1;
   }
   tga_inverted = 1 - ((tga_inverted >> 5) & 1);

   //   If I'm paletted, then I'll use the number of bits from the palette
   if ( tga_indexed ) tga_comp = stbi__tga_get_comp(tga_palette_bits, 0, &tga_rgb16);
   else tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3), &tga_rgb16);

   if(!tga_comp) // shouldn't really happen, stbi__tga_test() should have ensured basic consistency
      return stbi__errpuc(""bad format"", ""Can't find out TGA pixelformat"");

   //   tga info
   *x = tga_width;
   *y = tga_height;
   if (comp) *comp = tga_comp;

   if (!stbi__mad3sizes_valid(tga_width, tga_height, tga_comp, 0))
      return stbi__errpuc(""too large"", ""Corrupt TGA"");

   tga_data = (unsigned char*)stbi__malloc_mad3(tga_width, tga_height, tga_comp, 0);
   if (!tga_data) return stbi__errpuc(""outofmem"", ""Out of memory"");

   // skip to the data's starting position (offset usually = 0)
   stbi__skip(s, tga_offset );

   if ( !tga_indexed && !tga_is_RLE && !tga_rgb16 ) {
      for (i=0; i < tga_height; ++i) {
         int row = tga_inverted ? tga_height -i - 1 : i;
         stbi_uc *tga_row = tga_data + row*tga_width*tga_comp;
         stbi__getn(s, tga_row, tga_width * tga_comp);
      }
   } else  {
      //   do I need to load a palette?
      if ( tga_indexed)
      {
         if (tga_palette_len == 0) {  /* you have to have at least one entry! */
            STBI_FREE(tga_data);
            return stbi__errpuc(""bad palette"", ""Corrupt TGA"");
         }

         //   any data to skip? (offset usually = 0)
         stbi__skip(s, tga_palette_start );
         //   load the palette
         tga_palette = (unsigned char*)stbi__malloc_mad2(tga_palette_len, tga_comp, 0);
         if (!tga_palette) {
            STBI_FREE(tga_data);
            return stbi__errpuc(""outofmem"", ""Out of memory"");
         }
         if (tga_rgb16) {
            stbi_uc *pal_entry = tga_palette;
            STBI_ASSERT(tga_comp == STBI_rgb);
            for (i=0; i < tga_palette_len; ++i) {
               stbi__tga_read_rgb16(s, pal_entry);
               pal_entry += tga_comp;
            }
         } else if (!stbi__getn(s, tga_palette, tga_palette_len * tga_comp)) {
               STBI_FREE(tga_data);
               STBI_FREE(tga_palette);
               return stbi__errpuc(""bad palette"", ""Corrupt TGA"");
         }
      }
      //   load the data
      for (i=0; i < tga_width * tga_height; ++i)
      {
         //   if I'm in RLE mode, do I need to get a RLE stbi__pngchunk?
         if ( tga_is_RLE )
         {
            if ( RLE_count == 0 )
            {
               //   yep, get the next byte as a RLE command
               int RLE_cmd = stbi__get8(s);
               RLE_count = 1 + (RLE_cmd & 127);
               RLE_repeating = RLE_cmd >> 7;
               read_next_pixel = 1;
            } else if ( !RLE_repeating )
            {
               read_next_pixel = 1;
            }
         } else
         {
            read_next_pixel = 1;
         }
         //   OK, if I need to read a pixel, do it now
         if ( read_next_pixel )
         {
            //   load however much data we did have
            if ( tga_indexed )
            {
               // read in index, then perform the lookup
               int pal_idx = (tga_bits_per_pixel == 8) ? stbi__get8(s) : stbi__get16le(s);
               if ( pal_idx >= tga_palette_len ) {
                  // invalid index
                  pal_idx = 0;
               }
               pal_idx *= tga_comp;
               for (j = 0; j < tga_comp; ++j) {
                  raw_data[j] = tga_palette[pal_idx+j];
               }
            } else if(tga_rgb16) {
               STBI_ASSERT(tga_comp == STBI_rgb);
               stbi__tga_read_rgb16(s, raw_data);
            } else {
               //   read in the data raw
               for (j = 0; j < tga_comp; ++j) {
                  raw_data[j] = stbi__get8(s);
               }
            }
            //   clear the reading flag for the next pixel
            read_next_pixel = 0;
         } // end of reading a pixel

         // copy data
         for (j = 0; j < tga_comp; ++j)
           tga_data[i*tga_comp+j] = raw_data[j];

         //   in case we're in RLE mode, keep counting down
         --RLE_count;
      }
      //   do I need to invert the image?
      if ( tga_inverted )
      {
         for (j = 0; j*2 < tga_height; ++j)
         {
            int index1 = j * tga_width * tga_comp;
            int index2 = (tga_height - 1 - j) * tga_width * tga_comp;
            for (i = tga_width * tga_comp; i > 0; --i)
            {
               unsigned char temp = tga_data[index1];
               tga_data[index1] = tga_data[index2];
               tga_data[index2] = temp;
               ++index1;
               ++index2;
            }
         }
      }
      //   clear my palette, if I had one
      if ( tga_palette != NULL )
      {
         STBI_FREE( tga_palette );
      }
   }

   // swap RGB - if the source data was RGB16, it already is in the right order
   if (tga_comp >= 3 && !tga_rgb16)
   {
      unsigned char* tga_pixel = tga_data;
      for (i=0; i < tga_width * tga_height; ++i)
      {
         unsigned char temp = tga_pixel[0];
         tga_pixel[0] = tga_pixel[2];
         tga_pixel[2] = temp;
         tga_pixel += tga_comp;
      }
   }

   // convert to target component count
   if (req_comp && req_comp != tga_comp)
      tga_data = stbi__convert_format(tga_data, tga_comp, req_comp, tga_width, tga_height);

   //   the things I do to get rid of an error message, and yet keep
   //   Microsoft's C compilers happy... [8^(
   tga_palette_start = tga_palette_len = tga_palette_bits =
         tga_x_origin = tga_y_origin = 0;
   STBI_NOTUSED(tga_palette_start);
   //   OK, done
   return tga_data;
}","{'begin': {'line': 5871, 'column': 1}, 'end': {'line': 6074, 'column': 2}}",play_bmp_sequence.c,"['加载', '并', '解码', 'TGA', '图像', '，', '支持', 'RLE', '压缩', '和', '调色', '调色板', '处理', '。']"
350,350,stbi__process_gif_raster,stbi_uc *,"stbi_uc * stbi__process_gif_raster(stbi__context * s, stbi__gif * g)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'g', 'type': 'stbi__gif *'}]",处理GIF图像光栅数据，进行LZW解码,"static stbi_uc *stbi__process_gif_raster(stbi__context *s, stbi__gif *g)
{
   stbi_uc lzw_cs;
   stbi__int32 len, init_code;
   stbi__uint32 first;
   stbi__int32 codesize, codemask, avail, oldcode, bits, valid_bits, clear;
   stbi__gif_lzw *p;

   lzw_cs = stbi__get8(s);
   if (lzw_cs > 12) return NULL;
   clear = 1 << lzw_cs;
   first = 1;
   codesize = lzw_cs + 1;
   codemask = (1 << codesize) - 1;
   bits = 0;
   valid_bits = 0;
   for (init_code = 0; init_code < clear; init_code++) {
      g->codes[init_code].prefix = -1;
      g->codes[init_code].first = (stbi_uc) init_code;
      g->codes[init_code].suffix = (stbi_uc) init_code;
   }

   // support no starting clear code
   avail = clear+2;
   oldcode = -1;

   len = 0;
   for(;;) {
      if (valid_bits < codesize) {
         if (len == 0) {
            len = stbi__get8(s); // start new block
            if (len == 0)
               return g->out;
         }
         --len;
         bits |= (stbi__int32) stbi__get8(s) << valid_bits;
         valid_bits += 8;
      } else {
         stbi__int32 code = bits & codemask;
         bits >>= codesize;
         valid_bits -= codesize;
         // @OPTIMIZE: is there some way we can accelerate the non-clear path?
         if (code == clear) {  // clear code
            codesize = lzw_cs + 1;
            codemask = (1 << codesize) - 1;
            avail = clear + 2;
            oldcode = -1;
            first = 0;
         } else if (code == clear + 1) { // end of stream code
            stbi__skip(s, len);
            while ((len = stbi__get8(s)) > 0)
               stbi__skip(s,len);
            return g->out;
         } else if (code <= avail) {
            if (first) {
               return stbi__errpuc(""no clear code"", ""Corrupt GIF"");
            }

            if (oldcode >= 0) {
               p = &g->codes[avail++];
               if (avail > 8192) {
                  return stbi__errpuc(""too many codes"", ""Corrupt GIF"");
               }

               p->prefix = (stbi__int16) oldcode;
               p->first = g->codes[oldcode].first;
               p->suffix = (code == avail) ? p->first : g->codes[code].first;
            } else if (code == avail)
               return stbi__errpuc(""illegal code in raster"", ""Corrupt GIF"");

            stbi__out_gif_code(g, (stbi__uint16) code);

            if ((avail & codemask) == 0 && avail <= 0x0FFF) {
               codesize++;
               codemask = (1 << codesize) - 1;
            }

            oldcode = code;
         } else {
            return stbi__errpuc(""illegal code in raster"", ""Corrupt GIF"");
         }
      }
   }
}","{'begin': {'line': 6691, 'column': 1}, 'end': {'line': 6774, 'column': 2}}",play_bmp_sequence.c,"['处理', 'GIF', '图像', '光栅', '数据', '，', '进行', 'LZW', '解码']"
351,351,stbi__gif_load_next,stbi_uc *,"stbi_uc * stbi__gif_load_next(stbi__context * s, stbi__gif * g, int * comp, int req_comp, stbi_uc * two_back)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'g', 'type': 'stbi__gif *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'two_back', 'type': 'stbi_uc *'}]",逐帧加载GIF图像，处理透明和背景恢复,"static stbi_uc *stbi__gif_load_next(stbi__context *s, stbi__gif *g, int *comp, int req_comp, stbi_uc *two_back)
{
   int dispose;
   int first_frame;
   int pi;
   int pcount;
   STBI_NOTUSED(req_comp);

   // on first frame, any non-written pixels get the background colour (non-transparent)
   first_frame = 0;
   if (g->out == 0) {
      if (!stbi__gif_header(s, g, comp,0)) return 0; // stbi__g_failure_reason set by stbi__gif_header
      if (!stbi__mad3sizes_valid(4, g->w, g->h, 0))
         return stbi__errpuc(""too large"", ""GIF image is too large"");
      pcount = g->w * g->h;
      g->out = (stbi_uc *) stbi__malloc(4 * pcount);
      g->background = (stbi_uc *) stbi__malloc(4 * pcount);
      g->history = (stbi_uc *) stbi__malloc(pcount);
      if (!g->out || !g->background || !g->history)
         return stbi__errpuc(""outofmem"", ""Out of memory"");

      // image is treated as ""transparent"" at the start - ie, nothing overwrites the current background;
      // background colour is only used for pixels that are not rendered first frame, after that ""background""
      // color refers to the color that was there the previous frame.
      memset(g->out, 0x00, 4 * pcount);
      memset(g->background, 0x00, 4 * pcount); // state of the background (starts transparent)
      memset(g->history, 0x00, pcount);        // pixels that were affected previous frame
      first_frame = 1;
   } else {
      // second frame - how do we dispose of the previous one?
      dispose = (g->eflags & 0x1C) >> 2;
      pcount = g->w * g->h;

      if ((dispose == 3) && (two_back == 0)) {
         dispose = 2; // if I don't have an image to revert back to, default to the old background
      }

      if (dispose == 3) { // use previous graphic
         for (pi = 0; pi < pcount; ++pi) {
            if (g->history[pi]) {
               memcpy( &g->out[pi * 4], &two_back[pi * 4], 4 );
            }
         }
      } else if (dispose == 2) {
         // restore what was changed last frame to background before that frame;
         for (pi = 0; pi < pcount; ++pi) {
            if (g->history[pi]) {
               memcpy( &g->out[pi * 4], &g->background[pi * 4], 4 );
            }
         }
      } else {
         // This is a non-disposal case eithe way, so just
         // leave the pixels as is, and they will become the new background
         // 1: do not dispose
         // 0:  not specified.
      }

      // background is what out is after the undoing of the previou frame;
      memcpy( g->background, g->out, 4 * g->w * g->h );
   }

   // clear my history;
   memset( g->history, 0x00, g->w * g->h );        // pixels that were affected previous frame

   for (;;) {
      int tag = stbi__get8(s);
      switch (tag) {
         case 0x2C: /* Image Descriptor */
         {
            stbi__int32 x, y, w, h;
            stbi_uc *o;

            x = stbi__get16le(s);
            y = stbi__get16le(s);
            w = stbi__get16le(s);
            h = stbi__get16le(s);
            if (((x + w) > (g->w)) || ((y + h) > (g->h)))
               return stbi__errpuc(""bad Image Descriptor"", ""Corrupt GIF"");

            g->line_size = g->w * 4;
            g->start_x = x * 4;
            g->start_y = y * g->line_size;
            g->max_x   = g->start_x + w * 4;
            g->max_y   = g->start_y + h * g->line_size;
            g->cur_x   = g->start_x;
            g->cur_y   = g->start_y;

            // if the width of the specified rectangle is 0, that means
            // we may not see *any* pixels or the image is malformed;
            // to make sure this is caught, move the current y down to
            // max_y (which is what out_gif_code checks).
            if (w == 0)
               g->cur_y = g->max_y;

            g->lflags = stbi__get8(s);

            if (g->lflags & 0x40) {
               g->step = 8 * g->line_size; // first interlaced spacing
               g->parse = 3;
            } else {
               g->step = g->line_size;
               g->parse = 0;
            }

            if (g->lflags & 0x80) {
               stbi__gif_parse_colortable(s,g->lpal, 2 << (g->lflags & 7), g->eflags & 0x01 ? g->transparent : -1);
               g->color_table = (stbi_uc *) g->lpal;
            } else if (g->flags & 0x80) {
               g->color_table = (stbi_uc *) g->pal;
            } else
               return stbi__errpuc(""missing color table"", ""Corrupt GIF"");

            o = stbi__process_gif_raster(s, g);
            if (!o) return NULL;

            // if this was the first frame,
            pcount = g->w * g->h;
            if (first_frame && (g->bgindex > 0)) {
               // if first frame, any pixel not drawn to gets the background color
               for (pi = 0; pi < pcount; ++pi) {
                  if (g->history[pi] == 0) {
                     g->pal[g->bgindex][3] = 255; // just in case it was made transparent, undo that; It will be reset next frame if need be;
                     memcpy( &g->out[pi * 4], &g->pal[g->bgindex], 4 );
                  }
               }
            }

            return o;
         }

         case 0x21: // Comment Extension.
         {
            int len;
            int ext = stbi__get8(s);
            if (ext == 0xF9) { // Graphic Control Extension.
               len = stbi__get8(s);
               if (len == 4) {
                  g->eflags = stbi__get8(s);
                  g->delay = 10 * stbi__get16le(s); // delay - 1/100th of a second, saving as 1/1000ths.

                  // unset old transparent
                  if (g->transparent >= 0) {
                     g->pal[g->transparent][3] = 255;
                  }
                  if (g->eflags & 0x01) {
                     g->transparent = stbi__get8(s);
                     if (g->transparent >= 0) {
                        g->pal[g->transparent][3] = 0;
                     }
                  } else {
                     // don't need transparent
                     stbi__skip(s, 1);
                     g->transparent = -1;
                  }
               } else {
                  stbi__skip(s, len);
                  break;
               }
            }
            while ((len = stbi__get8(s)) != 0) {
               stbi__skip(s, len);
            }
            break;
         }

         case 0x3B: // gif stream termination code
            return (stbi_uc *) s; // using '1' causes warning on some compilers

         default:
            return stbi__errpuc(""unknown code"", ""Corrupt GIF"");
      }
   }
}","{'begin': {'line': 6778, 'column': 1}, 'end': {'line': 6950, 'column': 2}}",play_bmp_sequence.c,"['逐帧', '加载', 'GIF', '图像', '，', '处理', '透明', '和', '背景', '恢复']"
352,352,stbi__psd_test,int,int stbi__psd_test(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",检测输入是否为PSD格式文件,"static int stbi__psd_test(stbi__context *s)
{
   int r = (stbi__get32be(s) == 0x38425053);
   stbi__rewind(s);
   return r;
}","{'begin': {'line': 6081, 'column': 1}, 'end': {'line': 6086, 'column': 2}}",play_bmp_sequence.c,"['检测', '输入', '是否', '为', 'PSD', '格式', '文件', '格式文件']"
353,353,stbi__psd_decode_rle,int,"int stbi__psd_decode_rle(stbi__context * s, stbi_uc * p, int pixelCount)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'p', 'type': 'stbi_uc *'}, {'name': 'pixelCount', 'type': 'int'}]",解码PSD的RLE压缩像素数据。,"static int stbi__psd_decode_rle(stbi__context *s, stbi_uc *p, int pixelCount)
{
   int count, nleft, len;

   count = 0;
   while ((nleft = pixelCount - count) > 0) {
      len = stbi__get8(s);
      if (len == 128) {
         // No-op.
      } else if (len < 128) {
         // Copy next len+1 bytes literally.
         len++;
         if (len > nleft) return 0; // corrupt data
         count += len;
         while (len) {
            *p = stbi__get8(s);
            p += 4;
            len--;
         }
      } else if (len > 128) {
         stbi_uc   val;
         // Next -len+1 bytes in the dest are replicated from next source byte.
         // (Interpret len as a negative 8-bit int.)
         len = 257 - len;
         if (len > nleft) return 0; // corrupt data
         val = stbi__get8(s);
         count += len;
         while (len) {
            *p = val;
            p += 4;
            len--;
         }
      }
   }

   return 1;
}","{'begin': {'line': 6088, 'column': 1}, 'end': {'line': 6124, 'column': 2}}",play_bmp_sequence.c,"['解码', 'PSD', '的', 'RLE', '压缩', '像素', '数据', '。']"
354,354,stbi__psd_load,void *,"void * stbi__psd_load(stbi__context * s, int * x, int * y, int * comp, int req_comp, stbi__result_info * ri, int bpc)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'ri', 'type': 'stbi__result_info *'}, {'name': 'bpc', 'type': 'int'}]",解析PSD图像数据，处理压缩和通道转换,"static void *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)
{
   int pixelCount;
   int channelCount, compression;
   int channel, i;
   int bitdepth;
   int w,h;
   stbi_uc *out;
   STBI_NOTUSED(ri);

   // Check identifier
   if (stbi__get32be(s) != 0x38425053)   // ""8BPS""
      return stbi__errpuc(""not PSD"", ""Corrupt PSD image"");

   // Check file type version.
   if (stbi__get16be(s) != 1)
      return stbi__errpuc(""wrong version"", ""Unsupported version of PSD image"");

   // Skip 6 reserved bytes.
   stbi__skip(s, 6 );

   // Read the number of channels (R, G, B, A, etc).
   channelCount = stbi__get16be(s);
   if (channelCount < 0 || channelCount > 16)
      return stbi__errpuc(""wrong channel count"", ""Unsupported number of channels in PSD image"");

   // Read the rows and columns of the image.
   h = stbi__get32be(s);
   w = stbi__get32be(s);

   if (h > STBI_MAX_DIMENSIONS) return stbi__errpuc(""too large"",""Very large image (corrupt?)"");
   if (w > STBI_MAX_DIMENSIONS) return stbi__errpuc(""too large"",""Very large image (corrupt?)"");

   // Make sure the depth is 8 bits.
   bitdepth = stbi__get16be(s);
   if (bitdepth != 8 && bitdepth != 16)
      return stbi__errpuc(""unsupported bit depth"", ""PSD bit depth is not 8 or 16 bit"");

   // Make sure the color mode is RGB.
   // Valid options are:
   //   0: Bitmap
   //   1: Grayscale
   //   2: Indexed color
   //   3: RGB color
   //   4: CMYK color
   //   7: Multichannel
   //   8: Duotone
   //   9: Lab color
   if (stbi__get16be(s) != 3)
      return stbi__errpuc(""wrong color format"", ""PSD is not in RGB color format"");

   // Skip the Mode Data.  (It's the palette for indexed color; other info for other modes.)
   stbi__skip(s,stbi__get32be(s) );

   // Skip the image resources.  (resolution, pen tool paths, etc)
   stbi__skip(s, stbi__get32be(s) );

   // Skip the reserved data.
   stbi__skip(s, stbi__get32be(s) );

   // Find out if the data is compressed.
   // Known values:
   //   0: no compression
   //   1: RLE compressed
   compression = stbi__get16be(s);
   if (compression > 1)
      return stbi__errpuc(""bad compression"", ""PSD has an unknown compression format"");

   // Check size
   if (!stbi__mad3sizes_valid(4, w, h, 0))
      return stbi__errpuc(""too large"", ""Corrupt PSD"");

   // Create the destination image.

   if (!compression && bitdepth == 16 && bpc == 16) {
      out = (stbi_uc *) stbi__malloc_mad3(8, w, h, 0);
      ri->bits_per_channel = 16;
   } else
      out = (stbi_uc *) stbi__malloc(4 * w*h);

   if (!out) return stbi__errpuc(""outofmem"", ""Out of memory"");
   pixelCount = w*h;

   // Initialize the data to zero.
   //memset( out, 0, pixelCount * 4 );

   // Finally, the image data.
   if (compression) {
      // RLE as used by .PSD and .TIFF
      // Loop until you get the number of unpacked bytes you are expecting:
      //     Read the next source byte into n.
      //     If n is between 0 and 127 inclusive, copy the next n+1 bytes literally.
      //     Else if n is between -127 and -1 inclusive, copy the next byte -n+1 times.
      //     Else if n is 128, noop.
      // Endloop

      // The RLE-compressed data is preceded by a 2-byte data count for each row in the data,
      // which we're going to just skip.
      stbi__skip(s, h * channelCount * 2 );

      // Read the RLE data by channel.
      for (channel = 0; channel < 4; channel++) {
         stbi_uc *p;

         p = out+channel;
         if (channel >= channelCount) {
            // Fill this channel with default data.
            for (i = 0; i < pixelCount; i++, p += 4)
               *p = (channel == 3 ? 255 : 0);
         } else {
            // Read the RLE data.
            if (!stbi__psd_decode_rle(s, p, pixelCount)) {
               STBI_FREE(out);
               return stbi__errpuc(""corrupt"", ""bad RLE data"");
            }
         }
      }

   } else {
      // We're at the raw image data.  It's each channel in order (Red, Green, Blue, Alpha, ...)
      // where each channel consists of an 8-bit (or 16-bit) value for each pixel in the image.

      // Read the data by channel.
      for (channel = 0; channel < 4; channel++) {
         if (channel >= channelCount) {
            // Fill this channel with default data.
            if (bitdepth == 16 && bpc == 16) {
               stbi__uint16 *q = ((stbi__uint16 *) out) + channel;
               stbi__uint16 val = channel == 3 ? 65535 : 0;
               for (i = 0; i < pixelCount; i++, q += 4)
                  *q = val;
            } else {
               stbi_uc *p = out+channel;
               stbi_uc val = channel == 3 ? 255 : 0;
               for (i = 0; i < pixelCount; i++, p += 4)
                  *p = val;
            }
         } else {
            if (ri->bits_per_channel == 16) {    // output bpc
               stbi__uint16 *q = ((stbi__uint16 *) out) + channel;
               for (i = 0; i < pixelCount; i++, q += 4)
                  *q = (stbi__uint16) stbi__get16be(s);
            } else {
               stbi_uc *p = out+channel;
               if (bitdepth == 16) {  // input bpc
                  for (i = 0; i < pixelCount; i++, p += 4)
                     *p = (stbi_uc) (stbi__get16be(s) >> 8);
               } else {
                  for (i = 0; i < pixelCount; i++, p += 4)
                     *p = stbi__get8(s);
               }
            }
         }
      }
   }

   // remove weird white matte from PSD
   if (channelCount >= 4) {
      if (ri->bits_per_channel == 16) {
         for (i=0; i < w*h; ++i) {
            stbi__uint16 *pixel = (stbi__uint16 *) out + 4*i;
            if (pixel[3] != 0 && pixel[3] != 65535) {
               float a = pixel[3] / 65535.0f;
               float ra = 1.0f / a;
               float inv_a = 65535.0f * (1 - ra);
               pixel[0] = (stbi__uint16) (pixel[0]*ra + inv_a);
               pixel[1] = (stbi__uint16) (pixel[1]*ra + inv_a);
               pixel[2] = (stbi__uint16) (pixel[2]*ra + inv_a);
            }
         }
      } else {
         for (i=0; i < w*h; ++i) {
            unsigned char *pixel = out + 4*i;
            if (pixel[3] != 0 && pixel[3] != 255) {
               float a = pixel[3] / 255.0f;
               float ra = 1.0f / a;
               float inv_a = 255.0f * (1 - ra);
               pixel[0] = (unsigned char) (pixel[0]*ra + inv_a);
               pixel[1] = (unsigned char) (pixel[1]*ra + inv_a);
               pixel[2] = (unsigned char) (pixel[2]*ra + inv_a);
            }
         }
      }
   }

   // convert to desired output format
   if (req_comp && req_comp != 4) {
      if (ri->bits_per_channel == 16)
         out = (stbi_uc *) stbi__convert_format16((stbi__uint16 *) out, 4, req_comp, w, h);
      else
         out = stbi__convert_format(out, 4, req_comp, w, h);
      if (out == NULL) return out; // stbi__convert_format frees input on failure
   }

   if (comp) *comp = 4;
   *y = h;
   *x = w;

   return out;
}","{'begin': {'line': 6126, 'column': 1}, 'end': {'line': 6325, 'column': 2}}",play_bmp_sequence.c,"['解析', 'PSD', '图像', '数据', '，', '处理', '压缩', '和', '通道', '转换']"
355,355,stbi__load_gif_main_outofmem,void *,"void * stbi__load_gif_main_outofmem(stbi__gif * g, stbi_uc * out, int ** delays)","[{'name': 'g', 'type': 'stbi__gif *'}, {'name': 'out', 'type': 'stbi_uc *'}, {'name': 'delays', 'type': 'int **'}]",内存不足时释放资源并返回错误,"static void *stbi__load_gif_main_outofmem(stbi__gif *g, stbi_uc *out, int **delays)
{
   STBI_FREE(g->out);
   STBI_FREE(g->history);
   STBI_FREE(g->background);

   if (out) STBI_FREE(out);
   if (delays && *delays) STBI_FREE(*delays);
   return stbi__errpuc(""outofmem"", ""Out of memory"");
}","{'begin': {'line': 6952, 'column': 1}, 'end': {'line': 6961, 'column': 2}}",play_bmp_sequence.c,"['内存', '不足', '内存不足', '时', '释放', '资源', '并', '返回', '错误']"
356,356,stbi__load_gif_main,void *,"void * stbi__load_gif_main(stbi__context * s, int ** delays, int * x, int * y, int * z, int * comp, int req_comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'delays', 'type': 'int **'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'z', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",加载GIF图像，处理多帧动画及延迟时间,"static void *stbi__load_gif_main(stbi__context *s, int **delays, int *x, int *y, int *z, int *comp, int req_comp)
{
   if (stbi__gif_test(s)) {
      int layers = 0;
      stbi_uc *u = 0;
      stbi_uc *out = 0;
      stbi_uc *two_back = 0;
      stbi__gif g;
      int stride;
      int out_size = 0;
      int delays_size = 0;

      STBI_NOTUSED(out_size);
      STBI_NOTUSED(delays_size);

      memset(&g, 0, sizeof(g));
      if (delays) {
         *delays = 0;
      }

      do {
         u = stbi__gif_load_next(s, &g, comp, req_comp, two_back);
         if (u == (stbi_uc *) s) u = 0;  // end of animated gif marker

         if (u) {
            *x = g.w;
            *y = g.h;
            ++layers;
            stride = g.w * g.h * 4;

            if (out) {
               void *tmp = (stbi_uc*) STBI_REALLOC_SIZED( out, out_size, layers * stride );
               if (!tmp)
                  return stbi__load_gif_main_outofmem(&g, out, delays);
               else {
                   out = (stbi_uc*) tmp;
                   out_size = layers * stride;
               }

               if (delays) {
                  int *new_delays = (int*) STBI_REALLOC_SIZED( *delays, delays_size, sizeof(int) * layers );
                  if (!new_delays)
                     return stbi__load_gif_main_outofmem(&g, out, delays);
                  *delays = new_delays;
                  delays_size = layers * sizeof(int);
               }
            } else {
               out = (stbi_uc*)stbi__malloc( layers * stride );
               if (!out)
                  return stbi__load_gif_main_outofmem(&g, out, delays);
               out_size = layers * stride;
               if (delays) {
                  *delays = (int*) stbi__malloc( layers * sizeof(int) );
                  if (!*delays)
                     return stbi__load_gif_main_outofmem(&g, out, delays);
                  delays_size = layers * sizeof(int);
               }
            }
            memcpy( out + ((layers - 1) * stride), u, stride );
            if (layers >= 2) {
               two_back = out - 2 * stride;
            }

            if (delays) {
               (*delays)[layers - 1U] = g.delay;
            }
         }
      } while (u != 0);

      // free temp buffer;
      STBI_FREE(g.out);
      STBI_FREE(g.history);
      STBI_FREE(g.background);

      // do the final conversion after loading everything;
      if (req_comp && req_comp != 4)
         out = stbi__convert_format(out, 4, req_comp, layers * g.w, g.h);

      *z = layers;
      return out;
   } else {
      return stbi__errpuc(""not GIF"", ""Image was not as a gif type."");
   }
}","{'begin': {'line': 6963, 'column': 1}, 'end': {'line': 7046, 'column': 2}}",play_bmp_sequence.c,"['加载', 'GIF', '图像', '，', '处理', '多', '帧', '动画', '及', '延迟', '时间', '延迟时间']"
357,357,stbi__pic_is4,int,"int stbi__pic_is4(stbi__context * s, const char * str)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'str', 'type': 'const char *'}]",检查输入流前4字节是否匹配指定字符串,"static int stbi__pic_is4(stbi__context *s,const char *str)
{
   int i;
   for (i=0; i<4; ++i)
      if (stbi__get8(s) != (stbi_uc)str[i])
         return 0;

   return 1;
}","{'begin': {'line': 6336, 'column': 1}, 'end': {'line': 6344, 'column': 2}}",play_bmp_sequence.c,"['检查', '输入', '流前', '4', '字节', '是否', '匹配', '指定', '字符', '字符串']"
358,358,stbi__gif_load,void *,"void * stbi__gif_load(stbi__context * s, int * x, int * y, int * comp, int req_comp, stbi__result_info * ri)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'ri', 'type': 'stbi__result_info *'}]",加载GIF图像数据，处理多帧并转换格式,"static void *stbi__gif_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   stbi_uc *u = 0;
   stbi__gif g;
   memset(&g, 0, sizeof(g));
   STBI_NOTUSED(ri);

   u = stbi__gif_load_next(s, &g, comp, req_comp, 0);
   if (u == (stbi_uc *) s) u = 0;  // end of animated gif marker
   if (u) {
      *x = g.w;
      *y = g.h;

      // moved conversion to after successful load so that the same
      // can be done for multiple frames.
      if (req_comp && req_comp != 4)
         u = stbi__convert_format(u, 4, req_comp, g.w, g.h);
   } else if (g.out) {
      // if there was an error and we allocated an image buffer, free it!
      STBI_FREE(g.out);
   }

   // free buffers needed for multiple frame loading;
   STBI_FREE(g.history);
   STBI_FREE(g.background);

   return u;
}","{'begin': {'line': 7048, 'column': 1}, 'end': {'line': 7075, 'column': 2}}",play_bmp_sequence.c,"['加载', 'GIF', '图像', '数据', '，', '处理', '多', '帧', '并', '转换', '格式']"
359,359,stbi__pic_test_core,int,int stbi__pic_test_core(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",检测输入流是否为PIC格式,"static int stbi__pic_test_core(stbi__context *s)
{
   int i;

   if (!stbi__pic_is4(s,""\x53\x80\xF6\x34""))
      return 0;

   for(i=0;i<84;++i)
      stbi__get8(s);

   if (!stbi__pic_is4(s,""PICT""))
      return 0;

   return 1;
}","{'begin': {'line': 6346, 'column': 1}, 'end': {'line': 6360, 'column': 2}}",play_bmp_sequence.c,"['检测', '输入', '流', '是否', '为', 'PIC', '格式']"
360,360,stbi__gif_info,int,"int stbi__gif_info(stbi__context * s, int * x, int * y, int * comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",调用stbi__gif_info_raw获取GIF信息,"static int stbi__gif_info(stbi__context *s, int *x, int *y, int *comp)
{
   return stbi__gif_info_raw(s,x,y,comp);
}","{'begin': {'line': 7077, 'column': 1}, 'end': {'line': 7080, 'column': 2}}",play_bmp_sequence.c,"['调用', 'stbi', '__', 'gif', '_', 'info', '_', 'raw', '获取', 'GIF', '信息']"
361,361,stbi__hdr_test_core,int,"int stbi__hdr_test_core(stbi__context * s, const char * signature)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'signature', 'type': 'const char *'}]",验证输入流是否匹配指定签名,"static int stbi__hdr_test_core(stbi__context *s, const char *signature)
{
   int i;
   for (i=0; signature[i]; ++i)
      if (stbi__get8(s) != signature[i])
          return 0;
   stbi__rewind(s);
   return 1;
}","{'begin': {'line': 7087, 'column': 1}, 'end': {'line': 7095, 'column': 2}}",play_bmp_sequence.c,"['验证', '输入', '流', '是否', '匹配', '指定', '签名']"
362,362,stbi__readval,stbi_uc *,"stbi_uc * stbi__readval(stbi__context * s, int channel, stbi_uc * dest)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'channel', 'type': 'int'}, {'name': 'dest', 'type': 'stbi_uc *'}]",按通道掩码读取4个字节到目标数组,"static stbi_uc *stbi__readval(stbi__context *s, int channel, stbi_uc *dest)
{
   int mask=0x80, i;

   for (i=0; i<4; ++i, mask>>=1) {
      if (channel & mask) {
         if (stbi__at_eof(s)) return stbi__errpuc(""bad file"",""PIC file too short"");
         dest[i]=stbi__get8(s);
      }
   }

   return dest;
}","{'begin': {'line': 6367, 'column': 1}, 'end': {'line': 6379, 'column': 2}}",play_bmp_sequence.c,"['按', '通道', '掩码', '读取', '4', '个', '字节', '到', '目标', '数组']"
363,363,stbi__copyval,void,"void stbi__copyval(int channel, stbi_uc * dest, const stbi_uc * src)","[{'name': 'channel', 'type': 'int'}, {'name': 'dest', 'type': 'stbi_uc *'}, {'name': 'src', 'type': 'const stbi_uc *'}]",按通道掩码复制四个通道数据,"static void stbi__copyval(int channel,stbi_uc *dest,const stbi_uc *src)
{
   int mask=0x80,i;

   for (i=0;i<4; ++i, mask>>=1)
      if (channel&mask)
         dest[i]=src[i];
}","{'begin': {'line': 6381, 'column': 1}, 'end': {'line': 6388, 'column': 2}}",play_bmp_sequence.c,"['按', '通道', '掩码', '复制', '四个', '通道', '数据']"
364,364,stbi__hdr_test,int,int stbi__hdr_test(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",测试输入是否为HDR格式，检查RADIANCE和RGBE标识,"static int stbi__hdr_test(stbi__context* s)
{
   int r = stbi__hdr_test_core(s, ""#?RADIANCE\n"");
   stbi__rewind(s);
   if(!r) {
       r = stbi__hdr_test_core(s, ""#?RGBE\n"");
       stbi__rewind(s);
   }
   return r;
}","{'begin': {'line': 7097, 'column': 1}, 'end': {'line': 7106, 'column': 2}}",play_bmp_sequence.c,"['测试', '输入', '是否', '为', 'HDR', '格式', '，', '检查', 'RADIANCE', '和', 'RGBE', '标识']"
365,365,stbi__hdr_gettoken,char *,"char * stbi__hdr_gettoken(stbi__context * z, char * buffer)","[{'name': 'z', 'type': 'stbi__context *'}, {'name': 'buffer', 'type': 'char *'}]",读取HDR文件的一行到缓冲区,"static char *stbi__hdr_gettoken(stbi__context *z, char *buffer)
{
   int len=0;
   char c = '\0';

   c = (char) stbi__get8(z);

   while (!stbi__at_eof(z) && c != '\n') {
      buffer[len++] = c;
      if (len == STBI__HDR_BUFLEN-1) {
         // flush to end of line
         while (!stbi__at_eof(z) && stbi__get8(z) != '\n')
            ;
         break;
      }
      c = (char) stbi__get8(z);
   }

   buffer[len] = 0;
   return buffer;
}","{'begin': {'line': 7109, 'column': 1}, 'end': {'line': 7129, 'column': 2}}",play_bmp_sequence.c,"['读取', 'HDR', '文件', '的', '一行', '到', '缓冲', '缓冲区']"
366,366,stbi__pic_load_core,stbi_uc *,"stbi_uc * stbi__pic_load_core(stbi__context * s, int width, int height, int * comp, stbi_uc * result)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'width', 'type': 'int'}, {'name': 'height', 'type': 'int'}, {'name': 'comp', 'type': 'int *'}, {'name': 'result', 'type': 'stbi_uc *'}]",解析PIC图像数据包并解码像素信息,"static stbi_uc *stbi__pic_load_core(stbi__context *s,int width,int height,int *comp, stbi_uc *result)
{
   int act_comp=0,num_packets=0,y,chained;
   stbi__pic_packet packets[10];

   // this will (should...) cater for even some bizarre stuff like having data
    // for the same channel in multiple packets.
   do {
      stbi__pic_packet *packet;

      if (num_packets==sizeof(packets)/sizeof(packets[0]))
         return stbi__errpuc(""bad format"",""too many packets"");

      packet = &packets[num_packets++];

      chained = stbi__get8(s);
      packet->size    = stbi__get8(s);
      packet->type    = stbi__get8(s);
      packet->channel = stbi__get8(s);

      act_comp |= packet->channel;

      if (stbi__at_eof(s))          return stbi__errpuc(""bad file"",""file too short (reading packets)"");
      if (packet->size != 8)  return stbi__errpuc(""bad format"",""packet isn't 8bpp"");
   } while (chained);

   *comp = (act_comp & 0x10 ? 4 : 3); // has alpha channel?

   for(y=0; y<height; ++y) {
      int packet_idx;

      for(packet_idx=0; packet_idx < num_packets; ++packet_idx) {
         stbi__pic_packet *packet = &packets[packet_idx];
         stbi_uc *dest = result+y*width*4;

         switch (packet->type) {
            default:
               return stbi__errpuc(""bad format"",""packet has bad compression type"");

            case 0: {//uncompressed
               int x;

               for(x=0;x<width;++x, dest+=4)
                  if (!stbi__readval(s,packet->channel,dest))
                     return 0;
               break;
            }

            case 1://Pure RLE
               {
                  int left=width, i;

                  while (left>0) {
                     stbi_uc count,value[4];

                     count=stbi__get8(s);
                     if (stbi__at_eof(s))   return stbi__errpuc(""bad file"",""file too short (pure read count)"");

                     if (count > left)
                        count = (stbi_uc) left;

                     if (!stbi__readval(s,packet->channel,value))  return 0;

                     for(i=0; i<count; ++i,dest+=4)
                        stbi__copyval(packet->channel,dest,value);
                     left -= count;
                  }
               }
               break;

            case 2: {//Mixed RLE
               int left=width;
               while (left>0) {
                  int count = stbi__get8(s), i;
                  if (stbi__at_eof(s))  return stbi__errpuc(""bad file"",""file too short (mixed read count)"");

                  if (count >= 128) { // Repeated
                     stbi_uc value[4];

                     if (count==128)
                        count = stbi__get16be(s);
                     else
                        count -= 127;
                     if (count > left)
                        return stbi__errpuc(""bad file"",""scanline overrun"");

                     if (!stbi__readval(s,packet->channel,value))
                        return 0;

                     for(i=0;i<count;++i, dest += 4)
                        stbi__copyval(packet->channel,dest,value);
                  } else { // Raw
                     ++count;
                     if (count>left) return stbi__errpuc(""bad file"",""scanline overrun"");

                     for(i=0;i<count;++i, dest+=4)
                        if (!stbi__readval(s,packet->channel,dest))
                           return 0;
                  }
                  left-=count;
               }
               break;
            }
         }
      }
   }

   return result;
}","{'begin': {'line': 6390, 'column': 1}, 'end': {'line': 6498, 'column': 2}}",play_bmp_sequence.c,"['解析', 'PIC', '图像', '数据', '数据包', '并', '解码', '像素', '信息']"
367,367,stbi__hdr_convert,void,"void stbi__hdr_convert(float * output, stbi_uc * input, int req_comp)","[{'name': 'output', 'type': 'float *'}, {'name': 'input', 'type': 'stbi_uc *'}, {'name': 'req_comp', 'type': 'int'}]",HDR数据转换，处理颜色及透明度通道,"static void stbi__hdr_convert(float *output, stbi_uc *input, int req_comp)
{
   if ( input[3] != 0 ) {
      float f1;
      // Exponent
      f1 = (float) ldexp(1.0f, input[3] - (int)(128 + 8));
      if (req_comp <= 2)
         output[0] = (input[0] + input[1] + input[2]) * f1 / 3;
      else {
         output[0] = input[0] * f1;
         output[1] = input[1] * f1;
         output[2] = input[2] * f1;
      }
      if (req_comp == 2) output[1] = 1;
      if (req_comp == 4) output[3] = 1;
   } else {
      switch (req_comp) {
         case 4: output[3] = 1; /* fallthrough */
         case 3: output[0] = output[1] = output[2] = 0;
                 break;
         case 2: output[1] = 1; /* fallthrough */
         case 1: output[0] = 0;
                 break;
      }
   }
}","{'begin': {'line': 7131, 'column': 1}, 'end': {'line': 7156, 'column': 2}}",play_bmp_sequence.c,"['HDR', '数据', '转换', '，', '处理', '颜色', '及', '透明', '明度', '透明度', '通道']"
368,368,stbi__hdr_load,float *,"float * stbi__hdr_load(stbi__context * s, int * x, int * y, int * comp, int req_comp, stbi__result_info * ri)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'ri', 'type': 'stbi__result_info *'}]",加载并解析HDR图像，支持RLE解码,"static float *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   char buffer[STBI__HDR_BUFLEN];
   char *token;
   int valid = 0;
   int width, height;
   stbi_uc *scanline;
   float *hdr_data;
   int len;
   unsigned char count, value;
   int i, j, k, c1,c2, z;
   const char *headerToken;
   STBI_NOTUSED(ri);

   // Check identifier
   headerToken = stbi__hdr_gettoken(s,buffer);
   if (strcmp(headerToken, ""#?RADIANCE"") != 0 && strcmp(headerToken, ""#?RGBE"") != 0)
      return stbi__errpf(""not HDR"", ""Corrupt HDR image"");

   // Parse header
   for(;;) {
      token = stbi__hdr_gettoken(s,buffer);
      if (token[0] == 0) break;
      if (strcmp(token, ""FORMAT=32-bit_rle_rgbe"") == 0) valid = 1;
   }

   if (!valid)    return stbi__errpf(""unsupported format"", ""Unsupported HDR format"");

   // Parse width and height
   // can't use sscanf() if we're not using stdio!
   token = stbi__hdr_gettoken(s,buffer);
   if (strncmp(token, ""-Y "", 3))  return stbi__errpf(""unsupported data layout"", ""Unsupported HDR format"");
   token += 3;
   height = (int) strtol(token, &token, 10);
   while (*token == ' ') ++token;
   if (strncmp(token, ""+X "", 3))  return stbi__errpf(""unsupported data layout"", ""Unsupported HDR format"");
   token += 3;
   width = (int) strtol(token, NULL, 10);

   if (height > STBI_MAX_DIMENSIONS) return stbi__errpf(""too large"",""Very large image (corrupt?)"");
   if (width > STBI_MAX_DIMENSIONS) return stbi__errpf(""too large"",""Very large image (corrupt?)"");

   *x = width;
   *y = height;

   if (comp) *comp = 3;
   if (req_comp == 0) req_comp = 3;

   if (!stbi__mad4sizes_valid(width, height, req_comp, sizeof(float), 0))
      return stbi__errpf(""too large"", ""HDR image is too large"");

   // Read data
   hdr_data = (float *) stbi__malloc_mad4(width, height, req_comp, sizeof(float), 0);
   if (!hdr_data)
      return stbi__errpf(""outofmem"", ""Out of memory"");

   // Load image data
   // image data is stored as some number of sca
   if ( width < 8 || width >= 32768) {
      // Read flat data
      for (j=0; j < height; ++j) {
         for (i=0; i < width; ++i) {
            stbi_uc rgbe[4];
           main_decode_loop:
            stbi__getn(s, rgbe, 4);
            stbi__hdr_convert(hdr_data + j * width * req_comp + i * req_comp, rgbe, req_comp);
         }
      }
   } else {
      // Read RLE-encoded data
      scanline = NULL;

      for (j = 0; j < height; ++j) {
         c1 = stbi__get8(s);
         c2 = stbi__get8(s);
         len = stbi__get8(s);
         if (c1 != 2 || c2 != 2 || (len & 0x80)) {
            // not run-length encoded, so we have to actually use THIS data as a decoded
            // pixel (note this can't be a valid pixel--one of RGB must be >= 128)
            stbi_uc rgbe[4];
            rgbe[0] = (stbi_uc) c1;
            rgbe[1] = (stbi_uc) c2;
            rgbe[2] = (stbi_uc) len;
            rgbe[3] = (stbi_uc) stbi__get8(s);
            stbi__hdr_convert(hdr_data, rgbe, req_comp);
            i = 1;
            j = 0;
            STBI_FREE(scanline);
            goto main_decode_loop; // yes, this makes no sense
         }
         len <<= 8;
         len |= stbi__get8(s);
         if (len != width) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(""invalid decoded scanline length"", ""corrupt HDR""); }
         if (scanline == NULL) {
            scanline = (stbi_uc *) stbi__malloc_mad2(width, 4, 0);
            if (!scanline) {
               STBI_FREE(hdr_data);
               return stbi__errpf(""outofmem"", ""Out of memory"");
            }
         }

         for (k = 0; k < 4; ++k) {
            int nleft;
            i = 0;
            while ((nleft = width - i) > 0) {
               count = stbi__get8(s);
               if (count > 128) {
                  // Run
                  value = stbi__get8(s);
                  count -= 128;
                  if ((count == 0) || (count > nleft)) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(""corrupt"", ""bad RLE data in HDR""); }
                  for (z = 0; z < count; ++z)
                     scanline[i++ * 4 + k] = value;
               } else {
                  // Dump
                  if ((count == 0) || (count > nleft)) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(""corrupt"", ""bad RLE data in HDR""); }
                  for (z = 0; z < count; ++z)
                     scanline[i++ * 4 + k] = stbi__get8(s);
               }
            }
         }
         for (i=0; i < width; ++i)
            stbi__hdr_convert(hdr_data+(j*width + i)*req_comp, scanline + i*4, req_comp);
      }
      if (scanline)
         STBI_FREE(scanline);
   }

   return hdr_data;
}","{'begin': {'line': 7158, 'column': 1}, 'end': {'line': 7287, 'column': 2}}",play_bmp_sequence.c,"['加载', '并', '解析', 'HDR', '图像', '，', '支持', 'RLE', '解码']"
369,369,stbi__pic_load,void *,"void * stbi__pic_load(stbi__context * s, int * px, int * py, int * comp, int req_comp, stbi__result_info * ri)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'px', 'type': 'int *'}, {'name': 'py', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'ri', 'type': 'stbi__result_info *'}]",加载并解码PIC格式图像，返回像素数据。,"static void *stbi__pic_load(stbi__context *s,int *px,int *py,int *comp,int req_comp, stbi__result_info *ri)
{
   stbi_uc *result;
   int i, x,y, internal_comp;
   STBI_NOTUSED(ri);

   if (!comp) comp = &internal_comp;

   for (i=0; i<92; ++i)
      stbi__get8(s);

   x = stbi__get16be(s);
   y = stbi__get16be(s);

   if (y > STBI_MAX_DIMENSIONS) return stbi__errpuc(""too large"",""Very large image (corrupt?)"");
   if (x > STBI_MAX_DIMENSIONS) return stbi__errpuc(""too large"",""Very large image (corrupt?)"");

   if (stbi__at_eof(s))  return stbi__errpuc(""bad file"",""file too short (pic header)"");
   if (!stbi__mad3sizes_valid(x, y, 4, 0)) return stbi__errpuc(""too large"", ""PIC image too large to decode"");

   stbi__get32be(s); //skip `ratio'
   stbi__get16be(s); //skip `fields'
   stbi__get16be(s); //skip `pad'

   // intermediate buffer is RGBA
   result = (stbi_uc *) stbi__malloc_mad3(x, y, 4, 0);
   if (!result) return stbi__errpuc(""outofmem"", ""Out of memory"");
   memset(result, 0xff, x*y*4);

   if (!stbi__pic_load_core(s,x,y,comp, result)) {
      STBI_FREE(result);
      result=0;
   }
   *px = x;
   *py = y;
   if (req_comp == 0) req_comp = *comp;
   result=stbi__convert_format(result,4,req_comp,x,y);

   return result;
}","{'begin': {'line': 6500, 'column': 1}, 'end': {'line': 6539, 'column': 2}}",play_bmp_sequence.c,"['加载', '并', '解码', 'PIC', '格式', '图像', '，', '返回', '像素', '数据', '。']"
370,370,stbi__pic_test,int,int stbi__pic_test(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",测试PIC格式并重置流位置,"static int stbi__pic_test(stbi__context *s)
{
   int r = stbi__pic_test_core(s);
   stbi__rewind(s);
   return r;
}","{'begin': {'line': 6541, 'column': 1}, 'end': {'line': 6546, 'column': 2}}",play_bmp_sequence.c,"['测试', 'PIC', '格式', '并', '重置', '流', '位置']"
371,371,stbi__gif_test_raw,int,int stbi__gif_test_raw(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",检查输入是否为有效GIF格式,"static int stbi__gif_test_raw(stbi__context *s)
{
   int sz;
   if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8') return 0;
   sz = stbi__get8(s);
   if (sz != '9' && sz != '7') return 0;
   if (stbi__get8(s) != 'a') return 0;
   return 1;
}","{'begin': {'line': 6580, 'column': 1}, 'end': {'line': 6588, 'column': 2}}",play_bmp_sequence.c,"['检查', '输入', '是否', '为', '有效', 'GIF', '格式']"
372,372,stbi__gif_test,int,int stbi__gif_test(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",检测是否为GIF格式并重置流指针,"static int stbi__gif_test(stbi__context *s)
{
   int r = stbi__gif_test_raw(s);
   stbi__rewind(s);
   return r;
}","{'begin': {'line': 6590, 'column': 1}, 'end': {'line': 6595, 'column': 2}}",play_bmp_sequence.c,"['检测', '是否', '为', 'GIF', '格式', '并', '重置', '流', '指针']"
373,373,stbi__gif_parse_colortable,void,"void stbi__gif_parse_colortable(stbi__context * s, stbi_uc[256][4] pal, int num_entries, int transp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'pal', 'type': 'stbi_uc[256][4]'}, {'name': 'num_entries', 'type': 'int'}, {'name': 'transp', 'type': 'int'}]",解析GIF颜色表并设置透明度通道,"static void stbi__gif_parse_colortable(stbi__context *s, stbi_uc pal[256][4], int num_entries, int transp)
{
   int i;
   for (i=0; i < num_entries; ++i) {
      pal[i][2] = stbi__get8(s);
      pal[i][1] = stbi__get8(s);
      pal[i][0] = stbi__get8(s);
      pal[i][3] = transp == i ? 0 : 255;
   }
}","{'begin': {'line': 6597, 'column': 1}, 'end': {'line': 6606, 'column': 2}}",play_bmp_sequence.c,"['解析', 'GIF', '颜色', '表并', '设置', '透明', '明度', '透明度', '通道']"
374,374,stbi__gif_header,int,"int stbi__gif_header(stbi__context * s, stbi__gif * g, int * comp, int is_info)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'g', 'type': 'stbi__gif *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'is_info', 'type': 'int'}]",解析GIF头部信息，验证格式并提取尺寸参数,"static int stbi__gif_header(stbi__context *s, stbi__gif *g, int *comp, int is_info)
{
   stbi_uc version;
   if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8')
      return stbi__err(""not GIF"", ""Corrupt GIF"");

   version = stbi__get8(s);
   if (version != '7' && version != '9')    return stbi__err(""not GIF"", ""Corrupt GIF"");
   if (stbi__get8(s) != 'a')                return stbi__err(""not GIF"", ""Corrupt GIF"");

   stbi__g_failure_reason = """";
   g->w = stbi__get16le(s);
   g->h = stbi__get16le(s);
   g->flags = stbi__get8(s);
   g->bgindex = stbi__get8(s);
   g->ratio = stbi__get8(s);
   g->transparent = -1;

   if (g->w > STBI_MAX_DIMENSIONS) return stbi__err(""too large"",""Very large image (corrupt?)"");
   if (g->h > STBI_MAX_DIMENSIONS) return stbi__err(""too large"",""Very large image (corrupt?)"");

   if (comp != 0) *comp = 4;  // can't actually tell whether it's 3 or 4 until we parse the comments

   if (is_info) return 1;

   if (g->flags & 0x80)
      stbi__gif_parse_colortable(s,g->pal, 2 << (g->flags & 7), -1);

   return 1;
}","{'begin': {'line': 6608, 'column': 1}, 'end': {'line': 6637, 'column': 2}}",play_bmp_sequence.c,"['解析', 'GIF', '头部', '信息', '，', '验证', '格式', '并', '提取', '尺寸', '参数']"
375,375,stbi__hdr_info,int,"int stbi__hdr_info(stbi__context * s, int * x, int * y, int * comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",解析HDR图像头信息，获取宽高和通道数,"static int stbi__hdr_info(stbi__context *s, int *x, int *y, int *comp)
{
   char buffer[STBI__HDR_BUFLEN];
   char *token;
   int valid = 0;
   int dummy;

   if (!x) x = &dummy;
   if (!y) y = &dummy;
   if (!comp) comp = &dummy;

   if (stbi__hdr_test(s) == 0) {
       stbi__rewind( s );
       return 0;
   }

   for(;;) {
      token = stbi__hdr_gettoken(s,buffer);
      if (token[0] == 0) break;
      if (strcmp(token, ""FORMAT=32-bit_rle_rgbe"") == 0) valid = 1;
   }

   if (!valid) {
       stbi__rewind( s );
       return 0;
   }
   token = stbi__hdr_gettoken(s,buffer);
   if (strncmp(token, ""-Y "", 3)) {
       stbi__rewind( s );
       return 0;
   }
   token += 3;
   *y = (int) strtol(token, &token, 10);
   while (*token == ' ') ++token;
   if (strncmp(token, ""+X "", 3)) {
       stbi__rewind( s );
       return 0;
   }
   token += 3;
   *x = (int) strtol(token, NULL, 10);
   *comp = 3;
   return 1;
}","{'begin': {'line': 7289, 'column': 1}, 'end': {'line': 7331, 'column': 2}}",play_bmp_sequence.c,"['解析', 'HDR', '图像', '头', '信息', '，', '获取', '宽高', '和', '通道', '数']"
376,376,stbi__bmp_info,int,"int stbi__bmp_info(stbi__context * s, int * x, int * y, int * comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",解析BMP图像信息，获取尺寸和通道数,"static int stbi__bmp_info(stbi__context *s, int *x, int *y, int *comp)
{
   void *p;
   stbi__bmp_data info;

   info.all_a = 255;
   p = stbi__bmp_parse_header(s, &info);
   if (p == NULL) {
      stbi__rewind( s );
      return 0;
   }
   if (x) *x = s->img_x;
   if (y) *y = s->img_y;
   if (comp) {
      if (info.bpp == 24 && info.ma == 0xff000000)
         *comp = 3;
      else
         *comp = info.ma ? 4 : 3;
   }
   return 1;
}","{'begin': {'line': 7335, 'column': 1}, 'end': {'line': 7355, 'column': 2}}",play_bmp_sequence.c,"['解析', 'BMP', '图像', '信息', '，', '获取', '尺寸', '和', '通道', '数']"
377,377,stbi__gif_info_raw,int,"int stbi__gif_info_raw(stbi__context * s, int * x, int * y, int * comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",解析GIF图像尺寸和通道信息,"static int stbi__gif_info_raw(stbi__context *s, int *x, int *y, int *comp)
{
   stbi__gif* g = (stbi__gif*) stbi__malloc(sizeof(stbi__gif));
   if (!g) return stbi__err(""outofmem"", ""Out of memory"");
   if (!stbi__gif_header(s, g, comp, 1)) {
      STBI_FREE(g);
      stbi__rewind( s );
      return 0;
   }
   if (x) *x = g->w;
   if (y) *y = g->h;
   STBI_FREE(g);
   return 1;
}","{'begin': {'line': 6639, 'column': 1}, 'end': {'line': 6652, 'column': 2}}",play_bmp_sequence.c,"['解析', 'GIF', '图像', '尺寸', '和', '通道', '信息']"
378,378,stbi__out_gif_code,void,"void stbi__out_gif_code(stbi__gif * g, stbi__uint16 code)","[{'name': 'g', 'type': 'stbi__gif *'}, {'name': 'code', 'type': 'stbi__uint16'}]",递归解码GIF编码，应用颜色并更新绘制位置。,"static void stbi__out_gif_code(stbi__gif *g, stbi__uint16 code)
{
   stbi_uc *p, *c;
   int idx;

   // recurse to decode the prefixes, since the linked-list is backwards,
   // and working backwards through an interleaved image would be nasty
   if (g->codes[code].prefix >= 0)
      stbi__out_gif_code(g, g->codes[code].prefix);

   if (g->cur_y >= g->max_y) return;

   idx = g->cur_x + g->cur_y;
   p = &g->out[idx];
   g->history[idx / 4] = 1;

   c = &g->color_table[g->codes[code].suffix * 4];
   if (c[3] > 128) { // don't render transparent pixels;
      p[0] = c[2];
      p[1] = c[1];
      p[2] = c[0];
      p[3] = c[3];
   }
   g->cur_x += 4;

   if (g->cur_x >= g->max_x) {
      g->cur_x = g->start_x;
      g->cur_y += g->step;

      while (g->cur_y >= g->max_y && g->parse > 0) {
         g->step = (1 << g->parse) * g->line_size;
         g->cur_y = g->start_y + (g->step >> 1);
         --g->parse;
      }
   }
}","{'begin': {'line': 6654, 'column': 1}, 'end': {'line': 6689, 'column': 2}}",play_bmp_sequence.c,"['递归', '解码', 'GIF', '编码', '，', '应用', '颜色', '并', '更新', '绘制', '位置', '。']"
379,379,stbi__psd_info,int,"int stbi__psd_info(stbi__context * s, int * x, int * y, int * comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",解析PSD图像信息并获取宽高及通道数,"static int stbi__psd_info(stbi__context *s, int *x, int *y, int *comp)
{
   int channelCount, dummy, depth;
   if (!x) x = &dummy;
   if (!y) y = &dummy;
   if (!comp) comp = &dummy;
   if (stbi__get32be(s) != 0x38425053) {
       stbi__rewind( s );
       return 0;
   }
   if (stbi__get16be(s) != 1) {
       stbi__rewind( s );
       return 0;
   }
   stbi__skip(s, 6);
   channelCount = stbi__get16be(s);
   if (channelCount < 0 || channelCount > 16) {
       stbi__rewind( s );
       return 0;
   }
   *y = stbi__get32be(s);
   *x = stbi__get32be(s);
   depth = stbi__get16be(s);
   if (depth != 8 && depth != 16) {
       stbi__rewind( s );
       return 0;
   }
   if (stbi__get16be(s) != 3) {
       stbi__rewind( s );
       return 0;
   }
   *comp = 4;
   return 1;
}","{'begin': {'line': 7359, 'column': 1}, 'end': {'line': 7392, 'column': 2}}",play_bmp_sequence.c,"['解析', 'PSD', '图像', '信息', '并', '获取', '宽高及', '通道', '数']"
380,380,stbi__process_gif_raster,stbi_uc *,"stbi_uc * stbi__process_gif_raster(stbi__context * s, stbi__gif * g)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'g', 'type': 'stbi__gif *'}]",解码GIF的LZW压缩数据流，处理错误,"static stbi_uc *stbi__process_gif_raster(stbi__context *s, stbi__gif *g)
{
   stbi_uc lzw_cs;
   stbi__int32 len, init_code;
   stbi__uint32 first;
   stbi__int32 codesize, codemask, avail, oldcode, bits, valid_bits, clear;
   stbi__gif_lzw *p;

   lzw_cs = stbi__get8(s);
   if (lzw_cs > 12) return NULL;
   clear = 1 << lzw_cs;
   first = 1;
   codesize = lzw_cs + 1;
   codemask = (1 << codesize) - 1;
   bits = 0;
   valid_bits = 0;
   for (init_code = 0; init_code < clear; init_code++) {
      g->codes[init_code].prefix = -1;
      g->codes[init_code].first = (stbi_uc) init_code;
      g->codes[init_code].suffix = (stbi_uc) init_code;
   }

   // support no starting clear code
   avail = clear+2;
   oldcode = -1;

   len = 0;
   for(;;) {
      if (valid_bits < codesize) {
         if (len == 0) {
            len = stbi__get8(s); // start new block
            if (len == 0)
               return g->out;
         }
         --len;
         bits |= (stbi__int32) stbi__get8(s) << valid_bits;
         valid_bits += 8;
      } else {
         stbi__int32 code = bits & codemask;
         bits >>= codesize;
         valid_bits -= codesize;
         // @OPTIMIZE: is there some way we can accelerate the non-clear path?
         if (code == clear) {  // clear code
            codesize = lzw_cs + 1;
            codemask = (1 << codesize) - 1;
            avail = clear + 2;
            oldcode = -1;
            first = 0;
         } else if (code == clear + 1) { // end of stream code
            stbi__skip(s, len);
            while ((len = stbi__get8(s)) > 0)
               stbi__skip(s,len);
            return g->out;
         } else if (code <= avail) {
            if (first) {
               return stbi__errpuc(""no clear code"", ""Corrupt GIF"");
            }

            if (oldcode >= 0) {
               p = &g->codes[avail++];
               if (avail > 8192) {
                  return stbi__errpuc(""too many codes"", ""Corrupt GIF"");
               }

               p->prefix = (stbi__int16) oldcode;
               p->first = g->codes[oldcode].first;
               p->suffix = (code == avail) ? p->first : g->codes[code].first;
            } else if (code == avail)
               return stbi__errpuc(""illegal code in raster"", ""Corrupt GIF"");

            stbi__out_gif_code(g, (stbi__uint16) code);

            if ((avail & codemask) == 0 && avail <= 0x0FFF) {
               codesize++;
               codemask = (1 << codesize) - 1;
            }

            oldcode = code;
         } else {
            return stbi__errpuc(""illegal code in raster"", ""Corrupt GIF"");
         }
      }
   }
}","{'begin': {'line': 6691, 'column': 1}, 'end': {'line': 6774, 'column': 2}}",play_bmp_sequence.c,"['解码', 'GIF', '的', 'LZW', '压缩', '数据', '数据流', '，', '处理', '错误', '处理错误']"
381,381,stbi__psd_is16,int,int stbi__psd_is16(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",检查PSD图像是否为16位深度,"static int stbi__psd_is16(stbi__context *s)
{
   int channelCount, depth;
   if (stbi__get32be(s) != 0x38425053) {
       stbi__rewind( s );
       return 0;
   }
   if (stbi__get16be(s) != 1) {
       stbi__rewind( s );
       return 0;
   }
   stbi__skip(s, 6);
   channelCount = stbi__get16be(s);
   if (channelCount < 0 || channelCount > 16) {
       stbi__rewind( s );
       return 0;
   }
   STBI_NOTUSED(stbi__get32be(s));
   STBI_NOTUSED(stbi__get32be(s));
   depth = stbi__get16be(s);
   if (depth != 16) {
       stbi__rewind( s );
       return 0;
   }
   return 1;
}","{'begin': {'line': 7394, 'column': 1}, 'end': {'line': 7419, 'column': 2}}",play_bmp_sequence.c,"['检查', 'PSD', '图像', '是否', '为', '16', '位', '深度']"
382,382,stbi__pic_info,int,"int stbi__pic_info(stbi__context * s, int * x, int * y, int * comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",解析PIC图片尺寸及通道信息，返回是否成功,"static int stbi__pic_info(stbi__context *s, int *x, int *y, int *comp)
{
   int act_comp=0,num_packets=0,chained,dummy;
   stbi__pic_packet packets[10];

   if (!x) x = &dummy;
   if (!y) y = &dummy;
   if (!comp) comp = &dummy;

   if (!stbi__pic_is4(s,""\x53\x80\xF6\x34"")) {
      stbi__rewind(s);
      return 0;
   }

   stbi__skip(s, 88);

   *x = stbi__get16be(s);
   *y = stbi__get16be(s);
   if (stbi__at_eof(s)) {
      stbi__rewind( s);
      return 0;
   }
   if ( (*x) != 0 && (1 << 28) / (*x) < (*y)) {
      stbi__rewind( s );
      return 0;
   }

   stbi__skip(s, 8);

   do {
      stbi__pic_packet *packet;

      if (num_packets==sizeof(packets)/sizeof(packets[0]))
         return 0;

      packet = &packets[num_packets++];
      chained = stbi__get8(s);
      packet->size    = stbi__get8(s);
      packet->type    = stbi__get8(s);
      packet->channel = stbi__get8(s);
      act_comp |= packet->channel;

      if (stbi__at_eof(s)) {
          stbi__rewind( s );
          return 0;
      }
      if (packet->size != 8) {
          stbi__rewind( s );
          return 0;
      }
   } while (chained);

   *comp = (act_comp & 0x10 ? 4 : 3);

   return 1;
}","{'begin': {'line': 7423, 'column': 1}, 'end': {'line': 7478, 'column': 2}}",play_bmp_sequence.c,"['解析', 'PIC', '图片', '尺寸', '图片尺寸', '及', '通道', '信息', '，', '返回', '是否', '成功']"
383,383,stbi__gif_load_next,stbi_uc *,"stbi_uc * stbi__gif_load_next(stbi__context * s, stbi__gif * g, int * comp, int req_comp, stbi_uc * two_back)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'g', 'type': 'stbi__gif *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'two_back', 'type': 'stbi_uc *'}]",逐帧加载GIF图像，处理帧间过渡,"static stbi_uc *stbi__gif_load_next(stbi__context *s, stbi__gif *g, int *comp, int req_comp, stbi_uc *two_back)
{
   int dispose;
   int first_frame;
   int pi;
   int pcount;
   STBI_NOTUSED(req_comp);

   // on first frame, any non-written pixels get the background colour (non-transparent)
   first_frame = 0;
   if (g->out == 0) {
      if (!stbi__gif_header(s, g, comp,0)) return 0; // stbi__g_failure_reason set by stbi__gif_header
      if (!stbi__mad3sizes_valid(4, g->w, g->h, 0))
         return stbi__errpuc(""too large"", ""GIF image is too large"");
      pcount = g->w * g->h;
      g->out = (stbi_uc *) stbi__malloc(4 * pcount);
      g->background = (stbi_uc *) stbi__malloc(4 * pcount);
      g->history = (stbi_uc *) stbi__malloc(pcount);
      if (!g->out || !g->background || !g->history)
         return stbi__errpuc(""outofmem"", ""Out of memory"");

      // image is treated as ""transparent"" at the start - ie, nothing overwrites the current background;
      // background colour is only used for pixels that are not rendered first frame, after that ""background""
      // color refers to the color that was there the previous frame.
      memset(g->out, 0x00, 4 * pcount);
      memset(g->background, 0x00, 4 * pcount); // state of the background (starts transparent)
      memset(g->history, 0x00, pcount);        // pixels that were affected previous frame
      first_frame = 1;
   } else {
      // second frame - how do we dispose of the previous one?
      dispose = (g->eflags & 0x1C) >> 2;
      pcount = g->w * g->h;

      if ((dispose == 3) && (two_back == 0)) {
         dispose = 2; // if I don't have an image to revert back to, default to the old background
      }

      if (dispose == 3) { // use previous graphic
         for (pi = 0; pi < pcount; ++pi) {
            if (g->history[pi]) {
               memcpy( &g->out[pi * 4], &two_back[pi * 4], 4 );
            }
         }
      } else if (dispose == 2) {
         // restore what was changed last frame to background before that frame;
         for (pi = 0; pi < pcount; ++pi) {
            if (g->history[pi]) {
               memcpy( &g->out[pi * 4], &g->background[pi * 4], 4 );
            }
         }
      } else {
         // This is a non-disposal case eithe way, so just
         // leave the pixels as is, and they will become the new background
         // 1: do not dispose
         // 0:  not specified.
      }

      // background is what out is after the undoing of the previou frame;
      memcpy( g->background, g->out, 4 * g->w * g->h );
   }

   // clear my history;
   memset( g->history, 0x00, g->w * g->h );        // pixels that were affected previous frame

   for (;;) {
      int tag = stbi__get8(s);
      switch (tag) {
         case 0x2C: /* Image Descriptor */
         {
            stbi__int32 x, y, w, h;
            stbi_uc *o;

            x = stbi__get16le(s);
            y = stbi__get16le(s);
            w = stbi__get16le(s);
            h = stbi__get16le(s);
            if (((x + w) > (g->w)) || ((y + h) > (g->h)))
               return stbi__errpuc(""bad Image Descriptor"", ""Corrupt GIF"");

            g->line_size = g->w * 4;
            g->start_x = x * 4;
            g->start_y = y * g->line_size;
            g->max_x   = g->start_x + w * 4;
            g->max_y   = g->start_y + h * g->line_size;
            g->cur_x   = g->start_x;
            g->cur_y   = g->start_y;

            // if the width of the specified rectangle is 0, that means
            // we may not see *any* pixels or the image is malformed;
            // to make sure this is caught, move the current y down to
            // max_y (which is what out_gif_code checks).
            if (w == 0)
               g->cur_y = g->max_y;

            g->lflags = stbi__get8(s);

            if (g->lflags & 0x40) {
               g->step = 8 * g->line_size; // first interlaced spacing
               g->parse = 3;
            } else {
               g->step = g->line_size;
               g->parse = 0;
            }

            if (g->lflags & 0x80) {
               stbi__gif_parse_colortable(s,g->lpal, 2 << (g->lflags & 7), g->eflags & 0x01 ? g->transparent : -1);
               g->color_table = (stbi_uc *) g->lpal;
            } else if (g->flags & 0x80) {
               g->color_table = (stbi_uc *) g->pal;
            } else
               return stbi__errpuc(""missing color table"", ""Corrupt GIF"");

            o = stbi__process_gif_raster(s, g);
            if (!o) return NULL;

            // if this was the first frame,
            pcount = g->w * g->h;
            if (first_frame && (g->bgindex > 0)) {
               // if first frame, any pixel not drawn to gets the background color
               for (pi = 0; pi < pcount; ++pi) {
                  if (g->history[pi] == 0) {
                     g->pal[g->bgindex][3] = 255; // just in case it was made transparent, undo that; It will be reset next frame if need be;
                     memcpy( &g->out[pi * 4], &g->pal[g->bgindex], 4 );
                  }
               }
            }

            return o;
         }

         case 0x21: // Comment Extension.
         {
            int len;
            int ext = stbi__get8(s);
            if (ext == 0xF9) { // Graphic Control Extension.
               len = stbi__get8(s);
               if (len == 4) {
                  g->eflags = stbi__get8(s);
                  g->delay = 10 * stbi__get16le(s); // delay - 1/100th of a second, saving as 1/1000ths.

                  // unset old transparent
                  if (g->transparent >= 0) {
                     g->pal[g->transparent][3] = 255;
                  }
                  if (g->eflags & 0x01) {
                     g->transparent = stbi__get8(s);
                     if (g->transparent >= 0) {
                        g->pal[g->transparent][3] = 0;
                     }
                  } else {
                     // don't need transparent
                     stbi__skip(s, 1);
                     g->transparent = -1;
                  }
               } else {
                  stbi__skip(s, len);
                  break;
               }
            }
            while ((len = stbi__get8(s)) != 0) {
               stbi__skip(s, len);
            }
            break;
         }

         case 0x3B: // gif stream termination code
            return (stbi_uc *) s; // using '1' causes warning on some compilers

         default:
            return stbi__errpuc(""unknown code"", ""Corrupt GIF"");
      }
   }
}","{'begin': {'line': 6778, 'column': 1}, 'end': {'line': 6950, 'column': 2}}",play_bmp_sequence.c,"['逐帧', '加载', 'GIF', '图像', '，', '处理', '帧', '间', '过渡']"
384,384,stbi__pnm_test,int,int stbi__pnm_test(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",检测输入是否为PNM格式图像,"static int      stbi__pnm_test(stbi__context *s)
{
   char p, t;
   p = (char) stbi__get8(s);
   t = (char) stbi__get8(s);
   if (p != 'P' || (t != '5' && t != '6')) {
       stbi__rewind( s );
       return 0;
   }
   return 1;
}","{'begin': {'line': 7494, 'column': 1}, 'end': {'line': 7504, 'column': 2}}",play_bmp_sequence.c,"['检测', '输入', '是否', '为', 'PNM', '格式', '图像']"
385,385,stbi__pnm_load,void *,"void * stbi__pnm_load(stbi__context * s, int * x, int * y, int * comp, int req_comp, stbi__result_info * ri)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'ri', 'type': 'stbi__result_info *'}]",加载并转换PNM图像数据，处理尺寸和内存分配,"static void *stbi__pnm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   stbi_uc *out;
   STBI_NOTUSED(ri);

   ri->bits_per_channel = stbi__pnm_info(s, (int *)&s->img_x, (int *)&s->img_y, (int *)&s->img_n);
   if (ri->bits_per_channel == 0)
      return 0;

   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc(""too large"",""Very large image (corrupt?)"");
   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc(""too large"",""Very large image (corrupt?)"");

   *x = s->img_x;
   *y = s->img_y;
   if (comp) *comp = s->img_n;

   if (!stbi__mad4sizes_valid(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0))
      return stbi__errpuc(""too large"", ""PNM too large"");

   out = (stbi_uc *) stbi__malloc_mad4(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0);
   if (!out) return stbi__errpuc(""outofmem"", ""Out of memory"");
   if (!stbi__getn(s, out, s->img_n * s->img_x * s->img_y * (ri->bits_per_channel / 8))) {
      STBI_FREE(out);
      return stbi__errpuc(""bad PNM"", ""PNM file truncated"");
   }

   if (req_comp && req_comp != s->img_n) {
      if (ri->bits_per_channel == 16) {
         out = (stbi_uc *) stbi__convert_format16((stbi__uint16 *) out, s->img_n, req_comp, s->img_x, s->img_y);
      } else {
         out = stbi__convert_format(out, s->img_n, req_comp, s->img_x, s->img_y);
      }
      if (out == NULL) return out; // stbi__convert_format frees input on failure
   }
   return out;
}","{'begin': {'line': 7506, 'column': 1}, 'end': {'line': 7541, 'column': 2}}",play_bmp_sequence.c,"['加载', '并', '转换', 'PNM', '图像', '数据', '，', '处理', '尺寸', '和', '内存', '分配']"
386,386,stbi__pnm_isspace,int,int stbi__pnm_isspace(char c),"[{'name': 'c', 'type': 'char'}]",判断字符是否为空白字符,"static int      stbi__pnm_isspace(char c)
{
   return c == ' ' || c == '\t' || c == '\n' || c == '\v' || c == '\f' || c == '\r';
}","{'begin': {'line': 7543, 'column': 1}, 'end': {'line': 7546, 'column': 2}}",play_bmp_sequence.c,"['判断', '字符', '是否', '为', '空白', '字符']"
387,387,stbi__pnm_skip_whitespace,void,"void stbi__pnm_skip_whitespace(stbi__context * s, char * c)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'c', 'type': 'char *'}]",跳过PNM文件中的空白字符及注释,"static void     stbi__pnm_skip_whitespace(stbi__context *s, char *c)
{
   for (;;) {
      while (!stbi__at_eof(s) && stbi__pnm_isspace(*c))
         *c = (char) stbi__get8(s);

      if (stbi__at_eof(s) || *c != '#')
         break;

      while (!stbi__at_eof(s) && *c != '\n' && *c != '\r' )
         *c = (char) stbi__get8(s);
   }
}","{'begin': {'line': 7548, 'column': 1}, 'end': {'line': 7560, 'column': 2}}",play_bmp_sequence.c,"['跳过', 'PNM', '文件', '中', '的', '空白', '字符', '及', '注释']"
388,388,stbi__pnm_isdigit,int,int stbi__pnm_isdigit(char c),"[{'name': 'c', 'type': 'char'}]",检查字符是否为数字字符。,"static int      stbi__pnm_isdigit(char c)
{
   return c >= '0' && c <= '9';
}","{'begin': {'line': 7562, 'column': 1}, 'end': {'line': 7565, 'column': 2}}",play_bmp_sequence.c,"['检查', '字符', '是否', '为', '数字', '字符', '。']"
389,389,stbi__pnm_getinteger,int,"int stbi__pnm_getinteger(stbi__context * s, char * c)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'c', 'type': 'char *'}]",解析PNM头中的整数并检查溢出,"static int      stbi__pnm_getinteger(stbi__context *s, char *c)
{
   int value = 0;

   while (!stbi__at_eof(s) && stbi__pnm_isdigit(*c)) {
      value = value*10 + (*c - '0');
      *c = (char) stbi__get8(s);
      if((value > 214748364) || (value == 214748364 && *c > '7'))
          return stbi__err(""integer parse overflow"", ""Parsing an integer in the PPM header overflowed a 32-bit int"");
   }

   return value;
}","{'begin': {'line': 7567, 'column': 1}, 'end': {'line': 7579, 'column': 2}}",play_bmp_sequence.c,"['解析', 'PNM', '头中', '的', '整数', '并', '检查', '溢出']"
390,390,stbi__load_gif_main_outofmem,void *,"void * stbi__load_gif_main_outofmem(stbi__gif * g, stbi_uc * out, int ** delays)","[{'name': 'g', 'type': 'stbi__gif *'}, {'name': 'out', 'type': 'stbi_uc *'}, {'name': 'delays', 'type': 'int **'}]",释放内存并返回内存不足错误,"static void *stbi__load_gif_main_outofmem(stbi__gif *g, stbi_uc *out, int **delays)
{
   STBI_FREE(g->out);
   STBI_FREE(g->history);
   STBI_FREE(g->background);

   if (out) STBI_FREE(out);
   if (delays && *delays) STBI_FREE(*delays);
   return stbi__errpuc(""outofmem"", ""Out of memory"");
}","{'begin': {'line': 6952, 'column': 1}, 'end': {'line': 6961, 'column': 2}}",play_bmp_sequence.c,"['释放', '内存', '并', '返回', '内存', '不足', '内存不足', '错误']"
391,391,stbi__pnm_info,int,"int stbi__pnm_info(stbi__context * s, int * x, int * y, int * comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",解析PNM图像头信息，获取尺寸、通道和位深,"static int      stbi__pnm_info(stbi__context *s, int *x, int *y, int *comp)
{
   int maxv, dummy;
   char c, p, t;

   if (!x) x = &dummy;
   if (!y) y = &dummy;
   if (!comp) comp = &dummy;

   stbi__rewind(s);

   // Get identifier
   p = (char) stbi__get8(s);
   t = (char) stbi__get8(s);
   if (p != 'P' || (t != '5' && t != '6')) {
       stbi__rewind(s);
       return 0;
   }

   *comp = (t == '6') ? 3 : 1;  // '5' is 1-component .pgm; '6' is 3-component .ppm

   c = (char) stbi__get8(s);
   stbi__pnm_skip_whitespace(s, &c);

   *x = stbi__pnm_getinteger(s, &c); // read width
   if(*x == 0)
       return stbi__err(""invalid width"", ""PPM image header had zero or overflowing width"");
   stbi__pnm_skip_whitespace(s, &c);

   *y = stbi__pnm_getinteger(s, &c); // read height
   if (*y == 0)
       return stbi__err(""invalid width"", ""PPM image header had zero or overflowing width"");
   stbi__pnm_skip_whitespace(s, &c);

   maxv = stbi__pnm_getinteger(s, &c);  // read max value
   if (maxv > 65535)
      return stbi__err(""max value > 65535"", ""PPM image supports only 8-bit and 16-bit images"");
   else if (maxv > 255)
      return 16;
   else
      return 8;
}","{'begin': {'line': 7581, 'column': 1}, 'end': {'line': 7622, 'column': 2}}",play_bmp_sequence.c,"['解析', 'PNM', '图像', '头', '信息', '，', '获取', '尺寸', '、', '通道', '和', '位深']"
392,392,stbi__load_gif_main,void *,"void * stbi__load_gif_main(stbi__context * s, int ** delays, int * x, int * y, int * z, int * comp, int req_comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'delays', 'type': 'int **'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'z', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",加载GIF图像，支持多帧和延迟时间处理,"static void *stbi__load_gif_main(stbi__context *s, int **delays, int *x, int *y, int *z, int *comp, int req_comp)
{
   if (stbi__gif_test(s)) {
      int layers = 0;
      stbi_uc *u = 0;
      stbi_uc *out = 0;
      stbi_uc *two_back = 0;
      stbi__gif g;
      int stride;
      int out_size = 0;
      int delays_size = 0;

      STBI_NOTUSED(out_size);
      STBI_NOTUSED(delays_size);

      memset(&g, 0, sizeof(g));
      if (delays) {
         *delays = 0;
      }

      do {
         u = stbi__gif_load_next(s, &g, comp, req_comp, two_back);
         if (u == (stbi_uc *) s) u = 0;  // end of animated gif marker

         if (u) {
            *x = g.w;
            *y = g.h;
            ++layers;
            stride = g.w * g.h * 4;

            if (out) {
               void *tmp = (stbi_uc*) STBI_REALLOC_SIZED( out, out_size, layers * stride );
               if (!tmp)
                  return stbi__load_gif_main_outofmem(&g, out, delays);
               else {
                   out = (stbi_uc*) tmp;
                   out_size = layers * stride;
               }

               if (delays) {
                  int *new_delays = (int*) STBI_REALLOC_SIZED( *delays, delays_size, sizeof(int) * layers );
                  if (!new_delays)
                     return stbi__load_gif_main_outofmem(&g, out, delays);
                  *delays = new_delays;
                  delays_size = layers * sizeof(int);
               }
            } else {
               out = (stbi_uc*)stbi__malloc( layers * stride );
               if (!out)
                  return stbi__load_gif_main_outofmem(&g, out, delays);
               out_size = layers * stride;
               if (delays) {
                  *delays = (int*) stbi__malloc( layers * sizeof(int) );
                  if (!*delays)
                     return stbi__load_gif_main_outofmem(&g, out, delays);
                  delays_size = layers * sizeof(int);
               }
            }
            memcpy( out + ((layers - 1) * stride), u, stride );
            if (layers >= 2) {
               two_back = out - 2 * stride;
            }

            if (delays) {
               (*delays)[layers - 1U] = g.delay;
            }
         }
      } while (u != 0);

      // free temp buffer;
      STBI_FREE(g.out);
      STBI_FREE(g.history);
      STBI_FREE(g.background);

      // do the final conversion after loading everything;
      if (req_comp && req_comp != 4)
         out = stbi__convert_format(out, 4, req_comp, layers * g.w, g.h);

      *z = layers;
      return out;
   } else {
      return stbi__errpuc(""not GIF"", ""Image was not as a gif type."");
   }
}","{'begin': {'line': 6963, 'column': 1}, 'end': {'line': 7046, 'column': 2}}",play_bmp_sequence.c,"['加载', 'GIF', '图像', '，', '支持', '多', '帧', '和', '延迟', '时间', '延迟时间', '处理']"
393,393,stbi__pnm_is16,int,int stbi__pnm_is16(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",检测PNM图像是否为16位深度,"static int stbi__pnm_is16(stbi__context *s)
{
   if (stbi__pnm_info(s, NULL, NULL, NULL) == 16)
	   return 1;
   return 0;
}","{'begin': {'line': 7624, 'column': 1}, 'end': {'line': 7629, 'column': 2}}",play_bmp_sequence.c,"['检测', 'PNM', '图像', '是否', '为', '16', '位', '深度']"
394,394,stbi__info_main,int,"int stbi__info_main(stbi__context * s, int * x, int * y, int * comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",检测支持的图像格式并返回基本信息,"static int stbi__info_main(stbi__context *s, int *x, int *y, int *comp)
{
   #ifndef STBI_NO_JPEG
   if (stbi__jpeg_info(s, x, y, comp)) return 1;
   #endif

   #ifndef STBI_NO_PNG
   if (stbi__png_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_GIF
   if (stbi__gif_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_BMP
   if (stbi__bmp_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_PSD
   if (stbi__psd_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_PIC
   if (stbi__pic_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_PNM
   if (stbi__pnm_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_HDR
   if (stbi__hdr_info(s, x, y, comp))  return 1;
   #endif

   // test tga last because it's a crappy test!
   #ifndef STBI_NO_TGA
   if (stbi__tga_info(s, x, y, comp))
       return 1;
   #endif
   return stbi__err(""unknown image type"", ""Image not of any known type, or corrupt"");
}","{'begin': {'line': 7632, 'column': 1}, 'end': {'line': 7672, 'column': 2}}",play_bmp_sequence.c,"['检测', '支持', '的', '图像', '格式', '图像格式', '并', '返回', '基本', '信息']"
395,395,stbi__is_16_main,int,int stbi__is_16_main(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",检测图像是否为16位，支持多种格式,"static int stbi__is_16_main(stbi__context *s)
{
   #ifndef STBI_NO_PNG
   if (stbi__png_is16(s))  return 1;
   #endif

   #ifndef STBI_NO_PSD
   if (stbi__psd_is16(s))  return 1;
   #endif

   #ifndef STBI_NO_PNM
   if (stbi__pnm_is16(s))  return 1;
   #endif
   return 0;
}","{'begin': {'line': 7674, 'column': 1}, 'end': {'line': 7688, 'column': 2}}",play_bmp_sequence.c,"['检测', '图像', '是否', '为', '16', '位', '，', '支持', '多种', '格式']"
396,396,stbi_info,int,"int stbi_info(const char * filename, int * x, int * y, int * comp)","[{'name': 'filename', 'type': 'const char *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",获取图像文件信息（尺寸、通道数）,"STBIDEF int stbi_info(char const *filename, int *x, int *y, int *comp)
{
    FILE *f = stbi__fopen(filename, ""rb"");
    int result;
    if (!f) return stbi__err(""can't fopen"", ""Unable to open file"");
    result = stbi_info_from_file(f, x, y, comp);
    fclose(f);
    return result;
}","{'begin': {'line': 7691, 'column': 1}, 'end': {'line': 7699, 'column': 2}}",play_bmp_sequence.c,"['获取', '图像', '文件', '图像文件', '信息', '（', '尺寸', '、', '通道', '数', '）']"
397,397,stbi__gif_load,void *,"void * stbi__gif_load(stbi__context * s, int * x, int * y, int * comp, int req_comp, stbi__result_info * ri)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'ri', 'type': 'stbi__result_info *'}]",加载GIF图像数据并转换格式,"static void *stbi__gif_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   stbi_uc *u = 0;
   stbi__gif g;
   memset(&g, 0, sizeof(g));
   STBI_NOTUSED(ri);

   u = stbi__gif_load_next(s, &g, comp, req_comp, 0);
   if (u == (stbi_uc *) s) u = 0;  // end of animated gif marker
   if (u) {
      *x = g.w;
      *y = g.h;

      // moved conversion to after successful load so that the same
      // can be done for multiple frames.
      if (req_comp && req_comp != 4)
         u = stbi__convert_format(u, 4, req_comp, g.w, g.h);
   } else if (g.out) {
      // if there was an error and we allocated an image buffer, free it!
      STBI_FREE(g.out);
   }

   // free buffers needed for multiple frame loading;
   STBI_FREE(g.history);
   STBI_FREE(g.background);

   return u;
}","{'begin': {'line': 7048, 'column': 1}, 'end': {'line': 7075, 'column': 2}}",play_bmp_sequence.c,"['加载', 'GIF', '图像', '数据', '并', '转换', '格式']"
398,398,stbi_info_from_file,int,"int stbi_info_from_file(FILE * f, int * x, int * y, int * comp)","[{'name': 'f', 'type': 'FILE *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",从文件读取图像基本信息并保持文件位置,"STBIDEF int stbi_info_from_file(FILE *f, int *x, int *y, int *comp)
{
   int r;
   stbi__context s;
   long pos = ftell(f);
   stbi__start_file(&s, f);
   r = stbi__info_main(&s,x,y,comp);
   fseek(f,pos,SEEK_SET);
   return r;
}","{'begin': {'line': 7701, 'column': 1}, 'end': {'line': 7710, 'column': 2}}",play_bmp_sequence.c,"['文件', '从文件', '读取', '图像', '基本', '信息', '并', '保持', '文件', '位置']"
399,399,stbi_is_16_bit,int,int stbi_is_16_bit(const char * filename),"[{'name': 'filename', 'type': 'const char *'}]",检查文件是否为16位图像,"STBIDEF int stbi_is_16_bit(char const *filename)
{
    FILE *f = stbi__fopen(filename, ""rb"");
    int result;
    if (!f) return stbi__err(""can't fopen"", ""Unable to open file"");
    result = stbi_is_16_bit_from_file(f);
    fclose(f);
    return result;
}","{'begin': {'line': 7712, 'column': 1}, 'end': {'line': 7720, 'column': 2}}",play_bmp_sequence.c,"['检查', '文件', '是否', '为', '16', '位', '图像']"
400,400,stbi_is_16_bit_from_file,int,int stbi_is_16_bit_from_file(FILE * f),"[{'name': 'f', 'type': 'FILE *'}]",检查文件中的图像是否为16位，保持文件指针位置不变,"STBIDEF int stbi_is_16_bit_from_file(FILE *f)
{
   int r;
   stbi__context s;
   long pos = ftell(f);
   stbi__start_file(&s, f);
   r = stbi__is_16_main(&s);
   fseek(f,pos,SEEK_SET);
   return r;
}","{'begin': {'line': 7722, 'column': 1}, 'end': {'line': 7731, 'column': 2}}",play_bmp_sequence.c,"['检查', '文件', '中', '的', '图像', '是否', '为', '16', '位', '，', '保持', '文件', '指针', '位置', '不变']"
401,401,stbi__gif_info,int,"int stbi__gif_info(stbi__context * s, int * x, int * y, int * comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",调用原始函数获取GIF图像信息,"static int stbi__gif_info(stbi__context *s, int *x, int *y, int *comp)
{
   return stbi__gif_info_raw(s,x,y,comp);
}","{'begin': {'line': 7077, 'column': 1}, 'end': {'line': 7080, 'column': 2}}",play_bmp_sequence.c,"['调用', '原始', '函数', '获取', 'GIF', '图像', '信息']"
402,402,stbi__hdr_test_core,int,"int stbi__hdr_test_core(stbi__context * s, const char * signature)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'signature', 'type': 'const char *'}]",检查数据流是否以指定签名开头,"static int stbi__hdr_test_core(stbi__context *s, const char *signature)
{
   int i;
   for (i=0; signature[i]; ++i)
      if (stbi__get8(s) != signature[i])
          return 0;
   stbi__rewind(s);
   return 1;
}","{'begin': {'line': 7087, 'column': 1}, 'end': {'line': 7095, 'column': 2}}",play_bmp_sequence.c,"['检查', '数据', '数据流', '是否', '以', '指定', '签名', '开头']"
403,403,stbi_info_from_memory,int,"int stbi_info_from_memory(const stbi_uc * buffer, int len, int * x, int * y, int * comp)","[{'name': 'buffer', 'type': 'const stbi_uc *'}, {'name': 'len', 'type': 'int'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",从内存缓冲区获取图像尺寸和通道数,"STBIDEF int stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__info_main(&s,x,y,comp);
}","{'begin': {'line': 7734, 'column': 1}, 'end': {'line': 7739, 'column': 2}}",play_bmp_sequence.c,"['从', '内存', '缓冲', '缓冲区', '获取', '图像', '尺寸', '和', '通道', '数']"
404,404,stbi__hdr_test,int,int stbi__hdr_test(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",检测输入流是否为HDR格式文件,"static int stbi__hdr_test(stbi__context* s)
{
   int r = stbi__hdr_test_core(s, ""#?RADIANCE\n"");
   stbi__rewind(s);
   if(!r) {
       r = stbi__hdr_test_core(s, ""#?RGBE\n"");
       stbi__rewind(s);
   }
   return r;
}","{'begin': {'line': 7097, 'column': 1}, 'end': {'line': 7106, 'column': 2}}",play_bmp_sequence.c,"['检测', '输入', '流', '是否', '为', 'HDR', '格式', '文件', '格式文件']"
405,405,stbi_info_from_callbacks,int,"int stbi_info_from_callbacks(const stbi_io_callbacks * c, void * user, int * x, int * y, int * comp)","[{'name': 'c', 'type': 'const stbi_io_callbacks *'}, {'name': 'user', 'type': 'void *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",通过回调获取图像信息（尺寸和通道数）,"STBIDEF int stbi_info_from_callbacks(stbi_io_callbacks const *c, void *user, int *x, int *y, int *comp)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) c, user);
   return stbi__info_main(&s,x,y,comp);
}","{'begin': {'line': 7741, 'column': 1}, 'end': {'line': 7746, 'column': 2}}",play_bmp_sequence.c,"['通过', '回调', '获取', '图像', '信息', '（', '尺寸', '和', '通道', '数', '）']"
406,406,stbi__hdr_gettoken,char *,"char * stbi__hdr_gettoken(stbi__context * z, char * buffer)","[{'name': 'z', 'type': 'stbi__context *'}, {'name': 'buffer', 'type': 'char *'}]",读取HDR格式令牌直到换行符或缓冲区满,"static char *stbi__hdr_gettoken(stbi__context *z, char *buffer)
{
   int len=0;
   char c = '\0';

   c = (char) stbi__get8(z);

   while (!stbi__at_eof(z) && c != '\n') {
      buffer[len++] = c;
      if (len == STBI__HDR_BUFLEN-1) {
         // flush to end of line
         while (!stbi__at_eof(z) && stbi__get8(z) != '\n')
            ;
         break;
      }
      c = (char) stbi__get8(z);
   }

   buffer[len] = 0;
   return buffer;
}","{'begin': {'line': 7109, 'column': 1}, 'end': {'line': 7129, 'column': 2}}",play_bmp_sequence.c,"['读取', 'HDR', '格式', '令牌', '直到', '换行', '换行符', '或', '缓冲', '缓冲区', '满']"
407,407,stbi_is_16_bit_from_memory,int,"int stbi_is_16_bit_from_memory(const stbi_uc * buffer, int len)","[{'name': 'buffer', 'type': 'const stbi_uc *'}, {'name': 'len', 'type': 'int'}]",检查内存缓冲区的图像是否为16位格式,"STBIDEF int stbi_is_16_bit_from_memory(stbi_uc const *buffer, int len)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__is_16_main(&s);
}","{'begin': {'line': 7748, 'column': 1}, 'end': {'line': 7753, 'column': 2}}",play_bmp_sequence.c,"['检查', '内存', '缓冲', '缓冲区', '的', '图像', '是否', '为', '16', '位', '格式']"
408,408,stbi__hdr_convert,void,"void stbi__hdr_convert(float * output, stbi_uc * input, int req_comp)","[{'name': 'output', 'type': 'float *'}, {'name': 'input', 'type': 'stbi_uc *'}, {'name': 'req_comp', 'type': 'int'}]",将HDR输入转换为浮点数输出，调整通道数。,"static void stbi__hdr_convert(float *output, stbi_uc *input, int req_comp)
{
   if ( input[3] != 0 ) {
      float f1;
      // Exponent
      f1 = (float) ldexp(1.0f, input[3] - (int)(128 + 8));
      if (req_comp <= 2)
         output[0] = (input[0] + input[1] + input[2]) * f1 / 3;
      else {
         output[0] = input[0] * f1;
         output[1] = input[1] * f1;
         output[2] = input[2] * f1;
      }
      if (req_comp == 2) output[1] = 1;
      if (req_comp == 4) output[3] = 1;
   } else {
      switch (req_comp) {
         case 4: output[3] = 1; /* fallthrough */
         case 3: output[0] = output[1] = output[2] = 0;
                 break;
         case 2: output[1] = 1; /* fallthrough */
         case 1: output[0] = 0;
                 break;
      }
   }
}","{'begin': {'line': 7131, 'column': 1}, 'end': {'line': 7156, 'column': 2}}",play_bmp_sequence.c,"['将', 'HDR', '输入', '转换', '为', '浮点', '点数', '浮点数', '输出', '，', '调整', '通道', '数', '。']"
409,409,stbi_is_16_bit_from_callbacks,int,"int stbi_is_16_bit_from_callbacks(const stbi_io_callbacks * c, void * user)","[{'name': 'c', 'type': 'const stbi_io_callbacks *'}, {'name': 'user', 'type': 'void *'}]",通过回调函数检测图像是否为16位格式,"STBIDEF int stbi_is_16_bit_from_callbacks(stbi_io_callbacks const *c, void *user)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) c, user);
   return stbi__is_16_main(&s);
}","{'begin': {'line': 7755, 'column': 1}, 'end': {'line': 7760, 'column': 2}}",play_bmp_sequence.c,"['通过', '回调', '函数', '检测', '图像', '是否', '为', '16', '位', '格式']"
410,410,stbi__sse2_available,int,int stbi__sse2_available(),[],检查SSE2支持并始终返回1,"static int stbi__sse2_available(void)
{
   // If we're even attempting to compile this on GCC/Clang, that means
   // -msse2 is on, which means the compiler is allowed to use SSE2
   // instructions at will, and so are we.
   return 1;
}","{'begin': {'line': 765, 'column': 1}, 'end': {'line': 771, 'column': 2}}",key_monitor.c,"['检查', 'SSE2', '支持', '并', '始终', '返回', '1']"
411,411,stbi__start_mem,void,"void stbi__start_mem(stbi__context * s, const stbi_uc * buffer, int len)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'buffer', 'type': 'const stbi_uc *'}, {'name': 'len', 'type': 'int'}]",初始化内存图像读取上下文,"static void stbi__start_mem(stbi__context *s, stbi_uc const *buffer, int len)
{
   s->io.read = NULL;
   s->read_from_callbacks = 0;
   s->callback_already_read = 0;
   s->img_buffer = s->img_buffer_original = (stbi_uc *) buffer;
   s->img_buffer_end = s->img_buffer_original_end = (stbi_uc *) buffer+len;
}","{'begin': {'line': 826, 'column': 1}, 'end': {'line': 833, 'column': 2}}",key_monitor.c,"['初始', '初始化', '内存', '图像', '读取', '上下', '下文', '上下文']"
412,412,stbi__start_callbacks,void,"void stbi__start_callbacks(stbi__context * s, stbi_io_callbacks * c, void * user)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'c', 'type': 'stbi_io_callbacks *'}, {'name': 'user', 'type': 'void *'}]",初始化图像读取回调接口及缓冲区,"static void stbi__start_callbacks(stbi__context *s, stbi_io_callbacks *c, void *user)
{
   s->io = *c;
   s->io_user_data = user;
   s->buflen = sizeof(s->buffer_start);
   s->read_from_callbacks = 1;
   s->callback_already_read = 0;
   s->img_buffer = s->img_buffer_original = s->buffer_start;
   stbi__refill_buffer(s);
   s->img_buffer_original_end = s->img_buffer_end;
}","{'begin': {'line': 836, 'column': 1}, 'end': {'line': 846, 'column': 2}}",key_monitor.c,"['初始', '初始化', '图像', '读取', '回调', '接口', '及', '缓冲', '缓冲区']"
413,413,stbi__stdio_read,int,"int stbi__stdio_read(void * user, char * data, int size)","[{'name': 'user', 'type': 'void *'}, {'name': 'data', 'type': 'char *'}, {'name': 'size', 'type': 'int'}]",使用fread从文件指针读取数据,"static int stbi__stdio_read(void *user, char *data, int size)
{
   return (int) fread(data,1,size,(FILE*) user);
}","{'begin': {'line': 850, 'column': 1}, 'end': {'line': 853, 'column': 2}}",key_monitor.c,"['使用', 'fread', '文件', '从文件', '指针', '读取', '数据', '读取数据']"
414,414,stbi__stdio_skip,void,"void stbi__stdio_skip(void * user, int n)","[{'name': 'user', 'type': 'void *'}, {'name': 'n', 'type': 'int'}]",跳过文件流中指定字节数并处理EOF状态,"static void stbi__stdio_skip(void *user, int n)
{
   int ch;
   fseek((FILE*) user, n, SEEK_CUR);
   ch = fgetc((FILE*) user);  /* have to read a byte to reset feof()'s flag */
   if (ch != EOF) {
      ungetc(ch, (FILE *) user);  /* push byte back onto stream if valid. */
   }
}","{'begin': {'line': 855, 'column': 1}, 'end': {'line': 863, 'column': 2}}",key_monitor.c,"['跳过', '文件', '流中', '指定', '字节', '节数', '字节数', '并', '处理', 'EOF', '状态']"
415,415,stbi__stdio_eof,int,int stbi__stdio_eof(void * user),"[{'name': 'user', 'type': 'void *'}]",检查文件流结束或错误状态,"static int stbi__stdio_eof(void *user)
{
   return feof((FILE*) user) || ferror((FILE *) user);
}","{'begin': {'line': 865, 'column': 1}, 'end': {'line': 868, 'column': 2}}",key_monitor.c,"['检查', '文件', '流', '结束', '或', '错误', '状态']"
416,416,stbi__start_file,void,"void stbi__start_file(stbi__context * s, FILE * f)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'f', 'type': 'FILE *'}]",初始化文件读取上下文，使用标准I/O回调,"static void stbi__start_file(stbi__context *s, FILE *f)
{
   stbi__start_callbacks(s, &stbi__stdio_callbacks, (void *) f);
}","{'begin': {'line': 877, 'column': 1}, 'end': {'line': 880, 'column': 2}}",key_monitor.c,"['初始', '初始化', '文件', '读取', '上下', '下文', '上下文', '，', '使用', '标准', 'I', '/', 'O', '回调']"
417,417,stbi__rewind,void,void stbi__rewind(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",重置图像缓冲区到初始位置,"static void stbi__rewind(stbi__context *s)
{
   // conceptually rewind SHOULD rewind to the beginning of the stream,
   // but we just rewind to the beginning of the initial buffer, because
   // we only use it after doing 'test', which only ever looks at at most 92 bytes
   s->img_buffer = s->img_buffer_original;
   s->img_buffer_end = s->img_buffer_original_end;
}","{'begin': {'line': 886, 'column': 1}, 'end': {'line': 893, 'column': 2}}",key_monitor.c,"['重置', '图像', '缓冲', '缓冲区', '到', '初始', '位置']"
418,418,stbi_failure_reason,const char *,const char * stbi_failure_reason(),[],返回最近图像处理的错误信息,"STBIDEF const char *stbi_failure_reason(void)
{
   return stbi__g_failure_reason;
}","{'begin': {'line': 972, 'column': 1}, 'end': {'line': 975, 'column': 2}}",key_monitor.c,"['返回', '最近', '图像', '处理', '图像处理', '的', '错误', '误信', '信息', '错误信息']"
419,419,stbi__err,int,int stbi__err(const char * str),"[{'name': 'str', 'type': 'const char *'}]",设置错误信息并返回失败状态,"static int stbi__err(const char *str)
{
   stbi__g_failure_reason = str;
   return 0;
}","{'begin': {'line': 978, 'column': 1}, 'end': {'line': 982, 'column': 2}}",key_monitor.c,"['设置', '错误', '误信', '信息', '错误信息', '并', '返回', '失败', '状态']"
420,420,stbi__malloc,void *,void * stbi__malloc(int size),"[{'name': 'size', 'type': 'int'}]",分配指定大小的内存块，调用STBI_MALLOC实现,"static void *stbi__malloc(size_t size)
{
    return STBI_MALLOC(size);
}","{'begin': {'line': 985, 'column': 1}, 'end': {'line': 988, 'column': 2}}",key_monitor.c,"['分配', '指定', '大小', '的', '内存', '块', '，', '调用', 'STBI', '_', 'MALLOC', '实现']"
421,421,stbi__addsizes_valid,int,"int stbi__addsizes_valid(int a, int b)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}]",检查a加b是否不溢出整数范围,"static int stbi__addsizes_valid(int a, int b)
{
   if (b < 0) return 0;
   // now 0 <= b <= INT_MAX, hence also
   // 0 <= INT_MAX - b <= INTMAX.
   // And ""a + b <= INT_MAX"" (which might overflow) is the
   // same as a <= INT_MAX - b (no overflow)
   return a <= INT_MAX - b;
}","{'begin': {'line': 1002, 'column': 1}, 'end': {'line': 1010, 'column': 2}}",key_monitor.c,"['检查', 'a', '加', 'b', '是否', '不', '溢出', '整数', '范围']"
422,422,stbi__mul2sizes_valid,int,"int stbi__mul2sizes_valid(int a, int b)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}]",检查两数相乘是否有效，防止溢出,"static int stbi__mul2sizes_valid(int a, int b)
{
   if (a < 0 || b < 0) return 0;
   if (b == 0) return 1; // mul-by-0 is always safe
   // portable way to check for no overflows in a*b
   return a <= INT_MAX/b;
}","{'begin': {'line': 1014, 'column': 1}, 'end': {'line': 1020, 'column': 2}}",key_monitor.c,"['检查', '两', '数', '相乘', '是否', '有效', '，', '防止', '溢出']"
423,423,stbi__mad2sizes_valid,int,"int stbi__mad2sizes_valid(int a, int b, int add)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}, {'name': 'add', 'type': 'int'}]",验证乘加运算的有效性，防止溢出。,"static int stbi__mad2sizes_valid(int a, int b, int add)
{
   return stbi__mul2sizes_valid(a, b) && stbi__addsizes_valid(a*b, add);
}","{'begin': {'line': 1024, 'column': 1}, 'end': {'line': 1027, 'column': 2}}",key_monitor.c,"['验证', '乘加', '运算', '的', '有效', '有效性', '，', '防止', '溢出', '。']"
424,424,stbi__mad3sizes_valid,int,"int stbi__mad3sizes_valid(int a, int b, int c, int add)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}, {'name': 'c', 'type': 'int'}, {'name': 'add', 'type': 'int'}]",验证三个数相乘并加值的有效性,"static int stbi__mad3sizes_valid(int a, int b, int c, int add)
{
   return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&
      stbi__addsizes_valid(a*b*c, add);
}","{'begin': {'line': 1031, 'column': 1}, 'end': {'line': 1035, 'column': 2}}",key_monitor.c,"['验证', '三个', '数', '相乘', '并', '加值', '的', '有效', '有效性']"
425,425,stbi__mad4sizes_valid,int,"int stbi__mad4sizes_valid(int a, int b, int c, int d, int add)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}, {'name': 'c', 'type': 'int'}, {'name': 'd', 'type': 'int'}, {'name': 'add', 'type': 'int'}]",检查四个数相乘加值的有效性，防止溢出,"static int stbi__mad4sizes_valid(int a, int b, int c, int d, int add)
{
   return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&
      stbi__mul2sizes_valid(a*b*c, d) && stbi__addsizes_valid(a*b*c*d, add);
}","{'begin': {'line': 1039, 'column': 1}, 'end': {'line': 1043, 'column': 2}}",key_monitor.c,"['检查', '四个', '数', '相乘', '加值', '的', '有效', '有效性', '，', '防止', '溢出']"
426,426,stbi__malloc_mad2,void *,"void * stbi__malloc_mad2(int a, int b, int add)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}, {'name': 'add', 'type': 'int'}]",分配a*b+add内存前检查有效性,"static void *stbi__malloc_mad2(int a, int b, int add)
{
   if (!stbi__mad2sizes_valid(a, b, add)) return NULL;
   return stbi__malloc(a*b + add);
}","{'begin': {'line': 1048, 'column': 1}, 'end': {'line': 1052, 'column': 2}}",key_monitor.c,"['分配', 'a', '*', 'b', '+', 'add', '内存', '前', '检查', '有效', '有效性']"
427,427,stbi__malloc_mad3,void *,"void * stbi__malloc_mad3(int a, int b, int c, int add)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}, {'name': 'c', 'type': 'int'}, {'name': 'add', 'type': 'int'}]",验证并分配a*b*c + add大小的内存,"static void *stbi__malloc_mad3(int a, int b, int c, int add)
{
   if (!stbi__mad3sizes_valid(a, b, c, add)) return NULL;
   return stbi__malloc(a*b*c + add);
}","{'begin': {'line': 1055, 'column': 1}, 'end': {'line': 1059, 'column': 2}}",key_monitor.c,"['验证', '并', '分配', 'a', '*', 'b', '*', 'c', ' ', '+', ' ', 'add', '大小', '的', '内存']"
428,428,stbi__malloc_mad4,void *,"void * stbi__malloc_mad4(int a, int b, int c, int d, int add)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}, {'name': 'c', 'type': 'int'}, {'name': 'd', 'type': 'int'}, {'name': 'add', 'type': 'int'}]",验证四参数乘积加add后分配内存,"static void *stbi__malloc_mad4(int a, int b, int c, int d, int add)
{
   if (!stbi__mad4sizes_valid(a, b, c, d, add)) return NULL;
   return stbi__malloc(a*b*c*d + add);
}","{'begin': {'line': 1062, 'column': 1}, 'end': {'line': 1066, 'column': 2}}",key_monitor.c,"['验证', '四', '参数', '乘积', '加', 'add', '后', '分配', '内存', '分配内存']"
429,429,stbi__addints_valid,int,"int stbi__addints_valid(int a, int b)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}]",检查两整数相加是否溢出,"static int stbi__addints_valid(int a, int b)
{
   if ((a >= 0) != (b >= 0)) return 1; // a and b have different signs, so no overflow
   if (a < 0 && b < 0) return a >= INT_MIN - b; // same as a + b >= INT_MIN; INT_MIN - b cannot overflow since b < 0.
   return a <= INT_MAX - b;
}","{'begin': {'line': 1070, 'column': 1}, 'end': {'line': 1075, 'column': 2}}",key_monitor.c,"['检查', '两', '整数', '相加', '是否', '溢出']"
430,430,stbi__mul2shorts_valid,int,"int stbi__mul2shorts_valid(int a, int b)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}]",检查两整数相乘是否在short范围内,"static int stbi__mul2shorts_valid(int a, int b)
{
   if (b == 0 || b == -1) return 1; // multiplication by 0 is always 0; check for -1 so SHRT_MIN/b doesn't overflow
   if ((a >= 0) == (b >= 0)) return a <= SHRT_MAX/b; // product is positive, so similar to mul2sizes_valid
   if (b < 0) return a <= SHRT_MIN / b; // same as a * b >= SHRT_MIN
   return a >= SHRT_MIN / b;
}","{'begin': {'line': 1078, 'column': 1}, 'end': {'line': 1084, 'column': 2}}",key_monitor.c,"['检查', '两', '整数', '相乘', '是否', '在', 'short', '范围', '内']"
431,431,stbi_image_free,void,void stbi_image_free(void * retval_from_stbi_load),"[{'name': 'retval_from_stbi_load', 'type': 'void *'}]",释放由stbi_load加载的图像内存,"STBIDEF void stbi_image_free(void *retval_from_stbi_load)
{
   STBI_FREE(retval_from_stbi_load);
}","{'begin': {'line': 1101, 'column': 1}, 'end': {'line': 1104, 'column': 2}}",key_monitor.c,"['释放', '由', 'stbi', '_', 'load', '加载', '的', '图像', '内存']"
432,432,stbi_set_flip_vertically_on_load,void,void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip),"[{'name': 'flag_true_if_should_flip', 'type': 'int'}]",设置图像加载时垂直翻转标志,"STBIDEF void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip)
{
   stbi__vertically_flip_on_load_global = flag_true_if_should_flip;
}","{'begin': {'line': 1116, 'column': 1}, 'end': {'line': 1119, 'column': 2}}",key_monitor.c,"['设置', '图像', '加载', '时', '垂直', '翻转', '标志']"
433,433,stbi_set_flip_vertically_on_load_thread,void,void stbi_set_flip_vertically_on_load_thread(int flag_true_if_should_flip),"[{'name': 'flag_true_if_should_flip', 'type': 'int'}]",设置加载图像时是否垂直翻转（线程级）,"STBIDEF void stbi_set_flip_vertically_on_load_thread(int flag_true_if_should_flip)
{
   stbi__vertically_flip_on_load_local = flag_true_if_should_flip;
   stbi__vertically_flip_on_load_set = 1;
}","{'begin': {'line': 1126, 'column': 1}, 'end': {'line': 1130, 'column': 2}}",key_monitor.c,"['设置', '加载', '图像', '时', '是否', '垂直', '翻转', '（', '线程', '级', '）']"
434,434,stbi__load_main,void *,"void * stbi__load_main(stbi__context * s, int * x, int * y, int * comp, int req_comp, stbi__result_info * ri, int bpc)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'ri', 'type': 'stbi__result_info *'}, {'name': 'bpc', 'type': 'int'}]",检测图像格式并调用对应解码器加载数据,"static void *stbi__load_main(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)
{
   memset(ri, 0, sizeof(*ri)); // make sure it's initialized if we add new fields
   ri->bits_per_channel = 8; // default is 8 so most paths don't have to be changed
   ri->channel_order = STBI_ORDER_RGB; // all current input & output are this, but this is here so we can add BGR order
   ri->num_channels = 0;

   // test the formats with a very explicit header first (at least a FOURCC
   // or distinctive magic number first)
   #ifndef STBI_NO_PNG
   if (stbi__png_test(s))  return stbi__png_load(s,x,y,comp,req_comp, ri);
   #endif
   #ifndef STBI_NO_BMP
   if (stbi__bmp_test(s))  return stbi__bmp_load(s,x,y,comp,req_comp, ri);
   #endif
   #ifndef STBI_NO_GIF
   if (stbi__gif_test(s))  return stbi__gif_load(s,x,y,comp,req_comp, ri);
   #endif
   #ifndef STBI_NO_PSD
   if (stbi__psd_test(s))  return stbi__psd_load(s,x,y,comp,req_comp, ri, bpc);
   #else
   STBI_NOTUSED(bpc);
   #endif
   #ifndef STBI_NO_PIC
   if (stbi__pic_test(s))  return stbi__pic_load(s,x,y,comp,req_comp, ri);
   #endif

   // then the formats that can end up attempting to load with just 1 or 2
   // bytes matching expectations; these are prone to false positives, so
   // try them later
   #ifndef STBI_NO_JPEG
   if (stbi__jpeg_test(s)) return stbi__jpeg_load(s,x,y,comp,req_comp, ri);
   #endif
   #ifndef STBI_NO_PNM
   if (stbi__pnm_test(s))  return stbi__pnm_load(s,x,y,comp,req_comp, ri);
   #endif

   #ifndef STBI_NO_HDR
   if (stbi__hdr_test(s)) {
      float *hdr = stbi__hdr_load(s, x,y,comp,req_comp, ri);
      return stbi__hdr_to_ldr(hdr, *x, *y, req_comp ? req_comp : *comp);
   }
   #endif

   #ifndef STBI_NO_TGA
   // test tga last because it's a crappy test!
   if (stbi__tga_test(s))
      return stbi__tga_load(s,x,y,comp,req_comp, ri);
   #endif

   return stbi__errpuc(""unknown image type"", ""Image not of any known type, or corrupt"");
}","{'begin': {'line': 1137, 'column': 1}, 'end': {'line': 1188, 'column': 2}}",key_monitor.c,"['检测', '图像', '格式', '图像格式', '并', '调用', '对应', '解码', '码器', '解码器', '加载', '数据']"
435,435,stbi__sse2_available,int,int stbi__sse2_available(),[],检查SSE2支持是否启用，始终返回1。,"static int stbi__sse2_available(void)
{
   // If we're even attempting to compile this on GCC/Clang, that means
   // -msse2 is on, which means the compiler is allowed to use SSE2
   // instructions at will, and so are we.
   return 1;
}","{'begin': {'line': 765, 'column': 1}, 'end': {'line': 771, 'column': 2}}",show_image.c,"['检查', 'SSE2', '支持', '是否', '启用', '，', '始终', '返回', '1', '。']"
436,436,stbi__start_mem,void,"void stbi__start_mem(stbi__context * s, const stbi_uc * buffer, int len)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'buffer', 'type': 'const stbi_uc *'}, {'name': 'len', 'type': 'int'}]","好的，用户让我缩减之前的摘要到不超过50字，并且不要包含文件地址。之前的摘要已经是“初始化内存读取上下文”，已经很简洁了。不过用户可能觉得需要更详细一点？或者保持原样？需要检查是否符合要求。原来的摘要已经符合字数限制，而且没有文件地址，所以可能用户希望保持原样。确认后，直接返回原来的内容即可。

另外，用户可能是在测试我的适应能力，确保我能正确遵循不同的规则调整。需要严格按照新要求处理，但当前情况不需要修改。所以最终结果和之前一样。
</think>

{""name"": ""stbi__start_mem"", ""summary"": ""初始化内存读取上下文""}","static void stbi__start_mem(stbi__context *s, stbi_uc const *buffer, int len)
{
   s->io.read = NULL;
   s->read_from_callbacks = 0;
   s->callback_already_read = 0;
   s->img_buffer = s->img_buffer_original = (stbi_uc *) buffer;
   s->img_buffer_end = s->img_buffer_original_end = (stbi_uc *) buffer+len;
}","{'begin': {'line': 826, 'column': 1}, 'end': {'line': 833, 'column': 2}}",show_image.c,"['好', '的', '，', '用户', '让', '我', '缩减', '之前', '的', '摘要', '到', '不', '超过', '50', '字', '，', '并且', '不要', '包含', '文件', '地址', '。', '之前', '的', '摘要', '已经', '是', '“', '初始', '初始化', '内存', '读取', '上下', '下文', '上下文', '”', '，', '已经', '很', '简洁', '了', '。', '不过', '用户', '可能', '觉得', '需要', '更', '详细', '一点', '？', '或者', '保持', '原样', '？', '需要', '检查', '是否', '符合', '要求', '符合要求', '。', '原来', '的', '摘要', '已经', '符合', '字数', '限制', '，', '而且', '没有', '文件', '地址', '，', '所以', '可能', '用户', '希望', '保持', '原样', '。', '确认', '后', '，', '直接', '返回', '原来', '的', '内容', '即可', '。', '\n', '\n', '另外', '，', '用户', '可能', '是', '在', '测试', '我', '的', '适应', '应能', '能力', '适应能力', '，', '确保', '我能', '正确', '遵循', '不同', '的', '规则', '调整', '。', '需要', '严格', '按照', '新', '要求', '处理', '，', '但', '当前', '前情', '情况', '当前情况', '不', '需要', '修改', '。', '所以', '最终', '结果', '和', '之前', '一样', '。', '\n', '<', '/', 'think', '>', '\n', '\n', '{', '""', 'name', '""', ':', ' ', '""', 'stbi', '__', 'start', '_', 'mem', '""', ',', ' ', '""', 'summary', '""', ':', ' ', '""', '初始', '初始化', '内存', '读取', '上下', '下文', '上下文', '""', '}']"
437,437,stbi__start_callbacks,void,"void stbi__start_callbacks(stbi__context * s, stbi_io_callbacks * c, void * user)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'c', 'type': 'stbi_io_callbacks *'}, {'name': 'user', 'type': 'void *'}]",初始化图像解码回调函数配置,"static void stbi__start_callbacks(stbi__context *s, stbi_io_callbacks *c, void *user)
{
   s->io = *c;
   s->io_user_data = user;
   s->buflen = sizeof(s->buffer_start);
   s->read_from_callbacks = 1;
   s->callback_already_read = 0;
   s->img_buffer = s->img_buffer_original = s->buffer_start;
   stbi__refill_buffer(s);
   s->img_buffer_original_end = s->img_buffer_end;
}","{'begin': {'line': 836, 'column': 1}, 'end': {'line': 846, 'column': 2}}",show_image.c,"['初始', '初始化', '图像', '解码', '回调', '函数', '配置']"
438,438,stbi__stdio_read,int,"int stbi__stdio_read(void * user, char * data, int size)","[{'name': 'user', 'type': 'void *'}, {'name': 'data', 'type': 'char *'}, {'name': 'size', 'type': 'int'}]",使用fread从文件指针读取数据,"static int stbi__stdio_read(void *user, char *data, int size)
{
   return (int) fread(data,1,size,(FILE*) user);
}","{'begin': {'line': 850, 'column': 1}, 'end': {'line': 853, 'column': 2}}",show_image.c,"['使用', 'fread', '文件', '从文件', '指针', '读取', '数据', '读取数据']"
439,439,stbi__stdio_skip,void,"void stbi__stdio_skip(void * user, int n)","[{'name': 'user', 'type': 'void *'}, {'name': 'n', 'type': 'int'}]",跳过指定字节并重置文件结束标志,"static void stbi__stdio_skip(void *user, int n)
{
   int ch;
   fseek((FILE*) user, n, SEEK_CUR);
   ch = fgetc((FILE*) user);  /* have to read a byte to reset feof()'s flag */
   if (ch != EOF) {
      ungetc(ch, (FILE *) user);  /* push byte back onto stream if valid. */
   }
}","{'begin': {'line': 855, 'column': 1}, 'end': {'line': 863, 'column': 2}}",show_image.c,"['跳过', '指定', '字节', '并', '重置', '文件', '结束', '标志']"
440,440,stbi__stdio_eof,int,int stbi__stdio_eof(void * user),"[{'name': 'user', 'type': 'void *'}]",检查文件流是否结束或出错,"static int stbi__stdio_eof(void *user)
{
   return feof((FILE*) user) || ferror((FILE *) user);
}","{'begin': {'line': 865, 'column': 1}, 'end': {'line': 868, 'column': 2}}",show_image.c,"['检查', '文件', '流', '是否', '结束', '或', '出错']"
441,441,stbi__start_file,void,"void stbi__start_file(stbi__context * s, FILE * f)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'f', 'type': 'FILE *'}]",初始化文件读取上下文，使用标准IO回调,"static void stbi__start_file(stbi__context *s, FILE *f)
{
   stbi__start_callbacks(s, &stbi__stdio_callbacks, (void *) f);
}","{'begin': {'line': 877, 'column': 1}, 'end': {'line': 880, 'column': 2}}",show_image.c,"['初始', '初始化', '文件', '读取', '上下', '下文', '上下文', '，', '使用', '标准', 'IO', '回调']"
442,442,stbi__rewind,void,void stbi__rewind(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",重置图像缓冲区到初始位置,"static void stbi__rewind(stbi__context *s)
{
   // conceptually rewind SHOULD rewind to the beginning of the stream,
   // but we just rewind to the beginning of the initial buffer, because
   // we only use it after doing 'test', which only ever looks at at most 92 bytes
   s->img_buffer = s->img_buffer_original;
   s->img_buffer_end = s->img_buffer_original_end;
}","{'begin': {'line': 886, 'column': 1}, 'end': {'line': 893, 'column': 2}}",show_image.c,"['重置', '图像', '缓冲', '缓冲区', '到', '初始', '位置']"
443,443,stbi_failure_reason,const char *,const char * stbi_failure_reason(),[],返回最近一次图像加载失败的错误描述,"STBIDEF const char *stbi_failure_reason(void)
{
   return stbi__g_failure_reason;
}","{'begin': {'line': 972, 'column': 1}, 'end': {'line': 975, 'column': 2}}",show_image.c,"['返回', '最近', '一次', '图像', '加载', '失败', '的', '错误', '描述']"
444,444,stbi__err,int,int stbi__err(const char * str),"[{'name': 'str', 'type': 'const char *'}]",设置错误信息并返回失败状态,"static int stbi__err(const char *str)
{
   stbi__g_failure_reason = str;
   return 0;
}","{'begin': {'line': 978, 'column': 1}, 'end': {'line': 982, 'column': 2}}",show_image.c,"['设置', '错误', '误信', '信息', '错误信息', '并', '返回', '失败', '状态']"
445,445,stbi__malloc,void *,void * stbi__malloc(int size),"[{'name': 'size', 'type': 'int'}]",调用STBI_MALLOC分配内存,"static void *stbi__malloc(size_t size)
{
    return STBI_MALLOC(size);
}","{'begin': {'line': 985, 'column': 1}, 'end': {'line': 988, 'column': 2}}",show_image.c,"['调用', 'STBI', '_', 'MALLOC', '分配', '内存', '分配内存']"
446,446,stbi__addsizes_valid,int,"int stbi__addsizes_valid(int a, int b)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}]",检查两整数相加是否溢出,"static int stbi__addsizes_valid(int a, int b)
{
   if (b < 0) return 0;
   // now 0 <= b <= INT_MAX, hence also
   // 0 <= INT_MAX - b <= INTMAX.
   // And ""a + b <= INT_MAX"" (which might overflow) is the
   // same as a <= INT_MAX - b (no overflow)
   return a <= INT_MAX - b;
}","{'begin': {'line': 1002, 'column': 1}, 'end': {'line': 1010, 'column': 2}}",show_image.c,"['检查', '两', '整数', '相加', '是否', '溢出']"
447,447,stbi__mul2sizes_valid,int,"int stbi__mul2sizes_valid(int a, int b)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}]",检查两数相乘是否溢出，返回有效性,"static int stbi__mul2sizes_valid(int a, int b)
{
   if (a < 0 || b < 0) return 0;
   if (b == 0) return 1; // mul-by-0 is always safe
   // portable way to check for no overflows in a*b
   return a <= INT_MAX/b;
}","{'begin': {'line': 1014, 'column': 1}, 'end': {'line': 1020, 'column': 2}}",show_image.c,"['检查', '两', '数', '相乘', '是否', '溢出', '，', '返回', '有效', '有效性']"
448,448,stbi__mad2sizes_valid,int,"int stbi__mad2sizes_valid(int a, int b, int add)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}, {'name': 'add', 'type': 'int'}]",检查a*b及加上add是否有效,"static int stbi__mad2sizes_valid(int a, int b, int add)
{
   return stbi__mul2sizes_valid(a, b) && stbi__addsizes_valid(a*b, add);
}","{'begin': {'line': 1024, 'column': 1}, 'end': {'line': 1027, 'column': 2}}",show_image.c,"['检查', 'a', '*', 'b', '及', '加上', 'add', '是否', '有效']"
449,449,stbi__mad3sizes_valid,int,"int stbi__mad3sizes_valid(int a, int b, int c, int add)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}, {'name': 'c', 'type': 'int'}, {'name': 'add', 'type': 'int'}]",检查三数相乘加增量是否有效,"static int stbi__mad3sizes_valid(int a, int b, int c, int add)
{
   return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&
      stbi__addsizes_valid(a*b*c, add);
}","{'begin': {'line': 1031, 'column': 1}, 'end': {'line': 1035, 'column': 2}}",show_image.c,"['检查', '三', '数', '相乘', '加', '增量', '是否', '有效']"
450,450,stbi__mad4sizes_valid,int,"int stbi__mad4sizes_valid(int a, int b, int c, int d, int add)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}, {'name': 'c', 'type': 'int'}, {'name': 'd', 'type': 'int'}, {'name': 'add', 'type': 'int'}]",检查四数相乘加值是否有效,"static int stbi__mad4sizes_valid(int a, int b, int c, int d, int add)
{
   return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&
      stbi__mul2sizes_valid(a*b*c, d) && stbi__addsizes_valid(a*b*c*d, add);
}","{'begin': {'line': 1039, 'column': 1}, 'end': {'line': 1043, 'column': 2}}",show_image.c,"['检查', '四数', '相乘', '加值', '是否', '有效']"
451,451,stbi__malloc_mad2,void *,"void * stbi__malloc_mad2(int a, int b, int add)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}, {'name': 'add', 'type': 'int'}]",分配a*b+add内存并验证参数有效性,"static void *stbi__malloc_mad2(int a, int b, int add)
{
   if (!stbi__mad2sizes_valid(a, b, add)) return NULL;
   return stbi__malloc(a*b + add);
}","{'begin': {'line': 1048, 'column': 1}, 'end': {'line': 1052, 'column': 2}}",show_image.c,"['分配', 'a', '*', 'b', '+', 'add', '内存', '并', '验证', '参数', '有效', '有效性']"
452,452,stbi__malloc_mad3,void *,"void * stbi__malloc_mad3(int a, int b, int c, int add)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}, {'name': 'c', 'type': 'int'}, {'name': 'add', 'type': 'int'}]",检查参数并分配a*b*c + add内存,"static void *stbi__malloc_mad3(int a, int b, int c, int add)
{
   if (!stbi__mad3sizes_valid(a, b, c, add)) return NULL;
   return stbi__malloc(a*b*c + add);
}","{'begin': {'line': 1055, 'column': 1}, 'end': {'line': 1059, 'column': 2}}",show_image.c,"['检查', '参数', '并', '分配', 'a', '*', 'b', '*', 'c', ' ', '+', ' ', 'add', '内存']"
453,453,stbi__malloc_mad4,void *,"void * stbi__malloc_mad4(int a, int b, int c, int d, int add)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}, {'name': 'c', 'type': 'int'}, {'name': 'd', 'type': 'int'}, {'name': 'add', 'type': 'int'}]",分配验证后的四数乘积加add的内存空间,"static void *stbi__malloc_mad4(int a, int b, int c, int d, int add)
{
   if (!stbi__mad4sizes_valid(a, b, c, d, add)) return NULL;
   return stbi__malloc(a*b*c*d + add);
}","{'begin': {'line': 1062, 'column': 1}, 'end': {'line': 1066, 'column': 2}}",show_image.c,"['分配', '验证', '后', '的', '四数', '乘积', '加', 'add', '的', '内存', '空间', '内存空间']"
454,454,stbi__addints_valid,int,"int stbi__addints_valid(int a, int b)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}]",检查两个整数相加是否溢出,"static int stbi__addints_valid(int a, int b)
{
   if ((a >= 0) != (b >= 0)) return 1; // a and b have different signs, so no overflow
   if (a < 0 && b < 0) return a >= INT_MIN - b; // same as a + b >= INT_MIN; INT_MIN - b cannot overflow since b < 0.
   return a <= INT_MAX - b;
}","{'begin': {'line': 1070, 'column': 1}, 'end': {'line': 1075, 'column': 2}}",show_image.c,"['检查', '两个', '整数', '相加', '是否', '溢出']"
455,455,stbi__mul2shorts_valid,int,"int stbi__mul2shorts_valid(int a, int b)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}]",检查两数相乘是否在short范围内,"static int stbi__mul2shorts_valid(int a, int b)
{
   if (b == 0 || b == -1) return 1; // multiplication by 0 is always 0; check for -1 so SHRT_MIN/b doesn't overflow
   if ((a >= 0) == (b >= 0)) return a <= SHRT_MAX/b; // product is positive, so similar to mul2sizes_valid
   if (b < 0) return a <= SHRT_MIN / b; // same as a * b >= SHRT_MIN
   return a >= SHRT_MIN / b;
}","{'begin': {'line': 1078, 'column': 1}, 'end': {'line': 1084, 'column': 2}}",show_image.c,"['检查', '两', '数', '相乘', '是否', '在', 'short', '范围', '内']"
456,456,stbi_image_free,void,void stbi_image_free(void * retval_from_stbi_load),"[{'name': 'retval_from_stbi_load', 'type': 'void *'}]",释放由stbi_load函数加载的图像内存,"STBIDEF void stbi_image_free(void *retval_from_stbi_load)
{
   STBI_FREE(retval_from_stbi_load);
}","{'begin': {'line': 1101, 'column': 1}, 'end': {'line': 1104, 'column': 2}}",show_image.c,"['释放', '由', 'stbi', '_', 'load', '函数', '加载', '的', '图像', '内存']"
457,457,stbi_set_flip_vertically_on_load,void,void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip),"[{'name': 'flag_true_if_should_flip', 'type': 'int'}]",设置加载图像时垂直翻转的标志,"STBIDEF void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip)
{
   stbi__vertically_flip_on_load_global = flag_true_if_should_flip;
}","{'begin': {'line': 1116, 'column': 1}, 'end': {'line': 1119, 'column': 2}}",show_image.c,"['设置', '加载', '图像', '时', '垂直', '翻转', '的', '标志']"
458,458,stbi_set_flip_vertically_on_load_thread,void,void stbi_set_flip_vertically_on_load_thread(int flag_true_if_should_flip),"[{'name': 'flag_true_if_should_flip', 'type': 'int'}]",设置当前线程图像加载时垂直翻转标志,"STBIDEF void stbi_set_flip_vertically_on_load_thread(int flag_true_if_should_flip)
{
   stbi__vertically_flip_on_load_local = flag_true_if_should_flip;
   stbi__vertically_flip_on_load_set = 1;
}","{'begin': {'line': 1126, 'column': 1}, 'end': {'line': 1130, 'column': 2}}",show_image.c,"['设置', '当前', '线程', '图像', '加载', '时', '垂直', '翻转', '标志']"
459,459,stbi__load_main,void *,"void * stbi__load_main(stbi__context * s, int * x, int * y, int * comp, int req_comp, stbi__result_info * ri, int bpc)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'ri', 'type': 'stbi__result_info *'}, {'name': 'bpc', 'type': 'int'}]",主图像加载函数，支持多格式检测与加载,"static void *stbi__load_main(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)
{
   memset(ri, 0, sizeof(*ri)); // make sure it's initialized if we add new fields
   ri->bits_per_channel = 8; // default is 8 so most paths don't have to be changed
   ri->channel_order = STBI_ORDER_RGB; // all current input & output are this, but this is here so we can add BGR order
   ri->num_channels = 0;

   // test the formats with a very explicit header first (at least a FOURCC
   // or distinctive magic number first)
   #ifndef STBI_NO_PNG
   if (stbi__png_test(s))  return stbi__png_load(s,x,y,comp,req_comp, ri);
   #endif
   #ifndef STBI_NO_BMP
   if (stbi__bmp_test(s))  return stbi__bmp_load(s,x,y,comp,req_comp, ri);
   #endif
   #ifndef STBI_NO_GIF
   if (stbi__gif_test(s))  return stbi__gif_load(s,x,y,comp,req_comp, ri);
   #endif
   #ifndef STBI_NO_PSD
   if (stbi__psd_test(s))  return stbi__psd_load(s,x,y,comp,req_comp, ri, bpc);
   #else
   STBI_NOTUSED(bpc);
   #endif
   #ifndef STBI_NO_PIC
   if (stbi__pic_test(s))  return stbi__pic_load(s,x,y,comp,req_comp, ri);
   #endif

   // then the formats that can end up attempting to load with just 1 or 2
   // bytes matching expectations; these are prone to false positives, so
   // try them later
   #ifndef STBI_NO_JPEG
   if (stbi__jpeg_test(s)) return stbi__jpeg_load(s,x,y,comp,req_comp, ri);
   #endif
   #ifndef STBI_NO_PNM
   if (stbi__pnm_test(s))  return stbi__pnm_load(s,x,y,comp,req_comp, ri);
   #endif

   #ifndef STBI_NO_HDR
   if (stbi__hdr_test(s)) {
      float *hdr = stbi__hdr_load(s, x,y,comp,req_comp, ri);
      return stbi__hdr_to_ldr(hdr, *x, *y, req_comp ? req_comp : *comp);
   }
   #endif

   #ifndef STBI_NO_TGA
   // test tga last because it's a crappy test!
   if (stbi__tga_test(s))
      return stbi__tga_load(s,x,y,comp,req_comp, ri);
   #endif

   return stbi__errpuc(""unknown image type"", ""Image not of any known type, or corrupt"");
}","{'begin': {'line': 1137, 'column': 1}, 'end': {'line': 1188, 'column': 2}}",show_image.c,"['主', '图像', '加载', '函数', '，', '支持', '多', '格式', '检测', '与', '加载']"
460,460,stbi__convert_16_to_8,stbi_uc *,"stbi_uc * stbi__convert_16_to_8(stbi__uint16 * orig, int w, int h, int channels)","[{'name': 'orig', 'type': 'stbi__uint16 *'}, {'name': 'w', 'type': 'int'}, {'name': 'h', 'type': 'int'}, {'name': 'channels', 'type': 'int'}]",将16位图像数据高位截断转为8位，释放原内存,"static stbi_uc *stbi__convert_16_to_8(stbi__uint16 *orig, int w, int h, int channels)
{
   int i;
   int img_len = w * h * channels;
   stbi_uc *reduced;

   reduced = (stbi_uc *) stbi__malloc(img_len);
   if (reduced == NULL) return stbi__errpuc(""outofmem"", ""Out of memory"");

   for (i = 0; i < img_len; ++i)
      reduced[i] = (stbi_uc)((orig[i] >> 8) & 0xFF); // top half of each byte is sufficient approx of 16->8 bit scaling

   STBI_FREE(orig);
   return reduced;
}","{'begin': {'line': 1190, 'column': 1}, 'end': {'line': 1204, 'column': 2}}",show_image.c,"['将', '16', '位', '图像', '数据', '高位', '截断', '转为', '8', '位', '，', '释放', '原', '内存']"
461,461,stbi__convert_8_to_16,stbi__uint16 *,"stbi__uint16 * stbi__convert_8_to_16(stbi_uc * orig, int w, int h, int channels)","[{'name': 'orig', 'type': 'stbi_uc *'}, {'name': 'w', 'type': 'int'}, {'name': 'h', 'type': 'int'}, {'name': 'channels', 'type': 'int'}]",将8位图像数据转换为16位并释放原内存,"static stbi__uint16 *stbi__convert_8_to_16(stbi_uc *orig, int w, int h, int channels)
{
   int i;
   int img_len = w * h * channels;
   stbi__uint16 *enlarged;

   enlarged = (stbi__uint16 *) stbi__malloc(img_len*2);
   if (enlarged == NULL) return (stbi__uint16 *) stbi__errpuc(""outofmem"", ""Out of memory"");

   for (i = 0; i < img_len; ++i)
      enlarged[i] = (stbi__uint16)((orig[i] << 8) + orig[i]); // replicate to high and low byte, maps 0->0, 255->0xffff

   STBI_FREE(orig);
   return enlarged;
}","{'begin': {'line': 1206, 'column': 1}, 'end': {'line': 1220, 'column': 2}}",show_image.c,"['将', '8', '位', '图像', '数据', '转换', '为', '16', '位', '并', '释放', '原', '内存']"
462,462,stbi__vertical_flip,void,"void stbi__vertical_flip(void * image, int w, int h, int bytes_per_pixel)","[{'name': 'image', 'type': 'void *'}, {'name': 'w', 'type': 'int'}, {'name': 'h', 'type': 'int'}, {'name': 'bytes_per_pixel', 'type': 'int'}]",垂直翻转图像数据，按行交换,"static void stbi__vertical_flip(void *image, int w, int h, int bytes_per_pixel)
{
   int row;
   size_t bytes_per_row = (size_t)w * bytes_per_pixel;
   stbi_uc temp[2048];
   stbi_uc *bytes = (stbi_uc *)image;

   for (row = 0; row < (h>>1); row++) {
      stbi_uc *row0 = bytes + row*bytes_per_row;
      stbi_uc *row1 = bytes + (h - row - 1)*bytes_per_row;
      // swap row0 with row1
      size_t bytes_left = bytes_per_row;
      while (bytes_left) {
         size_t bytes_copy = (bytes_left < sizeof(temp)) ? bytes_left : sizeof(temp);
         memcpy(temp, row0, bytes_copy);
         memcpy(row0, row1, bytes_copy);
         memcpy(row1, temp, bytes_copy);
         row0 += bytes_copy;
         row1 += bytes_copy;
         bytes_left -= bytes_copy;
      }
   }
}","{'begin': {'line': 1222, 'column': 1}, 'end': {'line': 1244, 'column': 2}}",show_image.c,"['垂直', '翻转', '图像', '数据', '，', '按行', '交换']"
463,463,stbi__vertical_flip_slices,void,"void stbi__vertical_flip_slices(void * image, int w, int h, int z, int bytes_per_pixel)","[{'name': 'image', 'type': 'void *'}, {'name': 'w', 'type': 'int'}, {'name': 'h', 'type': 'int'}, {'name': 'z', 'type': 'int'}, {'name': 'bytes_per_pixel', 'type': 'int'}]",垂直翻转三维图像数据的每个切片层，参数指定宽、高、切片数和像素字节,"static void stbi__vertical_flip_slices(void *image, int w, int h, int z, int bytes_per_pixel)
{
   int slice;
   int slice_size = w * h * bytes_per_pixel;

   stbi_uc *bytes = (stbi_uc *)image;
   for (slice = 0; slice < z; ++slice) {
      stbi__vertical_flip(bytes, w, h, bytes_per_pixel);
      bytes += slice_size;
   }
}","{'begin': {'line': 1247, 'column': 1}, 'end': {'line': 1257, 'column': 2}}",show_image.c,"['垂直', '翻转', '三维', '图像', '数据', '的', '每个', '切片', '层', '，', '参数', '指定', '宽', '、', '高', '、', '切片', '数', '和', '像素', '字节']"
464,464,stbi__load_and_postprocess_8bit,unsigned char *,"unsigned char * stbi__load_and_postprocess_8bit(stbi__context * s, int * x, int * y, int * comp, int req_comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",加载图像并进行8位转换及垂直翻转后处理,"static unsigned char *stbi__load_and_postprocess_8bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
   stbi__result_info ri;
   void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 8);

   if (result == NULL)
      return NULL;

   // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.
   STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);

   if (ri.bits_per_channel != 8) {
      result = stbi__convert_16_to_8((stbi__uint16 *) result, *x, *y, req_comp == 0 ? *comp : req_comp);
      ri.bits_per_channel = 8;
   }

   // @TODO: move stbi__convert_format to here

   if (stbi__vertically_flip_on_load) {
      int channels = req_comp ? req_comp : *comp;
      stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi_uc));
   }

   return (unsigned char *) result;
}","{'begin': {'line': 1260, 'column': 1}, 'end': {'line': 1284, 'column': 2}}",show_image.c,"['加载', '图像', '并', '进行', '8', '位', '转换', '及', '垂直', '翻转', '处理', '后处理']"
465,465,stbi__load_and_postprocess_16bit,stbi__uint16 *,"stbi__uint16 * stbi__load_and_postprocess_16bit(stbi__context * s, int * x, int * y, int * comp, int req_comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",加载并处理16位图像数据，支持格式转换和垂直翻转,"static stbi__uint16 *stbi__load_and_postprocess_16bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
   stbi__result_info ri;
   void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 16);

   if (result == NULL)
      return NULL;

   // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.
   STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);

   if (ri.bits_per_channel != 16) {
      result = stbi__convert_8_to_16((stbi_uc *) result, *x, *y, req_comp == 0 ? *comp : req_comp);
      ri.bits_per_channel = 16;
   }

   // @TODO: move stbi__convert_format16 to here
   // @TODO: special case RGB-to-Y (and RGBA-to-YA) for 8-bit-to-16-bit case to keep more precision

   if (stbi__vertically_flip_on_load) {
      int channels = req_comp ? req_comp : *comp;
      stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi__uint16));
   }

   return (stbi__uint16 *) result;
}","{'begin': {'line': 1286, 'column': 1}, 'end': {'line': 1311, 'column': 2}}",show_image.c,"['加载', '并', '处理', '16', '位', '图像', '数据', '，', '支持', '格式', '转换', '和', '垂直', '翻转']"
466,466,stbi__float_postprocess,void,"void stbi__float_postprocess(float * result, int * x, int * y, int * comp, int req_comp)","[{'name': 'result', 'type': 'float *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",浮点数据加载后垂直翻转处理,"static void stbi__float_postprocess(float *result, int *x, int *y, int *comp, int req_comp)
{
   if (stbi__vertically_flip_on_load && result != NULL) {
      int channels = req_comp ? req_comp : *comp;
      stbi__vertical_flip(result, *x, *y, channels * sizeof(float));
   }
}","{'begin': {'line': 1314, 'column': 1}, 'end': {'line': 1320, 'column': 2}}",show_image.c,"['浮点', '数据', '加载', '后', '垂直', '翻转', '处理']"
467,467,stbi__fopen,FILE *,"FILE * stbi__fopen(const char * filename, const char * mode)","[{'name': 'filename', 'type': 'const char *'}, {'name': 'mode', 'type': 'const char *'}]",跨平台以UTF-8模式打开文件,"static FILE *stbi__fopen(char const *filename, char const *mode)
{
   FILE *f;
#if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
   wchar_t wMode[64];
   wchar_t wFilename[1024];
	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, filename, -1, wFilename, sizeof(wFilename)/sizeof(*wFilename)))
      return 0;

	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, mode, -1, wMode, sizeof(wMode)/sizeof(*wMode)))
      return 0;

#if defined(_MSC_VER) && _MSC_VER >= 1400
	if (0 != _wfopen_s(&f, wFilename, wMode))
		f = 0;
#else
   f = _wfopen(wFilename, wMode);
#endif

#elif defined(_MSC_VER) && _MSC_VER >= 1400
   if (0 != fopen_s(&f, filename, mode))
      f=0;
#else
   f = fopen(filename, mode);
#endif
   return f;
}","{'begin': {'line': 1337, 'column': 1}, 'end': {'line': 1363, 'column': 2}}",show_image.c,"['平台', '跨平台', '以', 'UTF', '-', '8', '模式', '打开', '文件']"
468,468,stbi__sse2_available,int,int stbi__sse2_available(),[],检测SSE2支持，编译时启用返回1,"static int stbi__sse2_available(void)
{
   // If we're even attempting to compile this on GCC/Clang, that means
   // -msse2 is on, which means the compiler is allowed to use SSE2
   // instructions at will, and so are we.
   return 1;
}","{'begin': {'line': 765, 'column': 1}, 'end': {'line': 771, 'column': 2}}",show_image.c,"['检测', 'SSE2', '支持', '，', '编译', '时', '启用', '返回', '1']"
469,469,stbi_load,stbi_uc *,"stbi_uc * stbi_load(const char * filename, int * x, int * y, int * comp, int req_comp)","[{'name': 'filename', 'type': 'const char *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",加载图像文件数据，返回像素指针及尺寸通道信息,"STBIDEF stbi_uc *stbi_load(char const *filename, int *x, int *y, int *comp, int req_comp)
{
   FILE *f = stbi__fopen(filename, ""rb"");
   unsigned char *result;
   if (!f) return stbi__errpuc(""can't fopen"", ""Unable to open file"");
   result = stbi_load_from_file(f,x,y,comp,req_comp);
   fclose(f);
   return result;
}","{'begin': {'line': 1366, 'column': 1}, 'end': {'line': 1374, 'column': 2}}",show_image.c,"['加载', '图像', '文件', '图像文件', '数据', '，', '返回', '像素', '指针', '及', '尺寸', '通道', '信息']"
470,470,stbi__start_mem,void,"void stbi__start_mem(stbi__context * s, const stbi_uc * buffer, int len)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'buffer', 'type': 'const stbi_uc *'}, {'name': 'len', 'type': 'int'}]",初始化内存图像读取上下文,"static void stbi__start_mem(stbi__context *s, stbi_uc const *buffer, int len)
{
   s->io.read = NULL;
   s->read_from_callbacks = 0;
   s->callback_already_read = 0;
   s->img_buffer = s->img_buffer_original = (stbi_uc *) buffer;
   s->img_buffer_end = s->img_buffer_original_end = (stbi_uc *) buffer+len;
}","{'begin': {'line': 826, 'column': 1}, 'end': {'line': 833, 'column': 2}}",show_image.c,"['初始', '初始化', '内存', '图像', '读取', '上下', '下文', '上下文']"
471,471,stbi_load_from_file,stbi_uc *,"stbi_uc * stbi_load_from_file(FILE * f, int * x, int * y, int * comp, int req_comp)","[{'name': 'f', 'type': 'FILE *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",从文件加载图像数据，调整文件指针位置,"STBIDEF stbi_uc *stbi_load_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
{
   unsigned char *result;
   stbi__context s;
   stbi__start_file(&s,f);
   result = stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
   if (result) {
      // need to 'unget' all the characters in the IO buffer
      fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);
   }
   return result;
}","{'begin': {'line': 1376, 'column': 1}, 'end': {'line': 1387, 'column': 2}}",show_image.c,"['文件', '从文件', '加载', '图像', '数据', '，', '调整', '文件', '指针', '位置']"
472,472,stbi__start_callbacks,void,"void stbi__start_callbacks(stbi__context * s, stbi_io_callbacks * c, void * user)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'c', 'type': 'stbi_io_callbacks *'}, {'name': 'user', 'type': 'void *'}]",初始化上下文并设置回调函数及用户数据,"static void stbi__start_callbacks(stbi__context *s, stbi_io_callbacks *c, void *user)
{
   s->io = *c;
   s->io_user_data = user;
   s->buflen = sizeof(s->buffer_start);
   s->read_from_callbacks = 1;
   s->callback_already_read = 0;
   s->img_buffer = s->img_buffer_original = s->buffer_start;
   stbi__refill_buffer(s);
   s->img_buffer_original_end = s->img_buffer_end;
}","{'begin': {'line': 836, 'column': 1}, 'end': {'line': 846, 'column': 2}}",show_image.c,"['初始', '初始化', '上下', '下文', '上下文', '并', '设置', '回调', '函数', '及', '用户', '数据']"
473,473,stbi_load_from_file_16,stbi_us *,"stbi_us * stbi_load_from_file_16(FILE * f, int * x, int * y, int * comp, int req_comp)","[{'name': 'f', 'type': 'FILE *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",从文件加载16位图像数据并调整文件指针,"STBIDEF stbi__uint16 *stbi_load_from_file_16(FILE *f, int *x, int *y, int *comp, int req_comp)
{
   stbi__uint16 *result;
   stbi__context s;
   stbi__start_file(&s,f);
   result = stbi__load_and_postprocess_16bit(&s,x,y,comp,req_comp);
   if (result) {
      // need to 'unget' all the characters in the IO buffer
      fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);
   }
   return result;
}","{'begin': {'line': 1389, 'column': 1}, 'end': {'line': 1400, 'column': 2}}",show_image.c,"['文件', '从文件', '加载', '16', '位', '图像', '数据', '并', '调整', '文件', '指针']"
474,474,stbi_load_16,stbi_us *,"stbi_us * stbi_load_16(const char * filename, int * x, int * y, int * comp, int req_comp)","[{'name': 'filename', 'type': 'const char *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",加载16位图像文件，返回像素数据及尺寸,"STBIDEF stbi_us *stbi_load_16(char const *filename, int *x, int *y, int *comp, int req_comp)
{
   FILE *f = stbi__fopen(filename, ""rb"");
   stbi__uint16 *result;
   if (!f) return (stbi_us *) stbi__errpuc(""can't fopen"", ""Unable to open file"");
   result = stbi_load_from_file_16(f,x,y,comp,req_comp);
   fclose(f);
   return result;
}","{'begin': {'line': 1402, 'column': 1}, 'end': {'line': 1410, 'column': 2}}",show_image.c,"['加载', '16', '位', '图像', '文件', '图像文件', '，', '返回', '像素', '数据', '及', '尺寸']"
475,475,stbi__stdio_read,int,"int stbi__stdio_read(void * user, char * data, int size)","[{'name': 'user', 'type': 'void *'}, {'name': 'data', 'type': 'char *'}, {'name': 'size', 'type': 'int'}]",使用fread从用户提供的文件指针读取数据,"static int stbi__stdio_read(void *user, char *data, int size)
{
   return (int) fread(data,1,size,(FILE*) user);
}","{'begin': {'line': 850, 'column': 1}, 'end': {'line': 853, 'column': 2}}",show_image.c,"['使用', 'fread', '从', '用户', '提供', '的', '文件', '指针', '读取', '数据', '读取数据']"
476,476,stbi__stdio_skip,void,"void stbi__stdio_skip(void * user, int n)","[{'name': 'user', 'type': 'void *'}, {'name': 'n', 'type': 'int'}]",跳过文件流中的n字节并重置EOF状态,"static void stbi__stdio_skip(void *user, int n)
{
   int ch;
   fseek((FILE*) user, n, SEEK_CUR);
   ch = fgetc((FILE*) user);  /* have to read a byte to reset feof()'s flag */
   if (ch != EOF) {
      ungetc(ch, (FILE *) user);  /* push byte back onto stream if valid. */
   }
}","{'begin': {'line': 855, 'column': 1}, 'end': {'line': 863, 'column': 2}}",show_image.c,"['跳过', '文件', '流中', '的', 'n', '字节', '并', '重置', 'EOF', '状态']"
477,477,stbi_load_16_from_memory,stbi_us *,"stbi_us * stbi_load_16_from_memory(const stbi_uc * buffer, int len, int * x, int * y, int * channels_in_file, int desired_channels)","[{'name': 'buffer', 'type': 'const stbi_uc *'}, {'name': 'len', 'type': 'int'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'channels_in_file', 'type': 'int *'}, {'name': 'desired_channels', 'type': 'int'}]",从内存加载16位图像数据，返回像素数组,"STBIDEF stbi_us *stbi_load_16_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);
}","{'begin': {'line': 1415, 'column': 1}, 'end': {'line': 1420, 'column': 2}}",show_image.c,"['从', '内存', '加载', '16', '位', '图像', '数据', '，', '返回', '像素', '数组']"
478,478,stbi__stdio_eof,int,int stbi__stdio_eof(void * user),"[{'name': 'user', 'type': 'void *'}]",检查文件流是否结束或出错,"static int stbi__stdio_eof(void *user)
{
   return feof((FILE*) user) || ferror((FILE *) user);
}","{'begin': {'line': 865, 'column': 1}, 'end': {'line': 868, 'column': 2}}",show_image.c,"['检查', '文件', '流', '是否', '结束', '或', '出错']"
479,479,stbi_load_16_from_callbacks,stbi_us *,"stbi_us * stbi_load_16_from_callbacks(const stbi_io_callbacks * clbk, void * user, int * x, int * y, int * channels_in_file, int desired_channels)","[{'name': 'clbk', 'type': 'const stbi_io_callbacks *'}, {'name': 'user', 'type': 'void *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'channels_in_file', 'type': 'int *'}, {'name': 'desired_channels', 'type': 'int'}]",通过回调加载16位图像数据,"STBIDEF stbi_us *stbi_load_16_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *channels_in_file, int desired_channels)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *)clbk, user);
   return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);
}","{'begin': {'line': 1422, 'column': 1}, 'end': {'line': 1427, 'column': 2}}",show_image.c,"['通过', '回调', '加载', '16', '位', '图像', '数据']"
480,480,stbi__start_file,void,"void stbi__start_file(stbi__context * s, FILE * f)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'f', 'type': 'FILE *'}]",使用标准I/O回调初始化文件读取上下文,"static void stbi__start_file(stbi__context *s, FILE *f)
{
   stbi__start_callbacks(s, &stbi__stdio_callbacks, (void *) f);
}","{'begin': {'line': 877, 'column': 1}, 'end': {'line': 880, 'column': 2}}",show_image.c,"['使用', '标准', 'I', '/', 'O', '回调', '初始', '初始化', '文件', '读取', '上下', '下文', '上下文']"
481,481,stbi__rewind,void,void stbi__rewind(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",将图像缓冲区重置到初始位置,"static void stbi__rewind(stbi__context *s)
{
   // conceptually rewind SHOULD rewind to the beginning of the stream,
   // but we just rewind to the beginning of the initial buffer, because
   // we only use it after doing 'test', which only ever looks at at most 92 bytes
   s->img_buffer = s->img_buffer_original;
   s->img_buffer_end = s->img_buffer_original_end;
}","{'begin': {'line': 886, 'column': 1}, 'end': {'line': 893, 'column': 2}}",show_image.c,"['将', '图像', '缓冲', '缓冲区', '重置', '到', '初始', '位置']"
482,482,stbi_load_from_memory,stbi_uc *,"stbi_uc * stbi_load_from_memory(const stbi_uc * buffer, int len, int * x, int * y, int * comp, int req_comp)","[{'name': 'buffer', 'type': 'const stbi_uc *'}, {'name': 'len', 'type': 'int'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",从内存加载图像数据，返回像素指针及尺寸信息,"STBIDEF stbi_uc *stbi_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
}","{'begin': {'line': 1429, 'column': 1}, 'end': {'line': 1434, 'column': 2}}",show_image.c,"['从', '内存', '加载', '图像', '数据', '，', '返回', '像素', '指针', '及', '尺寸', '信息']"
483,483,stbi_load_from_callbacks,stbi_uc *,"stbi_uc * stbi_load_from_callbacks(const stbi_io_callbacks * clbk, void * user, int * x, int * y, int * comp, int req_comp)","[{'name': 'clbk', 'type': 'const stbi_io_callbacks *'}, {'name': 'user', 'type': 'void *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",通过回调函数加载并解码图像数据,"STBIDEF stbi_uc *stbi_load_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
}","{'begin': {'line': 1436, 'column': 1}, 'end': {'line': 1441, 'column': 2}}",show_image.c,"['通过', '回调', '函数', '加载', '并', '解码', '图像', '数据']"
484,484,stbi_load_gif_from_memory,stbi_uc *,"stbi_uc * stbi_load_gif_from_memory(const stbi_uc * buffer, int len, int ** delays, int * x, int * y, int * z, int * comp, int req_comp)","[{'name': 'buffer', 'type': 'const stbi_uc *'}, {'name': 'len', 'type': 'int'}, {'name': 'delays', 'type': 'int **'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'z', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",从内存加载GIF图像数据，支持多帧和垂直翻转。,"STBIDEF stbi_uc *stbi_load_gif_from_memory(stbi_uc const *buffer, int len, int **delays, int *x, int *y, int *z, int *comp, int req_comp)
{
   unsigned char *result;
   stbi__context s;
   stbi__start_mem(&s,buffer,len);

   result = (unsigned char*) stbi__load_gif_main(&s, delays, x, y, z, comp, req_comp);
   if (stbi__vertically_flip_on_load) {
      stbi__vertical_flip_slices( result, *x, *y, *z, *comp );
   }

   return result;
}","{'begin': {'line': 1444, 'column': 1}, 'end': {'line': 1456, 'column': 2}}",show_image.c,"['从', '内存', '加载', 'GIF', '图像', '数据', '，', '支持', '多', '帧', '和', '垂直', '翻转', '。']"
485,485,stbi_failure_reason,const char *,const char * stbi_failure_reason(),[],返回最近一次加载失败的描述信息,"STBIDEF const char *stbi_failure_reason(void)
{
   return stbi__g_failure_reason;
}","{'begin': {'line': 972, 'column': 1}, 'end': {'line': 975, 'column': 2}}",show_image.c,"['返回', '最近', '一次', '加载', '失败', '的', '描述', '信息']"
486,486,stbi__loadf_main,float *,"float * stbi__loadf_main(stbi__context * s, int * x, int * y, int * comp, int req_comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",加载图像数据为浮点数格式，支持HDR和LDR转换,"static float *stbi__loadf_main(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
   unsigned char *data;
   #ifndef STBI_NO_HDR
   if (stbi__hdr_test(s)) {
      stbi__result_info ri;
      float *hdr_data = stbi__hdr_load(s,x,y,comp,req_comp, &ri);
      if (hdr_data)
         stbi__float_postprocess(hdr_data,x,y,comp,req_comp);
      return hdr_data;
   }
   #endif
   data = stbi__load_and_postprocess_8bit(s, x, y, comp, req_comp);
   if (data)
      return stbi__ldr_to_hdr(data, *x, *y, req_comp ? req_comp : *comp);
   return stbi__errpf(""unknown image type"", ""Image not of any known type, or corrupt"");
}","{'begin': {'line': 1460, 'column': 1}, 'end': {'line': 1476, 'column': 2}}",show_image.c,"['加载', '图像', '数据', '为', '浮点', '点数', '浮点数', '格式', '，', '支持', 'HDR', '和', 'LDR', '转换']"
487,487,stbi__err,int,int stbi__err(const char * str),"[{'name': 'str', 'type': 'const char *'}]",设置错误信息并返回0表示失败,"static int stbi__err(const char *str)
{
   stbi__g_failure_reason = str;
   return 0;
}","{'begin': {'line': 978, 'column': 1}, 'end': {'line': 982, 'column': 2}}",show_image.c,"['设置', '错误', '误信', '信息', '错误信息', '并', '返回', '0', '表示', '失败']"
488,488,stbi__malloc,void *,void * stbi__malloc(int size),"[{'name': 'size', 'type': 'int'}]","好的，用户让我重新生成摘要，需要缩减到不超过50字，并且不要包含文件地址。之前生成的摘要已经是“分配指定大小的内存块”，这已经符合要求了，但需要确认是否符合字数限制。中文的话，这句话是12个字，确实在50字以内。用户可能希望更简洁，或者是否还有其他信息需要调整？比如是否需要提到是静态函数或者返回类型？不过规则里说摘要主要描述功能和用法，所以保持原样应该没问题。确保没有提到文件路径或其他无关信息，现在的结果符合所有规则。直接输出即可。
</think>

{""name"": ""stbi__malloc"", ""summary"": ""分配指定大小的内存块""}","static void *stbi__malloc(size_t size)
{
    return STBI_MALLOC(size);
}","{'begin': {'line': 985, 'column': 1}, 'end': {'line': 988, 'column': 2}}",show_image.c,"['好', '的', '，', '用户', '让', '我', '重新', '生成', '摘要', '，', '需要', '缩减', '减到', '缩减到', '不', '超过', '50', '字', '，', '并且', '不要', '包含', '文件', '地址', '。', '之前', '生成', '的', '摘要', '已经', '是', '“', '分配', '指定', '大小', '的', '内存', '块', '”', '，', '这', '已经', '符合', '要求', '符合要求', '了', '，', '但', '需要', '确认', '是否', '符合', '字数', '限制', '。', '中文', '的话', '，', '这句', '话', '是', '12', '个', '字', '，', '确实', '在', '50', '字', '以内', '。', '用户', '可能', '希望', '更', '简洁', '，', '或者', '是否', '还有', '其他', '信息', '需要', '调整', '？', '比如', '是否', '需要', '提到', '是', '静态', '函数', '或者', '返回', '类型', '？', '不过', '规则', '里', '说', '摘要', '主要', '描述', '功能', '和', '用法', '，', '所以', '保持', '原样', '应该', '没', '问题', '。', '确保', '没有', '提到', '文件', '路径', '或', '其他', '无关', '信息', '，', '现在', '的', '结果', '符合', '所有', '规则', '。', '直接', '输出', '即可', '。', '\n', '<', '/', 'think', '>', '\n', '\n', '{', '""', 'name', '""', ':', ' ', '""', 'stbi', '__', 'malloc', '""', ',', ' ', '""', 'summary', '""', ':', ' ', '""', '分配', '指定', '大小', '的', '内存', '块', '""', '}']"
489,489,stbi__addsizes_valid,int,"int stbi__addsizes_valid(int a, int b)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}]",检查a和b相加是否不溢出且b非负,"static int stbi__addsizes_valid(int a, int b)
{
   if (b < 0) return 0;
   // now 0 <= b <= INT_MAX, hence also
   // 0 <= INT_MAX - b <= INTMAX.
   // And ""a + b <= INT_MAX"" (which might overflow) is the
   // same as a <= INT_MAX - b (no overflow)
   return a <= INT_MAX - b;
}","{'begin': {'line': 1002, 'column': 1}, 'end': {'line': 1010, 'column': 2}}",show_image.c,"['检查', 'a', '和', 'b', '相加', '是否', '不', '溢出', '且', 'b', '非负']"
490,490,stbi__mul2sizes_valid,int,"int stbi__mul2sizes_valid(int a, int b)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}]",检查两整数相乘是否安全（无溢出）,"static int stbi__mul2sizes_valid(int a, int b)
{
   if (a < 0 || b < 0) return 0;
   if (b == 0) return 1; // mul-by-0 is always safe
   // portable way to check for no overflows in a*b
   return a <= INT_MAX/b;
}","{'begin': {'line': 1014, 'column': 1}, 'end': {'line': 1020, 'column': 2}}",show_image.c,"['检查', '两', '整数', '相乘', '是否', '安全', '（', '无', '溢出', '）']"
491,491,stbi_loadf_from_memory,float *,"float * stbi_loadf_from_memory(const stbi_uc * buffer, int len, int * x, int * y, int * comp, int req_comp)","[{'name': 'buffer', 'type': 'const stbi_uc *'}, {'name': 'len', 'type': 'int'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",从内存加载浮点格式图像数据,"STBIDEF float *stbi_loadf_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__loadf_main(&s,x,y,comp,req_comp);
}","{'begin': {'line': 1478, 'column': 1}, 'end': {'line': 1483, 'column': 2}}",show_image.c,"['从', '内存', '加载', '浮点', '格式', '图像', '数据']"
492,492,stbi__mad2sizes_valid,int,"int stbi__mad2sizes_valid(int a, int b, int add)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}, {'name': 'add', 'type': 'int'}]",检查两个数相乘后再相加的有效性,"static int stbi__mad2sizes_valid(int a, int b, int add)
{
   return stbi__mul2sizes_valid(a, b) && stbi__addsizes_valid(a*b, add);
}","{'begin': {'line': 1024, 'column': 1}, 'end': {'line': 1027, 'column': 2}}",show_image.c,"['检查', '两个', '数', '相乘', '后', '再', '相加', '的', '有效', '有效性']"
493,493,stbi_loadf_from_callbacks,float *,"float * stbi_loadf_from_callbacks(const stbi_io_callbacks * clbk, void * user, int * x, int * y, int * comp, int req_comp)","[{'name': 'clbk', 'type': 'const stbi_io_callbacks *'}, {'name': 'user', 'type': 'void *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",通过回调函数加载浮点图像数据,"STBIDEF float *stbi_loadf_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi__loadf_main(&s,x,y,comp,req_comp);
}","{'begin': {'line': 1485, 'column': 1}, 'end': {'line': 1490, 'column': 2}}",show_image.c,"['通过', '回调', '函数', '加载', '浮点', '图像', '数据']"
494,494,stbi__mad3sizes_valid,int,"int stbi__mad3sizes_valid(int a, int b, int c, int add)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}, {'name': 'c', 'type': 'int'}, {'name': 'add', 'type': 'int'}]",验证三个数相乘加某值是否有效,"static int stbi__mad3sizes_valid(int a, int b, int c, int add)
{
   return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&
      stbi__addsizes_valid(a*b*c, add);
}","{'begin': {'line': 1031, 'column': 1}, 'end': {'line': 1035, 'column': 2}}",show_image.c,"['验证', '三个', '数', '相乘', '加', '某值', '是否', '有效']"
495,495,stbi_loadf,float *,"float * stbi_loadf(const char * filename, int * x, int * y, int * comp, int req_comp)","[{'name': 'filename', 'type': 'const char *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",加载图像文件为浮点数组，自动关闭文件,"STBIDEF float *stbi_loadf(char const *filename, int *x, int *y, int *comp, int req_comp)
{
   float *result;
   FILE *f = stbi__fopen(filename, ""rb"");
   if (!f) return stbi__errpf(""can't fopen"", ""Unable to open file"");
   result = stbi_loadf_from_file(f,x,y,comp,req_comp);
   fclose(f);
   return result;
}","{'begin': {'line': 1493, 'column': 1}, 'end': {'line': 1501, 'column': 2}}",show_image.c,"['加载', '图像', '文件', '图像文件', '为', '浮点', '数组', '，', '自动', '关闭', '文件']"
496,496,stbi__mad4sizes_valid,int,"int stbi__mad4sizes_valid(int a, int b, int c, int d, int add)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}, {'name': 'c', 'type': 'int'}, {'name': 'd', 'type': 'int'}, {'name': 'add', 'type': 'int'}]",检查四数相乘加某数是否有效防溢出,"static int stbi__mad4sizes_valid(int a, int b, int c, int d, int add)
{
   return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&
      stbi__mul2sizes_valid(a*b*c, d) && stbi__addsizes_valid(a*b*c*d, add);
}","{'begin': {'line': 1039, 'column': 1}, 'end': {'line': 1043, 'column': 2}}",show_image.c,"['检查', '四数', '相乘', '加', '某数', '是否', '有效', '防', '溢出']"
497,497,stbi_loadf_from_file,float *,"float * stbi_loadf_from_file(FILE * f, int * x, int * y, int * comp, int req_comp)","[{'name': 'f', 'type': 'FILE *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",从文件加载浮点型图像数据,"STBIDEF float *stbi_loadf_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_file(&s,f);
   return stbi__loadf_main(&s,x,y,comp,req_comp);
}","{'begin': {'line': 1503, 'column': 1}, 'end': {'line': 1508, 'column': 2}}",show_image.c,"['文件', '从文件', '加载', '浮点', '型', '图像', '数据']"
498,498,stbi_is_hdr_from_memory,int,"int stbi_is_hdr_from_memory(const stbi_uc * buffer, int len)","[{'name': 'buffer', 'type': 'const stbi_uc *'}, {'name': 'len', 'type': 'int'}]",检测内存缓冲区是否为HDR图像,"STBIDEF int stbi_is_hdr_from_memory(stbi_uc const *buffer, int len)
{
   #ifndef STBI_NO_HDR
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__hdr_test(&s);
   #else
   STBI_NOTUSED(buffer);
   STBI_NOTUSED(len);
   return 0;
   #endif
}","{'begin': {'line': 1517, 'column': 1}, 'end': {'line': 1528, 'column': 2}}",show_image.c,"['检测', '内存', '缓冲', '缓冲区', '是否', '为', 'HDR', '图像']"
499,499,stbi__malloc_mad2,void *,"void * stbi__malloc_mad2(int a, int b, int add)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}, {'name': 'add', 'type': 'int'}]",验证参数后分配a*b+add大小的内存,"static void *stbi__malloc_mad2(int a, int b, int add)
{
   if (!stbi__mad2sizes_valid(a, b, add)) return NULL;
   return stbi__malloc(a*b + add);
}","{'begin': {'line': 1048, 'column': 1}, 'end': {'line': 1052, 'column': 2}}",show_image.c,"['验证', '参数', '后', '分配', 'a', '*', 'b', '+', 'add', '大小', '的', '内存']"
500,500,stbi_is_hdr,int,int stbi_is_hdr(const char * filename),"[{'name': 'filename', 'type': 'const char *'}]",检查指定文件是否为HDR格式图像,"STBIDEF int      stbi_is_hdr          (char const *filename)
{
   FILE *f = stbi__fopen(filename, ""rb"");
   int result=0;
   if (f) {
      result = stbi_is_hdr_from_file(f);
      fclose(f);
   }
   return result;
}","{'begin': {'line': 1531, 'column': 1}, 'end': {'line': 1540, 'column': 2}}",show_image.c,"['检查', '指定', '文件', '是否', '为', 'HDR', '格式', '图像']"
501,501,stbi__malloc_mad3,void *,"void * stbi__malloc_mad3(int a, int b, int c, int add)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}, {'name': 'c', 'type': 'int'}, {'name': 'add', 'type': 'int'}]",分配a*b*c + add内存，检查有效性,"static void *stbi__malloc_mad3(int a, int b, int c, int add)
{
   if (!stbi__mad3sizes_valid(a, b, c, add)) return NULL;
   return stbi__malloc(a*b*c + add);
}","{'begin': {'line': 1055, 'column': 1}, 'end': {'line': 1059, 'column': 2}}",show_image.c,"['分配', 'a', '*', 'b', '*', 'c', ' ', '+', ' ', 'add', '内存', '，', '检查', '有效', '有效性']"
502,502,stbi_is_hdr_from_file,int,int stbi_is_hdr_from_file(FILE * f),"[{'name': 'f', 'type': 'FILE *'}]",检测文件是否为HDR格式并保持文件位置,"STBIDEF int stbi_is_hdr_from_file(FILE *f)
{
   #ifndef STBI_NO_HDR
   long pos = ftell(f);
   int res;
   stbi__context s;
   stbi__start_file(&s,f);
   res = stbi__hdr_test(&s);
   fseek(f, pos, SEEK_SET);
   return res;
   #else
   STBI_NOTUSED(f);
   return 0;
   #endif
}","{'begin': {'line': 1542, 'column': 1}, 'end': {'line': 1556, 'column': 2}}",show_image.c,"['检测', '文件', '是否', '为', 'HDR', '格式', '并', '保持', '文件', '位置']"
503,503,stbi__malloc_mad4,void *,"void * stbi__malloc_mad4(int a, int b, int c, int d, int add)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}, {'name': 'c', 'type': 'int'}, {'name': 'd', 'type': 'int'}, {'name': 'add', 'type': 'int'}]",验证并分配a*b*c*d + add大小的内存空间,"static void *stbi__malloc_mad4(int a, int b, int c, int d, int add)
{
   if (!stbi__mad4sizes_valid(a, b, c, d, add)) return NULL;
   return stbi__malloc(a*b*c*d + add);
}","{'begin': {'line': 1062, 'column': 1}, 'end': {'line': 1066, 'column': 2}}",show_image.c,"['验证', '并', '分配', 'a', '*', 'b', '*', 'c', '*', 'd', ' ', '+', ' ', 'add', '大小', '的', '内存', '空间', '内存空间']"
504,504,stbi_is_hdr_from_callbacks,int,"int stbi_is_hdr_from_callbacks(const stbi_io_callbacks * clbk, void * user)","[{'name': 'clbk', 'type': 'const stbi_io_callbacks *'}, {'name': 'user', 'type': 'void *'}]",通过回调检测图像是否为HDR格式,"STBIDEF int      stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user)
{
   #ifndef STBI_NO_HDR
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi__hdr_test(&s);
   #else
   STBI_NOTUSED(clbk);
   STBI_NOTUSED(user);
   return 0;
   #endif
}","{'begin': {'line': 1559, 'column': 1}, 'end': {'line': 1570, 'column': 2}}",show_image.c,"['通过', '回调', '检测', '图像', '是否', '为', 'HDR', '格式']"
505,505,stbi__addints_valid,int,"int stbi__addints_valid(int a, int b)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}]",检查两整数相加是否溢出,"static int stbi__addints_valid(int a, int b)
{
   if ((a >= 0) != (b >= 0)) return 1; // a and b have different signs, so no overflow
   if (a < 0 && b < 0) return a >= INT_MIN - b; // same as a + b >= INT_MIN; INT_MIN - b cannot overflow since b < 0.
   return a <= INT_MAX - b;
}","{'begin': {'line': 1070, 'column': 1}, 'end': {'line': 1075, 'column': 2}}",show_image.c,"['检查', '两', '整数', '相加', '是否', '溢出']"
506,506,stbi__mul2shorts_valid,int,"int stbi__mul2shorts_valid(int a, int b)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}]",检查两个整数相乘是否在short范围内,"static int stbi__mul2shorts_valid(int a, int b)
{
   if (b == 0 || b == -1) return 1; // multiplication by 0 is always 0; check for -1 so SHRT_MIN/b doesn't overflow
   if ((a >= 0) == (b >= 0)) return a <= SHRT_MAX/b; // product is positive, so similar to mul2sizes_valid
   if (b < 0) return a <= SHRT_MIN / b; // same as a * b >= SHRT_MIN
   return a >= SHRT_MIN / b;
}","{'begin': {'line': 1078, 'column': 1}, 'end': {'line': 1084, 'column': 2}}",show_image.c,"['检查', '两个', '整数', '相乘', '是否', '在', 'short', '范围', '内']"
507,507,stbi_ldr_to_hdr_gamma,void,void stbi_ldr_to_hdr_gamma(float gamma),"[{'name': 'gamma', 'type': 'float'}]",设置LDR转HDR时的伽马值,"STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma) { stbi__l2h_gamma = gamma; }
","{'begin': {'line': 1575, 'column': 1}, 'end': {'line': 1575, 'column': 79}}",show_image.c,"['设置', 'LDR', '转', 'HDR', '时', '的', '伽马', '值']"
508,508,stbi_ldr_to_hdr_scale,void,void stbi_ldr_to_hdr_scale(float scale),"[{'name': 'scale', 'type': 'float'}]",设置LDR到HDR转换的缩放比例,"STBIDEF void   stbi_ldr_to_hdr_scale(float scale) { stbi__l2h_scale = scale; }
","{'begin': {'line': 1576, 'column': 1}, 'end': {'line': 1576, 'column': 79}}",show_image.c,"['设置', 'LDR', '到', 'HDR', '转换', '的', '缩放', '比例']"
509,509,stbi_image_free,void,void stbi_image_free(void * retval_from_stbi_load),"[{'name': 'retval_from_stbi_load', 'type': 'void *'}]",释放由stbi_load加载的图像内存,"STBIDEF void stbi_image_free(void *retval_from_stbi_load)
{
   STBI_FREE(retval_from_stbi_load);
}","{'begin': {'line': 1101, 'column': 1}, 'end': {'line': 1104, 'column': 2}}",show_image.c,"['释放', '由', 'stbi', '_', 'load', '加载', '的', '图像', '内存']"
510,510,stbi_hdr_to_ldr_gamma,void,void stbi_hdr_to_ldr_gamma(float gamma),"[{'name': 'gamma', 'type': 'float'}]",设置HDR转LDR的gamma校正参数,"STBIDEF void   stbi_hdr_to_ldr_gamma(float gamma) { stbi__h2l_gamma_i = 1/gamma; }
","{'begin': {'line': 1581, 'column': 1}, 'end': {'line': 1581, 'column': 83}}",show_image.c,"['设置', 'HDR', '转', 'LDR', '的', 'gamma', '校正', '参数']"
511,511,stbi_hdr_to_ldr_scale,void,void stbi_hdr_to_ldr_scale(float scale),"[{'name': 'scale', 'type': 'float'}]",设置HDR到LDR转换的缩放比例,"STBIDEF void   stbi_hdr_to_ldr_scale(float scale) { stbi__h2l_scale_i = 1/scale; }
","{'begin': {'line': 1582, 'column': 1}, 'end': {'line': 1582, 'column': 83}}",show_image.c,"['设置', 'HDR', '到', 'LDR', '转换', '的', '缩放', '比例']"
512,512,stbi_set_flip_vertically_on_load,void,void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip),"[{'name': 'flag_true_if_should_flip', 'type': 'int'}]",设置加载图像时垂直翻转开关,"STBIDEF void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip)
{
   stbi__vertically_flip_on_load_global = flag_true_if_should_flip;
}","{'begin': {'line': 1116, 'column': 1}, 'end': {'line': 1119, 'column': 2}}",show_image.c,"['设置', '加载', '图像', '时', '垂直', '翻转', '开关']"
513,513,stbi_set_flip_vertically_on_load_thread,void,void stbi_set_flip_vertically_on_load_thread(int flag_true_if_should_flip),"[{'name': 'flag_true_if_should_flip', 'type': 'int'}]",设置加载图像时垂直翻转标志（线程内）,"STBIDEF void stbi_set_flip_vertically_on_load_thread(int flag_true_if_should_flip)
{
   stbi__vertically_flip_on_load_local = flag_true_if_should_flip;
   stbi__vertically_flip_on_load_set = 1;
}","{'begin': {'line': 1126, 'column': 1}, 'end': {'line': 1130, 'column': 2}}",show_image.c,"['设置', '加载', '图像', '时', '垂直', '翻转', '标志', '（', '线程', '内', '）']"
514,514,stbi__refill_buffer,void,void stbi__refill_buffer(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",重新填充输入缓冲区，处理文件结束情况,"static void stbi__refill_buffer(stbi__context *s)
{
   int n = (s->io.read)(s->io_user_data,(char*)s->buffer_start,s->buflen);
   s->callback_already_read += (int) (s->img_buffer - s->img_buffer_original);
   if (n == 0) {
      // at end of file, treat same as if from memory, but need to handle case
      // where s->img_buffer isn't pointing to safe memory, e.g. 0-byte file
      s->read_from_callbacks = 0;
      s->img_buffer = s->buffer_start;
      s->img_buffer_end = s->buffer_start+1;
      *s->img_buffer = 0;
   } else {
      s->img_buffer = s->buffer_start;
      s->img_buffer_end = s->buffer_start + n;
   }
}","{'begin': {'line': 1597, 'column': 1}, 'end': {'line': 1612, 'column': 2}}",show_image.c,"['重新', '填充', '输入', '缓冲', '缓冲区', '，', '处理', '文件', '结束', '情况']"
515,515,stbi__load_main,void *,"void * stbi__load_main(stbi__context * s, int * x, int * y, int * comp, int req_comp, stbi__result_info * ri, int bpc)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'ri', 'type': 'stbi__result_info *'}, {'name': 'bpc', 'type': 'int'}]",根据输入数据检测图像格式并加载相应图像数据,"static void *stbi__load_main(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)
{
   memset(ri, 0, sizeof(*ri)); // make sure it's initialized if we add new fields
   ri->bits_per_channel = 8; // default is 8 so most paths don't have to be changed
   ri->channel_order = STBI_ORDER_RGB; // all current input & output are this, but this is here so we can add BGR order
   ri->num_channels = 0;

   // test the formats with a very explicit header first (at least a FOURCC
   // or distinctive magic number first)
   #ifndef STBI_NO_PNG
   if (stbi__png_test(s))  return stbi__png_load(s,x,y,comp,req_comp, ri);
   #endif
   #ifndef STBI_NO_BMP
   if (stbi__bmp_test(s))  return stbi__bmp_load(s,x,y,comp,req_comp, ri);
   #endif
   #ifndef STBI_NO_GIF
   if (stbi__gif_test(s))  return stbi__gif_load(s,x,y,comp,req_comp, ri);
   #endif
   #ifndef STBI_NO_PSD
   if (stbi__psd_test(s))  return stbi__psd_load(s,x,y,comp,req_comp, ri, bpc);
   #else
   STBI_NOTUSED(bpc);
   #endif
   #ifndef STBI_NO_PIC
   if (stbi__pic_test(s))  return stbi__pic_load(s,x,y,comp,req_comp, ri);
   #endif

   // then the formats that can end up attempting to load with just 1 or 2
   // bytes matching expectations; these are prone to false positives, so
   // try them later
   #ifndef STBI_NO_JPEG
   if (stbi__jpeg_test(s)) return stbi__jpeg_load(s,x,y,comp,req_comp, ri);
   #endif
   #ifndef STBI_NO_PNM
   if (stbi__pnm_test(s))  return stbi__pnm_load(s,x,y,comp,req_comp, ri);
   #endif

   #ifndef STBI_NO_HDR
   if (stbi__hdr_test(s)) {
      float *hdr = stbi__hdr_load(s, x,y,comp,req_comp, ri);
      return stbi__hdr_to_ldr(hdr, *x, *y, req_comp ? req_comp : *comp);
   }
   #endif

   #ifndef STBI_NO_TGA
   // test tga last because it's a crappy test!
   if (stbi__tga_test(s))
      return stbi__tga_load(s,x,y,comp,req_comp, ri);
   #endif

   return stbi__errpuc(""unknown image type"", ""Image not of any known type, or corrupt"");
}","{'begin': {'line': 1137, 'column': 1}, 'end': {'line': 1188, 'column': 2}}",show_image.c,"['根据', '输入', '数据', '检测', '图像', '格式', '图像格式', '并', '加载', '相应', '图像', '数据']"
516,516,stbi__get8,stbi_uc,stbi_uc stbi__get8(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",从图像缓冲区读取下一个字节，必要时重新填充,"static stbi_uc stbi__get8(stbi__context *s)
{
   if (s->img_buffer < s->img_buffer_end)
      return *s->img_buffer++;
   if (s->read_from_callbacks) {
      stbi__refill_buffer(s);
      return *s->img_buffer++;
   }
   return 0;
}","{'begin': {'line': 1614, 'column': 13}, 'end': {'line': 1623, 'column': 2}}",show_image.c,"['从', '图像', '缓冲', '缓冲区', '读取', '下', '一个', '字节', '，', '必要', '时', '重新', '填充']"
517,517,stbi__at_eof,int,int stbi__at_eof(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",检查数据流是否已读取到末尾,"static int stbi__at_eof(stbi__context *s)
{
   if (s->io.read) {
      if (!(s->io.eof)(s->io_user_data)) return 0;
      // if feof() is true, check if buffer = end
      // special case: we've only got the special 0 character at the end
      if (s->read_from_callbacks == 0) return 1;
   }

   return s->img_buffer >= s->img_buffer_end;
}","{'begin': {'line': 1628, 'column': 13}, 'end': {'line': 1638, 'column': 2}}",show_image.c,"['检查', '数据', '数据流', '是否', '已', '读取', '到', '末尾']"
518,518,stbi__skip,void,"void stbi__skip(stbi__context * s, int n)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'n', 'type': 'int'}]",移动缓冲区指针，跳过n字节数据,"static void stbi__skip(stbi__context *s, int n)
{
   if (n == 0) return;  // already there!
   if (n < 0) {
      s->img_buffer = s->img_buffer_end;
      return;
   }
   if (s->io.read) {
      int blen = (int) (s->img_buffer_end - s->img_buffer);
      if (blen < n) {
         s->img_buffer = s->img_buffer_end;
         (s->io.skip)(s->io_user_data, n - blen);
         return;
      }
   }
   s->img_buffer += n;
}","{'begin': {'line': 1644, 'column': 1}, 'end': {'line': 1660, 'column': 2}}",show_image.c,"['移动', '缓冲', '缓冲区', '指针', '，', '跳过', 'n', '字节', '数据']"
519,519,stbi__convert_16_to_8,stbi_uc *,"stbi_uc * stbi__convert_16_to_8(stbi__uint16 * orig, int w, int h, int channels)","[{'name': 'orig', 'type': 'stbi__uint16 *'}, {'name': 'w', 'type': 'int'}, {'name': 'h', 'type': 'int'}, {'name': 'channels', 'type': 'int'}]",将16位图像数据转换为8位并释放原内存,"static stbi_uc *stbi__convert_16_to_8(stbi__uint16 *orig, int w, int h, int channels)
{
   int i;
   int img_len = w * h * channels;
   stbi_uc *reduced;

   reduced = (stbi_uc *) stbi__malloc(img_len);
   if (reduced == NULL) return stbi__errpuc(""outofmem"", ""Out of memory"");

   for (i = 0; i < img_len; ++i)
      reduced[i] = (stbi_uc)((orig[i] >> 8) & 0xFF); // top half of each byte is sufficient approx of 16->8 bit scaling

   STBI_FREE(orig);
   return reduced;
}","{'begin': {'line': 1190, 'column': 1}, 'end': {'line': 1204, 'column': 2}}",show_image.c,"['将', '16', '位', '图像', '数据', '转换', '为', '8', '位', '并', '释放', '原', '内存']"
520,520,stbi__getn,int,"int stbi__getn(stbi__context * s, stbi_uc * buffer, int n)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'buffer', 'type': 'stbi_uc *'}, {'name': 'n', 'type': 'int'}]",从上下文中读取指定数量字节到缓冲区,"static int stbi__getn(stbi__context *s, stbi_uc *buffer, int n)
{
   if (s->io.read) {
      int blen = (int) (s->img_buffer_end - s->img_buffer);
      if (blen < n) {
         int res, count;

         memcpy(buffer, s->img_buffer, blen);

         count = (s->io.read)(s->io_user_data, (char*) buffer + blen, n - blen);
         res = (count == (n-blen));
         s->img_buffer = s->img_buffer_end;
         return res;
      }
   }

   if (s->img_buffer+n <= s->img_buffer_end) {
      memcpy(buffer, s->img_buffer, n);
      s->img_buffer += n;
      return 1;
   } else
      return 0;
}","{'begin': {'line': 1666, 'column': 1}, 'end': {'line': 1688, 'column': 2}}",show_image.c,"['从', '上下', '下文', '上下文', '中', '读取', '指定', '数量', '字节', '到', '缓冲', '缓冲区']"
521,521,stbi__convert_8_to_16,stbi__uint16 *,"stbi__uint16 * stbi__convert_8_to_16(stbi_uc * orig, int w, int h, int channels)","[{'name': 'orig', 'type': 'stbi_uc *'}, {'name': 'w', 'type': 'int'}, {'name': 'h', 'type': 'int'}, {'name': 'channels', 'type': 'int'}]",将8位图像数据转换为16位，释放原内存。,"static stbi__uint16 *stbi__convert_8_to_16(stbi_uc *orig, int w, int h, int channels)
{
   int i;
   int img_len = w * h * channels;
   stbi__uint16 *enlarged;

   enlarged = (stbi__uint16 *) stbi__malloc(img_len*2);
   if (enlarged == NULL) return (stbi__uint16 *) stbi__errpuc(""outofmem"", ""Out of memory"");

   for (i = 0; i < img_len; ++i)
      enlarged[i] = (stbi__uint16)((orig[i] << 8) + orig[i]); // replicate to high and low byte, maps 0->0, 255->0xffff

   STBI_FREE(orig);
   return enlarged;
}","{'begin': {'line': 1206, 'column': 1}, 'end': {'line': 1220, 'column': 2}}",show_image.c,"['将', '8', '位', '图像', '数据', '转换', '为', '16', '位', '，', '释放', '原', '内存', '。']"
522,522,stbi__vertical_flip,void,"void stbi__vertical_flip(void * image, int w, int h, int bytes_per_pixel)","[{'name': 'image', 'type': 'void *'}, {'name': 'w', 'type': 'int'}, {'name': 'h', 'type': 'int'}, {'name': 'bytes_per_pixel', 'type': 'int'}]",垂直翻转图像数据，按行交换像素内容。,"static void stbi__vertical_flip(void *image, int w, int h, int bytes_per_pixel)
{
   int row;
   size_t bytes_per_row = (size_t)w * bytes_per_pixel;
   stbi_uc temp[2048];
   stbi_uc *bytes = (stbi_uc *)image;

   for (row = 0; row < (h>>1); row++) {
      stbi_uc *row0 = bytes + row*bytes_per_row;
      stbi_uc *row1 = bytes + (h - row - 1)*bytes_per_row;
      // swap row0 with row1
      size_t bytes_left = bytes_per_row;
      while (bytes_left) {
         size_t bytes_copy = (bytes_left < sizeof(temp)) ? bytes_left : sizeof(temp);
         memcpy(temp, row0, bytes_copy);
         memcpy(row0, row1, bytes_copy);
         memcpy(row1, temp, bytes_copy);
         row0 += bytes_copy;
         row1 += bytes_copy;
         bytes_left -= bytes_copy;
      }
   }
}","{'begin': {'line': 1222, 'column': 1}, 'end': {'line': 1244, 'column': 2}}",show_image.c,"['垂直', '翻转', '图像', '数据', '，', '按行', '交换', '像素', '内容', '。']"
523,523,stbi__get16be,int,int stbi__get16be(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",从上下文中读取大端序的16位整数,"static int stbi__get16be(stbi__context *s)
{
   int z = stbi__get8(s);
   return (z << 8) + stbi__get8(s);
}","{'begin': {'line': 1694, 'column': 1}, 'end': {'line': 1698, 'column': 2}}",show_image.c,"['从', '上下', '下文', '上下文', '中', '读取', '大端', '大端序', '的', '16', '位', '整数']"
524,524,stbi__vertical_flip_slices,void,"void stbi__vertical_flip_slices(void * image, int w, int h, int z, int bytes_per_pixel)","[{'name': 'image', 'type': 'void *'}, {'name': 'w', 'type': 'int'}, {'name': 'h', 'type': 'int'}, {'name': 'z', 'type': 'int'}, {'name': 'bytes_per_pixel', 'type': 'int'}]",垂直翻转三维图像的各切片数据,"static void stbi__vertical_flip_slices(void *image, int w, int h, int z, int bytes_per_pixel)
{
   int slice;
   int slice_size = w * h * bytes_per_pixel;

   stbi_uc *bytes = (stbi_uc *)image;
   for (slice = 0; slice < z; ++slice) {
      stbi__vertical_flip(bytes, w, h, bytes_per_pixel);
      bytes += slice_size;
   }
}","{'begin': {'line': 1247, 'column': 1}, 'end': {'line': 1257, 'column': 2}}",show_image.c,"['垂直', '翻转', '三维', '图像', '的', '各', '切片', '数据']"
525,525,stbi__get32be,stbi__uint32,stbi__uint32 stbi__get32be(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",以大端序从上下文读取32位无符号整数,"static stbi__uint32 stbi__get32be(stbi__context *s)
{
   stbi__uint32 z = stbi__get16be(s);
   return (z << 16) + stbi__get16be(s);
}","{'begin': {'line': 1704, 'column': 1}, 'end': {'line': 1708, 'column': 2}}",show_image.c,"['大端', '以大端序', '从', '上下', '下文', '上下文', '读取', '32', '位', '无', '符号', '整数']"
526,526,stbi__get16le,int,int stbi__get16le(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",以小端序从上下文读取16位整数,"static int stbi__get16le(stbi__context *s)
{
   int z = stbi__get8(s);
   return z + (stbi__get8(s) << 8);
}","{'begin': {'line': 1714, 'column': 1}, 'end': {'line': 1718, 'column': 2}}",show_image.c,"['以小端序', '从', '上下', '下文', '上下文', '读取', '16', '位', '整数']"
527,527,stbi__load_and_postprocess_8bit,unsigned char *,"unsigned char * stbi__load_and_postprocess_8bit(stbi__context * s, int * x, int * y, int * comp, int req_comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",加载并处理图像为8位，支持垂直翻转。,"static unsigned char *stbi__load_and_postprocess_8bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
   stbi__result_info ri;
   void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 8);

   if (result == NULL)
      return NULL;

   // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.
   STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);

   if (ri.bits_per_channel != 8) {
      result = stbi__convert_16_to_8((stbi__uint16 *) result, *x, *y, req_comp == 0 ? *comp : req_comp);
      ri.bits_per_channel = 8;
   }

   // @TODO: move stbi__convert_format to here

   if (stbi__vertically_flip_on_load) {
      int channels = req_comp ? req_comp : *comp;
      stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi_uc));
   }

   return (unsigned char *) result;
}","{'begin': {'line': 1260, 'column': 1}, 'end': {'line': 1284, 'column': 2}}",show_image.c,"['加载', '并', '处理', '图像', '为', '8', '位', '，', '支持', '垂直', '翻转', '。']"
528,528,stbi__get32le,stbi__uint32,stbi__uint32 stbi__get32le(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",读取小端格式的32位整数,"static stbi__uint32 stbi__get32le(stbi__context *s)
{
   stbi__uint32 z = stbi__get16le(s);
   z += (stbi__uint32)stbi__get16le(s) << 16;
   return z;
}","{'begin': {'line': 1722, 'column': 1}, 'end': {'line': 1727, 'column': 2}}",show_image.c,"['读取', '小端', '格式', '的', '32', '位', '整数']"
529,529,stbi__compute_y,stbi_uc,"stbi_uc stbi__compute_y(int r, int g, int b)","[{'name': 'r', 'type': 'int'}, {'name': 'g', 'type': 'int'}, {'name': 'b', 'type': 'int'}]",将RGB值转换为亮度Y分量,"static stbi_uc stbi__compute_y(int r, int g, int b)
{
   return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);
}","{'begin': {'line': 1746, 'column': 1}, 'end': {'line': 1749, 'column': 2}}",show_image.c,"['将', 'RGB', '值', '转换', '为', '亮度', 'Y', '分量']"
530,530,stbi__convert_format,unsigned char *,"unsigned char * stbi__convert_format(unsigned char * data, int img_n, int req_comp, unsigned int x, unsigned int y)","[{'name': 'data', 'type': 'unsigned char *'}, {'name': 'img_n', 'type': 'int'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'x', 'type': 'unsigned int'}, {'name': 'y', 'type': 'unsigned int'}]",转换图像数据通道格式，支持多种组合,"static unsigned char *stbi__convert_format(unsigned char *data, int img_n, int req_comp, unsigned int x, unsigned int y)
{
   int i,j;
   unsigned char *good;

   if (req_comp == img_n) return data;
   STBI_ASSERT(req_comp >= 1 && req_comp <= 4);

   good = (unsigned char *) stbi__malloc_mad3(req_comp, x, y, 0);
   if (good == NULL) {
      STBI_FREE(data);
      return stbi__errpuc(""outofmem"", ""Out of memory"");
   }

   for (j=0; j < (int) y; ++j) {
      unsigned char *src  = data + j * x * img_n   ;
      unsigned char *dest = good + j * x * req_comp;

      #define STBI__COMBO(a,b)  ((a)*8+(b))
      #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
      // convert source image with img_n components to one with req_comp components;
      // avoid switch per pixel, so use switch per scanline and massive macros
      switch (STBI__COMBO(img_n, req_comp)) {
         STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=255;                                     } break;
         STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
         STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=255;                     } break;
         STBI__CASE(2,1) { dest[0]=src[0];                                                  } break;
         STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
         STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                  } break;
         STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=255;        } break;
         STBI__CASE(3,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
         STBI__CASE(3,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = 255;    } break;
         STBI__CASE(4,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
         STBI__CASE(4,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = src[3]; } break;
         STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                    } break;
         default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return stbi__errpuc(""unsupported"", ""Unsupported format conversion"");
      }
      #undef STBI__CASE
   }

   STBI_FREE(data);
   return good;
}","{'begin': {'line': 1755, 'column': 1}, 'end': {'line': 1797, 'column': 2}}",show_image.c,"['转换', '图像', '数据', '通道', '数据通', '数据通道', '格式', '，', '支持', '多种', '组合']"
531,531,stbi__load_and_postprocess_16bit,stbi__uint16 *,"stbi__uint16 * stbi__load_and_postprocess_16bit(stbi__context * s, int * x, int * y, int * comp, int req_comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",加载并后处理16位图像数据，支持格式转换和垂直翻转,"static stbi__uint16 *stbi__load_and_postprocess_16bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
   stbi__result_info ri;
   void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 16);

   if (result == NULL)
      return NULL;

   // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.
   STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);

   if (ri.bits_per_channel != 16) {
      result = stbi__convert_8_to_16((stbi_uc *) result, *x, *y, req_comp == 0 ? *comp : req_comp);
      ri.bits_per_channel = 16;
   }

   // @TODO: move stbi__convert_format16 to here
   // @TODO: special case RGB-to-Y (and RGBA-to-YA) for 8-bit-to-16-bit case to keep more precision

   if (stbi__vertically_flip_on_load) {
      int channels = req_comp ? req_comp : *comp;
      stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi__uint16));
   }

   return (stbi__uint16 *) result;
}","{'begin': {'line': 1286, 'column': 1}, 'end': {'line': 1311, 'column': 2}}",show_image.c,"['加载', '并', '处理', '后处理', '16', '位', '图像', '数据', '，', '支持', '格式', '转换', '和', '垂直', '翻转']"
532,532,stbi__float_postprocess,void,"void stbi__float_postprocess(float * result, int * x, int * y, int * comp, int req_comp)","[{'name': 'result', 'type': 'float *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",处理浮点数据加载后的垂直翻转操作,"static void stbi__float_postprocess(float *result, int *x, int *y, int *comp, int req_comp)
{
   if (stbi__vertically_flip_on_load && result != NULL) {
      int channels = req_comp ? req_comp : *comp;
      stbi__vertical_flip(result, *x, *y, channels * sizeof(float));
   }
}","{'begin': {'line': 1314, 'column': 1}, 'end': {'line': 1320, 'column': 2}}",show_image.c,"['处理', '浮点', '数据', '加载', '后', '的', '垂直', '翻转', '操作']"
533,533,stbi__fopen,FILE *,"FILE * stbi__fopen(const char * filename, const char * mode)","[{'name': 'filename', 'type': 'const char *'}, {'name': 'mode', 'type': 'const char *'}]",跨平台打开文件，支持UTF-8路径,"static FILE *stbi__fopen(char const *filename, char const *mode)
{
   FILE *f;
#if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
   wchar_t wMode[64];
   wchar_t wFilename[1024];
	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, filename, -1, wFilename, sizeof(wFilename)/sizeof(*wFilename)))
      return 0;

	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, mode, -1, wMode, sizeof(wMode)/sizeof(*wMode)))
      return 0;

#if defined(_MSC_VER) && _MSC_VER >= 1400
	if (0 != _wfopen_s(&f, wFilename, wMode))
		f = 0;
#else
   f = _wfopen(wFilename, wMode);
#endif

#elif defined(_MSC_VER) && _MSC_VER >= 1400
   if (0 != fopen_s(&f, filename, mode))
      f=0;
#else
   f = fopen(filename, mode);
#endif
   return f;
}","{'begin': {'line': 1337, 'column': 1}, 'end': {'line': 1363, 'column': 2}}",show_image.c,"['平台', '跨平台', '打开', '文件', '，', '支持', 'UTF', '-', '8', '路径']"
534,534,stbi_load,stbi_uc *,"stbi_uc * stbi_load(const char * filename, int * x, int * y, int * comp, int req_comp)","[{'name': 'filename', 'type': 'const char *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",加载图像文件，返回像素数据及尺寸信息,"STBIDEF stbi_uc *stbi_load(char const *filename, int *x, int *y, int *comp, int req_comp)
{
   FILE *f = stbi__fopen(filename, ""rb"");
   unsigned char *result;
   if (!f) return stbi__errpuc(""can't fopen"", ""Unable to open file"");
   result = stbi_load_from_file(f,x,y,comp,req_comp);
   fclose(f);
   return result;
}","{'begin': {'line': 1366, 'column': 1}, 'end': {'line': 1374, 'column': 2}}",show_image.c,"['加载', '图像', '文件', '图像文件', '，', '返回', '像素', '数据', '及', '尺寸', '信息']"
535,535,stbi_load_from_file,stbi_uc *,"stbi_uc * stbi_load_from_file(FILE * f, int * x, int * y, int * comp, int req_comp)","[{'name': 'f', 'type': 'FILE *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",从文件加载图像数据并调整指针位置,"STBIDEF stbi_uc *stbi_load_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
{
   unsigned char *result;
   stbi__context s;
   stbi__start_file(&s,f);
   result = stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
   if (result) {
      // need to 'unget' all the characters in the IO buffer
      fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);
   }
   return result;
}","{'begin': {'line': 1376, 'column': 1}, 'end': {'line': 1387, 'column': 2}}",show_image.c,"['文件', '从文件', '加载', '图像', '数据', '并', '调整', '指针', '位置']"
536,536,stbi_load_from_file_16,stbi_us *,"stbi_us * stbi_load_from_file_16(FILE * f, int * x, int * y, int * comp, int req_comp)","[{'name': 'f', 'type': 'FILE *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",从文件加载16位图像数据并处理,"STBIDEF stbi__uint16 *stbi_load_from_file_16(FILE *f, int *x, int *y, int *comp, int req_comp)
{
   stbi__uint16 *result;
   stbi__context s;
   stbi__start_file(&s,f);
   result = stbi__load_and_postprocess_16bit(&s,x,y,comp,req_comp);
   if (result) {
      // need to 'unget' all the characters in the IO buffer
      fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);
   }
   return result;
}","{'begin': {'line': 1389, 'column': 1}, 'end': {'line': 1400, 'column': 2}}",show_image.c,"['文件', '从文件', '加载', '16', '位', '图像', '数据', '并', '处理']"
537,537,stbi_load_16,stbi_us *,"stbi_us * stbi_load_16(const char * filename, int * x, int * y, int * comp, int req_comp)","[{'name': 'filename', 'type': 'const char *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",加载16位图像文件，返回尺寸及通道信息,"STBIDEF stbi_us *stbi_load_16(char const *filename, int *x, int *y, int *comp, int req_comp)
{
   FILE *f = stbi__fopen(filename, ""rb"");
   stbi__uint16 *result;
   if (!f) return (stbi_us *) stbi__errpuc(""can't fopen"", ""Unable to open file"");
   result = stbi_load_from_file_16(f,x,y,comp,req_comp);
   fclose(f);
   return result;
}","{'begin': {'line': 1402, 'column': 1}, 'end': {'line': 1410, 'column': 2}}",show_image.c,"['加载', '16', '位', '图像', '文件', '图像文件', '，', '返回', '尺寸', '及', '通道', '信息']"
538,538,stbi_load_16_from_memory,stbi_us *,"stbi_us * stbi_load_16_from_memory(const stbi_uc * buffer, int len, int * x, int * y, int * channels_in_file, int desired_channels)","[{'name': 'buffer', 'type': 'const stbi_uc *'}, {'name': 'len', 'type': 'int'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'channels_in_file', 'type': 'int *'}, {'name': 'desired_channels', 'type': 'int'}]",从内存加载16位图像数据,"STBIDEF stbi_us *stbi_load_16_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);
}","{'begin': {'line': 1415, 'column': 1}, 'end': {'line': 1420, 'column': 2}}",show_image.c,"['从', '内存', '加载', '16', '位', '图像', '数据']"
539,539,stbi_load_16_from_callbacks,stbi_us *,"stbi_us * stbi_load_16_from_callbacks(const stbi_io_callbacks * clbk, void * user, int * x, int * y, int * channels_in_file, int desired_channels)","[{'name': 'clbk', 'type': 'const stbi_io_callbacks *'}, {'name': 'user', 'type': 'void *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'channels_in_file', 'type': 'int *'}, {'name': 'desired_channels', 'type': 'int'}]",通过回调加载并处理16位图像数据，调整通道数,"STBIDEF stbi_us *stbi_load_16_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *channels_in_file, int desired_channels)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *)clbk, user);
   return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);
}","{'begin': {'line': 1422, 'column': 1}, 'end': {'line': 1427, 'column': 2}}",show_image.c,"['通过', '回调', '加载', '并', '处理', '16', '位', '图像', '数据', '，', '调整', '通道', '数']"
540,540,stbi_load_from_memory,stbi_uc *,"stbi_uc * stbi_load_from_memory(const stbi_uc * buffer, int len, int * x, int * y, int * comp, int req_comp)","[{'name': 'buffer', 'type': 'const stbi_uc *'}, {'name': 'len', 'type': 'int'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",从内存缓冲区加载并处理图像数据,"STBIDEF stbi_uc *stbi_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
}","{'begin': {'line': 1429, 'column': 1}, 'end': {'line': 1434, 'column': 2}}",show_image.c,"['从', '内存', '缓冲', '缓冲区', '加载', '并', '处理', '图像', '数据']"
541,541,stbi_load_from_callbacks,stbi_uc *,"stbi_uc * stbi_load_from_callbacks(const stbi_io_callbacks * clbk, void * user, int * x, int * y, int * comp, int req_comp)","[{'name': 'clbk', 'type': 'const stbi_io_callbacks *'}, {'name': 'user', 'type': 'void *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",通过回调函数加载并处理图像数据,"STBIDEF stbi_uc *stbi_load_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
}","{'begin': {'line': 1436, 'column': 1}, 'end': {'line': 1441, 'column': 2}}",show_image.c,"['通过', '回调', '函数', '加载', '并', '处理', '图像', '数据']"
542,542,stbi_load_gif_from_memory,stbi_uc *,"stbi_uc * stbi_load_gif_from_memory(const stbi_uc * buffer, int len, int ** delays, int * x, int * y, int * z, int * comp, int req_comp)","[{'name': 'buffer', 'type': 'const stbi_uc *'}, {'name': 'len', 'type': 'int'}, {'name': 'delays', 'type': 'int **'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'z', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",从内存加载GIF图像，返回像素数据及帧延迟和尺寸,"STBIDEF stbi_uc *stbi_load_gif_from_memory(stbi_uc const *buffer, int len, int **delays, int *x, int *y, int *z, int *comp, int req_comp)
{
   unsigned char *result;
   stbi__context s;
   stbi__start_mem(&s,buffer,len);

   result = (unsigned char*) stbi__load_gif_main(&s, delays, x, y, z, comp, req_comp);
   if (stbi__vertically_flip_on_load) {
      stbi__vertical_flip_slices( result, *x, *y, *z, *comp );
   }

   return result;
}","{'begin': {'line': 1444, 'column': 1}, 'end': {'line': 1456, 'column': 2}}",show_image.c,"['从', '内存', '加载', 'GIF', '图像', '，', '返回', '像素', '数据', '及', '帧', '延迟', '和', '尺寸']"
543,543,stbi__compute_y_16,stbi__uint16,"stbi__uint16 stbi__compute_y_16(int r, int g, int b)","[{'name': 'r', 'type': 'int'}, {'name': 'g', 'type': 'int'}, {'name': 'b', 'type': 'int'}]",计算RGB16分量的亮度值,"static stbi__uint16 stbi__compute_y_16(int r, int g, int b)
{
   return (stbi__uint16) (((r*77) + (g*150) +  (29*b)) >> 8);
}","{'begin': {'line': 1803, 'column': 1}, 'end': {'line': 1806, 'column': 2}}",show_image.c,"['计算', 'RGB16', '分量', '的', '亮度', '值']"
544,544,stbi__convert_format16,stbi__uint16 *,"stbi__uint16 * stbi__convert_format16(stbi__uint16 * data, int img_n, int req_comp, unsigned int x, unsigned int y)","[{'name': 'data', 'type': 'stbi__uint16 *'}, {'name': 'img_n', 'type': 'int'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'x', 'type': 'unsigned int'}, {'name': 'y', 'type': 'unsigned int'}]",转换16位图像数据格式，调整通道数,"static stbi__uint16 *stbi__convert_format16(stbi__uint16 *data, int img_n, int req_comp, unsigned int x, unsigned int y)
{
   int i,j;
   stbi__uint16 *good;

   if (req_comp == img_n) return data;
   STBI_ASSERT(req_comp >= 1 && req_comp <= 4);

   good = (stbi__uint16 *) stbi__malloc(req_comp * x * y * 2);
   if (good == NULL) {
      STBI_FREE(data);
      return (stbi__uint16 *) stbi__errpuc(""outofmem"", ""Out of memory"");
   }

   for (j=0; j < (int) y; ++j) {
      stbi__uint16 *src  = data + j * x * img_n   ;
      stbi__uint16 *dest = good + j * x * req_comp;

      #define STBI__COMBO(a,b)  ((a)*8+(b))
      #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
      // convert source image with img_n components to one with req_comp components;
      // avoid switch per pixel, so use switch per scanline and massive macros
      switch (STBI__COMBO(img_n, req_comp)) {
         STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=0xffff;                                     } break;
         STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
         STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=0xffff;                     } break;
         STBI__CASE(2,1) { dest[0]=src[0];                                                     } break;
         STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
         STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                     } break;
         STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=0xffff;        } break;
         STBI__CASE(3,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
         STBI__CASE(3,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = 0xffff; } break;
         STBI__CASE(4,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
         STBI__CASE(4,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = src[3]; } break;
         STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                       } break;
         default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return (stbi__uint16*) stbi__errpuc(""unsupported"", ""Unsupported format conversion"");
      }
      #undef STBI__CASE
   }

   STBI_FREE(data);
   return good;
}","{'begin': {'line': 1812, 'column': 1}, 'end': {'line': 1854, 'column': 2}}",show_image.c,"['转换', '16', '位', '图像', '数据', '格式', '数据格式', '，', '调整', '通道', '数']"
545,545,stbi__loadf_main,float *,"float * stbi__loadf_main(stbi__context * s, int * x, int * y, int * comp, int req_comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",加载图像数据并转换为HDR浮点格式,"static float *stbi__loadf_main(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
   unsigned char *data;
   #ifndef STBI_NO_HDR
   if (stbi__hdr_test(s)) {
      stbi__result_info ri;
      float *hdr_data = stbi__hdr_load(s,x,y,comp,req_comp, &ri);
      if (hdr_data)
         stbi__float_postprocess(hdr_data,x,y,comp,req_comp);
      return hdr_data;
   }
   #endif
   data = stbi__load_and_postprocess_8bit(s, x, y, comp, req_comp);
   if (data)
      return stbi__ldr_to_hdr(data, *x, *y, req_comp ? req_comp : *comp);
   return stbi__errpf(""unknown image type"", ""Image not of any known type, or corrupt"");
}","{'begin': {'line': 1460, 'column': 1}, 'end': {'line': 1476, 'column': 2}}",show_image.c,"['加载', '图像', '数据', '并', '转换', '为', 'HDR', '浮点', '格式']"
546,546,stbi_loadf_from_memory,float *,"float * stbi_loadf_from_memory(const stbi_uc * buffer, int len, int * x, int * y, int * comp, int req_comp)","[{'name': 'buffer', 'type': 'const stbi_uc *'}, {'name': 'len', 'type': 'int'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",从内存加载浮点格式图像数据,"STBIDEF float *stbi_loadf_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__loadf_main(&s,x,y,comp,req_comp);
}","{'begin': {'line': 1478, 'column': 1}, 'end': {'line': 1483, 'column': 2}}",show_image.c,"['从', '内存', '加载', '浮点', '格式', '图像', '数据']"
547,547,stbi_loadf_from_callbacks,float *,"float * stbi_loadf_from_callbacks(const stbi_io_callbacks * clbk, void * user, int * x, int * y, int * comp, int req_comp)","[{'name': 'clbk', 'type': 'const stbi_io_callbacks *'}, {'name': 'user', 'type': 'void *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",通过回调加载浮点图像数据,"STBIDEF float *stbi_loadf_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi__loadf_main(&s,x,y,comp,req_comp);
}","{'begin': {'line': 1485, 'column': 1}, 'end': {'line': 1490, 'column': 2}}",show_image.c,"['通过', '回调', '加载', '浮点', '图像', '数据']"
548,548,stbi_loadf,float *,"float * stbi_loadf(const char * filename, int * x, int * y, int * comp, int req_comp)","[{'name': 'filename', 'type': 'const char *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",加载图像文件为浮点数组，返回指针及尺寸信息,"STBIDEF float *stbi_loadf(char const *filename, int *x, int *y, int *comp, int req_comp)
{
   float *result;
   FILE *f = stbi__fopen(filename, ""rb"");
   if (!f) return stbi__errpf(""can't fopen"", ""Unable to open file"");
   result = stbi_loadf_from_file(f,x,y,comp,req_comp);
   fclose(f);
   return result;
}","{'begin': {'line': 1493, 'column': 1}, 'end': {'line': 1501, 'column': 2}}",show_image.c,"['加载', '图像', '文件', '图像文件', '为', '浮点', '数组', '，', '返回', '指针', '及', '尺寸', '信息']"
549,549,stbi_loadf_from_file,float *,"float * stbi_loadf_from_file(FILE * f, int * x, int * y, int * comp, int req_comp)","[{'name': 'f', 'type': 'FILE *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",从文件加载浮点格式图像数据，返回像素数组,"STBIDEF float *stbi_loadf_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_file(&s,f);
   return stbi__loadf_main(&s,x,y,comp,req_comp);
}","{'begin': {'line': 1503, 'column': 1}, 'end': {'line': 1508, 'column': 2}}",show_image.c,"['文件', '从文件', '加载', '浮点', '格式', '图像', '数据', '，', '返回', '像素', '数组']"
550,550,stbi_is_hdr_from_memory,int,"int stbi_is_hdr_from_memory(const stbi_uc * buffer, int len)","[{'name': 'buffer', 'type': 'const stbi_uc *'}, {'name': 'len', 'type': 'int'}]",检测内存缓冲区是否为HDR图像格式,"STBIDEF int stbi_is_hdr_from_memory(stbi_uc const *buffer, int len)
{
   #ifndef STBI_NO_HDR
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__hdr_test(&s);
   #else
   STBI_NOTUSED(buffer);
   STBI_NOTUSED(len);
   return 0;
   #endif
}","{'begin': {'line': 1517, 'column': 1}, 'end': {'line': 1528, 'column': 2}}",show_image.c,"['检测', '内存', '缓冲', '缓冲区', '是否', '为', 'HDR', '图像', '格式', '图像格式']"
551,551,stbi_is_hdr,int,int stbi_is_hdr(const char * filename),"[{'name': 'filename', 'type': 'const char *'}]",检查指定文件是否为HDR图像,"STBIDEF int      stbi_is_hdr          (char const *filename)
{
   FILE *f = stbi__fopen(filename, ""rb"");
   int result=0;
   if (f) {
      result = stbi_is_hdr_from_file(f);
      fclose(f);
   }
   return result;
}","{'begin': {'line': 1531, 'column': 1}, 'end': {'line': 1540, 'column': 2}}",show_image.c,"['检查', '指定', '文件', '是否', '为', 'HDR', '图像']"
552,552,stbi_is_hdr_from_file,int,int stbi_is_hdr_from_file(FILE * f),"[{'name': 'f', 'type': 'FILE *'}]",检测文件是否为HDR格式，不移动文件指针,"STBIDEF int stbi_is_hdr_from_file(FILE *f)
{
   #ifndef STBI_NO_HDR
   long pos = ftell(f);
   int res;
   stbi__context s;
   stbi__start_file(&s,f);
   res = stbi__hdr_test(&s);
   fseek(f, pos, SEEK_SET);
   return res;
   #else
   STBI_NOTUSED(f);
   return 0;
   #endif
}","{'begin': {'line': 1542, 'column': 1}, 'end': {'line': 1556, 'column': 2}}",show_image.c,"['检测', '文件', '是否', '为', 'HDR', '格式', '，', '不', '移动', '文件', '指针']"
553,553,stbi_is_hdr_from_callbacks,int,"int stbi_is_hdr_from_callbacks(const stbi_io_callbacks * clbk, void * user)","[{'name': 'clbk', 'type': 'const stbi_io_callbacks *'}, {'name': 'user', 'type': 'void *'}]",通过回调检测图像是否为HDR格式,"STBIDEF int      stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user)
{
   #ifndef STBI_NO_HDR
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi__hdr_test(&s);
   #else
   STBI_NOTUSED(clbk);
   STBI_NOTUSED(user);
   return 0;
   #endif
}","{'begin': {'line': 1559, 'column': 1}, 'end': {'line': 1570, 'column': 2}}",show_image.c,"['通过', '回调', '检测', '图像', '是否', '为', 'HDR', '格式']"
554,554,stbi_ldr_to_hdr_gamma,void,void stbi_ldr_to_hdr_gamma(float gamma),"[{'name': 'gamma', 'type': 'float'}]",设置LDR到HDR转换的gamma值,"STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma) { stbi__l2h_gamma = gamma; }
","{'begin': {'line': 1575, 'column': 1}, 'end': {'line': 1575, 'column': 79}}",show_image.c,"['设置', 'LDR', '到', 'HDR', '转换', '的', 'gamma', '值']"
555,555,stbi_ldr_to_hdr_scale,void,void stbi_ldr_to_hdr_scale(float scale),"[{'name': 'scale', 'type': 'float'}]",设置LDR转HDR的缩放比例,"STBIDEF void   stbi_ldr_to_hdr_scale(float scale) { stbi__l2h_scale = scale; }
","{'begin': {'line': 1576, 'column': 1}, 'end': {'line': 1576, 'column': 79}}",show_image.c,"['设置', 'LDR', '转', 'HDR', '的', '缩放', '比例']"
556,556,stbi_hdr_to_ldr_gamma,void,void stbi_hdr_to_ldr_gamma(float gamma),"[{'name': 'gamma', 'type': 'float'}]",设置HDR转LDR的逆伽马值,"STBIDEF void   stbi_hdr_to_ldr_gamma(float gamma) { stbi__h2l_gamma_i = 1/gamma; }
","{'begin': {'line': 1581, 'column': 1}, 'end': {'line': 1581, 'column': 83}}",show_image.c,"['设置', 'HDR', '转', 'LDR', '的', '逆', '伽马', '值']"
557,557,stbi_hdr_to_ldr_scale,void,void stbi_hdr_to_ldr_scale(float scale),"[{'name': 'scale', 'type': 'float'}]",设置HDR转LDR的缩放比例参数,"STBIDEF void   stbi_hdr_to_ldr_scale(float scale) { stbi__h2l_scale_i = 1/scale; }
","{'begin': {'line': 1582, 'column': 1}, 'end': {'line': 1582, 'column': 83}}",show_image.c,"['设置', 'HDR', '转', 'LDR', '的', '缩放', '比例', '参数']"
558,558,stbi__refill_buffer,void,void stbi__refill_buffer(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",重新填充输入缓冲区数据,"static void stbi__refill_buffer(stbi__context *s)
{
   int n = (s->io.read)(s->io_user_data,(char*)s->buffer_start,s->buflen);
   s->callback_already_read += (int) (s->img_buffer - s->img_buffer_original);
   if (n == 0) {
      // at end of file, treat same as if from memory, but need to handle case
      // where s->img_buffer isn't pointing to safe memory, e.g. 0-byte file
      s->read_from_callbacks = 0;
      s->img_buffer = s->buffer_start;
      s->img_buffer_end = s->buffer_start+1;
      *s->img_buffer = 0;
   } else {
      s->img_buffer = s->buffer_start;
      s->img_buffer_end = s->buffer_start + n;
   }
}","{'begin': {'line': 1597, 'column': 1}, 'end': {'line': 1612, 'column': 2}}",show_image.c,"['重新', '填充', '输入', '缓冲', '缓冲区', '数据']"
559,559,stbi__get8,stbi_uc,stbi_uc stbi__get8(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",从缓冲区读取下一个字节，必要时重新填充,"static stbi_uc stbi__get8(stbi__context *s)
{
   if (s->img_buffer < s->img_buffer_end)
      return *s->img_buffer++;
   if (s->read_from_callbacks) {
      stbi__refill_buffer(s);
      return *s->img_buffer++;
   }
   return 0;
}","{'begin': {'line': 1614, 'column': 13}, 'end': {'line': 1623, 'column': 2}}",show_image.c,"['从', '缓冲', '缓冲区', '读取', '下', '一个', '字节', '，', '必要', '时', '重新', '填充']"
560,560,stbi__at_eof,int,int stbi__at_eof(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",检查是否到达文件或缓冲区末尾,"static int stbi__at_eof(stbi__context *s)
{
   if (s->io.read) {
      if (!(s->io.eof)(s->io_user_data)) return 0;
      // if feof() is true, check if buffer = end
      // special case: we've only got the special 0 character at the end
      if (s->read_from_callbacks == 0) return 1;
   }

   return s->img_buffer >= s->img_buffer_end;
}","{'begin': {'line': 1628, 'column': 13}, 'end': {'line': 1638, 'column': 2}}",show_image.c,"['检查', '是否', '到达', '文件', '或', '缓冲', '缓冲区', '末尾']"
561,561,stbi__ldr_to_hdr,float *,"float * stbi__ldr_to_hdr(stbi_uc * data, int x, int y, int comp)","[{'name': 'data', 'type': 'stbi_uc *'}, {'name': 'x', 'type': 'int'}, {'name': 'y', 'type': 'int'}, {'name': 'comp', 'type': 'int'}]",将LDR图像转换为HDR，应用伽马校正并处理Alpha通道,"static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp)
{
   int i,k,n;
   float *output;
   if (!data) return NULL;
   output = (float *) stbi__malloc_mad4(x, y, comp, sizeof(float), 0);
   if (output == NULL) { STBI_FREE(data); return stbi__errpf(""outofmem"", ""Out of memory""); }
   // compute number of non-alpha components
   if (comp & 1) n = comp; else n = comp-1;
   for (i=0; i < x*y; ++i) {
      for (k=0; k < n; ++k) {
         output[i*comp + k] = (float) (pow(data[i*comp+k]/255.0f, stbi__l2h_gamma) * stbi__l2h_scale);
      }
   }
   if (n < comp) {
      for (i=0; i < x*y; ++i) {
         output[i*comp + n] = data[i*comp + n]/255.0f;
      }
   }
   STBI_FREE(data);
   return output;
}","{'begin': {'line': 1858, 'column': 1}, 'end': {'line': 1879, 'column': 2}}",show_image.c,"['将', 'LDR', '图像', '转换', '为', 'HDR', '，', '应用', '伽马', '校正', '并', '处理', 'Alpha', '通道']"
562,562,stbi__skip,void,"void stbi__skip(stbi__context * s, int n)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'n', 'type': 'int'}]",跳过输入流的n个字节，处理缓冲和IO,"static void stbi__skip(stbi__context *s, int n)
{
   if (n == 0) return;  // already there!
   if (n < 0) {
      s->img_buffer = s->img_buffer_end;
      return;
   }
   if (s->io.read) {
      int blen = (int) (s->img_buffer_end - s->img_buffer);
      if (blen < n) {
         s->img_buffer = s->img_buffer_end;
         (s->io.skip)(s->io_user_data, n - blen);
         return;
      }
   }
   s->img_buffer += n;
}","{'begin': {'line': 1644, 'column': 1}, 'end': {'line': 1660, 'column': 2}}",show_image.c,"['跳过', '输入', '流', '的', 'n', '个', '字节', '，', '处理', '缓冲', '和', 'IO']"
563,563,stbi__getn,int,"int stbi__getn(stbi__context * s, stbi_uc * buffer, int n)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'buffer', 'type': 'stbi_uc *'}, {'name': 'n', 'type': 'int'}]",从上下文读取指定字节到缓冲区,"static int stbi__getn(stbi__context *s, stbi_uc *buffer, int n)
{
   if (s->io.read) {
      int blen = (int) (s->img_buffer_end - s->img_buffer);
      if (blen < n) {
         int res, count;

         memcpy(buffer, s->img_buffer, blen);

         count = (s->io.read)(s->io_user_data, (char*) buffer + blen, n - blen);
         res = (count == (n-blen));
         s->img_buffer = s->img_buffer_end;
         return res;
      }
   }

   if (s->img_buffer+n <= s->img_buffer_end) {
      memcpy(buffer, s->img_buffer, n);
      s->img_buffer += n;
      return 1;
   } else
      return 0;
}","{'begin': {'line': 1666, 'column': 1}, 'end': {'line': 1688, 'column': 2}}",show_image.c,"['从', '上下', '下文', '上下文', '读取', '指定', '字节', '到', '缓冲', '缓冲区']"
564,564,stbi__hdr_to_ldr,stbi_uc *,"stbi_uc * stbi__hdr_to_ldr(float * data, int x, int y, int comp)","[{'name': 'data', 'type': 'float *'}, {'name': 'x', 'type': 'int'}, {'name': 'y', 'type': 'int'}, {'name': 'comp', 'type': 'int'}]",将HDR图像数据转换为LDR格式，应用伽马校正并释放原数据内存,"static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp)
{
   int i,k,n;
   stbi_uc *output;
   if (!data) return NULL;
   output = (stbi_uc *) stbi__malloc_mad3(x, y, comp, 0);
   if (output == NULL) { STBI_FREE(data); return stbi__errpuc(""outofmem"", ""Out of memory""); }
   // compute number of non-alpha components
   if (comp & 1) n = comp; else n = comp-1;
   for (i=0; i < x*y; ++i) {
      for (k=0; k < n; ++k) {
         float z = (float) pow(data[i*comp+k]*stbi__h2l_scale_i, stbi__h2l_gamma_i) * 255 + 0.5f;
         if (z < 0) z = 0;
         if (z > 255) z = 255;
         output[i*comp + k] = (stbi_uc) stbi__float2int(z);
      }
      if (k < comp) {
         float z = data[i*comp+k] * 255 + 0.5f;
         if (z < 0) z = 0;
         if (z > 255) z = 255;
         output[i*comp + k] = (stbi_uc) stbi__float2int(z);
      }
   }
   STBI_FREE(data);
   return output;
}","{'begin': {'line': 1884, 'column': 1}, 'end': {'line': 1909, 'column': 2}}",show_image.c,"['将', 'HDR', '图像', '数据', '转换', '为', 'LDR', '格式', '，', '应用', '伽马', '校正', '并', '释放', '原', '数据', '内存']"
565,565,stbi__get16be,int,int stbi__get16be(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",以大端序读取并组合两个字节为16位整数,"static int stbi__get16be(stbi__context *s)
{
   int z = stbi__get8(s);
   return (z << 8) + stbi__get8(s);
}","{'begin': {'line': 1694, 'column': 1}, 'end': {'line': 1698, 'column': 2}}",show_image.c,"['大端', '以大端序', '读取', '并', '组合', '两个', '字节', '为', '16', '位', '整数']"
566,566,stbi__get32be,stbi__uint32,stbi__uint32 stbi__get32be(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",从大端字节流读取32位整数,"static stbi__uint32 stbi__get32be(stbi__context *s)
{
   stbi__uint32 z = stbi__get16be(s);
   return (z << 16) + stbi__get16be(s);
}","{'begin': {'line': 1704, 'column': 1}, 'end': {'line': 1708, 'column': 2}}",show_image.c,"['大端', '从大端', '字节', '流', '读取', '32', '位', '整数']"
567,567,stbi__get16le,int,int stbi__get16le(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",以小端序从上下文读取16位整数,"static int stbi__get16le(stbi__context *s)
{
   int z = stbi__get8(s);
   return z + (stbi__get8(s) << 8);
}","{'begin': {'line': 1714, 'column': 1}, 'end': {'line': 1718, 'column': 2}}",show_image.c,"['以小端序', '从', '上下', '下文', '上下文', '读取', '16', '位', '整数']"
568,568,stbi__get32le,stbi__uint32,stbi__uint32 stbi__get32le(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",以小端格式读取32位整数,"static stbi__uint32 stbi__get32le(stbi__context *s)
{
   stbi__uint32 z = stbi__get16le(s);
   z += (stbi__uint32)stbi__get16le(s) << 16;
   return z;
}","{'begin': {'line': 1722, 'column': 1}, 'end': {'line': 1727, 'column': 2}}",show_image.c,"['以小端', '格式', '读取', '32', '位', '整数']"
569,569,stbi__compute_y,stbi_uc,"stbi_uc stbi__compute_y(int r, int g, int b)","[{'name': 'r', 'type': 'int'}, {'name': 'g', 'type': 'int'}, {'name': 'b', 'type': 'int'}]",计算RGB的亮度(Y)值，使用整数运算优化,"static stbi_uc stbi__compute_y(int r, int g, int b)
{
   return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);
}","{'begin': {'line': 1746, 'column': 1}, 'end': {'line': 1749, 'column': 2}}",show_image.c,"['计算', 'RGB', '的', '亮度', '(', 'Y', ')', '值', '，', '使用', '整数', '运算', '优化']"
570,570,stbi__convert_format,unsigned char *,"unsigned char * stbi__convert_format(unsigned char * data, int img_n, int req_comp, unsigned int x, unsigned int y)","[{'name': 'data', 'type': 'unsigned char *'}, {'name': 'img_n', 'type': 'int'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'x', 'type': 'unsigned int'}, {'name': 'y', 'type': 'unsigned int'}]",转换图像数据格式，支持不同通道数互转,"static unsigned char *stbi__convert_format(unsigned char *data, int img_n, int req_comp, unsigned int x, unsigned int y)
{
   int i,j;
   unsigned char *good;

   if (req_comp == img_n) return data;
   STBI_ASSERT(req_comp >= 1 && req_comp <= 4);

   good = (unsigned char *) stbi__malloc_mad3(req_comp, x, y, 0);
   if (good == NULL) {
      STBI_FREE(data);
      return stbi__errpuc(""outofmem"", ""Out of memory"");
   }

   for (j=0; j < (int) y; ++j) {
      unsigned char *src  = data + j * x * img_n   ;
      unsigned char *dest = good + j * x * req_comp;

      #define STBI__COMBO(a,b)  ((a)*8+(b))
      #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
      // convert source image with img_n components to one with req_comp components;
      // avoid switch per pixel, so use switch per scanline and massive macros
      switch (STBI__COMBO(img_n, req_comp)) {
         STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=255;                                     } break;
         STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
         STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=255;                     } break;
         STBI__CASE(2,1) { dest[0]=src[0];                                                  } break;
         STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
         STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                  } break;
         STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=255;        } break;
         STBI__CASE(3,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
         STBI__CASE(3,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = 255;    } break;
         STBI__CASE(4,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
         STBI__CASE(4,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = src[3]; } break;
         STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                    } break;
         default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return stbi__errpuc(""unsupported"", ""Unsupported format conversion"");
      }
      #undef STBI__CASE
   }

   STBI_FREE(data);
   return good;
}","{'begin': {'line': 1755, 'column': 1}, 'end': {'line': 1797, 'column': 2}}",show_image.c,"['转换', '图像', '数据', '格式', '数据格式', '，', '支持', '不同', '通道', '数', '互转']"
571,571,stbi__build_huffman,int,"int stbi__build_huffman(stbi__huffman * h, int * count)","[{'name': 'h', 'type': 'stbi__huffman *'}, {'name': 'count', 'type': 'int *'}]",构建哈夫曼表，用于JPEG解码加速,"static int stbi__build_huffman(stbi__huffman *h, int *count)
{
   int i,j,k=0;
   unsigned int code;
   // build size list for each symbol (from JPEG spec)
   for (i=0; i < 16; ++i) {
      for (j=0; j < count[i]; ++j) {
         h->size[k++] = (stbi_uc) (i+1);
         if(k >= 257) return stbi__err(""bad size list"",""Corrupt JPEG"");
      }
   }
   h->size[k] = 0;

   // compute actual symbols (from jpeg spec)
   code = 0;
   k = 0;
   for(j=1; j <= 16; ++j) {
      // compute delta to add to code to compute symbol id
      h->delta[j] = k - code;
      if (h->size[k] == j) {
         while (h->size[k] == j)
            h->code[k++] = (stbi__uint16) (code++);
         if (code-1 >= (1u << j)) return stbi__err(""bad code lengths"",""Corrupt JPEG"");
      }
      // compute largest code + 1 for this size, preshifted as needed later
      h->maxcode[j] = code << (16-j);
      code <<= 1;
   }
   h->maxcode[j] = 0xffffffff;

   // build non-spec acceleration table; 255 is flag for not-accelerated
   memset(h->fast, 255, 1 << FAST_BITS);
   for (i=0; i < k; ++i) {
      int s = h->size[i];
      if (s <= FAST_BITS) {
         int c = h->code[i] << (FAST_BITS-s);
         int m = 1 << (FAST_BITS-s);
         for (j=0; j < m; ++j) {
            h->fast[c+j] = (stbi_uc) i;
         }
      }
   }
   return 1;
}","{'begin': {'line': 2003, 'column': 1}, 'end': {'line': 2046, 'column': 2}}",show_image.c,"['构建', '夫曼', '哈夫曼', '表', '，', '用于', 'JPEG', '解码', '加速']"
572,572,stbi__build_fast_ac,void,"void stbi__build_fast_ac(stbi__int16 * fast_ac, stbi__huffman * h)","[{'name': 'fast_ac', 'type': 'stbi__int16 *'}, {'name': 'h', 'type': 'stbi__huffman *'}]",生成快速AC霍夫曼解码表,"static void stbi__build_fast_ac(stbi__int16 *fast_ac, stbi__huffman *h)
{
   int i;
   for (i=0; i < (1 << FAST_BITS); ++i) {
      stbi_uc fast = h->fast[i];
      fast_ac[i] = 0;
      if (fast < 255) {
         int rs = h->values[fast];
         int run = (rs >> 4) & 15;
         int magbits = rs & 15;
         int len = h->size[fast];

         if (magbits && len + magbits <= FAST_BITS) {
            // magnitude code followed by receive_extend code
            int k = ((i << len) & ((1 << FAST_BITS) - 1)) >> (FAST_BITS - magbits);
            int m = 1 << (magbits - 1);
            if (k < m) k += (~0U << magbits) + 1;
            // if the result is small enough, we can fit it in fast_ac table
            if (k >= -128 && k <= 127)
               fast_ac[i] = (stbi__int16) ((k * 256) + (run * 16) + (len + magbits));
         }
      }
   }
}","{'begin': {'line': 2050, 'column': 1}, 'end': {'line': 2073, 'column': 2}}",show_image.c,"['生成', '快速', 'AC', '夫曼', '霍夫曼', '解码', '表']"
573,573,stbi__grow_buffer_unsafe,void,void stbi__grow_buffer_unsafe(stbi__jpeg * j),"[{'name': 'j', 'type': 'stbi__jpeg *'}]",扩展JPEG解码缓冲区并处理标记字节,"static void stbi__grow_buffer_unsafe(stbi__jpeg *j)
{
   do {
      unsigned int b = j->nomore ? 0 : stbi__get8(j->s);
      if (b == 0xff) {
         int c = stbi__get8(j->s);
         while (c == 0xff) c = stbi__get8(j->s); // consume fill bytes
         if (c != 0) {
            j->marker = (unsigned char) c;
            j->nomore = 1;
            return;
         }
      }
      j->code_buffer |= b << (24 - j->code_bits);
      j->code_bits += 8;
   } while (j->code_bits <= 24);
}","{'begin': {'line': 2075, 'column': 1}, 'end': {'line': 2091, 'column': 2}}",show_image.c,"['扩展', 'JPEG', '解码', '缓冲', '缓冲区', '并', '处理', '标记', '字节']"
574,574,stbi__jpeg_huff_decode,int,"int stbi__jpeg_huff_decode(stbi__jpeg * j, stbi__huffman * h)","[{'name': 'j', 'type': 'stbi__jpeg *'}, {'name': 'h', 'type': 'stbi__huffman *'}]",JPEG霍夫曼解码，返回解码值或错误,"static int stbi__jpeg_huff_decode(stbi__jpeg *j, stbi__huffman *h)
{
   unsigned int temp;
   int c,k;

   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

   // look at the top FAST_BITS and determine what symbol ID it is,
   // if the code is <= FAST_BITS
   c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
   k = h->fast[c];
   if (k < 255) {
      int s = h->size[k];
      if (s > j->code_bits)
         return -1;
      j->code_buffer <<= s;
      j->code_bits -= s;
      return h->values[k];
   }

   // naive test is to shift the code_buffer down so k bits are
   // valid, then test against maxcode. To speed this up, we've
   // preshifted maxcode left so that it has (16-k) 0s at the
   // end; in other words, regardless of the number of bits, it
   // wants to be compared against something shifted to have 16;
   // that way we don't need to shift inside the loop.
   temp = j->code_buffer >> 16;
   for (k=FAST_BITS+1 ; ; ++k)
      if (temp < h->maxcode[k])
         break;
   if (k == 17) {
      // error! code not found
      j->code_bits -= 16;
      return -1;
   }

   if (k > j->code_bits)
      return -1;

   // convert the huffman code to the symbol id
   c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];
   if(c < 0 || c >= 256) // symbol id out of bounds!
       return -1;
   STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);

   // convert the id to a symbol
   j->code_bits -= k;
   j->code_buffer <<= k;
   return h->values[c];
}","{'begin': {'line': 2097, 'column': 13}, 'end': {'line': 2146, 'column': 2}}",show_image.c,"['JPEG', '夫曼', '霍夫曼', '解码', '，', '返回', '解码', '值', '或', '错误']"
575,575,stbi__compute_y_16,stbi__uint16,"stbi__uint16 stbi__compute_y_16(int r, int g, int b)","[{'name': 'r', 'type': 'int'}, {'name': 'g', 'type': 'int'}, {'name': 'b', 'type': 'int'}]",将RGB值转换为16位亮度值,"static stbi__uint16 stbi__compute_y_16(int r, int g, int b)
{
   return (stbi__uint16) (((r*77) + (g*150) +  (29*b)) >> 8);
}","{'begin': {'line': 1803, 'column': 1}, 'end': {'line': 1806, 'column': 2}}",show_image.c,"['将', 'RGB', '值', '转换', '为', '16', '位', '亮度', '值']"
576,576,stbi__convert_format16,stbi__uint16 *,"stbi__uint16 * stbi__convert_format16(stbi__uint16 * data, int img_n, int req_comp, unsigned int x, unsigned int y)","[{'name': 'data', 'type': 'stbi__uint16 *'}, {'name': 'img_n', 'type': 'int'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'x', 'type': 'unsigned int'}, {'name': 'y', 'type': 'unsigned int'}]",转换16位图像数据的通道格式,"static stbi__uint16 *stbi__convert_format16(stbi__uint16 *data, int img_n, int req_comp, unsigned int x, unsigned int y)
{
   int i,j;
   stbi__uint16 *good;

   if (req_comp == img_n) return data;
   STBI_ASSERT(req_comp >= 1 && req_comp <= 4);

   good = (stbi__uint16 *) stbi__malloc(req_comp * x * y * 2);
   if (good == NULL) {
      STBI_FREE(data);
      return (stbi__uint16 *) stbi__errpuc(""outofmem"", ""Out of memory"");
   }

   for (j=0; j < (int) y; ++j) {
      stbi__uint16 *src  = data + j * x * img_n   ;
      stbi__uint16 *dest = good + j * x * req_comp;

      #define STBI__COMBO(a,b)  ((a)*8+(b))
      #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
      // convert source image with img_n components to one with req_comp components;
      // avoid switch per pixel, so use switch per scanline and massive macros
      switch (STBI__COMBO(img_n, req_comp)) {
         STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=0xffff;                                     } break;
         STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
         STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=0xffff;                     } break;
         STBI__CASE(2,1) { dest[0]=src[0];                                                     } break;
         STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
         STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                     } break;
         STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=0xffff;        } break;
         STBI__CASE(3,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
         STBI__CASE(3,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = 0xffff; } break;
         STBI__CASE(4,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
         STBI__CASE(4,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = src[3]; } break;
         STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                       } break;
         default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return (stbi__uint16*) stbi__errpuc(""unsupported"", ""Unsupported format conversion"");
      }
      #undef STBI__CASE
   }

   STBI_FREE(data);
   return good;
}","{'begin': {'line': 1812, 'column': 1}, 'end': {'line': 1854, 'column': 2}}",show_image.c,"['转换', '16', '位', '图像', '数据', '的', '通道', '格式']"
577,577,stbi__extend_receive,int,"int stbi__extend_receive(stbi__jpeg * j, int n)","[{'name': 'j', 'type': 'stbi__jpeg *'}, {'name': 'n', 'type': 'int'}]",接收并扩展JPEG解码器的n位数据，处理符号扩展,"static int stbi__extend_receive(stbi__jpeg *j, int n)
{
   unsigned int k;
   int sgn;
   if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
   if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing

   sgn = j->code_buffer >> 31; // sign bit always in MSB; 0 if MSB clear (positive), 1 if MSB set (negative)
   k = stbi_lrot(j->code_buffer, n);
   j->code_buffer = k & ~stbi__bmask[n];
   k &= stbi__bmask[n];
   j->code_bits -= n;
   return k + (stbi__jbias[n] & (sgn - 1));
}","{'begin': {'line': 2153, 'column': 13}, 'end': {'line': 2166, 'column': 2}}",show_image.c,"['接收', '并', '扩展', 'JPEG', '解码', '码器', '解码器', '的', 'n', '位', '数据', '，', '处理', '符号', '扩展']"
578,578,stbi__jpeg_get_bits,int,"int stbi__jpeg_get_bits(stbi__jpeg * j, int n)","[{'name': 'j', 'type': 'stbi__jpeg *'}, {'name': 'n', 'type': 'int'}]",从JPEG比特流中提取指定位数,"static int stbi__jpeg_get_bits(stbi__jpeg *j, int n)
{
   unsigned int k;
   if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
   if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing
   k = stbi_lrot(j->code_buffer, n);
   j->code_buffer = k & ~stbi__bmask[n];
   k &= stbi__bmask[n];
   j->code_bits -= n;
   return k;
}","{'begin': {'line': 2169, 'column': 13}, 'end': {'line': 2179, 'column': 2}}",show_image.c,"['从', 'JPEG', '比特', '比特流', '中', '提取', '指定', '位数']"
579,579,stbi__jpeg_get_bit,int,int stbi__jpeg_get_bit(stbi__jpeg * j),"[{'name': 'j', 'type': 'stbi__jpeg *'}]",从JPEG数据流中读取一个比特位,"static int stbi__jpeg_get_bit(stbi__jpeg *j)
{
   unsigned int k;
   if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);
   if (j->code_bits < 1) return 0; // ran out of bits from stream, return 0s intead of continuing
   k = j->code_buffer;
   j->code_buffer <<= 1;
   --j->code_bits;
   return k & 0x80000000;
}","{'begin': {'line': 2181, 'column': 13}, 'end': {'line': 2190, 'column': 2}}",show_image.c,"['从', 'JPEG', '数据', '数据流', '中', '读取', '一个', '比特', '位']"
580,580,stbi__jpeg_decode_block,int,"int stbi__jpeg_decode_block(stbi__jpeg * j, short[64] data, stbi__huffman * hdc, stbi__huffman * hac, stbi__int16 * fac, int b, stbi__uint16 * dequant)","[{'name': 'j', 'type': 'stbi__jpeg *'}, {'name': 'data', 'type': 'short[64]'}, {'name': 'hdc', 'type': 'stbi__huffman *'}, {'name': 'hac', 'type': 'stbi__huffman *'}, {'name': 'fac', 'type': 'stbi__int16 *'}, {'name': 'b', 'type': 'int'}, {'name': 'dequant', 'type': 'stbi__uint16 *'}]",解码JPEG图像块数据，处理DC和AC系数，应用霍夫曼解码及反量化。,"static int stbi__jpeg_decode_block(stbi__jpeg *j, short data[64], stbi__huffman *hdc, stbi__huffman *hac, stbi__int16 *fac, int b, stbi__uint16 *dequant)
{
   int diff,dc,k;
   int t;

   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
   t = stbi__jpeg_huff_decode(j, hdc);
   if (t < 0 || t > 15) return stbi__err(""bad huffman code"",""Corrupt JPEG"");

   // 0 all the ac values now so we can do it 32-bits at a time
   memset(data,0,64*sizeof(data[0]));

   diff = t ? stbi__extend_receive(j, t) : 0;
   if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err(""bad delta"",""Corrupt JPEG"");
   dc = j->img_comp[b].dc_pred + diff;
   j->img_comp[b].dc_pred = dc;
   if (!stbi__mul2shorts_valid(dc, dequant[0])) return stbi__err(""can't merge dc and ac"", ""Corrupt JPEG"");
   data[0] = (short) (dc * dequant[0]);

   // decode AC components, see JPEG spec
   k = 1;
   do {
      unsigned int zig;
      int c,r,s;
      if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
      c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
      r = fac[c];
      if (r) { // fast-AC path
         k += (r >> 4) & 15; // run
         s = r & 15; // combined length
         if (s > j->code_bits) return stbi__err(""bad huffman code"", ""Combined length longer than code bits available"");
         j->code_buffer <<= s;
         j->code_bits -= s;
         // decode into unzigzag'd location
         zig = stbi__jpeg_dezigzag[k++];
         data[zig] = (short) ((r >> 8) * dequant[zig]);
      } else {
         int rs = stbi__jpeg_huff_decode(j, hac);
         if (rs < 0) return stbi__err(""bad huffman code"",""Corrupt JPEG"");
         s = rs & 15;
         r = rs >> 4;
         if (s == 0) {
            if (rs != 0xf0) break; // end block
            k += 16;
         } else {
            k += r;
            // decode into unzigzag'd location
            zig = stbi__jpeg_dezigzag[k++];
            data[zig] = (short) (stbi__extend_receive(j,s) * dequant[zig]);
         }
      }
   } while (k < 64);
   return 1;
}","{'begin': {'line': 2210, 'column': 1}, 'end': {'line': 2263, 'column': 2}}",show_image.c,"['解码', 'JPEG', '图像', '块', '数据', '，', '处理', 'DC', '和', 'AC', '系数', '，', '应用', '夫曼', '霍夫曼', '解码', '及', '反', '量化', '。']"
581,581,stbi__jpeg_decode_block_prog_dc,int,"int stbi__jpeg_decode_block_prog_dc(stbi__jpeg * j, short[64] data, stbi__huffman * hdc, int b)","[{'name': 'j', 'type': 'stbi__jpeg *'}, {'name': 'data', 'type': 'short[64]'}, {'name': 'hdc', 'type': 'stbi__huffman *'}, {'name': 'b', 'type': 'int'}]",解码渐进式JPEG的DC系数块，处理初始和细化扫描,"static int stbi__jpeg_decode_block_prog_dc(stbi__jpeg *j, short data[64], stbi__huffman *hdc, int b)
{
   int diff,dc;
   int t;
   if (j->spec_end != 0) return stbi__err(""can't merge dc and ac"", ""Corrupt JPEG"");

   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

   if (j->succ_high == 0) {
      // first scan for DC coefficient, must be first
      memset(data,0,64*sizeof(data[0])); // 0 all the ac values now
      t = stbi__jpeg_huff_decode(j, hdc);
      if (t < 0 || t > 15) return stbi__err(""can't merge dc and ac"", ""Corrupt JPEG"");
      diff = t ? stbi__extend_receive(j, t) : 0;

      if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err(""bad delta"", ""Corrupt JPEG"");
      dc = j->img_comp[b].dc_pred + diff;
      j->img_comp[b].dc_pred = dc;
      if (!stbi__mul2shorts_valid(dc, 1 << j->succ_low)) return stbi__err(""can't merge dc and ac"", ""Corrupt JPEG"");
      data[0] = (short) (dc * (1 << j->succ_low));
   } else {
      // refinement scan for DC coefficient
      if (stbi__jpeg_get_bit(j))
         data[0] += (short) (1 << j->succ_low);
   }
   return 1;
}","{'begin': {'line': 2265, 'column': 1}, 'end': {'line': 2291, 'column': 2}}",show_image.c,"['解码', '渐进', '渐进式', 'JPEG', '的', 'DC', '系数', '块', '，', '处理', '初始', '和', '细化', '扫描']"
582,582,stbi__ldr_to_hdr,float *,"float * stbi__ldr_to_hdr(stbi_uc * data, int x, int y, int comp)","[{'name': 'data', 'type': 'stbi_uc *'}, {'name': 'x', 'type': 'int'}, {'name': 'y', 'type': 'int'}, {'name': 'comp', 'type': 'int'}]",将8位LDR图像转换为浮点HDR，处理Gamma和Alpha。,"static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp)
{
   int i,k,n;
   float *output;
   if (!data) return NULL;
   output = (float *) stbi__malloc_mad4(x, y, comp, sizeof(float), 0);
   if (output == NULL) { STBI_FREE(data); return stbi__errpf(""outofmem"", ""Out of memory""); }
   // compute number of non-alpha components
   if (comp & 1) n = comp; else n = comp-1;
   for (i=0; i < x*y; ++i) {
      for (k=0; k < n; ++k) {
         output[i*comp + k] = (float) (pow(data[i*comp+k]/255.0f, stbi__l2h_gamma) * stbi__l2h_scale);
      }
   }
   if (n < comp) {
      for (i=0; i < x*y; ++i) {
         output[i*comp + n] = data[i*comp + n]/255.0f;
      }
   }
   STBI_FREE(data);
   return output;
}","{'begin': {'line': 1858, 'column': 1}, 'end': {'line': 1879, 'column': 2}}",show_image.c,"['将', '8', '位', 'LDR', '图像', '转换', '为', '浮点', 'HDR', '，', '处理', 'Gamma', '和', 'Alpha', '。']"
583,583,stbi__jpeg_decode_block_prog_ac,int,"int stbi__jpeg_decode_block_prog_ac(stbi__jpeg * j, short[64] data, stbi__huffman * hac, stbi__int16 * fac)","[{'name': 'j', 'type': 'stbi__jpeg *'}, {'name': 'data', 'type': 'short[64]'}, {'name': 'hac', 'type': 'stbi__huffman *'}, {'name': 'fac', 'type': 'stbi__int16 *'}]",解码渐进式JPEG的AC系数块数据,"static int stbi__jpeg_decode_block_prog_ac(stbi__jpeg *j, short data[64], stbi__huffman *hac, stbi__int16 *fac)
{
   int k;
   if (j->spec_start == 0) return stbi__err(""can't merge dc and ac"", ""Corrupt JPEG"");

   if (j->succ_high == 0) {
      int shift = j->succ_low;

      if (j->eob_run) {
         --j->eob_run;
         return 1;
      }

      k = j->spec_start;
      do {
         unsigned int zig;
         int c,r,s;
         if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
         c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
         r = fac[c];
         if (r) { // fast-AC path
            k += (r >> 4) & 15; // run
            s = r & 15; // combined length
            if (s > j->code_bits) return stbi__err(""bad huffman code"", ""Combined length longer than code bits available"");
            j->code_buffer <<= s;
            j->code_bits -= s;
            zig = stbi__jpeg_dezigzag[k++];
            data[zig] = (short) ((r >> 8) * (1 << shift));
         } else {
            int rs = stbi__jpeg_huff_decode(j, hac);
            if (rs < 0) return stbi__err(""bad huffman code"",""Corrupt JPEG"");
            s = rs & 15;
            r = rs >> 4;
            if (s == 0) {
               if (r < 15) {
                  j->eob_run = (1 << r);
                  if (r)
                     j->eob_run += stbi__jpeg_get_bits(j, r);
                  --j->eob_run;
                  break;
               }
               k += 16;
            } else {
               k += r;
               zig = stbi__jpeg_dezigzag[k++];
               data[zig] = (short) (stbi__extend_receive(j,s) * (1 << shift));
            }
         }
      } while (k <= j->spec_end);
   } else {
      // refinement scan for these AC coefficients

      short bit = (short) (1 << j->succ_low);

      if (j->eob_run) {
         --j->eob_run;
         for (k = j->spec_start; k <= j->spec_end; ++k) {
            short *p = &data[stbi__jpeg_dezigzag[k]];
            if (*p != 0)
               if (stbi__jpeg_get_bit(j))
                  if ((*p & bit)==0) {
                     if (*p > 0)
                        *p += bit;
                     else
                        *p -= bit;
                  }
         }
      } else {
         k = j->spec_start;
         do {
            int r,s;
            int rs = stbi__jpeg_huff_decode(j, hac); // @OPTIMIZE see if we can use the fast path here, advance-by-r is so slow, eh
            if (rs < 0) return stbi__err(""bad huffman code"",""Corrupt JPEG"");
            s = rs & 15;
            r = rs >> 4;
            if (s == 0) {
               if (r < 15) {
                  j->eob_run = (1 << r) - 1;
                  if (r)
                     j->eob_run += stbi__jpeg_get_bits(j, r);
                  r = 64; // force end of block
               } else {
                  // r=15 s=0 should write 16 0s, so we just do
                  // a run of 15 0s and then write s (which is 0),
                  // so we don't have to do anything special here
               }
            } else {
               if (s != 1) return stbi__err(""bad huffman code"", ""Corrupt JPEG"");
               // sign bit
               if (stbi__jpeg_get_bit(j))
                  s = bit;
               else
                  s = -bit;
            }

            // advance by r
            while (k <= j->spec_end) {
               short *p = &data[stbi__jpeg_dezigzag[k++]];
               if (*p != 0) {
                  if (stbi__jpeg_get_bit(j))
                     if ((*p & bit)==0) {
                        if (*p > 0)
                           *p += bit;
                        else
                           *p -= bit;
                     }
               } else {
                  if (r == 0) {
                     *p = (short) s;
                     break;
                  }
                  --r;
               }
            }
         } while (k <= j->spec_end);
      }
   }
   return 1;
}","{'begin': {'line': 2295, 'column': 1}, 'end': {'line': 2413, 'column': 2}}",show_image.c,"['解码', '渐进', '渐进式', 'JPEG', '的', 'AC', '系数', '块', '数据']"
584,584,stbi__hdr_to_ldr,stbi_uc *,"stbi_uc * stbi__hdr_to_ldr(float * data, int x, int y, int comp)","[{'name': 'data', 'type': 'float *'}, {'name': 'x', 'type': 'int'}, {'name': 'y', 'type': 'int'}, {'name': 'comp', 'type': 'int'}]",将HDR数据转换为LDR格式，应用伽马校正并量化,"static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp)
{
   int i,k,n;
   stbi_uc *output;
   if (!data) return NULL;
   output = (stbi_uc *) stbi__malloc_mad3(x, y, comp, 0);
   if (output == NULL) { STBI_FREE(data); return stbi__errpuc(""outofmem"", ""Out of memory""); }
   // compute number of non-alpha components
   if (comp & 1) n = comp; else n = comp-1;
   for (i=0; i < x*y; ++i) {
      for (k=0; k < n; ++k) {
         float z = (float) pow(data[i*comp+k]*stbi__h2l_scale_i, stbi__h2l_gamma_i) * 255 + 0.5f;
         if (z < 0) z = 0;
         if (z > 255) z = 255;
         output[i*comp + k] = (stbi_uc) stbi__float2int(z);
      }
      if (k < comp) {
         float z = data[i*comp+k] * 255 + 0.5f;
         if (z < 0) z = 0;
         if (z > 255) z = 255;
         output[i*comp + k] = (stbi_uc) stbi__float2int(z);
      }
   }
   STBI_FREE(data);
   return output;
}","{'begin': {'line': 1884, 'column': 1}, 'end': {'line': 1909, 'column': 2}}",show_image.c,"['将', 'HDR', '数据', '转换', '为', 'LDR', '格式', '，', '应用', '伽马', '校正', '并', '量化']"
585,585,stbi__build_huffman,int,"int stbi__build_huffman(stbi__huffman * h, int * count)","[{'name': 'h', 'type': 'stbi__huffman *'}, {'name': 'count', 'type': 'int *'}]",构建哈夫曼表用于JPEG解码,"static int stbi__build_huffman(stbi__huffman *h, int *count)
{
   int i,j,k=0;
   unsigned int code;
   // build size list for each symbol (from JPEG spec)
   for (i=0; i < 16; ++i) {
      for (j=0; j < count[i]; ++j) {
         h->size[k++] = (stbi_uc) (i+1);
         if(k >= 257) return stbi__err(""bad size list"",""Corrupt JPEG"");
      }
   }
   h->size[k] = 0;

   // compute actual symbols (from jpeg spec)
   code = 0;
   k = 0;
   for(j=1; j <= 16; ++j) {
      // compute delta to add to code to compute symbol id
      h->delta[j] = k - code;
      if (h->size[k] == j) {
         while (h->size[k] == j)
            h->code[k++] = (stbi__uint16) (code++);
         if (code-1 >= (1u << j)) return stbi__err(""bad code lengths"",""Corrupt JPEG"");
      }
      // compute largest code + 1 for this size, preshifted as needed later
      h->maxcode[j] = code << (16-j);
      code <<= 1;
   }
   h->maxcode[j] = 0xffffffff;

   // build non-spec acceleration table; 255 is flag for not-accelerated
   memset(h->fast, 255, 1 << FAST_BITS);
   for (i=0; i < k; ++i) {
      int s = h->size[i];
      if (s <= FAST_BITS) {
         int c = h->code[i] << (FAST_BITS-s);
         int m = 1 << (FAST_BITS-s);
         for (j=0; j < m; ++j) {
            h->fast[c+j] = (stbi_uc) i;
         }
      }
   }
   return 1;
}","{'begin': {'line': 2003, 'column': 1}, 'end': {'line': 2046, 'column': 2}}",show_image.c,"['构建', '夫曼', '哈夫曼', '表', '用于', 'JPEG', '解码']"
586,586,stbi__clamp,stbi_uc,stbi_uc stbi__clamp(int x),"[{'name': 'x', 'type': 'int'}]",将输入值钳制在0-255范围内并返回无符号字符,"static stbi_uc stbi__clamp(int x)
{
   // trick to use a single test to catch both cases
   if ((unsigned int) x > 255) {
      if (x < 0) return 0;
      if (x > 255) return 255;
   }
   return (stbi_uc) x;
}","{'begin': {'line': 2416, 'column': 13}, 'end': {'line': 2424, 'column': 2}}",show_image.c,"['将', '输入', '值', '钳制', '在', '0', '-', '255', '范围', '内', '并', '返回', '无', '符号', '字符']"
587,587,stbi__idct_block,void,"void stbi__idct_block(stbi_uc * out, int out_stride, short[64] data)","[{'name': 'out', 'type': 'stbi_uc *'}, {'name': 'out_stride', 'type': 'int'}, {'name': 'data', 'type': 'short[64]'}]",执行8x8块的逆离散余弦变换，用于JPEG解码,"static void stbi__idct_block(stbi_uc *out, int out_stride, short data[64])
{
   int i,val[64],*v=val;
   stbi_uc *o;
   short *d = data;

   // columns
   for (i=0; i < 8; ++i,++d, ++v) {
      // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing
      if (d[ 8]==0 && d[16]==0 && d[24]==0 && d[32]==0
           && d[40]==0 && d[48]==0 && d[56]==0) {
         //    no shortcut                 0     seconds
         //    (1|2|3|4|5|6|7)==0          0     seconds
         //    all separate               -0.047 seconds
         //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds
         int dcterm = d[0]*4;
         v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;
      } else {
         STBI__IDCT_1D(d[ 0],d[ 8],d[16],d[24],d[32],d[40],d[48],d[56])
         // constants scaled things up by 1<<12; let's bring them back
         // down, but keep 2 extra bits of precision
         x0 += 512; x1 += 512; x2 += 512; x3 += 512;
         v[ 0] = (x0+t3) >> 10;
         v[56] = (x0-t3) >> 10;
         v[ 8] = (x1+t2) >> 10;
         v[48] = (x1-t2) >> 10;
         v[16] = (x2+t1) >> 10;
         v[40] = (x2-t1) >> 10;
         v[24] = (x3+t0) >> 10;
         v[32] = (x3-t0) >> 10;
      }
   }

   for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {
      // no fast case since the first 1D IDCT spread components out
      STBI__IDCT_1D(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7])
      // constants scaled things up by 1<<12, plus we had 1<<2 from first
      // loop, plus horizontal and vertical each scale by sqrt(8) so together
      // we've got an extra 1<<3, so 1<<17 total we need to remove.
      // so we want to round that, which means adding 0.5 * 1<<17,
      // aka 65536. Also, we'll end up with -128 to 127 that we want
      // to encode as 0..255 by adding 128, so we'll add that before the shift
      x0 += 65536 + (128<<17);
      x1 += 65536 + (128<<17);
      x2 += 65536 + (128<<17);
      x3 += 65536 + (128<<17);
      // tried computing the shifts into temps, or'ing the temps to see
      // if any were out of range, but that was slower
      o[0] = stbi__clamp((x0+t3) >> 17);
      o[7] = stbi__clamp((x0-t3) >> 17);
      o[1] = stbi__clamp((x1+t2) >> 17);
      o[6] = stbi__clamp((x1-t2) >> 17);
      o[2] = stbi__clamp((x2+t1) >> 17);
      o[5] = stbi__clamp((x2-t1) >> 17);
      o[3] = stbi__clamp((x3+t0) >> 17);
      o[4] = stbi__clamp((x3-t0) >> 17);
   }
}","{'begin': {'line': 2467, 'column': 1}, 'end': {'line': 2524, 'column': 2}}",show_image.c,"['执行', '8x8', '块', '的', '逆', '离散', '余弦', '变换', '，', '用于', 'JPEG', '解码']"
588,588,stbi__build_fast_ac,void,"void stbi__build_fast_ac(stbi__int16 * fast_ac, stbi__huffman * h)","[{'name': 'fast_ac', 'type': 'stbi__int16 *'}, {'name': 'h', 'type': 'stbi__huffman *'}]",构建快速AC霍夫曼解码表,"static void stbi__build_fast_ac(stbi__int16 *fast_ac, stbi__huffman *h)
{
   int i;
   for (i=0; i < (1 << FAST_BITS); ++i) {
      stbi_uc fast = h->fast[i];
      fast_ac[i] = 0;
      if (fast < 255) {
         int rs = h->values[fast];
         int run = (rs >> 4) & 15;
         int magbits = rs & 15;
         int len = h->size[fast];

         if (magbits && len + magbits <= FAST_BITS) {
            // magnitude code followed by receive_extend code
            int k = ((i << len) & ((1 << FAST_BITS) - 1)) >> (FAST_BITS - magbits);
            int m = 1 << (magbits - 1);
            if (k < m) k += (~0U << magbits) + 1;
            // if the result is small enough, we can fit it in fast_ac table
            if (k >= -128 && k <= 127)
               fast_ac[i] = (stbi__int16) ((k * 256) + (run * 16) + (len + magbits));
         }
      }
   }
}","{'begin': {'line': 2050, 'column': 1}, 'end': {'line': 2073, 'column': 2}}",show_image.c,"['构建', '快速', 'AC', '夫曼', '霍夫曼', '解码', '表']"
589,589,stbi__grow_buffer_unsafe,void,void stbi__grow_buffer_unsafe(stbi__jpeg * j),"[{'name': 'j', 'type': 'stbi__jpeg *'}]",扩展JPEG解码缓冲区并处理填充字节,"static void stbi__grow_buffer_unsafe(stbi__jpeg *j)
{
   do {
      unsigned int b = j->nomore ? 0 : stbi__get8(j->s);
      if (b == 0xff) {
         int c = stbi__get8(j->s);
         while (c == 0xff) c = stbi__get8(j->s); // consume fill bytes
         if (c != 0) {
            j->marker = (unsigned char) c;
            j->nomore = 1;
            return;
         }
      }
      j->code_buffer |= b << (24 - j->code_bits);
      j->code_bits += 8;
   } while (j->code_bits <= 24);
}","{'begin': {'line': 2075, 'column': 1}, 'end': {'line': 2091, 'column': 2}}",show_image.c,"['扩展', 'JPEG', '解码', '缓冲', '缓冲区', '并', '处理', '填充', '字节']"
590,590,stbi__jpeg_huff_decode,int,"int stbi__jpeg_huff_decode(stbi__jpeg * j, stbi__huffman * h)","[{'name': 'j', 'type': 'stbi__jpeg *'}, {'name': 'h', 'type': 'stbi__huffman *'}]",JPEG霍夫曼解码，通过快速表查找符号,"static int stbi__jpeg_huff_decode(stbi__jpeg *j, stbi__huffman *h)
{
   unsigned int temp;
   int c,k;

   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

   // look at the top FAST_BITS and determine what symbol ID it is,
   // if the code is <= FAST_BITS
   c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
   k = h->fast[c];
   if (k < 255) {
      int s = h->size[k];
      if (s > j->code_bits)
         return -1;
      j->code_buffer <<= s;
      j->code_bits -= s;
      return h->values[k];
   }

   // naive test is to shift the code_buffer down so k bits are
   // valid, then test against maxcode. To speed this up, we've
   // preshifted maxcode left so that it has (16-k) 0s at the
   // end; in other words, regardless of the number of bits, it
   // wants to be compared against something shifted to have 16;
   // that way we don't need to shift inside the loop.
   temp = j->code_buffer >> 16;
   for (k=FAST_BITS+1 ; ; ++k)
      if (temp < h->maxcode[k])
         break;
   if (k == 17) {
      // error! code not found
      j->code_bits -= 16;
      return -1;
   }

   if (k > j->code_bits)
      return -1;

   // convert the huffman code to the symbol id
   c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];
   if(c < 0 || c >= 256) // symbol id out of bounds!
       return -1;
   STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);

   // convert the id to a symbol
   j->code_bits -= k;
   j->code_buffer <<= k;
   return h->values[c];
}","{'begin': {'line': 2097, 'column': 13}, 'end': {'line': 2146, 'column': 2}}",show_image.c,"['JPEG', '夫曼', '霍夫曼', '解码', '，', '通过', '快速', '表', '查找', '符号']"
591,591,stbi__extend_receive,int,"int stbi__extend_receive(stbi__jpeg * j, int n)","[{'name': 'j', 'type': 'stbi__jpeg *'}, {'name': 'n', 'type': 'int'}]",从JPEG比特流接收并扩展n位有符号数,"static int stbi__extend_receive(stbi__jpeg *j, int n)
{
   unsigned int k;
   int sgn;
   if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
   if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing

   sgn = j->code_buffer >> 31; // sign bit always in MSB; 0 if MSB clear (positive), 1 if MSB set (negative)
   k = stbi_lrot(j->code_buffer, n);
   j->code_buffer = k & ~stbi__bmask[n];
   k &= stbi__bmask[n];
   j->code_bits -= n;
   return k + (stbi__jbias[n] & (sgn - 1));
}","{'begin': {'line': 2153, 'column': 13}, 'end': {'line': 2166, 'column': 2}}",show_image.c,"['从', 'JPEG', '比特', '比特流', '接收', '并', '扩展', 'n', '位有', '符号', '数']"
592,592,stbi__jpeg_get_bits,int,"int stbi__jpeg_get_bits(stbi__jpeg * j, int n)","[{'name': 'j', 'type': 'stbi__jpeg *'}, {'name': 'n', 'type': 'int'}]",从JPEG流中提取指定位数的比特值,"static int stbi__jpeg_get_bits(stbi__jpeg *j, int n)
{
   unsigned int k;
   if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
   if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing
   k = stbi_lrot(j->code_buffer, n);
   j->code_buffer = k & ~stbi__bmask[n];
   k &= stbi__bmask[n];
   j->code_bits -= n;
   return k;
}","{'begin': {'line': 2169, 'column': 13}, 'end': {'line': 2179, 'column': 2}}",show_image.c,"['从', 'JPEG', '流中', '提取', '指定', '位数', '的', '比特', '值']"
593,593,stbi__jpeg_get_bit,int,int stbi__jpeg_get_bit(stbi__jpeg * j),"[{'name': 'j', 'type': 'stbi__jpeg *'}]",从JPEG比特流中读取一个比特,"static int stbi__jpeg_get_bit(stbi__jpeg *j)
{
   unsigned int k;
   if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);
   if (j->code_bits < 1) return 0; // ran out of bits from stream, return 0s intead of continuing
   k = j->code_buffer;
   j->code_buffer <<= 1;
   --j->code_bits;
   return k & 0x80000000;
}","{'begin': {'line': 2181, 'column': 13}, 'end': {'line': 2190, 'column': 2}}",show_image.c,"['从', 'JPEG', '比特', '比特流', '中', '读取', '一个', '比特']"
594,594,stbi__idct_simd,void,"void stbi__idct_simd(stbi_uc * out, int out_stride, short[64] data)","[{'name': 'out', 'type': 'stbi_uc *'}, {'name': 'out_stride', 'type': 'int'}, {'name': 'data', 'type': 'short[64]'}]",使用SIMD优化的整数IDCT实现，用于快速图像解码。,"static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
{
   // This is constructed to match our regular (generic) integer IDCT exactly.
   __m128i row0, row1, row2, row3, row4, row5, row6, row7;
   __m128i tmp;

   // dot product constant: even elems=x, odd elems=y
   #define dct_const(x,y)  _mm_setr_epi16((x),(y),(x),(y),(x),(y),(x),(y))

   // out(0) = c0[even]*x + c0[odd]*y   (c0, x, y 16-bit, out 32-bit)
   // out(1) = c1[even]*x + c1[odd]*y
   #define dct_rot(out0,out1, x,y,c0,c1) \
      __m128i c0##lo = _mm_unpacklo_epi16((x),(y)); \
      __m128i c0##hi = _mm_unpackhi_epi16((x),(y)); \
      __m128i out0##_l = _mm_madd_epi16(c0##lo, c0); \
      __m128i out0##_h = _mm_madd_epi16(c0##hi, c0); \
      __m128i out1##_l = _mm_madd_epi16(c0##lo, c1); \
      __m128i out1##_h = _mm_madd_epi16(c0##hi, c1)

   // out = in << 12  (in 16-bit, out 32-bit)
   #define dct_widen(out, in) \
      __m128i out##_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (in)), 4); \
      __m128i out##_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (in)), 4)

   // wide add
   #define dct_wadd(out, a, b) \
      __m128i out##_l = _mm_add_epi32(a##_l, b##_l); \
      __m128i out##_h = _mm_add_epi32(a##_h, b##_h)

   // wide sub
   #define dct_wsub(out, a, b) \
      __m128i out##_l = _mm_sub_epi32(a##_l, b##_l); \
      __m128i out##_h = _mm_sub_epi32(a##_h, b##_h)

   // butterfly a/b, add bias, then shift by ""s"" and pack
   #define dct_bfly32o(out0, out1, a,b,bias,s) \
      { \
         __m128i abiased_l = _mm_add_epi32(a##_l, bias); \
         __m128i abiased_h = _mm_add_epi32(a##_h, bias); \
         dct_wadd(sum, abiased, b); \
         dct_wsub(dif, abiased, b); \
         out0 = _mm_packs_epi32(_mm_srai_epi32(sum_l, s), _mm_srai_epi32(sum_h, s)); \
         out1 = _mm_packs_epi32(_mm_srai_epi32(dif_l, s), _mm_srai_epi32(dif_h, s)); \
      }

   // 8-bit interleave step (for transposes)
   #define dct_interleave8(a, b) \
      tmp = a; \
      a = _mm_unpacklo_epi8(a, b); \
      b = _mm_unpackhi_epi8(tmp, b)

   // 16-bit interleave step (for transposes)
   #define dct_interleave16(a, b) \
      tmp = a; \
      a = _mm_unpacklo_epi16(a, b); \
      b = _mm_unpackhi_epi16(tmp, b)

   #define dct_pass(bias,shift) \
      { \
         /* even part */ \
         dct_rot(t2e,t3e, row2,row6, rot0_0,rot0_1); \
         __m128i sum04 = _mm_add_epi16(row0, row4); \
         __m128i dif04 = _mm_sub_epi16(row0, row4); \
         dct_widen(t0e, sum04); \
         dct_widen(t1e, dif04); \
         dct_wadd(x0, t0e, t3e); \
         dct_wsub(x3, t0e, t3e); \
         dct_wadd(x1, t1e, t2e); \
         dct_wsub(x2, t1e, t2e); \
         /* odd part */ \
         dct_rot(y0o,y2o, row7,row3, rot2_0,rot2_1); \
         dct_rot(y1o,y3o, row5,row1, rot3_0,rot3_1); \
         __m128i sum17 = _mm_add_epi16(row1, row7); \
         __m128i sum35 = _mm_add_epi16(row3, row5); \
         dct_rot(y4o,y5o, sum17,sum35, rot1_0,rot1_1); \
         dct_wadd(x4, y0o, y4o); \
         dct_wadd(x5, y1o, y5o); \
         dct_wadd(x6, y2o, y5o); \
         dct_wadd(x7, y3o, y4o); \
         dct_bfly32o(row0,row7, x0,x7,bias,shift); \
         dct_bfly32o(row1,row6, x1,x6,bias,shift); \
         dct_bfly32o(row2,row5, x2,x5,bias,shift); \
         dct_bfly32o(row3,row4, x3,x4,bias,shift); \
      }

   __m128i rot0_0 = dct_const(stbi__f2f(0.5411961f), stbi__f2f(0.5411961f) + stbi__f2f(-1.847759065f));
   __m128i rot0_1 = dct_const(stbi__f2f(0.5411961f) + stbi__f2f( 0.765366865f), stbi__f2f(0.5411961f));
   __m128i rot1_0 = dct_const(stbi__f2f(1.175875602f) + stbi__f2f(-0.899976223f), stbi__f2f(1.175875602f));
   __m128i rot1_1 = dct_const(stbi__f2f(1.175875602f), stbi__f2f(1.175875602f) + stbi__f2f(-2.562915447f));
   __m128i rot2_0 = dct_const(stbi__f2f(-1.961570560f) + stbi__f2f( 0.298631336f), stbi__f2f(-1.961570560f));
   __m128i rot2_1 = dct_const(stbi__f2f(-1.961570560f), stbi__f2f(-1.961570560f) + stbi__f2f( 3.072711026f));
   __m128i rot3_0 = dct_const(stbi__f2f(-0.390180644f) + stbi__f2f( 2.053119869f), stbi__f2f(-0.390180644f));
   __m128i rot3_1 = dct_const(stbi__f2f(-0.390180644f), stbi__f2f(-0.390180644f) + stbi__f2f( 1.501321110f));

   // rounding biases in column/row passes, see stbi__idct_block for explanation.
   __m128i bias_0 = _mm_set1_epi32(512);
   __m128i bias_1 = _mm_set1_epi32(65536 + (128<<17));

   // load
   row0 = _mm_load_si128((const __m128i *) (data + 0*8));
   row1 = _mm_load_si128((const __m128i *) (data + 1*8));
   row2 = _mm_load_si128((const __m128i *) (data + 2*8));
   row3 = _mm_load_si128((const __m128i *) (data + 3*8));
   row4 = _mm_load_si128((const __m128i *) (data + 4*8));
   row5 = _mm_load_si128((const __m128i *) (data + 5*8));
   row6 = _mm_load_si128((const __m128i *) (data + 6*8));
   row7 = _mm_load_si128((const __m128i *) (data + 7*8));

   // column pass
   dct_pass(bias_0, 10);

   {
      // 16bit 8x8 transpose pass 1
      dct_interleave16(row0, row4);
      dct_interleave16(row1, row5);
      dct_interleave16(row2, row6);
      dct_interleave16(row3, row7);

      // transpose pass 2
      dct_interleave16(row0, row2);
      dct_interleave16(row1, row3);
      dct_interleave16(row4, row6);
      dct_interleave16(row5, row7);

      // transpose pass 3
      dct_interleave16(row0, row1);
      dct_interleave16(row2, row3);
      dct_interleave16(row4, row5);
      dct_interleave16(row6, row7);
   }

   // row pass
   dct_pass(bias_1, 17);

   {
      // pack
      __m128i p0 = _mm_packus_epi16(row0, row1); // a0a1a2a3...a7b0b1b2b3...b7
      __m128i p1 = _mm_packus_epi16(row2, row3);
      __m128i p2 = _mm_packus_epi16(row4, row5);
      __m128i p3 = _mm_packus_epi16(row6, row7);

      // 8bit 8x8 transpose pass 1
      dct_interleave8(p0, p2); // a0e0a1e1...
      dct_interleave8(p1, p3); // c0g0c1g1...

      // transpose pass 2
      dct_interleave8(p0, p1); // a0c0e0g0...
      dct_interleave8(p2, p3); // b0d0f0h0...

      // transpose pass 3
      dct_interleave8(p0, p2); // a0b0c0d0...
      dct_interleave8(p1, p3); // a4b4c4d4...

      // store
      _mm_storel_epi64((__m128i *) out, p0); out += out_stride;
      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p0, 0x4e)); out += out_stride;
      _mm_storel_epi64((__m128i *) out, p2); out += out_stride;
      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p2, 0x4e)); out += out_stride;
      _mm_storel_epi64((__m128i *) out, p1); out += out_stride;
      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p1, 0x4e)); out += out_stride;
      _mm_storel_epi64((__m128i *) out, p3); out += out_stride;
      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p3, 0x4e));
   }

#undef dct_const
#undef dct_rot
#undef dct_widen
#undef dct_wadd
#undef dct_wsub
#undef dct_bfly32o
#undef dct_interleave8
#undef dct_interleave16
#undef dct_pass
}","{'begin': {'line': 2530, 'column': 1}, 'end': {'line': 2703, 'column': 2}}",show_image.c,"['使用', 'SIMD', '优化', '的', '整数', 'IDCT', '实现', '，', '用于', '快速', '图像', '解码', '。']"
595,595,stbi__get_marker,stbi_uc,stbi_uc stbi__get_marker(stbi__jpeg * j),"[{'name': 'j', 'type': 'stbi__jpeg *'}]",获取JPEG标记，处理重复0xff填充字节,"static stbi_uc stbi__get_marker(stbi__jpeg *j)
{
   stbi_uc x;
   if (j->marker != STBI__MARKER_none) { x = j->marker; j->marker = STBI__MARKER_none; return x; }
   x = stbi__get8(j->s);
   if (x != 0xff) return STBI__MARKER_none;
   while (x == 0xff)
      x = stbi__get8(j->s); // consume repeated 0xff fill bytes
   return x;
}","{'begin': {'line': 2919, 'column': 1}, 'end': {'line': 2928, 'column': 2}}",show_image.c,"['获取', 'JPEG', '标记', '，', '处理', '重复', '0xff', '填充', '字节']"
596,596,stbi__jpeg_decode_block,int,"int stbi__jpeg_decode_block(stbi__jpeg * j, short[64] data, stbi__huffman * hdc, stbi__huffman * hac, stbi__int16 * fac, int b, stbi__uint16 * dequant)","[{'name': 'j', 'type': 'stbi__jpeg *'}, {'name': 'data', 'type': 'short[64]'}, {'name': 'hdc', 'type': 'stbi__huffman *'}, {'name': 'hac', 'type': 'stbi__huffman *'}, {'name': 'fac', 'type': 'stbi__int16 *'}, {'name': 'b', 'type': 'int'}, {'name': 'dequant', 'type': 'stbi__uint16 *'}]",解码JPEG单个数据块的DC和AC系数，应用量化和霍夫曼解码。,"static int stbi__jpeg_decode_block(stbi__jpeg *j, short data[64], stbi__huffman *hdc, stbi__huffman *hac, stbi__int16 *fac, int b, stbi__uint16 *dequant)
{
   int diff,dc,k;
   int t;

   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
   t = stbi__jpeg_huff_decode(j, hdc);
   if (t < 0 || t > 15) return stbi__err(""bad huffman code"",""Corrupt JPEG"");

   // 0 all the ac values now so we can do it 32-bits at a time
   memset(data,0,64*sizeof(data[0]));

   diff = t ? stbi__extend_receive(j, t) : 0;
   if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err(""bad delta"",""Corrupt JPEG"");
   dc = j->img_comp[b].dc_pred + diff;
   j->img_comp[b].dc_pred = dc;
   if (!stbi__mul2shorts_valid(dc, dequant[0])) return stbi__err(""can't merge dc and ac"", ""Corrupt JPEG"");
   data[0] = (short) (dc * dequant[0]);

   // decode AC components, see JPEG spec
   k = 1;
   do {
      unsigned int zig;
      int c,r,s;
      if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
      c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
      r = fac[c];
      if (r) { // fast-AC path
         k += (r >> 4) & 15; // run
         s = r & 15; // combined length
         if (s > j->code_bits) return stbi__err(""bad huffman code"", ""Combined length longer than code bits available"");
         j->code_buffer <<= s;
         j->code_bits -= s;
         // decode into unzigzag'd location
         zig = stbi__jpeg_dezigzag[k++];
         data[zig] = (short) ((r >> 8) * dequant[zig]);
      } else {
         int rs = stbi__jpeg_huff_decode(j, hac);
         if (rs < 0) return stbi__err(""bad huffman code"",""Corrupt JPEG"");
         s = rs & 15;
         r = rs >> 4;
         if (s == 0) {
            if (rs != 0xf0) break; // end block
            k += 16;
         } else {
            k += r;
            // decode into unzigzag'd location
            zig = stbi__jpeg_dezigzag[k++];
            data[zig] = (short) (stbi__extend_receive(j,s) * dequant[zig]);
         }
      }
   } while (k < 64);
   return 1;
}","{'begin': {'line': 2210, 'column': 1}, 'end': {'line': 2263, 'column': 2}}",show_image.c,"['解码', 'JPEG', '单个', '数据', '块', '的', 'DC', '和', 'AC', '系数', '，', '应用', '量化', '和', '夫曼', '霍夫曼', '解码', '。']"
597,597,stbi__jpeg_reset,void,void stbi__jpeg_reset(stbi__jpeg * j),"[{'name': 'j', 'type': 'stbi__jpeg *'}]",重置JPEG解码器状态以重新开始解码,"static void stbi__jpeg_reset(stbi__jpeg *j)
{
   j->code_bits = 0;
   j->code_buffer = 0;
   j->nomore = 0;
   j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = j->img_comp[3].dc_pred = 0;
   j->marker = STBI__MARKER_none;
   j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;
   j->eob_run = 0;
   // no more than 1<<31 MCUs if no restart_interal? that's plenty safe,
   // since we don't even allow 1<<30 pixels
}","{'begin': {'line': 2936, 'column': 1}, 'end': {'line': 2947, 'column': 2}}",show_image.c,"['重置', 'JPEG', '解码', '码器', '解码器', '状态', '以', '重新', '开始', '解码']"
598,598,stbi__parse_entropy_coded_data,int,int stbi__parse_entropy_coded_data(stbi__jpeg * z),"[{'name': 'z', 'type': 'stbi__jpeg *'}]",解析JPEG熵编码数据，处理渐进与非渐进格式解码,"static int stbi__parse_entropy_coded_data(stbi__jpeg *z)
{
   stbi__jpeg_reset(z);
   if (!z->progressive) {
      if (z->scan_n == 1) {
         int i,j;
         STBI_SIMD_ALIGN(short, data[64]);
         int n = z->order[0];
         // non-interleaved data, we just need to process one block at a time,
         // in trivial scanline order
         // number of blocks to do just depends on how many actual ""pixels"" this
         // component has, independent of interleaved MCU blocking and such
         int w = (z->img_comp[n].x+7) >> 3;
         int h = (z->img_comp[n].y+7) >> 3;
         for (j=0; j < h; ++j) {
            for (i=0; i < w; ++i) {
               int ha = z->img_comp[n].ha;
               if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
               z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
               // every data block is an MCU, so countdown the restart interval
               if (--z->todo <= 0) {
                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
                  // if it's NOT a restart, then just bail, so we get corrupt data
                  // rather than no data
                  if (!STBI__RESTART(z->marker)) return 1;
                  stbi__jpeg_reset(z);
               }
            }
         }
         return 1;
      } else { // interleaved
         int i,j,k,x,y;
         STBI_SIMD_ALIGN(short, data[64]);
         for (j=0; j < z->img_mcu_y; ++j) {
            for (i=0; i < z->img_mcu_x; ++i) {
               // scan an interleaved mcu... process scan_n components in order
               for (k=0; k < z->scan_n; ++k) {
                  int n = z->order[k];
                  // scan out an mcu's worth of this component; that's just determined
                  // by the basic H and V specified for the component
                  for (y=0; y < z->img_comp[n].v; ++y) {
                     for (x=0; x < z->img_comp[n].h; ++x) {
                        int x2 = (i*z->img_comp[n].h + x)*8;
                        int y2 = (j*z->img_comp[n].v + y)*8;
                        int ha = z->img_comp[n].ha;
                        if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
                        z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*y2+x2, z->img_comp[n].w2, data);
                     }
                  }
               }
               // after all interleaved components, that's an interleaved MCU,
               // so now count down the restart interval
               if (--z->todo <= 0) {
                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
                  if (!STBI__RESTART(z->marker)) return 1;
                  stbi__jpeg_reset(z);
               }
            }
         }
         return 1;
      }
   } else {
      if (z->scan_n == 1) {
         int i,j;
         int n = z->order[0];
         // non-interleaved data, we just need to process one block at a time,
         // in trivial scanline order
         // number of blocks to do just depends on how many actual ""pixels"" this
         // component has, independent of interleaved MCU blocking and such
         int w = (z->img_comp[n].x+7) >> 3;
         int h = (z->img_comp[n].y+7) >> 3;
         for (j=0; j < h; ++j) {
            for (i=0; i < w; ++i) {
               short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
               if (z->spec_start == 0) {
                  if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
                     return 0;
               } else {
                  int ha = z->img_comp[n].ha;
                  if (!stbi__jpeg_decode_block_prog_ac(z, data, &z->huff_ac[ha], z->fast_ac[ha]))
                     return 0;
               }
               // every data block is an MCU, so countdown the restart interval
               if (--z->todo <= 0) {
                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
                  if (!STBI__RESTART(z->marker)) return 1;
                  stbi__jpeg_reset(z);
               }
            }
         }
         return 1;
      } else { // interleaved
         int i,j,k,x,y;
         for (j=0; j < z->img_mcu_y; ++j) {
            for (i=0; i < z->img_mcu_x; ++i) {
               // scan an interleaved mcu... process scan_n components in order
               for (k=0; k < z->scan_n; ++k) {
                  int n = z->order[k];
                  // scan out an mcu's worth of this component; that's just determined
                  // by the basic H and V specified for the component
                  for (y=0; y < z->img_comp[n].v; ++y) {
                     for (x=0; x < z->img_comp[n].h; ++x) {
                        int x2 = (i*z->img_comp[n].h + x);
                        int y2 = (j*z->img_comp[n].v + y);
                        short *data = z->img_comp[n].coeff + 64 * (x2 + y2 * z->img_comp[n].coeff_w);
                        if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
                           return 0;
                     }
                  }
               }
               // after all interleaved components, that's an interleaved MCU,
               // so now count down the restart interval
               if (--z->todo <= 0) {
                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
                  if (!STBI__RESTART(z->marker)) return 1;
                  stbi__jpeg_reset(z);
               }
            }
         }
         return 1;
      }
   }
}","{'begin': {'line': 2949, 'column': 1}, 'end': {'line': 3071, 'column': 2}}",show_image.c,"['解析', 'JPEG', '熵', '编码', '码数', '数据', '编码数据', '，', '处理', '渐进', '与非', '渐进', '格式', '解码']"
599,599,stbi__jpeg_decode_block_prog_dc,int,"int stbi__jpeg_decode_block_prog_dc(stbi__jpeg * j, short[64] data, stbi__huffman * hdc, int b)","[{'name': 'j', 'type': 'stbi__jpeg *'}, {'name': 'data', 'type': 'short[64]'}, {'name': 'hdc', 'type': 'stbi__huffman *'}, {'name': 'b', 'type': 'int'}]",渐进式JPEG解码块的直流分量处理,"static int stbi__jpeg_decode_block_prog_dc(stbi__jpeg *j, short data[64], stbi__huffman *hdc, int b)
{
   int diff,dc;
   int t;
   if (j->spec_end != 0) return stbi__err(""can't merge dc and ac"", ""Corrupt JPEG"");

   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

   if (j->succ_high == 0) {
      // first scan for DC coefficient, must be first
      memset(data,0,64*sizeof(data[0])); // 0 all the ac values now
      t = stbi__jpeg_huff_decode(j, hdc);
      if (t < 0 || t > 15) return stbi__err(""can't merge dc and ac"", ""Corrupt JPEG"");
      diff = t ? stbi__extend_receive(j, t) : 0;

      if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err(""bad delta"", ""Corrupt JPEG"");
      dc = j->img_comp[b].dc_pred + diff;
      j->img_comp[b].dc_pred = dc;
      if (!stbi__mul2shorts_valid(dc, 1 << j->succ_low)) return stbi__err(""can't merge dc and ac"", ""Corrupt JPEG"");
      data[0] = (short) (dc * (1 << j->succ_low));
   } else {
      // refinement scan for DC coefficient
      if (stbi__jpeg_get_bit(j))
         data[0] += (short) (1 << j->succ_low);
   }
   return 1;
}","{'begin': {'line': 2265, 'column': 1}, 'end': {'line': 2291, 'column': 2}}",show_image.c,"['渐进', '渐进式', 'JPEG', '解码', '块', '的', '直流', '分量', '处理']"
600,600,stbi__jpeg_decode_block_prog_ac,int,"int stbi__jpeg_decode_block_prog_ac(stbi__jpeg * j, short[64] data, stbi__huffman * hac, stbi__int16 * fac)","[{'name': 'j', 'type': 'stbi__jpeg *'}, {'name': 'data', 'type': 'short[64]'}, {'name': 'hac', 'type': 'stbi__huffman *'}, {'name': 'fac', 'type': 'stbi__int16 *'}]",渐进式JPEG解码AC系数块，处理细化扫描,"static int stbi__jpeg_decode_block_prog_ac(stbi__jpeg *j, short data[64], stbi__huffman *hac, stbi__int16 *fac)
{
   int k;
   if (j->spec_start == 0) return stbi__err(""can't merge dc and ac"", ""Corrupt JPEG"");

   if (j->succ_high == 0) {
      int shift = j->succ_low;

      if (j->eob_run) {
         --j->eob_run;
         return 1;
      }

      k = j->spec_start;
      do {
         unsigned int zig;
         int c,r,s;
         if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
         c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
         r = fac[c];
         if (r) { // fast-AC path
            k += (r >> 4) & 15; // run
            s = r & 15; // combined length
            if (s > j->code_bits) return stbi__err(""bad huffman code"", ""Combined length longer than code bits available"");
            j->code_buffer <<= s;
            j->code_bits -= s;
            zig = stbi__jpeg_dezigzag[k++];
            data[zig] = (short) ((r >> 8) * (1 << shift));
         } else {
            int rs = stbi__jpeg_huff_decode(j, hac);
            if (rs < 0) return stbi__err(""bad huffman code"",""Corrupt JPEG"");
            s = rs & 15;
            r = rs >> 4;
            if (s == 0) {
               if (r < 15) {
                  j->eob_run = (1 << r);
                  if (r)
                     j->eob_run += stbi__jpeg_get_bits(j, r);
                  --j->eob_run;
                  break;
               }
               k += 16;
            } else {
               k += r;
               zig = stbi__jpeg_dezigzag[k++];
               data[zig] = (short) (stbi__extend_receive(j,s) * (1 << shift));
            }
         }
      } while (k <= j->spec_end);
   } else {
      // refinement scan for these AC coefficients

      short bit = (short) (1 << j->succ_low);

      if (j->eob_run) {
         --j->eob_run;
         for (k = j->spec_start; k <= j->spec_end; ++k) {
            short *p = &data[stbi__jpeg_dezigzag[k]];
            if (*p != 0)
               if (stbi__jpeg_get_bit(j))
                  if ((*p & bit)==0) {
                     if (*p > 0)
                        *p += bit;
                     else
                        *p -= bit;
                  }
         }
      } else {
         k = j->spec_start;
         do {
            int r,s;
            int rs = stbi__jpeg_huff_decode(j, hac); // @OPTIMIZE see if we can use the fast path here, advance-by-r is so slow, eh
            if (rs < 0) return stbi__err(""bad huffman code"",""Corrupt JPEG"");
            s = rs & 15;
            r = rs >> 4;
            if (s == 0) {
               if (r < 15) {
                  j->eob_run = (1 << r) - 1;
                  if (r)
                     j->eob_run += stbi__jpeg_get_bits(j, r);
                  r = 64; // force end of block
               } else {
                  // r=15 s=0 should write 16 0s, so we just do
                  // a run of 15 0s and then write s (which is 0),
                  // so we don't have to do anything special here
               }
            } else {
               if (s != 1) return stbi__err(""bad huffman code"", ""Corrupt JPEG"");
               // sign bit
               if (stbi__jpeg_get_bit(j))
                  s = bit;
               else
                  s = -bit;
            }

            // advance by r
            while (k <= j->spec_end) {
               short *p = &data[stbi__jpeg_dezigzag[k++]];
               if (*p != 0) {
                  if (stbi__jpeg_get_bit(j))
                     if ((*p & bit)==0) {
                        if (*p > 0)
                           *p += bit;
                        else
                           *p -= bit;
                     }
               } else {
                  if (r == 0) {
                     *p = (short) s;
                     break;
                  }
                  --r;
               }
            }
         } while (k <= j->spec_end);
      }
   }
   return 1;
}","{'begin': {'line': 2295, 'column': 1}, 'end': {'line': 2413, 'column': 2}}",show_image.c,"['渐进', '渐进式', 'JPEG', '解码', 'AC', '系数', '块', '，', '处理', '细化', '扫描']"
601,601,stbi__jpeg_dequantize,void,"void stbi__jpeg_dequantize(short * data, stbi__uint16 * dequant)","[{'name': 'data', 'type': 'short *'}, {'name': 'dequant', 'type': 'stbi__uint16 *'}]",对JPEG数据块执行反量化处理,"static void stbi__jpeg_dequantize(short *data, stbi__uint16 *dequant)
{
   int i;
   for (i=0; i < 64; ++i)
      data[i] *= dequant[i];
}","{'begin': {'line': 3073, 'column': 1}, 'end': {'line': 3078, 'column': 2}}",show_image.c,"['对', 'JPEG', '数据', '块', '执行', '反', '量化', '处理']"
602,602,stbi__jpeg_finish,void,void stbi__jpeg_finish(stbi__jpeg * z),"[{'name': 'z', 'type': 'stbi__jpeg *'}]",完成渐进式JPEG解码的反量化与逆DCT变换,"static void stbi__jpeg_finish(stbi__jpeg *z)
{
   if (z->progressive) {
      // dequantize and idct the data
      int i,j,n;
      for (n=0; n < z->s->img_n; ++n) {
         int w = (z->img_comp[n].x+7) >> 3;
         int h = (z->img_comp[n].y+7) >> 3;
         for (j=0; j < h; ++j) {
            for (i=0; i < w; ++i) {
               short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
               stbi__jpeg_dequantize(data, z->dequant[z->img_comp[n].tq]);
               z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
            }
         }
      }
   }
}","{'begin': {'line': 3080, 'column': 1}, 'end': {'line': 3097, 'column': 2}}",show_image.c,"['完成', '渐进', '渐进式', 'JPEG', '解码', '的', '反', '量化', '与', '逆', 'DCT', '变换']"
603,603,stbi__clamp,stbi_uc,stbi_uc stbi__clamp(int x),"[{'name': 'x', 'type': 'int'}]",将输入值限制在0-255范围内并返回,"static stbi_uc stbi__clamp(int x)
{
   // trick to use a single test to catch both cases
   if ((unsigned int) x > 255) {
      if (x < 0) return 0;
      if (x > 255) return 255;
   }
   return (stbi_uc) x;
}","{'begin': {'line': 2416, 'column': 13}, 'end': {'line': 2424, 'column': 2}}",show_image.c,"['将', '输入', '值', '限制', '在', '0', '-', '255', '范围', '内', '并', '返回']"
604,604,stbi__process_marker,int,"int stbi__process_marker(stbi__jpeg * z, int m)","[{'name': 'z', 'type': 'stbi__jpeg *'}, {'name': 'm', 'type': 'int'}]",处理JPEG标记，解析元数据及错误检查,"static int stbi__process_marker(stbi__jpeg *z, int m)
{
   int L;
   switch (m) {
      case STBI__MARKER_none: // no marker found
         return stbi__err(""expected marker"",""Corrupt JPEG"");

      case 0xDD: // DRI - specify restart interval
         if (stbi__get16be(z->s) != 4) return stbi__err(""bad DRI len"",""Corrupt JPEG"");
         z->restart_interval = stbi__get16be(z->s);
         return 1;

      case 0xDB: // DQT - define quantization table
         L = stbi__get16be(z->s)-2;
         while (L > 0) {
            int q = stbi__get8(z->s);
            int p = q >> 4, sixteen = (p != 0);
            int t = q & 15,i;
            if (p != 0 && p != 1) return stbi__err(""bad DQT type"",""Corrupt JPEG"");
            if (t > 3) return stbi__err(""bad DQT table"",""Corrupt JPEG"");

            for (i=0; i < 64; ++i)
               z->dequant[t][stbi__jpeg_dezigzag[i]] = (stbi__uint16)(sixteen ? stbi__get16be(z->s) : stbi__get8(z->s));
            L -= (sixteen ? 129 : 65);
         }
         return L==0;

      case 0xC4: // DHT - define huffman table
         L = stbi__get16be(z->s)-2;
         while (L > 0) {
            stbi_uc *v;
            int sizes[16],i,n=0;
            int q = stbi__get8(z->s);
            int tc = q >> 4;
            int th = q & 15;
            if (tc > 1 || th > 3) return stbi__err(""bad DHT header"",""Corrupt JPEG"");
            for (i=0; i < 16; ++i) {
               sizes[i] = stbi__get8(z->s);
               n += sizes[i];
            }
            if(n > 256) return stbi__err(""bad DHT header"",""Corrupt JPEG""); // Loop over i < n would write past end of values!
            L -= 17;
            if (tc == 0) {
               if (!stbi__build_huffman(z->huff_dc+th, sizes)) return 0;
               v = z->huff_dc[th].values;
            } else {
               if (!stbi__build_huffman(z->huff_ac+th, sizes)) return 0;
               v = z->huff_ac[th].values;
            }
            for (i=0; i < n; ++i)
               v[i] = stbi__get8(z->s);
            if (tc != 0)
               stbi__build_fast_ac(z->fast_ac[th], z->huff_ac + th);
            L -= n;
         }
         return L==0;
   }

   // check for comment block or APP blocks
   if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {
      L = stbi__get16be(z->s);
      if (L < 2) {
         if (m == 0xFE)
            return stbi__err(""bad COM len"",""Corrupt JPEG"");
         else
            return stbi__err(""bad APP len"",""Corrupt JPEG"");
      }
      L -= 2;

      if (m == 0xE0 && L >= 5) { // JFIF APP0 segment
         static const unsigned char tag[5] = {'J','F','I','F','\0'};
         int ok = 1;
         int i;
         for (i=0; i < 5; ++i)
            if (stbi__get8(z->s) != tag[i])
               ok = 0;
         L -= 5;
         if (ok)
            z->jfif = 1;
      } else if (m == 0xEE && L >= 12) { // Adobe APP14 segment
         static const unsigned char tag[6] = {'A','d','o','b','e','\0'};
         int ok = 1;
         int i;
         for (i=0; i < 6; ++i)
            if (stbi__get8(z->s) != tag[i])
               ok = 0;
         L -= 6;
         if (ok) {
            stbi__get8(z->s); // version
            stbi__get16be(z->s); // flags0
            stbi__get16be(z->s); // flags1
            z->app14_color_transform = stbi__get8(z->s); // color transform
            L -= 6;
         }
      }

      stbi__skip(z->s, L);
      return 1;
   }

   return stbi__err(""unknown marker"",""Corrupt JPEG"");
}","{'begin': {'line': 3099, 'column': 1}, 'end': {'line': 3200, 'column': 2}}",show_image.c,"['处理', 'JPEG', '标记', '，', '解析', '元', '数据', '及', '错误', '检查']"
605,605,stbi__idct_block,void,"void stbi__idct_block(stbi_uc * out, int out_stride, short[64] data)","[{'name': 'out', 'type': 'stbi_uc *'}, {'name': 'out_stride', 'type': 'int'}, {'name': 'data', 'type': 'short[64]'}]",对8x8数据块执行逆DCT变换并输出像素值，优化全零列处理。,"static void stbi__idct_block(stbi_uc *out, int out_stride, short data[64])
{
   int i,val[64],*v=val;
   stbi_uc *o;
   short *d = data;

   // columns
   for (i=0; i < 8; ++i,++d, ++v) {
      // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing
      if (d[ 8]==0 && d[16]==0 && d[24]==0 && d[32]==0
           && d[40]==0 && d[48]==0 && d[56]==0) {
         //    no shortcut                 0     seconds
         //    (1|2|3|4|5|6|7)==0          0     seconds
         //    all separate               -0.047 seconds
         //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds
         int dcterm = d[0]*4;
         v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;
      } else {
         STBI__IDCT_1D(d[ 0],d[ 8],d[16],d[24],d[32],d[40],d[48],d[56])
         // constants scaled things up by 1<<12; let's bring them back
         // down, but keep 2 extra bits of precision
         x0 += 512; x1 += 512; x2 += 512; x3 += 512;
         v[ 0] = (x0+t3) >> 10;
         v[56] = (x0-t3) >> 10;
         v[ 8] = (x1+t2) >> 10;
         v[48] = (x1-t2) >> 10;
         v[16] = (x2+t1) >> 10;
         v[40] = (x2-t1) >> 10;
         v[24] = (x3+t0) >> 10;
         v[32] = (x3-t0) >> 10;
      }
   }

   for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {
      // no fast case since the first 1D IDCT spread components out
      STBI__IDCT_1D(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7])
      // constants scaled things up by 1<<12, plus we had 1<<2 from first
      // loop, plus horizontal and vertical each scale by sqrt(8) so together
      // we've got an extra 1<<3, so 1<<17 total we need to remove.
      // so we want to round that, which means adding 0.5 * 1<<17,
      // aka 65536. Also, we'll end up with -128 to 127 that we want
      // to encode as 0..255 by adding 128, so we'll add that before the shift
      x0 += 65536 + (128<<17);
      x1 += 65536 + (128<<17);
      x2 += 65536 + (128<<17);
      x3 += 65536 + (128<<17);
      // tried computing the shifts into temps, or'ing the temps to see
      // if any were out of range, but that was slower
      o[0] = stbi__clamp((x0+t3) >> 17);
      o[7] = stbi__clamp((x0-t3) >> 17);
      o[1] = stbi__clamp((x1+t2) >> 17);
      o[6] = stbi__clamp((x1-t2) >> 17);
      o[2] = stbi__clamp((x2+t1) >> 17);
      o[5] = stbi__clamp((x2-t1) >> 17);
      o[3] = stbi__clamp((x3+t0) >> 17);
      o[4] = stbi__clamp((x3-t0) >> 17);
   }
}","{'begin': {'line': 2467, 'column': 1}, 'end': {'line': 2524, 'column': 2}}",show_image.c,"['对', '8x8', '数据', '块', '执行', '逆', 'DCT', '变换', '并', '输出', '像素', '值', '，', '优化', '全零列', '处理', '。']"
606,606,stbi__process_scan_header,int,int stbi__process_scan_header(stbi__jpeg * z),"[{'name': 'z', 'type': 'stbi__jpeg *'}]",解析JPEG扫描头并验证参数有效性,"static int stbi__process_scan_header(stbi__jpeg *z)
{
   int i;
   int Ls = stbi__get16be(z->s);
   z->scan_n = stbi__get8(z->s);
   if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int) z->s->img_n) return stbi__err(""bad SOS component count"",""Corrupt JPEG"");
   if (Ls != 6+2*z->scan_n) return stbi__err(""bad SOS len"",""Corrupt JPEG"");
   for (i=0; i < z->scan_n; ++i) {
      int id = stbi__get8(z->s), which;
      int q = stbi__get8(z->s);
      for (which = 0; which < z->s->img_n; ++which)
         if (z->img_comp[which].id == id)
            break;
      if (which == z->s->img_n) return 0; // no match
      z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return stbi__err(""bad DC huff"",""Corrupt JPEG"");
      z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return stbi__err(""bad AC huff"",""Corrupt JPEG"");
      z->order[i] = which;
   }

   {
      int aa;
      z->spec_start = stbi__get8(z->s);
      z->spec_end   = stbi__get8(z->s); // should be 63, but might be 0
      aa = stbi__get8(z->s);
      z->succ_high = (aa >> 4);
      z->succ_low  = (aa & 15);
      if (z->progressive) {
         if (z->spec_start > 63 || z->spec_end > 63  || z->spec_start > z->spec_end || z->succ_high > 13 || z->succ_low > 13)
            return stbi__err(""bad SOS"", ""Corrupt JPEG"");
      } else {
         if (z->spec_start != 0) return stbi__err(""bad SOS"",""Corrupt JPEG"");
         if (z->succ_high != 0 || z->succ_low != 0) return stbi__err(""bad SOS"",""Corrupt JPEG"");
         z->spec_end = 63;
      }
   }

   return 1;
}","{'begin': {'line': 3203, 'column': 1}, 'end': {'line': 3240, 'column': 2}}",show_image.c,"['解析', 'JPEG', '扫描', '头', '并', '验证', '参数', '有效', '有效性']"
607,607,stbi__free_jpeg_components,int,"int stbi__free_jpeg_components(stbi__jpeg * z, int ncomp, int why)","[{'name': 'z', 'type': 'stbi__jpeg *'}, {'name': 'ncomp', 'type': 'int'}, {'name': 'why', 'type': 'int'}]",释放JPEG组件的原始数据、系数及行缓冲区,"static int stbi__free_jpeg_components(stbi__jpeg *z, int ncomp, int why)
{
   int i;
   for (i=0; i < ncomp; ++i) {
      if (z->img_comp[i].raw_data) {
         STBI_FREE(z->img_comp[i].raw_data);
         z->img_comp[i].raw_data = NULL;
         z->img_comp[i].data = NULL;
      }
      if (z->img_comp[i].raw_coeff) {
         STBI_FREE(z->img_comp[i].raw_coeff);
         z->img_comp[i].raw_coeff = 0;
         z->img_comp[i].coeff = 0;
      }
      if (z->img_comp[i].linebuf) {
         STBI_FREE(z->img_comp[i].linebuf);
         z->img_comp[i].linebuf = NULL;
      }
   }
   return why;
}","{'begin': {'line': 3242, 'column': 1}, 'end': {'line': 3262, 'column': 2}}",show_image.c,"['释放', 'JPEG', '组件', '的', '原始', '数据', '原始数据', '、', '系数', '及行', '缓冲', '缓冲区']"
608,608,stbi__process_frame_header,int,"int stbi__process_frame_header(stbi__jpeg * z, int scan)","[{'name': 'z', 'type': 'stbi__jpeg *'}, {'name': 'scan', 'type': 'int'}]",解析JPEG帧头，验证参数并初始化组件数据,"static int stbi__process_frame_header(stbi__jpeg *z, int scan)
{
   stbi__context *s = z->s;
   int Lf,p,i,q, h_max=1,v_max=1,c;
   Lf = stbi__get16be(s);         if (Lf < 11) return stbi__err(""bad SOF len"",""Corrupt JPEG""); // JPEG
   p  = stbi__get8(s);            if (p != 8) return stbi__err(""only 8-bit"",""JPEG format not supported: 8-bit only""); // JPEG baseline
   s->img_y = stbi__get16be(s);   if (s->img_y == 0) return stbi__err(""no header height"", ""JPEG format not supported: delayed height""); // Legal, but we don't handle it--but neither does IJG
   s->img_x = stbi__get16be(s);   if (s->img_x == 0) return stbi__err(""0 width"",""Corrupt JPEG""); // JPEG requires
   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err(""too large"",""Very large image (corrupt?)"");
   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err(""too large"",""Very large image (corrupt?)"");
   c = stbi__get8(s);
   if (c != 3 && c != 1 && c != 4) return stbi__err(""bad component count"",""Corrupt JPEG"");
   s->img_n = c;
   for (i=0; i < c; ++i) {
      z->img_comp[i].data = NULL;
      z->img_comp[i].linebuf = NULL;
   }

   if (Lf != 8+3*s->img_n) return stbi__err(""bad SOF len"",""Corrupt JPEG"");

   z->rgb = 0;
   for (i=0; i < s->img_n; ++i) {
      static const unsigned char rgb[3] = { 'R', 'G', 'B' };
      z->img_comp[i].id = stbi__get8(s);
      if (s->img_n == 3 && z->img_comp[i].id == rgb[i])
         ++z->rgb;
      q = stbi__get8(s);
      z->img_comp[i].h = (q >> 4);  if (!z->img_comp[i].h || z->img_comp[i].h > 4) return stbi__err(""bad H"",""Corrupt JPEG"");
      z->img_comp[i].v = q & 15;    if (!z->img_comp[i].v || z->img_comp[i].v > 4) return stbi__err(""bad V"",""Corrupt JPEG"");
      z->img_comp[i].tq = stbi__get8(s);  if (z->img_comp[i].tq > 3) return stbi__err(""bad TQ"",""Corrupt JPEG"");
   }

   if (scan != STBI__SCAN_load) return 1;

   if (!stbi__mad3sizes_valid(s->img_x, s->img_y, s->img_n, 0)) return stbi__err(""too large"", ""Image too large to decode"");

   for (i=0; i < s->img_n; ++i) {
      if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h;
      if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v;
   }

   // check that plane subsampling factors are integer ratios; our resamplers can't deal with fractional ratios
   // and I've never seen a non-corrupted JPEG file actually use them
   for (i=0; i < s->img_n; ++i) {
      if (h_max % z->img_comp[i].h != 0) return stbi__err(""bad H"",""Corrupt JPEG"");
      if (v_max % z->img_comp[i].v != 0) return stbi__err(""bad V"",""Corrupt JPEG"");
   }

   // compute interleaved mcu info
   z->img_h_max = h_max;
   z->img_v_max = v_max;
   z->img_mcu_w = h_max * 8;
   z->img_mcu_h = v_max * 8;
   // these sizes can't be more than 17 bits
   z->img_mcu_x = (s->img_x + z->img_mcu_w-1) / z->img_mcu_w;
   z->img_mcu_y = (s->img_y + z->img_mcu_h-1) / z->img_mcu_h;

   for (i=0; i < s->img_n; ++i) {
      // number of effective pixels (e.g. for non-interleaved MCU)
      z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max-1) / h_max;
      z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max-1) / v_max;
      // to simplify generation, we'll allocate enough memory to decode
      // the bogus oversized data from using interleaved MCUs and their
      // big blocks (e.g. a 16x16 iMCU on an image of width 33); we won't
      // discard the extra data until colorspace conversion
      //
      // img_mcu_x, img_mcu_y: <=17 bits; comp[i].h and .v are <=4 (checked earlier)
      // so these muls can't overflow with 32-bit ints (which we require)
      z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8;
      z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8;
      z->img_comp[i].coeff = 0;
      z->img_comp[i].raw_coeff = 0;
      z->img_comp[i].linebuf = NULL;
      z->img_comp[i].raw_data = stbi__malloc_mad2(z->img_comp[i].w2, z->img_comp[i].h2, 15);
      if (z->img_comp[i].raw_data == NULL)
         return stbi__free_jpeg_components(z, i+1, stbi__err(""outofmem"", ""Out of memory""));
      // align blocks for idct using mmx/sse
      z->img_comp[i].data = (stbi_uc*) (((size_t) z->img_comp[i].raw_data + 15) & ~15);
      if (z->progressive) {
         // w2, h2 are multiples of 8 (see above)
         z->img_comp[i].coeff_w = z->img_comp[i].w2 / 8;
         z->img_comp[i].coeff_h = z->img_comp[i].h2 / 8;
         z->img_comp[i].raw_coeff = stbi__malloc_mad3(z->img_comp[i].w2, z->img_comp[i].h2, sizeof(short), 15);
         if (z->img_comp[i].raw_coeff == NULL)
            return stbi__free_jpeg_components(z, i+1, stbi__err(""outofmem"", ""Out of memory""));
         z->img_comp[i].coeff = (short*) (((size_t) z->img_comp[i].raw_coeff + 15) & ~15);
      }
   }

   return 1;
}","{'begin': {'line': 3264, 'column': 1}, 'end': {'line': 3354, 'column': 2}}",show_image.c,"['解析', 'JPEG', '帧', '头', '，', '验证', '参数', '并', '初始', '初始化', '组件', '数据']"
609,609,stbi__idct_simd,void,"void stbi__idct_simd(stbi_uc * out, int out_stride, short[64] data)","[{'name': 'out', 'type': 'stbi_uc *'}, {'name': 'out_stride', 'type': 'int'}, {'name': 'data', 'type': 'short[64]'}]",使用SIMD指令优化的逆离散余弦变换实现,"static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
{
   // This is constructed to match our regular (generic) integer IDCT exactly.
   __m128i row0, row1, row2, row3, row4, row5, row6, row7;
   __m128i tmp;

   // dot product constant: even elems=x, odd elems=y
   #define dct_const(x,y)  _mm_setr_epi16((x),(y),(x),(y),(x),(y),(x),(y))

   // out(0) = c0[even]*x + c0[odd]*y   (c0, x, y 16-bit, out 32-bit)
   // out(1) = c1[even]*x + c1[odd]*y
   #define dct_rot(out0,out1, x,y,c0,c1) \
      __m128i c0##lo = _mm_unpacklo_epi16((x),(y)); \
      __m128i c0##hi = _mm_unpackhi_epi16((x),(y)); \
      __m128i out0##_l = _mm_madd_epi16(c0##lo, c0); \
      __m128i out0##_h = _mm_madd_epi16(c0##hi, c0); \
      __m128i out1##_l = _mm_madd_epi16(c0##lo, c1); \
      __m128i out1##_h = _mm_madd_epi16(c0##hi, c1)

   // out = in << 12  (in 16-bit, out 32-bit)
   #define dct_widen(out, in) \
      __m128i out##_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (in)), 4); \
      __m128i out##_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (in)), 4)

   // wide add
   #define dct_wadd(out, a, b) \
      __m128i out##_l = _mm_add_epi32(a##_l, b##_l); \
      __m128i out##_h = _mm_add_epi32(a##_h, b##_h)

   // wide sub
   #define dct_wsub(out, a, b) \
      __m128i out##_l = _mm_sub_epi32(a##_l, b##_l); \
      __m128i out##_h = _mm_sub_epi32(a##_h, b##_h)

   // butterfly a/b, add bias, then shift by ""s"" and pack
   #define dct_bfly32o(out0, out1, a,b,bias,s) \
      { \
         __m128i abiased_l = _mm_add_epi32(a##_l, bias); \
         __m128i abiased_h = _mm_add_epi32(a##_h, bias); \
         dct_wadd(sum, abiased, b); \
         dct_wsub(dif, abiased, b); \
         out0 = _mm_packs_epi32(_mm_srai_epi32(sum_l, s), _mm_srai_epi32(sum_h, s)); \
         out1 = _mm_packs_epi32(_mm_srai_epi32(dif_l, s), _mm_srai_epi32(dif_h, s)); \
      }

   // 8-bit interleave step (for transposes)
   #define dct_interleave8(a, b) \
      tmp = a; \
      a = _mm_unpacklo_epi8(a, b); \
      b = _mm_unpackhi_epi8(tmp, b)

   // 16-bit interleave step (for transposes)
   #define dct_interleave16(a, b) \
      tmp = a; \
      a = _mm_unpacklo_epi16(a, b); \
      b = _mm_unpackhi_epi16(tmp, b)

   #define dct_pass(bias,shift) \
      { \
         /* even part */ \
         dct_rot(t2e,t3e, row2,row6, rot0_0,rot0_1); \
         __m128i sum04 = _mm_add_epi16(row0, row4); \
         __m128i dif04 = _mm_sub_epi16(row0, row4); \
         dct_widen(t0e, sum04); \
         dct_widen(t1e, dif04); \
         dct_wadd(x0, t0e, t3e); \
         dct_wsub(x3, t0e, t3e); \
         dct_wadd(x1, t1e, t2e); \
         dct_wsub(x2, t1e, t2e); \
         /* odd part */ \
         dct_rot(y0o,y2o, row7,row3, rot2_0,rot2_1); \
         dct_rot(y1o,y3o, row5,row1, rot3_0,rot3_1); \
         __m128i sum17 = _mm_add_epi16(row1, row7); \
         __m128i sum35 = _mm_add_epi16(row3, row5); \
         dct_rot(y4o,y5o, sum17,sum35, rot1_0,rot1_1); \
         dct_wadd(x4, y0o, y4o); \
         dct_wadd(x5, y1o, y5o); \
         dct_wadd(x6, y2o, y5o); \
         dct_wadd(x7, y3o, y4o); \
         dct_bfly32o(row0,row7, x0,x7,bias,shift); \
         dct_bfly32o(row1,row6, x1,x6,bias,shift); \
         dct_bfly32o(row2,row5, x2,x5,bias,shift); \
         dct_bfly32o(row3,row4, x3,x4,bias,shift); \
      }

   __m128i rot0_0 = dct_const(stbi__f2f(0.5411961f), stbi__f2f(0.5411961f) + stbi__f2f(-1.847759065f));
   __m128i rot0_1 = dct_const(stbi__f2f(0.5411961f) + stbi__f2f( 0.765366865f), stbi__f2f(0.5411961f));
   __m128i rot1_0 = dct_const(stbi__f2f(1.175875602f) + stbi__f2f(-0.899976223f), stbi__f2f(1.175875602f));
   __m128i rot1_1 = dct_const(stbi__f2f(1.175875602f), stbi__f2f(1.175875602f) + stbi__f2f(-2.562915447f));
   __m128i rot2_0 = dct_const(stbi__f2f(-1.961570560f) + stbi__f2f( 0.298631336f), stbi__f2f(-1.961570560f));
   __m128i rot2_1 = dct_const(stbi__f2f(-1.961570560f), stbi__f2f(-1.961570560f) + stbi__f2f( 3.072711026f));
   __m128i rot3_0 = dct_const(stbi__f2f(-0.390180644f) + stbi__f2f( 2.053119869f), stbi__f2f(-0.390180644f));
   __m128i rot3_1 = dct_const(stbi__f2f(-0.390180644f), stbi__f2f(-0.390180644f) + stbi__f2f( 1.501321110f));

   // rounding biases in column/row passes, see stbi__idct_block for explanation.
   __m128i bias_0 = _mm_set1_epi32(512);
   __m128i bias_1 = _mm_set1_epi32(65536 + (128<<17));

   // load
   row0 = _mm_load_si128((const __m128i *) (data + 0*8));
   row1 = _mm_load_si128((const __m128i *) (data + 1*8));
   row2 = _mm_load_si128((const __m128i *) (data + 2*8));
   row3 = _mm_load_si128((const __m128i *) (data + 3*8));
   row4 = _mm_load_si128((const __m128i *) (data + 4*8));
   row5 = _mm_load_si128((const __m128i *) (data + 5*8));
   row6 = _mm_load_si128((const __m128i *) (data + 6*8));
   row7 = _mm_load_si128((const __m128i *) (data + 7*8));

   // column pass
   dct_pass(bias_0, 10);

   {
      // 16bit 8x8 transpose pass 1
      dct_interleave16(row0, row4);
      dct_interleave16(row1, row5);
      dct_interleave16(row2, row6);
      dct_interleave16(row3, row7);

      // transpose pass 2
      dct_interleave16(row0, row2);
      dct_interleave16(row1, row3);
      dct_interleave16(row4, row6);
      dct_interleave16(row5, row7);

      // transpose pass 3
      dct_interleave16(row0, row1);
      dct_interleave16(row2, row3);
      dct_interleave16(row4, row5);
      dct_interleave16(row6, row7);
   }

   // row pass
   dct_pass(bias_1, 17);

   {
      // pack
      __m128i p0 = _mm_packus_epi16(row0, row1); // a0a1a2a3...a7b0b1b2b3...b7
      __m128i p1 = _mm_packus_epi16(row2, row3);
      __m128i p2 = _mm_packus_epi16(row4, row5);
      __m128i p3 = _mm_packus_epi16(row6, row7);

      // 8bit 8x8 transpose pass 1
      dct_interleave8(p0, p2); // a0e0a1e1...
      dct_interleave8(p1, p3); // c0g0c1g1...

      // transpose pass 2
      dct_interleave8(p0, p1); // a0c0e0g0...
      dct_interleave8(p2, p3); // b0d0f0h0...

      // transpose pass 3
      dct_interleave8(p0, p2); // a0b0c0d0...
      dct_interleave8(p1, p3); // a4b4c4d4...

      // store
      _mm_storel_epi64((__m128i *) out, p0); out += out_stride;
      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p0, 0x4e)); out += out_stride;
      _mm_storel_epi64((__m128i *) out, p2); out += out_stride;
      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p2, 0x4e)); out += out_stride;
      _mm_storel_epi64((__m128i *) out, p1); out += out_stride;
      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p1, 0x4e)); out += out_stride;
      _mm_storel_epi64((__m128i *) out, p3); out += out_stride;
      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p3, 0x4e));
   }

#undef dct_const
#undef dct_rot
#undef dct_widen
#undef dct_wadd
#undef dct_wsub
#undef dct_bfly32o
#undef dct_interleave8
#undef dct_interleave16
#undef dct_pass
}","{'begin': {'line': 2530, 'column': 1}, 'end': {'line': 2703, 'column': 2}}",show_image.c,"['使用', 'SIMD', '指令', '优化', '的', '逆', '离散', '余弦', '变换', '实现']"
610,610,stbi__get_marker,stbi_uc,stbi_uc stbi__get_marker(stbi__jpeg * j),"[{'name': 'j', 'type': 'stbi__jpeg *'}]",获取并返回下一个JPEG标记，跳过填充字节,"static stbi_uc stbi__get_marker(stbi__jpeg *j)
{
   stbi_uc x;
   if (j->marker != STBI__MARKER_none) { x = j->marker; j->marker = STBI__MARKER_none; return x; }
   x = stbi__get8(j->s);
   if (x != 0xff) return STBI__MARKER_none;
   while (x == 0xff)
      x = stbi__get8(j->s); // consume repeated 0xff fill bytes
   return x;
}","{'begin': {'line': 2919, 'column': 1}, 'end': {'line': 2928, 'column': 2}}",show_image.c,"['获取', '并', '返回', '下', '一个', 'JPEG', '标记', '，', '跳过', '填充', '字节']"
611,611,stbi__jpeg_reset,void,void stbi__jpeg_reset(stbi__jpeg * j),"[{'name': 'j', 'type': 'stbi__jpeg *'}]",重置JPEG解码器的内部状态,"static void stbi__jpeg_reset(stbi__jpeg *j)
{
   j->code_bits = 0;
   j->code_buffer = 0;
   j->nomore = 0;
   j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = j->img_comp[3].dc_pred = 0;
   j->marker = STBI__MARKER_none;
   j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;
   j->eob_run = 0;
   // no more than 1<<31 MCUs if no restart_interal? that's plenty safe,
   // since we don't even allow 1<<30 pixels
}","{'begin': {'line': 2936, 'column': 1}, 'end': {'line': 2947, 'column': 2}}",show_image.c,"['重置', 'JPEG', '解码', '码器', '解码器', '的', '内部', '状态']"
612,612,stbi__parse_entropy_coded_data,int,int stbi__parse_entropy_coded_data(stbi__jpeg * z),"[{'name': 'z', 'type': 'stbi__jpeg *'}]",解析JPEG熵编码数据，处理交织和非交织块解码及重启间隔。,"static int stbi__parse_entropy_coded_data(stbi__jpeg *z)
{
   stbi__jpeg_reset(z);
   if (!z->progressive) {
      if (z->scan_n == 1) {
         int i,j;
         STBI_SIMD_ALIGN(short, data[64]);
         int n = z->order[0];
         // non-interleaved data, we just need to process one block at a time,
         // in trivial scanline order
         // number of blocks to do just depends on how many actual ""pixels"" this
         // component has, independent of interleaved MCU blocking and such
         int w = (z->img_comp[n].x+7) >> 3;
         int h = (z->img_comp[n].y+7) >> 3;
         for (j=0; j < h; ++j) {
            for (i=0; i < w; ++i) {
               int ha = z->img_comp[n].ha;
               if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
               z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
               // every data block is an MCU, so countdown the restart interval
               if (--z->todo <= 0) {
                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
                  // if it's NOT a restart, then just bail, so we get corrupt data
                  // rather than no data
                  if (!STBI__RESTART(z->marker)) return 1;
                  stbi__jpeg_reset(z);
               }
            }
         }
         return 1;
      } else { // interleaved
         int i,j,k,x,y;
         STBI_SIMD_ALIGN(short, data[64]);
         for (j=0; j < z->img_mcu_y; ++j) {
            for (i=0; i < z->img_mcu_x; ++i) {
               // scan an interleaved mcu... process scan_n components in order
               for (k=0; k < z->scan_n; ++k) {
                  int n = z->order[k];
                  // scan out an mcu's worth of this component; that's just determined
                  // by the basic H and V specified for the component
                  for (y=0; y < z->img_comp[n].v; ++y) {
                     for (x=0; x < z->img_comp[n].h; ++x) {
                        int x2 = (i*z->img_comp[n].h + x)*8;
                        int y2 = (j*z->img_comp[n].v + y)*8;
                        int ha = z->img_comp[n].ha;
                        if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
                        z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*y2+x2, z->img_comp[n].w2, data);
                     }
                  }
               }
               // after all interleaved components, that's an interleaved MCU,
               // so now count down the restart interval
               if (--z->todo <= 0) {
                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
                  if (!STBI__RESTART(z->marker)) return 1;
                  stbi__jpeg_reset(z);
               }
            }
         }
         return 1;
      }
   } else {
      if (z->scan_n == 1) {
         int i,j;
         int n = z->order[0];
         // non-interleaved data, we just need to process one block at a time,
         // in trivial scanline order
         // number of blocks to do just depends on how many actual ""pixels"" this
         // component has, independent of interleaved MCU blocking and such
         int w = (z->img_comp[n].x+7) >> 3;
         int h = (z->img_comp[n].y+7) >> 3;
         for (j=0; j < h; ++j) {
            for (i=0; i < w; ++i) {
               short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
               if (z->spec_start == 0) {
                  if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
                     return 0;
               } else {
                  int ha = z->img_comp[n].ha;
                  if (!stbi__jpeg_decode_block_prog_ac(z, data, &z->huff_ac[ha], z->fast_ac[ha]))
                     return 0;
               }
               // every data block is an MCU, so countdown the restart interval
               if (--z->todo <= 0) {
                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
                  if (!STBI__RESTART(z->marker)) return 1;
                  stbi__jpeg_reset(z);
               }
            }
         }
         return 1;
      } else { // interleaved
         int i,j,k,x,y;
         for (j=0; j < z->img_mcu_y; ++j) {
            for (i=0; i < z->img_mcu_x; ++i) {
               // scan an interleaved mcu... process scan_n components in order
               for (k=0; k < z->scan_n; ++k) {
                  int n = z->order[k];
                  // scan out an mcu's worth of this component; that's just determined
                  // by the basic H and V specified for the component
                  for (y=0; y < z->img_comp[n].v; ++y) {
                     for (x=0; x < z->img_comp[n].h; ++x) {
                        int x2 = (i*z->img_comp[n].h + x);
                        int y2 = (j*z->img_comp[n].v + y);
                        short *data = z->img_comp[n].coeff + 64 * (x2 + y2 * z->img_comp[n].coeff_w);
                        if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
                           return 0;
                     }
                  }
               }
               // after all interleaved components, that's an interleaved MCU,
               // so now count down the restart interval
               if (--z->todo <= 0) {
                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
                  if (!STBI__RESTART(z->marker)) return 1;
                  stbi__jpeg_reset(z);
               }
            }
         }
         return 1;
      }
   }
}","{'begin': {'line': 2949, 'column': 1}, 'end': {'line': 3071, 'column': 2}}",show_image.c,"['解析', 'JPEG', '熵', '编码', '码数', '数据', '编码数据', '，', '处理', '交织', '和', '非', '交织', '块', '解码', '及', '重启', '间隔', '。']"
613,613,stbi__decode_jpeg_header,int,"int stbi__decode_jpeg_header(stbi__jpeg * z, int scan)","[{'name': 'z', 'type': 'stbi__jpeg *'}, {'name': 'scan', 'type': 'int'}]",解析JPEG头部信息并验证结构,"static int stbi__decode_jpeg_header(stbi__jpeg *z, int scan)
{
   int m;
   z->jfif = 0;
   z->app14_color_transform = -1; // valid values are 0,1,2
   z->marker = STBI__MARKER_none; // initialize cached marker to empty
   m = stbi__get_marker(z);
   if (!stbi__SOI(m)) return stbi__err(""no SOI"",""Corrupt JPEG"");
   if (scan == STBI__SCAN_type) return 1;
   m = stbi__get_marker(z);
   while (!stbi__SOF(m)) {
      if (!stbi__process_marker(z,m)) return 0;
      m = stbi__get_marker(z);
      while (m == STBI__MARKER_none) {
         // some files have extra padding after their blocks, so ok, we'll scan
         if (stbi__at_eof(z->s)) return stbi__err(""no SOF"", ""Corrupt JPEG"");
         m = stbi__get_marker(z);
      }
   }
   z->progressive = stbi__SOF_progressive(m);
   if (!stbi__process_frame_header(z, scan)) return 0;
   return 1;
}","{'begin': {'line': 3365, 'column': 1}, 'end': {'line': 3387, 'column': 2}}",show_image.c,"['解析', 'JPEG', '头部', '信息', '并', '验证', '结构']"
614,614,stbi__skip_jpeg_junk_at_end,stbi_uc,stbi_uc stbi__skip_jpeg_junk_at_end(stbi__jpeg * j),"[{'name': 'j', 'type': 'stbi__jpeg *'}]",跳过JPEG文件末尾无效数据并寻找有效标记,"static stbi_uc stbi__skip_jpeg_junk_at_end(stbi__jpeg *j)
{
   // some JPEGs have junk at end, skip over it but if we find what looks
   // like a valid marker, resume there
   while (!stbi__at_eof(j->s)) {
      stbi_uc x = stbi__get8(j->s);
      while (x == 0xff) { // might be a marker
         if (stbi__at_eof(j->s)) return STBI__MARKER_none;
         x = stbi__get8(j->s);
         if (x != 0x00 && x != 0xff) {
            // not a stuffed zero or lead-in to another marker, looks
            // like an actual marker, return it
            return x;
         }
         // stuffed zero has x=0 now which ends the loop, meaning we go
         // back to regular scan loop.
         // repeated 0xff keeps trying to read the next byte of the marker.
      }
   }
   return STBI__MARKER_none;
}","{'begin': {'line': 3389, 'column': 1}, 'end': {'line': 3409, 'column': 2}}",show_image.c,"['跳过', 'JPEG', '文件', '末尾', '无效', '数据', '并', '寻找', '有效', '标记']"
615,615,stbi__decode_jpeg_image,int,int stbi__decode_jpeg_image(stbi__jpeg * j),"[{'name': 'j', 'type': 'stbi__jpeg *'}]",解码JPEG图像数据，处理标记和扫描信息,"static int stbi__decode_jpeg_image(stbi__jpeg *j)
{
   int m;
   for (m = 0; m < 4; m++) {
      j->img_comp[m].raw_data = NULL;
      j->img_comp[m].raw_coeff = NULL;
   }
   j->restart_interval = 0;
   if (!stbi__decode_jpeg_header(j, STBI__SCAN_load)) return 0;
   m = stbi__get_marker(j);
   while (!stbi__EOI(m)) {
      if (stbi__SOS(m)) {
         if (!stbi__process_scan_header(j)) return 0;
         if (!stbi__parse_entropy_coded_data(j)) return 0;
         if (j->marker == STBI__MARKER_none ) {
         j->marker = stbi__skip_jpeg_junk_at_end(j);
            // if we reach eof without hitting a marker, stbi__get_marker() below will fail and we'll eventually return 0
         }
         m = stbi__get_marker(j);
         if (STBI__RESTART(m))
            m = stbi__get_marker(j);
      } else if (stbi__DNL(m)) {
         int Ld = stbi__get16be(j->s);
         stbi__uint32 NL = stbi__get16be(j->s);
         if (Ld != 4) return stbi__err(""bad DNL len"", ""Corrupt JPEG"");
         if (NL != j->s->img_y) return stbi__err(""bad DNL height"", ""Corrupt JPEG"");
         m = stbi__get_marker(j);
      } else {
         if (!stbi__process_marker(j, m)) return 1;
         m = stbi__get_marker(j);
      }
   }
   if (j->progressive)
      stbi__jpeg_finish(j);
   return 1;
}","{'begin': {'line': 3412, 'column': 1}, 'end': {'line': 3447, 'column': 2}}",show_image.c,"['解码', 'JPEG', '图像', '数据', '，', '处理', '标记', '和', '扫描', '信息']"
616,616,stbi__jpeg_dequantize,void,"void stbi__jpeg_dequantize(short * data, stbi__uint16 * dequant)","[{'name': 'data', 'type': 'short *'}, {'name': 'dequant', 'type': 'stbi__uint16 *'}]",对64元素数据块应用反量化表进行反量化,"static void stbi__jpeg_dequantize(short *data, stbi__uint16 *dequant)
{
   int i;
   for (i=0; i < 64; ++i)
      data[i] *= dequant[i];
}","{'begin': {'line': 3073, 'column': 1}, 'end': {'line': 3078, 'column': 2}}",show_image.c,"['对', '64', '元素', '数据', '块', '应用', '反', '量化', '表', '进行', '反', '量化']"
617,617,stbi__jpeg_finish,void,void stbi__jpeg_finish(stbi__jpeg * z),"[{'name': 'z', 'type': 'stbi__jpeg *'}]",处理渐进式JPEG解码后的反量化与IDCT变换,"static void stbi__jpeg_finish(stbi__jpeg *z)
{
   if (z->progressive) {
      // dequantize and idct the data
      int i,j,n;
      for (n=0; n < z->s->img_n; ++n) {
         int w = (z->img_comp[n].x+7) >> 3;
         int h = (z->img_comp[n].y+7) >> 3;
         for (j=0; j < h; ++j) {
            for (i=0; i < w; ++i) {
               short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
               stbi__jpeg_dequantize(data, z->dequant[z->img_comp[n].tq]);
               z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
            }
         }
      }
   }
}","{'begin': {'line': 3080, 'column': 1}, 'end': {'line': 3097, 'column': 2}}",show_image.c,"['处理', '渐进', '渐进式', 'JPEG', '解码', '后', '的', '反', '量化', '与', 'IDCT', '变换']"
618,618,resample_row_1,stbi_uc *,"stbi_uc * resample_row_1(stbi_uc * out, stbi_uc * in_near, stbi_uc * in_far, int w, int hs)","[{'name': 'out', 'type': 'stbi_uc *'}, {'name': 'in_near', 'type': 'stbi_uc *'}, {'name': 'in_far', 'type': 'stbi_uc *'}, {'name': 'w', 'type': 'int'}, {'name': 'hs', 'type': 'int'}]",直接返回输入数据，不进行重采样处理,"static stbi_uc *resample_row_1(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   STBI_NOTUSED(out);
   STBI_NOTUSED(in_far);
   STBI_NOTUSED(w);
   STBI_NOTUSED(hs);
   return in_near;
}","{'begin': {'line': 3456, 'column': 1}, 'end': {'line': 3463, 'column': 2}}",show_image.c,"['直接', '返回', '输入', '数据', '，', '不', '进行', '重', '采样', '处理']"
619,619,stbi__resample_row_v_2,stbi_uc *,"stbi_uc * stbi__resample_row_v_2(stbi_uc * out, stbi_uc * in_near, stbi_uc * in_far, int w, int hs)","[{'name': 'out', 'type': 'stbi_uc *'}, {'name': 'in_near', 'type': 'stbi_uc *'}, {'name': 'in_far', 'type': 'stbi_uc *'}, {'name': 'w', 'type': 'int'}, {'name': 'hs', 'type': 'int'}]",垂直双倍采样，使用3:1加权平均生成输出行,"static stbi_uc* stbi__resample_row_v_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // need to generate two samples vertically for every one in input
   int i;
   STBI_NOTUSED(hs);
   for (i=0; i < w; ++i)
      out[i] = stbi__div4(3*in_near[i] + in_far[i] + 2);
   return out;
}","{'begin': {'line': 3465, 'column': 1}, 'end': {'line': 3473, 'column': 2}}",show_image.c,"['垂直', '双倍', '采样', '，', '使用', '3', ':', '1', '加权', '平均', '生成', '输出', '行']"
620,620,stbi__resample_row_h_2,stbi_uc *,"stbi_uc * stbi__resample_row_h_2(stbi_uc * out, stbi_uc * in_near, stbi_uc * in_far, int w, int hs)","[{'name': 'out', 'type': 'stbi_uc *'}, {'name': 'in_near', 'type': 'stbi_uc *'}, {'name': 'in_far', 'type': 'stbi_uc *'}, {'name': 'w', 'type': 'int'}, {'name': 'hs', 'type': 'int'}]",水平双倍上采样，使用线性插值处理像素,"static stbi_uc*  stbi__resample_row_h_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // need to generate two samples horizontally for every one in input
   int i;
   stbi_uc *input = in_near;

   if (w == 1) {
      // if only one sample, can't do any interpolation
      out[0] = out[1] = input[0];
      return out;
   }

   out[0] = input[0];
   out[1] = stbi__div4(input[0]*3 + input[1] + 2);
   for (i=1; i < w-1; ++i) {
      int n = 3*input[i]+2;
      out[i*2+0] = stbi__div4(n+input[i-1]);
      out[i*2+1] = stbi__div4(n+input[i+1]);
   }
   out[i*2+0] = stbi__div4(input[w-2]*3 + input[w-1] + 2);
   out[i*2+1] = input[w-1];

   STBI_NOTUSED(in_far);
   STBI_NOTUSED(hs);

   return out;
}","{'begin': {'line': 3475, 'column': 1}, 'end': {'line': 3501, 'column': 2}}",show_image.c,"['水平', '双倍', '上', '采样', '，', '使用', '线性', '插值', '线性插值', '处理', '像素']"
621,621,stbi__process_marker,int,"int stbi__process_marker(stbi__jpeg * z, int m)","[{'name': 'z', 'type': 'stbi__jpeg *'}, {'name': 'm', 'type': 'int'}]",处理JPEG标记并解析相关数据,"static int stbi__process_marker(stbi__jpeg *z, int m)
{
   int L;
   switch (m) {
      case STBI__MARKER_none: // no marker found
         return stbi__err(""expected marker"",""Corrupt JPEG"");

      case 0xDD: // DRI - specify restart interval
         if (stbi__get16be(z->s) != 4) return stbi__err(""bad DRI len"",""Corrupt JPEG"");
         z->restart_interval = stbi__get16be(z->s);
         return 1;

      case 0xDB: // DQT - define quantization table
         L = stbi__get16be(z->s)-2;
         while (L > 0) {
            int q = stbi__get8(z->s);
            int p = q >> 4, sixteen = (p != 0);
            int t = q & 15,i;
            if (p != 0 && p != 1) return stbi__err(""bad DQT type"",""Corrupt JPEG"");
            if (t > 3) return stbi__err(""bad DQT table"",""Corrupt JPEG"");

            for (i=0; i < 64; ++i)
               z->dequant[t][stbi__jpeg_dezigzag[i]] = (stbi__uint16)(sixteen ? stbi__get16be(z->s) : stbi__get8(z->s));
            L -= (sixteen ? 129 : 65);
         }
         return L==0;

      case 0xC4: // DHT - define huffman table
         L = stbi__get16be(z->s)-2;
         while (L > 0) {
            stbi_uc *v;
            int sizes[16],i,n=0;
            int q = stbi__get8(z->s);
            int tc = q >> 4;
            int th = q & 15;
            if (tc > 1 || th > 3) return stbi__err(""bad DHT header"",""Corrupt JPEG"");
            for (i=0; i < 16; ++i) {
               sizes[i] = stbi__get8(z->s);
               n += sizes[i];
            }
            if(n > 256) return stbi__err(""bad DHT header"",""Corrupt JPEG""); // Loop over i < n would write past end of values!
            L -= 17;
            if (tc == 0) {
               if (!stbi__build_huffman(z->huff_dc+th, sizes)) return 0;
               v = z->huff_dc[th].values;
            } else {
               if (!stbi__build_huffman(z->huff_ac+th, sizes)) return 0;
               v = z->huff_ac[th].values;
            }
            for (i=0; i < n; ++i)
               v[i] = stbi__get8(z->s);
            if (tc != 0)
               stbi__build_fast_ac(z->fast_ac[th], z->huff_ac + th);
            L -= n;
         }
         return L==0;
   }

   // check for comment block or APP blocks
   if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {
      L = stbi__get16be(z->s);
      if (L < 2) {
         if (m == 0xFE)
            return stbi__err(""bad COM len"",""Corrupt JPEG"");
         else
            return stbi__err(""bad APP len"",""Corrupt JPEG"");
      }
      L -= 2;

      if (m == 0xE0 && L >= 5) { // JFIF APP0 segment
         static const unsigned char tag[5] = {'J','F','I','F','\0'};
         int ok = 1;
         int i;
         for (i=0; i < 5; ++i)
            if (stbi__get8(z->s) != tag[i])
               ok = 0;
         L -= 5;
         if (ok)
            z->jfif = 1;
      } else if (m == 0xEE && L >= 12) { // Adobe APP14 segment
         static const unsigned char tag[6] = {'A','d','o','b','e','\0'};
         int ok = 1;
         int i;
         for (i=0; i < 6; ++i)
            if (stbi__get8(z->s) != tag[i])
               ok = 0;
         L -= 6;
         if (ok) {
            stbi__get8(z->s); // version
            stbi__get16be(z->s); // flags0
            stbi__get16be(z->s); // flags1
            z->app14_color_transform = stbi__get8(z->s); // color transform
            L -= 6;
         }
      }

      stbi__skip(z->s, L);
      return 1;
   }

   return stbi__err(""unknown marker"",""Corrupt JPEG"");
}","{'begin': {'line': 3099, 'column': 1}, 'end': {'line': 3200, 'column': 2}}",show_image.c,"['处理', 'JPEG', '标记', '并', '解析', '相关', '数据']"
622,622,stbi__resample_row_hv_2,stbi_uc *,"stbi_uc * stbi__resample_row_hv_2(stbi_uc * out, stbi_uc * in_near, stbi_uc * in_far, int w, int hs)","[{'name': 'out', 'type': 'stbi_uc *'}, {'name': 'in_near', 'type': 'stbi_uc *'}, {'name': 'in_far', 'type': 'stbi_uc *'}, {'name': 'w', 'type': 'int'}, {'name': 'hs', 'type': 'int'}]",双倍重采样输入行，生成水平/垂直插值输出。,"static stbi_uc *stbi__resample_row_hv_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // need to generate 2x2 samples for every one in input
   int i,t0,t1;
   if (w == 1) {
      out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);
      return out;
   }

   t1 = 3*in_near[0] + in_far[0];
   out[0] = stbi__div4(t1+2);
   for (i=1; i < w; ++i) {
      t0 = t1;
      t1 = 3*in_near[i]+in_far[i];
      out[i*2-1] = stbi__div16(3*t0 + t1 + 8);
      out[i*2  ] = stbi__div16(3*t1 + t0 + 8);
   }
   out[w*2-1] = stbi__div4(t1+2);

   STBI_NOTUSED(hs);

   return out;
}","{'begin': {'line': 3505, 'column': 1}, 'end': {'line': 3527, 'column': 2}}",show_image.c,"['双倍', '重', '采样', '输入', '行', '，', '生成', '水平', '/', '垂直', '插值', '输出', '。']"
623,623,stbi__resample_row_hv_2_simd,stbi_uc *,"stbi_uc * stbi__resample_row_hv_2_simd(stbi_uc * out, stbi_uc * in_near, stbi_uc * in_far, int w, int hs)","[{'name': 'out', 'type': 'stbi_uc *'}, {'name': 'in_near', 'type': 'stbi_uc *'}, {'name': 'in_far', 'type': 'stbi_uc *'}, {'name': 'w', 'type': 'int'}, {'name': 'hs', 'type': 'int'}]",使用SIMD优化的双倍重采样行处理函数,"static stbi_uc *stbi__resample_row_hv_2_simd(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // need to generate 2x2 samples for every one in input
   int i=0,t0,t1;

   if (w == 1) {
      out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);
      return out;
   }

   t1 = 3*in_near[0] + in_far[0];
   // process groups of 8 pixels for as long as we can.
   // note we can't handle the last pixel in a row in this loop
   // because we need to handle the filter boundary conditions.
   for (; i < ((w-1) & ~7); i += 8) {
#if defined(STBI_SSE2)
      // load and perform the vertical filtering pass
      // this uses 3*x + y = 4*x + (y - x)
      __m128i zero  = _mm_setzero_si128();
      __m128i farb  = _mm_loadl_epi64((__m128i *) (in_far + i));
      __m128i nearb = _mm_loadl_epi64((__m128i *) (in_near + i));
      __m128i farw  = _mm_unpacklo_epi8(farb, zero);
      __m128i nearw = _mm_unpacklo_epi8(nearb, zero);
      __m128i diff  = _mm_sub_epi16(farw, nearw);
      __m128i nears = _mm_slli_epi16(nearw, 2);
      __m128i curr  = _mm_add_epi16(nears, diff); // current row

      // horizontal filter works the same based on shifted vers of current
      // row. ""prev"" is current row shifted right by 1 pixel; we need to
      // insert the previous pixel value (from t1).
      // ""next"" is current row shifted left by 1 pixel, with first pixel
      // of next block of 8 pixels added in.
      __m128i prv0 = _mm_slli_si128(curr, 2);
      __m128i nxt0 = _mm_srli_si128(curr, 2);
      __m128i prev = _mm_insert_epi16(prv0, t1, 0);
      __m128i next = _mm_insert_epi16(nxt0, 3*in_near[i+8] + in_far[i+8], 7);

      // horizontal filter, polyphase implementation since it's convenient:
      // even pixels = 3*cur + prev = cur*4 + (prev - cur)
      // odd  pixels = 3*cur + next = cur*4 + (next - cur)
      // note the shared term.
      __m128i bias  = _mm_set1_epi16(8);
      __m128i curs = _mm_slli_epi16(curr, 2);
      __m128i prvd = _mm_sub_epi16(prev, curr);
      __m128i nxtd = _mm_sub_epi16(next, curr);
      __m128i curb = _mm_add_epi16(curs, bias);
      __m128i even = _mm_add_epi16(prvd, curb);
      __m128i odd  = _mm_add_epi16(nxtd, curb);

      // interleave even and odd pixels, then undo scaling.
      __m128i int0 = _mm_unpacklo_epi16(even, odd);
      __m128i int1 = _mm_unpackhi_epi16(even, odd);
      __m128i de0  = _mm_srli_epi16(int0, 4);
      __m128i de1  = _mm_srli_epi16(int1, 4);

      // pack and write output
      __m128i outv = _mm_packus_epi16(de0, de1);
      _mm_storeu_si128((__m128i *) (out + i*2), outv);
#elif defined(STBI_NEON)
      // load and perform the vertical filtering pass
      // this uses 3*x + y = 4*x + (y - x)
      uint8x8_t farb  = vld1_u8(in_far + i);
      uint8x8_t nearb = vld1_u8(in_near + i);
      int16x8_t diff  = vreinterpretq_s16_u16(vsubl_u8(farb, nearb));
      int16x8_t nears = vreinterpretq_s16_u16(vshll_n_u8(nearb, 2));
      int16x8_t curr  = vaddq_s16(nears, diff); // current row

      // horizontal filter works the same based on shifted vers of current
      // row. ""prev"" is current row shifted right by 1 pixel; we need to
      // insert the previous pixel value (from t1).
      // ""next"" is current row shifted left by 1 pixel, with first pixel
      // of next block of 8 pixels added in.
      int16x8_t prv0 = vextq_s16(curr, curr, 7);
      int16x8_t nxt0 = vextq_s16(curr, curr, 1);
      int16x8_t prev = vsetq_lane_s16(t1, prv0, 0);
      int16x8_t next = vsetq_lane_s16(3*in_near[i+8] + in_far[i+8], nxt0, 7);

      // horizontal filter, polyphase implementation since it's convenient:
      // even pixels = 3*cur + prev = cur*4 + (prev - cur)
      // odd  pixels = 3*cur + next = cur*4 + (next - cur)
      // note the shared term.
      int16x8_t curs = vshlq_n_s16(curr, 2);
      int16x8_t prvd = vsubq_s16(prev, curr);
      int16x8_t nxtd = vsubq_s16(next, curr);
      int16x8_t even = vaddq_s16(curs, prvd);
      int16x8_t odd  = vaddq_s16(curs, nxtd);

      // undo scaling and round, then store with even/odd phases interleaved
      uint8x8x2_t o;
      o.val[0] = vqrshrun_n_s16(even, 4);
      o.val[1] = vqrshrun_n_s16(odd,  4);
      vst2_u8(out + i*2, o);
#endif

      // ""previous"" value for next iter
      t1 = 3*in_near[i+7] + in_far[i+7];
   }

   t0 = t1;
   t1 = 3*in_near[i] + in_far[i];
   out[i*2] = stbi__div16(3*t1 + t0 + 8);

   for (++i; i < w; ++i) {
      t0 = t1;
      t1 = 3*in_near[i]+in_far[i];
      out[i*2-1] = stbi__div16(3*t0 + t1 + 8);
      out[i*2  ] = stbi__div16(3*t1 + t0 + 8);
   }
   out[w*2-1] = stbi__div4(t1+2);

   STBI_NOTUSED(hs);

   return out;
}","{'begin': {'line': 3530, 'column': 1}, 'end': {'line': 3643, 'column': 2}}",show_image.c,"['使用', 'SIMD', '优化', '的', '双倍', '重', '采样', '行', '处理', '函数', '处理函数']"
624,624,stbi__process_scan_header,int,int stbi__process_scan_header(stbi__jpeg * z),"[{'name': 'z', 'type': 'stbi__jpeg *'}]",处理JPEG扫描头并验证参数合法性,"static int stbi__process_scan_header(stbi__jpeg *z)
{
   int i;
   int Ls = stbi__get16be(z->s);
   z->scan_n = stbi__get8(z->s);
   if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int) z->s->img_n) return stbi__err(""bad SOS component count"",""Corrupt JPEG"");
   if (Ls != 6+2*z->scan_n) return stbi__err(""bad SOS len"",""Corrupt JPEG"");
   for (i=0; i < z->scan_n; ++i) {
      int id = stbi__get8(z->s), which;
      int q = stbi__get8(z->s);
      for (which = 0; which < z->s->img_n; ++which)
         if (z->img_comp[which].id == id)
            break;
      if (which == z->s->img_n) return 0; // no match
      z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return stbi__err(""bad DC huff"",""Corrupt JPEG"");
      z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return stbi__err(""bad AC huff"",""Corrupt JPEG"");
      z->order[i] = which;
   }

   {
      int aa;
      z->spec_start = stbi__get8(z->s);
      z->spec_end   = stbi__get8(z->s); // should be 63, but might be 0
      aa = stbi__get8(z->s);
      z->succ_high = (aa >> 4);
      z->succ_low  = (aa & 15);
      if (z->progressive) {
         if (z->spec_start > 63 || z->spec_end > 63  || z->spec_start > z->spec_end || z->succ_high > 13 || z->succ_low > 13)
            return stbi__err(""bad SOS"", ""Corrupt JPEG"");
      } else {
         if (z->spec_start != 0) return stbi__err(""bad SOS"",""Corrupt JPEG"");
         if (z->succ_high != 0 || z->succ_low != 0) return stbi__err(""bad SOS"",""Corrupt JPEG"");
         z->spec_end = 63;
      }
   }

   return 1;
}","{'begin': {'line': 3203, 'column': 1}, 'end': {'line': 3240, 'column': 2}}",show_image.c,"['处理', 'JPEG', '扫描', '头', '并', '验证', '参数', '合法', '合法性']"
625,625,stbi__resample_row_generic,stbi_uc *,"stbi_uc * stbi__resample_row_generic(stbi_uc * out, stbi_uc * in_near, stbi_uc * in_far, int w, int hs)","[{'name': 'out', 'type': 'stbi_uc *'}, {'name': 'in_near', 'type': 'stbi_uc *'}, {'name': 'in_far', 'type': 'stbi_uc *'}, {'name': 'w', 'type': 'int'}, {'name': 'hs', 'type': 'int'}]",使用最近邻插值对行进行重采样,"static stbi_uc *stbi__resample_row_generic(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // resample with nearest-neighbor
   int i,j;
   STBI_NOTUSED(in_far);
   for (i=0; i < w; ++i)
      for (j=0; j < hs; ++j)
         out[i*hs+j] = in_near[i];
   return out;
}","{'begin': {'line': 3646, 'column': 1}, 'end': {'line': 3655, 'column': 2}}",show_image.c,"['使用', '最近', '邻', '插值', '对行', '进行', '重', '采样']"
626,626,stbi__YCbCr_to_RGB_row,void,"void stbi__YCbCr_to_RGB_row(stbi_uc * out, const stbi_uc * y, const stbi_uc * pcb, const stbi_uc * pcr, int count, int step)","[{'name': 'out', 'type': 'stbi_uc *'}, {'name': 'y', 'type': 'const stbi_uc *'}, {'name': 'pcb', 'type': 'const stbi_uc *'}, {'name': 'pcr', 'type': 'const stbi_uc *'}, {'name': 'count', 'type': 'int'}, {'name': 'step', 'type': 'int'}]",将YCbCr颜色数据转换为RGB格式的行处理函数,"static void stbi__YCbCr_to_RGB_row(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step)
{
   int i;
   for (i=0; i < count; ++i) {
      int y_fixed = (y[i] << 20) + (1<<19); // rounding
      int r,g,b;
      int cr = pcr[i] - 128;
      int cb = pcb[i] - 128;
      r = y_fixed +  cr* stbi__float2fixed(1.40200f);
      g = y_fixed + (cr*-stbi__float2fixed(0.71414f)) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);
      b = y_fixed                                     +   cb* stbi__float2fixed(1.77200f);
      r >>= 20;
      g >>= 20;
      b >>= 20;
      if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }
      if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }
      if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }
      out[0] = (stbi_uc)r;
      out[1] = (stbi_uc)g;
      out[2] = (stbi_uc)b;
      out[3] = 255;
      out += step;
   }
}","{'begin': {'line': 3660, 'column': 1}, 'end': {'line': 3683, 'column': 2}}",show_image.c,"['将', 'YCbCr', '颜色', '数据', '转换', '为', 'RGB', '格式', '的', '行', '处理', '函数', '处理函数']"
627,627,stbi__free_jpeg_components,int,"int stbi__free_jpeg_components(stbi__jpeg * z, int ncomp, int why)","[{'name': 'z', 'type': 'stbi__jpeg *'}, {'name': 'ncomp', 'type': 'int'}, {'name': 'why', 'type': 'int'}]",释放JPEG组件内存资源,"static int stbi__free_jpeg_components(stbi__jpeg *z, int ncomp, int why)
{
   int i;
   for (i=0; i < ncomp; ++i) {
      if (z->img_comp[i].raw_data) {
         STBI_FREE(z->img_comp[i].raw_data);
         z->img_comp[i].raw_data = NULL;
         z->img_comp[i].data = NULL;
      }
      if (z->img_comp[i].raw_coeff) {
         STBI_FREE(z->img_comp[i].raw_coeff);
         z->img_comp[i].raw_coeff = 0;
         z->img_comp[i].coeff = 0;
      }
      if (z->img_comp[i].linebuf) {
         STBI_FREE(z->img_comp[i].linebuf);
         z->img_comp[i].linebuf = NULL;
      }
   }
   return why;
}","{'begin': {'line': 3242, 'column': 1}, 'end': {'line': 3262, 'column': 2}}",show_image.c,"['释放', 'JPEG', '组件', '内存', '资源']"
628,628,stbi__YCbCr_to_RGB_simd,void,"void stbi__YCbCr_to_RGB_simd(stbi_uc * out, const stbi_uc * y, const stbi_uc * pcb, const stbi_uc * pcr, int count, int step)","[{'name': 'out', 'type': 'stbi_uc *'}, {'name': 'y', 'type': 'const stbi_uc *'}, {'name': 'pcb', 'type': 'const stbi_uc *'}, {'name': 'pcr', 'type': 'const stbi_uc *'}, {'name': 'count', 'type': 'int'}, {'name': 'step', 'type': 'int'}]",使用SIMD优化将YCbCr转换为RGB，支持步长4的高效处理。,"static void stbi__YCbCr_to_RGB_simd(stbi_uc *out, stbi_uc const *y, stbi_uc const *pcb, stbi_uc const *pcr, int count, int step)
{
   int i = 0;

#ifdef STBI_SSE2
   // step == 3 is pretty ugly on the final interleave, and i'm not convinced
   // it's useful in practice (you wouldn't use it for textures, for example).
   // so just accelerate step == 4 case.
   if (step == 4) {
      // this is a fairly straightforward implementation and not super-optimized.
      __m128i signflip  = _mm_set1_epi8(-0x80);
      __m128i cr_const0 = _mm_set1_epi16(   (short) ( 1.40200f*4096.0f+0.5f));
      __m128i cr_const1 = _mm_set1_epi16( - (short) ( 0.71414f*4096.0f+0.5f));
      __m128i cb_const0 = _mm_set1_epi16( - (short) ( 0.34414f*4096.0f+0.5f));
      __m128i cb_const1 = _mm_set1_epi16(   (short) ( 1.77200f*4096.0f+0.5f));
      __m128i y_bias = _mm_set1_epi8((char) (unsigned char) 128);
      __m128i xw = _mm_set1_epi16(255); // alpha channel

      for (; i+7 < count; i += 8) {
         // load
         __m128i y_bytes = _mm_loadl_epi64((__m128i *) (y+i));
         __m128i cr_bytes = _mm_loadl_epi64((__m128i *) (pcr+i));
         __m128i cb_bytes = _mm_loadl_epi64((__m128i *) (pcb+i));
         __m128i cr_biased = _mm_xor_si128(cr_bytes, signflip); // -128
         __m128i cb_biased = _mm_xor_si128(cb_bytes, signflip); // -128

         // unpack to short (and left-shift cr, cb by 8)
         __m128i yw  = _mm_unpacklo_epi8(y_bias, y_bytes);
         __m128i crw = _mm_unpacklo_epi8(_mm_setzero_si128(), cr_biased);
         __m128i cbw = _mm_unpacklo_epi8(_mm_setzero_si128(), cb_biased);

         // color transform
         __m128i yws = _mm_srli_epi16(yw, 4);
         __m128i cr0 = _mm_mulhi_epi16(cr_const0, crw);
         __m128i cb0 = _mm_mulhi_epi16(cb_const0, cbw);
         __m128i cb1 = _mm_mulhi_epi16(cbw, cb_const1);
         __m128i cr1 = _mm_mulhi_epi16(crw, cr_const1);
         __m128i rws = _mm_add_epi16(cr0, yws);
         __m128i gwt = _mm_add_epi16(cb0, yws);
         __m128i bws = _mm_add_epi16(yws, cb1);
         __m128i gws = _mm_add_epi16(gwt, cr1);

         // descale
         __m128i rw = _mm_srai_epi16(rws, 4);
         __m128i bw = _mm_srai_epi16(bws, 4);
         __m128i gw = _mm_srai_epi16(gws, 4);

         // back to byte, set up for transpose
         __m128i brb = _mm_packus_epi16(rw, bw);
         __m128i gxb = _mm_packus_epi16(gw, xw);

         // transpose to interleave channels
         __m128i t0 = _mm_unpacklo_epi8(brb, gxb);
         __m128i t1 = _mm_unpackhi_epi8(brb, gxb);
         __m128i o0 = _mm_unpacklo_epi16(t0, t1);
         __m128i o1 = _mm_unpackhi_epi16(t0, t1);

         // store
         _mm_storeu_si128((__m128i *) (out + 0), o0);
         _mm_storeu_si128((__m128i *) (out + 16), o1);
         out += 32;
      }
   }
#endif

#ifdef STBI_NEON
   // in this version, step=3 support would be easy to add. but is there demand?
   if (step == 4) {
      // this is a fairly straightforward implementation and not super-optimized.
      uint8x8_t signflip = vdup_n_u8(0x80);
      int16x8_t cr_const0 = vdupq_n_s16(   (short) ( 1.40200f*4096.0f+0.5f));
      int16x8_t cr_const1 = vdupq_n_s16( - (short) ( 0.71414f*4096.0f+0.5f));
      int16x8_t cb_const0 = vdupq_n_s16( - (short) ( 0.34414f*4096.0f+0.5f));
      int16x8_t cb_const1 = vdupq_n_s16(   (short) ( 1.77200f*4096.0f+0.5f));

      for (; i+7 < count; i += 8) {
         // load
         uint8x8_t y_bytes  = vld1_u8(y + i);
         uint8x8_t cr_bytes = vld1_u8(pcr + i);
         uint8x8_t cb_bytes = vld1_u8(pcb + i);
         int8x8_t cr_biased = vreinterpret_s8_u8(vsub_u8(cr_bytes, signflip));
         int8x8_t cb_biased = vreinterpret_s8_u8(vsub_u8(cb_bytes, signflip));

         // expand to s16
         int16x8_t yws = vreinterpretq_s16_u16(vshll_n_u8(y_bytes, 4));
         int16x8_t crw = vshll_n_s8(cr_biased, 7);
         int16x8_t cbw = vshll_n_s8(cb_biased, 7);

         // color transform
         int16x8_t cr0 = vqdmulhq_s16(crw, cr_const0);
         int16x8_t cb0 = vqdmulhq_s16(cbw, cb_const0);
         int16x8_t cr1 = vqdmulhq_s16(crw, cr_const1);
         int16x8_t cb1 = vqdmulhq_s16(cbw, cb_const1);
         int16x8_t rws = vaddq_s16(yws, cr0);
         int16x8_t gws = vaddq_s16(vaddq_s16(yws, cb0), cr1);
         int16x8_t bws = vaddq_s16(yws, cb1);

         // undo scaling, round, convert to byte
         uint8x8x4_t o;
         o.val[0] = vqrshrun_n_s16(rws, 4);
         o.val[1] = vqrshrun_n_s16(gws, 4);
         o.val[2] = vqrshrun_n_s16(bws, 4);
         o.val[3] = vdup_n_u8(255);

         // store, interleaving r/g/b/a
         vst4_u8(out, o);
         out += 8*4;
      }
   }
#endif

   for (; i < count; ++i) {
      int y_fixed = (y[i] << 20) + (1<<19); // rounding
      int r,g,b;
      int cr = pcr[i] - 128;
      int cb = pcb[i] - 128;
      r = y_fixed + cr* stbi__float2fixed(1.40200f);
      g = y_fixed + cr*-stbi__float2fixed(0.71414f) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);
      b = y_fixed                                   +   cb* stbi__float2fixed(1.77200f);
      r >>= 20;
      g >>= 20;
      b >>= 20;
      if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }
      if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }
      if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }
      out[0] = (stbi_uc)r;
      out[1] = (stbi_uc)g;
      out[2] = (stbi_uc)b;
      out[3] = 255;
      out += step;
   }
}","{'begin': {'line': 3686, 'column': 1}, 'end': {'line': 3817, 'column': 2}}",show_image.c,"['使用', 'SIMD', '优化', '将', 'YCbCr', '转换', '为', 'RGB', '，', '支持', '步长', '4', '的', '高效', '处理', '。']"
629,629,stbi__process_frame_header,int,"int stbi__process_frame_header(stbi__jpeg * z, int scan)","[{'name': 'z', 'type': 'stbi__jpeg *'}, {'name': 'scan', 'type': 'int'}]",解析JPEG帧头，验证参数并初始化组件,"static int stbi__process_frame_header(stbi__jpeg *z, int scan)
{
   stbi__context *s = z->s;
   int Lf,p,i,q, h_max=1,v_max=1,c;
   Lf = stbi__get16be(s);         if (Lf < 11) return stbi__err(""bad SOF len"",""Corrupt JPEG""); // JPEG
   p  = stbi__get8(s);            if (p != 8) return stbi__err(""only 8-bit"",""JPEG format not supported: 8-bit only""); // JPEG baseline
   s->img_y = stbi__get16be(s);   if (s->img_y == 0) return stbi__err(""no header height"", ""JPEG format not supported: delayed height""); // Legal, but we don't handle it--but neither does IJG
   s->img_x = stbi__get16be(s);   if (s->img_x == 0) return stbi__err(""0 width"",""Corrupt JPEG""); // JPEG requires
   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err(""too large"",""Very large image (corrupt?)"");
   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err(""too large"",""Very large image (corrupt?)"");
   c = stbi__get8(s);
   if (c != 3 && c != 1 && c != 4) return stbi__err(""bad component count"",""Corrupt JPEG"");
   s->img_n = c;
   for (i=0; i < c; ++i) {
      z->img_comp[i].data = NULL;
      z->img_comp[i].linebuf = NULL;
   }

   if (Lf != 8+3*s->img_n) return stbi__err(""bad SOF len"",""Corrupt JPEG"");

   z->rgb = 0;
   for (i=0; i < s->img_n; ++i) {
      static const unsigned char rgb[3] = { 'R', 'G', 'B' };
      z->img_comp[i].id = stbi__get8(s);
      if (s->img_n == 3 && z->img_comp[i].id == rgb[i])
         ++z->rgb;
      q = stbi__get8(s);
      z->img_comp[i].h = (q >> 4);  if (!z->img_comp[i].h || z->img_comp[i].h > 4) return stbi__err(""bad H"",""Corrupt JPEG"");
      z->img_comp[i].v = q & 15;    if (!z->img_comp[i].v || z->img_comp[i].v > 4) return stbi__err(""bad V"",""Corrupt JPEG"");
      z->img_comp[i].tq = stbi__get8(s);  if (z->img_comp[i].tq > 3) return stbi__err(""bad TQ"",""Corrupt JPEG"");
   }

   if (scan != STBI__SCAN_load) return 1;

   if (!stbi__mad3sizes_valid(s->img_x, s->img_y, s->img_n, 0)) return stbi__err(""too large"", ""Image too large to decode"");

   for (i=0; i < s->img_n; ++i) {
      if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h;
      if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v;
   }

   // check that plane subsampling factors are integer ratios; our resamplers can't deal with fractional ratios
   // and I've never seen a non-corrupted JPEG file actually use them
   for (i=0; i < s->img_n; ++i) {
      if (h_max % z->img_comp[i].h != 0) return stbi__err(""bad H"",""Corrupt JPEG"");
      if (v_max % z->img_comp[i].v != 0) return stbi__err(""bad V"",""Corrupt JPEG"");
   }

   // compute interleaved mcu info
   z->img_h_max = h_max;
   z->img_v_max = v_max;
   z->img_mcu_w = h_max * 8;
   z->img_mcu_h = v_max * 8;
   // these sizes can't be more than 17 bits
   z->img_mcu_x = (s->img_x + z->img_mcu_w-1) / z->img_mcu_w;
   z->img_mcu_y = (s->img_y + z->img_mcu_h-1) / z->img_mcu_h;

   for (i=0; i < s->img_n; ++i) {
      // number of effective pixels (e.g. for non-interleaved MCU)
      z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max-1) / h_max;
      z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max-1) / v_max;
      // to simplify generation, we'll allocate enough memory to decode
      // the bogus oversized data from using interleaved MCUs and their
      // big blocks (e.g. a 16x16 iMCU on an image of width 33); we won't
      // discard the extra data until colorspace conversion
      //
      // img_mcu_x, img_mcu_y: <=17 bits; comp[i].h and .v are <=4 (checked earlier)
      // so these muls can't overflow with 32-bit ints (which we require)
      z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8;
      z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8;
      z->img_comp[i].coeff = 0;
      z->img_comp[i].raw_coeff = 0;
      z->img_comp[i].linebuf = NULL;
      z->img_comp[i].raw_data = stbi__malloc_mad2(z->img_comp[i].w2, z->img_comp[i].h2, 15);
      if (z->img_comp[i].raw_data == NULL)
         return stbi__free_jpeg_components(z, i+1, stbi__err(""outofmem"", ""Out of memory""));
      // align blocks for idct using mmx/sse
      z->img_comp[i].data = (stbi_uc*) (((size_t) z->img_comp[i].raw_data + 15) & ~15);
      if (z->progressive) {
         // w2, h2 are multiples of 8 (see above)
         z->img_comp[i].coeff_w = z->img_comp[i].w2 / 8;
         z->img_comp[i].coeff_h = z->img_comp[i].h2 / 8;
         z->img_comp[i].raw_coeff = stbi__malloc_mad3(z->img_comp[i].w2, z->img_comp[i].h2, sizeof(short), 15);
         if (z->img_comp[i].raw_coeff == NULL)
            return stbi__free_jpeg_components(z, i+1, stbi__err(""outofmem"", ""Out of memory""));
         z->img_comp[i].coeff = (short*) (((size_t) z->img_comp[i].raw_coeff + 15) & ~15);
      }
   }

   return 1;
}","{'begin': {'line': 3264, 'column': 1}, 'end': {'line': 3354, 'column': 2}}",show_image.c,"['解析', 'JPEG', '帧', '头', '，', '验证', '参数', '并', '初始', '初始化', '组件']"
630,630,stbi__setup_jpeg,void,void stbi__setup_jpeg(stbi__jpeg * j),"[{'name': 'j', 'type': 'stbi__jpeg *'}]",配置JPEG解码函数指针，支持SIMD优化,"static void stbi__setup_jpeg(stbi__jpeg *j)
{
   j->idct_block_kernel = stbi__idct_block;
   j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_row;
   j->resample_row_hv_2_kernel = stbi__resample_row_hv_2;

#ifdef STBI_SSE2
   if (stbi__sse2_available()) {
      j->idct_block_kernel = stbi__idct_simd;
      j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
      j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
   }
#endif

#ifdef STBI_NEON
   j->idct_block_kernel = stbi__idct_simd;
   j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
   j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
#endif
}","{'begin': {'line': 3821, 'column': 1}, 'end': {'line': 3840, 'column': 2}}",show_image.c,"['配置', 'JPEG', '解码', '函数', '指针', '函数指针', '，', '支持', 'SIMD', '优化']"
631,631,stbi__cleanup_jpeg,void,void stbi__cleanup_jpeg(stbi__jpeg * j),"[{'name': 'j', 'type': 'stbi__jpeg *'}]",清理JPEG解码资源，释放内存组件,"static void stbi__cleanup_jpeg(stbi__jpeg *j)
{
   stbi__free_jpeg_components(j, j->s->img_n, 0);
}","{'begin': {'line': 3843, 'column': 1}, 'end': {'line': 3846, 'column': 2}}",show_image.c,"['清理', 'JPEG', '解码', '资源', '，', '释放', '内存', '组件']"
632,632,stbi__blinn_8x8,stbi_uc,"stbi_uc stbi__blinn_8x8(stbi_uc x, stbi_uc y)","[{'name': 'x', 'type': 'stbi_uc'}, {'name': 'y', 'type': 'stbi_uc'}]",对两个8位颜色值执行Blinn混合运算，通过位操作优化计算,"static stbi_uc stbi__blinn_8x8(stbi_uc x, stbi_uc y)
{
   unsigned int t = x*y + 128;
   return (stbi_uc) ((t + (t >>8)) >> 8);
}","{'begin': {'line': 3859, 'column': 1}, 'end': {'line': 3863, 'column': 2}}",show_image.c,"['对', '两个', '8', '位', '颜色', '值', '执行', 'Blinn', '混合', '运算', '，', '通过', '操作', '位操作', '优化', '计算']"
633,633,load_jpeg_image,stbi_uc *,"stbi_uc * load_jpeg_image(stbi__jpeg * z, int * out_x, int * out_y, int * comp, int req_comp)","[{'name': 'z', 'type': 'stbi__jpeg *'}, {'name': 'out_x', 'type': 'int *'}, {'name': 'out_y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",解码JPEG图像并进行颜色转换与重采样,"static stbi_uc *load_jpeg_image(stbi__jpeg *z, int *out_x, int *out_y, int *comp, int req_comp)
{
   int n, decode_n, is_rgb;
   z->s->img_n = 0; // make stbi__cleanup_jpeg safe

   // validate req_comp
   if (req_comp < 0 || req_comp > 4) return stbi__errpuc(""bad req_comp"", ""Internal error"");

   // load a jpeg image from whichever source, but leave in YCbCr format
   if (!stbi__decode_jpeg_image(z)) { stbi__cleanup_jpeg(z); return NULL; }

   // determine actual number of components to generate
   n = req_comp ? req_comp : z->s->img_n >= 3 ? 3 : 1;

   is_rgb = z->s->img_n == 3 && (z->rgb == 3 || (z->app14_color_transform == 0 && !z->jfif));

   if (z->s->img_n == 3 && n < 3 && !is_rgb)
      decode_n = 1;
   else
      decode_n = z->s->img_n;

   // nothing to do if no components requested; check this now to avoid
   // accessing uninitialized coutput[0] later
   if (decode_n <= 0) { stbi__cleanup_jpeg(z); return NULL; }

   // resample and color-convert
   {
      int k;
      unsigned int i,j;
      stbi_uc *output;
      stbi_uc *coutput[4] = { NULL, NULL, NULL, NULL };

      stbi__resample res_comp[4];

      for (k=0; k < decode_n; ++k) {
         stbi__resample *r = &res_comp[k];

         // allocate line buffer big enough for upsampling off the edges
         // with upsample factor of 4
         z->img_comp[k].linebuf = (stbi_uc *) stbi__malloc(z->s->img_x + 3);
         if (!z->img_comp[k].linebuf) { stbi__cleanup_jpeg(z); return stbi__errpuc(""outofmem"", ""Out of memory""); }

         r->hs      = z->img_h_max / z->img_comp[k].h;
         r->vs      = z->img_v_max / z->img_comp[k].v;
         r->ystep   = r->vs >> 1;
         r->w_lores = (z->s->img_x + r->hs-1) / r->hs;
         r->ypos    = 0;
         r->line0   = r->line1 = z->img_comp[k].data;

         if      (r->hs == 1 && r->vs == 1) r->resample = resample_row_1;
         else if (r->hs == 1 && r->vs == 2) r->resample = stbi__resample_row_v_2;
         else if (r->hs == 2 && r->vs == 1) r->resample = stbi__resample_row_h_2;
         else if (r->hs == 2 && r->vs == 2) r->resample = z->resample_row_hv_2_kernel;
         else                               r->resample = stbi__resample_row_generic;
      }

      // can't error after this so, this is safe
      output = (stbi_uc *) stbi__malloc_mad3(n, z->s->img_x, z->s->img_y, 1);
      if (!output) { stbi__cleanup_jpeg(z); return stbi__errpuc(""outofmem"", ""Out of memory""); }

      // now go ahead and resample
      for (j=0; j < z->s->img_y; ++j) {
         stbi_uc *out = output + n * z->s->img_x * j;
         for (k=0; k < decode_n; ++k) {
            stbi__resample *r = &res_comp[k];
            int y_bot = r->ystep >= (r->vs >> 1);
            coutput[k] = r->resample(z->img_comp[k].linebuf,
                                     y_bot ? r->line1 : r->line0,
                                     y_bot ? r->line0 : r->line1,
                                     r->w_lores, r->hs);
            if (++r->ystep >= r->vs) {
               r->ystep = 0;
               r->line0 = r->line1;
               if (++r->ypos < z->img_comp[k].y)
                  r->line1 += z->img_comp[k].w2;
            }
         }
         if (n >= 3) {
            stbi_uc *y = coutput[0];
            if (z->s->img_n == 3) {
               if (is_rgb) {
                  for (i=0; i < z->s->img_x; ++i) {
                     out[0] = y[i];
                     out[1] = coutput[1][i];
                     out[2] = coutput[2][i];
                     out[3] = 255;
                     out += n;
                  }
               } else {
                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
               }
            } else if (z->s->img_n == 4) {
               if (z->app14_color_transform == 0) { // CMYK
                  for (i=0; i < z->s->img_x; ++i) {
                     stbi_uc m = coutput[3][i];
                     out[0] = stbi__blinn_8x8(coutput[0][i], m);
                     out[1] = stbi__blinn_8x8(coutput[1][i], m);
                     out[2] = stbi__blinn_8x8(coutput[2][i], m);
                     out[3] = 255;
                     out += n;
                  }
               } else if (z->app14_color_transform == 2) { // YCCK
                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
                  for (i=0; i < z->s->img_x; ++i) {
                     stbi_uc m = coutput[3][i];
                     out[0] = stbi__blinn_8x8(255 - out[0], m);
                     out[1] = stbi__blinn_8x8(255 - out[1], m);
                     out[2] = stbi__blinn_8x8(255 - out[2], m);
                     out += n;
                  }
               } else { // YCbCr + alpha?  Ignore the fourth channel for now
                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
               }
            } else
               for (i=0; i < z->s->img_x; ++i) {
                  out[0] = out[1] = out[2] = y[i];
                  out[3] = 255; // not used if n==3
                  out += n;
               }
         } else {
            if (is_rgb) {
               if (n == 1)
                  for (i=0; i < z->s->img_x; ++i)
                     *out++ = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
               else {
                  for (i=0; i < z->s->img_x; ++i, out += 2) {
                     out[0] = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
                     out[1] = 255;
                  }
               }
            } else if (z->s->img_n == 4 && z->app14_color_transform == 0) {
               for (i=0; i < z->s->img_x; ++i) {
                  stbi_uc m = coutput[3][i];
                  stbi_uc r = stbi__blinn_8x8(coutput[0][i], m);
                  stbi_uc g = stbi__blinn_8x8(coutput[1][i], m);
                  stbi_uc b = stbi__blinn_8x8(coutput[2][i], m);
                  out[0] = stbi__compute_y(r, g, b);
                  out[1] = 255;
                  out += n;
               }
            } else if (z->s->img_n == 4 && z->app14_color_transform == 2) {
               for (i=0; i < z->s->img_x; ++i) {
                  out[0] = stbi__blinn_8x8(255 - coutput[0][i], coutput[3][i]);
                  out[1] = 255;
                  out += n;
               }
            } else {
               stbi_uc *y = coutput[0];
               if (n == 1)
                  for (i=0; i < z->s->img_x; ++i) out[i] = y[i];
               else
                  for (i=0; i < z->s->img_x; ++i) { *out++ = y[i]; *out++ = 255; }
            }
         }
      }
      stbi__cleanup_jpeg(z);
      *out_x = z->s->img_x;
      *out_y = z->s->img_y;
      if (comp) *comp = z->s->img_n >= 3 ? 3 : 1; // report original components, not output
      return output;
   }
}","{'begin': {'line': 3865, 'column': 1}, 'end': {'line': 4026, 'column': 2}}",show_image.c,"['解码', 'JPEG', '图像', '并', '进行', '颜色', '转换', '与', '重', '采样']"
634,634,stbi__decode_jpeg_header,int,"int stbi__decode_jpeg_header(stbi__jpeg * z, int scan)","[{'name': 'z', 'type': 'stbi__jpeg *'}, {'name': 'scan', 'type': 'int'}]",解析JPEG头部信息并验证有效性,"static int stbi__decode_jpeg_header(stbi__jpeg *z, int scan)
{
   int m;
   z->jfif = 0;
   z->app14_color_transform = -1; // valid values are 0,1,2
   z->marker = STBI__MARKER_none; // initialize cached marker to empty
   m = stbi__get_marker(z);
   if (!stbi__SOI(m)) return stbi__err(""no SOI"",""Corrupt JPEG"");
   if (scan == STBI__SCAN_type) return 1;
   m = stbi__get_marker(z);
   while (!stbi__SOF(m)) {
      if (!stbi__process_marker(z,m)) return 0;
      m = stbi__get_marker(z);
      while (m == STBI__MARKER_none) {
         // some files have extra padding after their blocks, so ok, we'll scan
         if (stbi__at_eof(z->s)) return stbi__err(""no SOF"", ""Corrupt JPEG"");
         m = stbi__get_marker(z);
      }
   }
   z->progressive = stbi__SOF_progressive(m);
   if (!stbi__process_frame_header(z, scan)) return 0;
   return 1;
}","{'begin': {'line': 3365, 'column': 1}, 'end': {'line': 3387, 'column': 2}}",show_image.c,"['解析', 'JPEG', '头部', '信息', '并', '验证', '有效', '有效性']"
635,635,stbi__skip_jpeg_junk_at_end,stbi_uc,stbi_uc stbi__skip_jpeg_junk_at_end(stbi__jpeg * j),"[{'name': 'j', 'type': 'stbi__jpeg *'}]",跳过JPEG文件末尾的无效数据并检测有效标记,"static stbi_uc stbi__skip_jpeg_junk_at_end(stbi__jpeg *j)
{
   // some JPEGs have junk at end, skip over it but if we find what looks
   // like a valid marker, resume there
   while (!stbi__at_eof(j->s)) {
      stbi_uc x = stbi__get8(j->s);
      while (x == 0xff) { // might be a marker
         if (stbi__at_eof(j->s)) return STBI__MARKER_none;
         x = stbi__get8(j->s);
         if (x != 0x00 && x != 0xff) {
            // not a stuffed zero or lead-in to another marker, looks
            // like an actual marker, return it
            return x;
         }
         // stuffed zero has x=0 now which ends the loop, meaning we go
         // back to regular scan loop.
         // repeated 0xff keeps trying to read the next byte of the marker.
      }
   }
   return STBI__MARKER_none;
}","{'begin': {'line': 3389, 'column': 1}, 'end': {'line': 3409, 'column': 2}}",show_image.c,"['跳过', 'JPEG', '文件', '末尾', '的', '无效', '数据', '并', '检测', '有效', '标记']"
636,636,stbi__decode_jpeg_image,int,int stbi__decode_jpeg_image(stbi__jpeg * j),"[{'name': 'j', 'type': 'stbi__jpeg *'}]",解码JPEG图像数据，处理标记并支持渐进式解码,"static int stbi__decode_jpeg_image(stbi__jpeg *j)
{
   int m;
   for (m = 0; m < 4; m++) {
      j->img_comp[m].raw_data = NULL;
      j->img_comp[m].raw_coeff = NULL;
   }
   j->restart_interval = 0;
   if (!stbi__decode_jpeg_header(j, STBI__SCAN_load)) return 0;
   m = stbi__get_marker(j);
   while (!stbi__EOI(m)) {
      if (stbi__SOS(m)) {
         if (!stbi__process_scan_header(j)) return 0;
         if (!stbi__parse_entropy_coded_data(j)) return 0;
         if (j->marker == STBI__MARKER_none ) {
         j->marker = stbi__skip_jpeg_junk_at_end(j);
            // if we reach eof without hitting a marker, stbi__get_marker() below will fail and we'll eventually return 0
         }
         m = stbi__get_marker(j);
         if (STBI__RESTART(m))
            m = stbi__get_marker(j);
      } else if (stbi__DNL(m)) {
         int Ld = stbi__get16be(j->s);
         stbi__uint32 NL = stbi__get16be(j->s);
         if (Ld != 4) return stbi__err(""bad DNL len"", ""Corrupt JPEG"");
         if (NL != j->s->img_y) return stbi__err(""bad DNL height"", ""Corrupt JPEG"");
         m = stbi__get_marker(j);
      } else {
         if (!stbi__process_marker(j, m)) return 1;
         m = stbi__get_marker(j);
      }
   }
   if (j->progressive)
      stbi__jpeg_finish(j);
   return 1;
}","{'begin': {'line': 3412, 'column': 1}, 'end': {'line': 3447, 'column': 2}}",show_image.c,"['解码', 'JPEG', '图像', '数据', '，', '处理', '标记', '并', '支持', '渐进', '渐进式', '解码']"
637,637,resample_row_1,stbi_uc *,"stbi_uc * resample_row_1(stbi_uc * out, stbi_uc * in_near, stbi_uc * in_far, int w, int hs)","[{'name': 'out', 'type': 'stbi_uc *'}, {'name': 'in_near', 'type': 'stbi_uc *'}, {'name': 'in_far', 'type': 'stbi_uc *'}, {'name': 'w', 'type': 'int'}, {'name': 'hs', 'type': 'int'}]",直接返回输入中的邻近行数据,"static stbi_uc *resample_row_1(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   STBI_NOTUSED(out);
   STBI_NOTUSED(in_far);
   STBI_NOTUSED(w);
   STBI_NOTUSED(hs);
   return in_near;
}","{'begin': {'line': 3456, 'column': 1}, 'end': {'line': 3463, 'column': 2}}",show_image.c,"['直接', '返回', '输入', '中', '的', '邻近', '行', '数据']"
638,638,stbi__resample_row_v_2,stbi_uc *,"stbi_uc * stbi__resample_row_v_2(stbi_uc * out, stbi_uc * in_near, stbi_uc * in_far, int w, int hs)","[{'name': 'out', 'type': 'stbi_uc *'}, {'name': 'in_near', 'type': 'stbi_uc *'}, {'name': 'in_far', 'type': 'stbi_uc *'}, {'name': 'w', 'type': 'int'}, {'name': 'hs', 'type': 'int'}]",垂直双倍线性插值处理图像行,"static stbi_uc* stbi__resample_row_v_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // need to generate two samples vertically for every one in input
   int i;
   STBI_NOTUSED(hs);
   for (i=0; i < w; ++i)
      out[i] = stbi__div4(3*in_near[i] + in_far[i] + 2);
   return out;
}","{'begin': {'line': 3465, 'column': 1}, 'end': {'line': 3473, 'column': 2}}",show_image.c,"['垂直', '双倍', '线性', '插值', '线性插值', '处理', '图像', '行']"
639,639,stbi__resample_row_h_2,stbi_uc *,"stbi_uc * stbi__resample_row_h_2(stbi_uc * out, stbi_uc * in_near, stbi_uc * in_far, int w, int hs)","[{'name': 'out', 'type': 'stbi_uc *'}, {'name': 'in_near', 'type': 'stbi_uc *'}, {'name': 'in_far', 'type': 'stbi_uc *'}, {'name': 'w', 'type': 'int'}, {'name': 'hs', 'type': 'int'}]",水平双倍重采样，使用线性插值处理图像行,"static stbi_uc*  stbi__resample_row_h_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // need to generate two samples horizontally for every one in input
   int i;
   stbi_uc *input = in_near;

   if (w == 1) {
      // if only one sample, can't do any interpolation
      out[0] = out[1] = input[0];
      return out;
   }

   out[0] = input[0];
   out[1] = stbi__div4(input[0]*3 + input[1] + 2);
   for (i=1; i < w-1; ++i) {
      int n = 3*input[i]+2;
      out[i*2+0] = stbi__div4(n+input[i-1]);
      out[i*2+1] = stbi__div4(n+input[i+1]);
   }
   out[i*2+0] = stbi__div4(input[w-2]*3 + input[w-1] + 2);
   out[i*2+1] = input[w-1];

   STBI_NOTUSED(in_far);
   STBI_NOTUSED(hs);

   return out;
}","{'begin': {'line': 3475, 'column': 1}, 'end': {'line': 3501, 'column': 2}}",show_image.c,"['水平', '双倍', '重', '采样', '，', '使用', '线性', '插值', '线性插值', '处理', '图像', '行']"
640,640,stbi__jpeg_load,void *,"void * stbi__jpeg_load(stbi__context * s, int * x, int * y, int * comp, int req_comp, stbi__result_info * ri)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'ri', 'type': 'stbi__result_info *'}]",加载并解码JPEG图像数据,"static void *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   unsigned char* result;
   stbi__jpeg* j = (stbi__jpeg*) stbi__malloc(sizeof(stbi__jpeg));
   if (!j) return stbi__errpuc(""outofmem"", ""Out of memory"");
   memset(j, 0, sizeof(stbi__jpeg));
   STBI_NOTUSED(ri);
   j->s = s;
   stbi__setup_jpeg(j);
   result = load_jpeg_image(j, x,y,comp,req_comp);
   STBI_FREE(j);
   return result;
}","{'begin': {'line': 4028, 'column': 1}, 'end': {'line': 4040, 'column': 2}}",show_image.c,"['加载', '并', '解码', 'JPEG', '图像', '数据']"
641,641,stbi__jpeg_test,int,int stbi__jpeg_test(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",检测输入是否为JPEG格式图像,"static int stbi__jpeg_test(stbi__context *s)
{
   int r;
   stbi__jpeg* j = (stbi__jpeg*)stbi__malloc(sizeof(stbi__jpeg));
   if (!j) return stbi__err(""outofmem"", ""Out of memory"");
   memset(j, 0, sizeof(stbi__jpeg));
   j->s = s;
   stbi__setup_jpeg(j);
   r = stbi__decode_jpeg_header(j, STBI__SCAN_type);
   stbi__rewind(s);
   STBI_FREE(j);
   return r;
}","{'begin': {'line': 4042, 'column': 1}, 'end': {'line': 4054, 'column': 2}}",show_image.c,"['检测', '输入', '是否', '为', 'JPEG', '格式', '图像']"
642,642,stbi__resample_row_hv_2,stbi_uc *,"stbi_uc * stbi__resample_row_hv_2(stbi_uc * out, stbi_uc * in_near, stbi_uc * in_far, int w, int hs)","[{'name': 'out', 'type': 'stbi_uc *'}, {'name': 'in_near', 'type': 'stbi_uc *'}, {'name': 'in_far', 'type': 'stbi_uc *'}, {'name': 'w', 'type': 'int'}, {'name': 'hs', 'type': 'int'}]",双线性插值实现双倍缩放的行重采样,"static stbi_uc *stbi__resample_row_hv_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // need to generate 2x2 samples for every one in input
   int i,t0,t1;
   if (w == 1) {
      out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);
      return out;
   }

   t1 = 3*in_near[0] + in_far[0];
   out[0] = stbi__div4(t1+2);
   for (i=1; i < w; ++i) {
      t0 = t1;
      t1 = 3*in_near[i]+in_far[i];
      out[i*2-1] = stbi__div16(3*t0 + t1 + 8);
      out[i*2  ] = stbi__div16(3*t1 + t0 + 8);
   }
   out[w*2-1] = stbi__div4(t1+2);

   STBI_NOTUSED(hs);

   return out;
}","{'begin': {'line': 3505, 'column': 1}, 'end': {'line': 3527, 'column': 2}}",show_image.c,"['双', '线性', '插值', '线性插值', '实现', '双倍', '缩放', '的', '行重', '采样']"
643,643,stbi__jpeg_info_raw,int,"int stbi__jpeg_info_raw(stbi__jpeg * j, int * x, int * y, int * comp)","[{'name': 'j', 'type': 'stbi__jpeg *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",解析JPEG图像尺寸和通道信息，返回成功状态,"static int stbi__jpeg_info_raw(stbi__jpeg *j, int *x, int *y, int *comp)
{
   if (!stbi__decode_jpeg_header(j, STBI__SCAN_header)) {
      stbi__rewind( j->s );
      return 0;
   }
   if (x) *x = j->s->img_x;
   if (y) *y = j->s->img_y;
   if (comp) *comp = j->s->img_n >= 3 ? 3 : 1;
   return 1;
}","{'begin': {'line': 4056, 'column': 1}, 'end': {'line': 4066, 'column': 2}}",show_image.c,"['解析', 'JPEG', '图像', '尺寸', '和', '通道', '信息', '，', '返回', '成功', '状态']"
644,644,stbi__jpeg_info,int,"int stbi__jpeg_info(stbi__context * s, int * x, int * y, int * comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",获取JPEG图像的尺寸和通道信息,"static int stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp)
{
   int result;
   stbi__jpeg* j = (stbi__jpeg*) (stbi__malloc(sizeof(stbi__jpeg)));
   if (!j) return stbi__err(""outofmem"", ""Out of memory"");
   memset(j, 0, sizeof(stbi__jpeg));
   j->s = s;
   result = stbi__jpeg_info_raw(j, x, y, comp);
   STBI_FREE(j);
   return result;
}","{'begin': {'line': 4068, 'column': 1}, 'end': {'line': 4078, 'column': 2}}",show_image.c,"['获取', 'JPEG', '图像', '的', '尺寸', '和', '通道', '信息']"
645,645,stbi__resample_row_hv_2_simd,stbi_uc *,"stbi_uc * stbi__resample_row_hv_2_simd(stbi_uc * out, stbi_uc * in_near, stbi_uc * in_far, int w, int hs)","[{'name': 'out', 'type': 'stbi_uc *'}, {'name': 'in_near', 'type': 'stbi_uc *'}, {'name': 'in_far', 'type': 'stbi_uc *'}, {'name': 'w', 'type': 'int'}, {'name': 'hs', 'type': 'int'}]",使用SIMD进行双倍行重采样,"static stbi_uc *stbi__resample_row_hv_2_simd(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // need to generate 2x2 samples for every one in input
   int i=0,t0,t1;

   if (w == 1) {
      out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);
      return out;
   }

   t1 = 3*in_near[0] + in_far[0];
   // process groups of 8 pixels for as long as we can.
   // note we can't handle the last pixel in a row in this loop
   // because we need to handle the filter boundary conditions.
   for (; i < ((w-1) & ~7); i += 8) {
#if defined(STBI_SSE2)
      // load and perform the vertical filtering pass
      // this uses 3*x + y = 4*x + (y - x)
      __m128i zero  = _mm_setzero_si128();
      __m128i farb  = _mm_loadl_epi64((__m128i *) (in_far + i));
      __m128i nearb = _mm_loadl_epi64((__m128i *) (in_near + i));
      __m128i farw  = _mm_unpacklo_epi8(farb, zero);
      __m128i nearw = _mm_unpacklo_epi8(nearb, zero);
      __m128i diff  = _mm_sub_epi16(farw, nearw);
      __m128i nears = _mm_slli_epi16(nearw, 2);
      __m128i curr  = _mm_add_epi16(nears, diff); // current row

      // horizontal filter works the same based on shifted vers of current
      // row. ""prev"" is current row shifted right by 1 pixel; we need to
      // insert the previous pixel value (from t1).
      // ""next"" is current row shifted left by 1 pixel, with first pixel
      // of next block of 8 pixels added in.
      __m128i prv0 = _mm_slli_si128(curr, 2);
      __m128i nxt0 = _mm_srli_si128(curr, 2);
      __m128i prev = _mm_insert_epi16(prv0, t1, 0);
      __m128i next = _mm_insert_epi16(nxt0, 3*in_near[i+8] + in_far[i+8], 7);

      // horizontal filter, polyphase implementation since it's convenient:
      // even pixels = 3*cur + prev = cur*4 + (prev - cur)
      // odd  pixels = 3*cur + next = cur*4 + (next - cur)
      // note the shared term.
      __m128i bias  = _mm_set1_epi16(8);
      __m128i curs = _mm_slli_epi16(curr, 2);
      __m128i prvd = _mm_sub_epi16(prev, curr);
      __m128i nxtd = _mm_sub_epi16(next, curr);
      __m128i curb = _mm_add_epi16(curs, bias);
      __m128i even = _mm_add_epi16(prvd, curb);
      __m128i odd  = _mm_add_epi16(nxtd, curb);

      // interleave even and odd pixels, then undo scaling.
      __m128i int0 = _mm_unpacklo_epi16(even, odd);
      __m128i int1 = _mm_unpackhi_epi16(even, odd);
      __m128i de0  = _mm_srli_epi16(int0, 4);
      __m128i de1  = _mm_srli_epi16(int1, 4);

      // pack and write output
      __m128i outv = _mm_packus_epi16(de0, de1);
      _mm_storeu_si128((__m128i *) (out + i*2), outv);
#elif defined(STBI_NEON)
      // load and perform the vertical filtering pass
      // this uses 3*x + y = 4*x + (y - x)
      uint8x8_t farb  = vld1_u8(in_far + i);
      uint8x8_t nearb = vld1_u8(in_near + i);
      int16x8_t diff  = vreinterpretq_s16_u16(vsubl_u8(farb, nearb));
      int16x8_t nears = vreinterpretq_s16_u16(vshll_n_u8(nearb, 2));
      int16x8_t curr  = vaddq_s16(nears, diff); // current row

      // horizontal filter works the same based on shifted vers of current
      // row. ""prev"" is current row shifted right by 1 pixel; we need to
      // insert the previous pixel value (from t1).
      // ""next"" is current row shifted left by 1 pixel, with first pixel
      // of next block of 8 pixels added in.
      int16x8_t prv0 = vextq_s16(curr, curr, 7);
      int16x8_t nxt0 = vextq_s16(curr, curr, 1);
      int16x8_t prev = vsetq_lane_s16(t1, prv0, 0);
      int16x8_t next = vsetq_lane_s16(3*in_near[i+8] + in_far[i+8], nxt0, 7);

      // horizontal filter, polyphase implementation since it's convenient:
      // even pixels = 3*cur + prev = cur*4 + (prev - cur)
      // odd  pixels = 3*cur + next = cur*4 + (next - cur)
      // note the shared term.
      int16x8_t curs = vshlq_n_s16(curr, 2);
      int16x8_t prvd = vsubq_s16(prev, curr);
      int16x8_t nxtd = vsubq_s16(next, curr);
      int16x8_t even = vaddq_s16(curs, prvd);
      int16x8_t odd  = vaddq_s16(curs, nxtd);

      // undo scaling and round, then store with even/odd phases interleaved
      uint8x8x2_t o;
      o.val[0] = vqrshrun_n_s16(even, 4);
      o.val[1] = vqrshrun_n_s16(odd,  4);
      vst2_u8(out + i*2, o);
#endif

      // ""previous"" value for next iter
      t1 = 3*in_near[i+7] + in_far[i+7];
   }

   t0 = t1;
   t1 = 3*in_near[i] + in_far[i];
   out[i*2] = stbi__div16(3*t1 + t0 + 8);

   for (++i; i < w; ++i) {
      t0 = t1;
      t1 = 3*in_near[i]+in_far[i];
      out[i*2-1] = stbi__div16(3*t0 + t1 + 8);
      out[i*2  ] = stbi__div16(3*t1 + t0 + 8);
   }
   out[w*2-1] = stbi__div4(t1+2);

   STBI_NOTUSED(hs);

   return out;
}","{'begin': {'line': 3530, 'column': 1}, 'end': {'line': 3643, 'column': 2}}",show_image.c,"['使用', 'SIMD', '进行', '双倍', '行重', '采样']"
646,646,stbi__bitreverse16,int,int stbi__bitreverse16(int n),"[{'name': 'n', 'type': 'int'}]",反转16位整数的比特位,"static int stbi__bitreverse16(int n)
{
  n = ((n & 0xAAAA) >>  1) | ((n & 0x5555) << 1);
  n = ((n & 0xCCCC) >>  2) | ((n & 0x3333) << 2);
  n = ((n & 0xF0F0) >>  4) | ((n & 0x0F0F) << 4);
  n = ((n & 0xFF00) >>  8) | ((n & 0x00FF) << 8);
  return n;
}","{'begin': {'line': 4107, 'column': 13}, 'end': {'line': 4114, 'column': 2}}",show_image.c,"['反转', '16', '位', '整数', '的', '比特', '位']"
647,647,stbi__bit_reverse,int,"int stbi__bit_reverse(int v, int bits)","[{'name': 'v', 'type': 'int'}, {'name': 'bits', 'type': 'int'}]",按指定位数反转二进制位,"static int stbi__bit_reverse(int v, int bits)
{
   STBI_ASSERT(bits <= 16);
   // to bit reverse n bits, reverse 16 and shift
   // e.g. 11 bits, bit reverse and shift away 5
   return stbi__bitreverse16(v) >> (16-bits);
}","{'begin': {'line': 4116, 'column': 13}, 'end': {'line': 4122, 'column': 2}}",show_image.c,"['按', '指定', '位数', '反转', '进制', '二进制', '二进制位']"
648,648,stbi__zbuild_huffman,int,"int stbi__zbuild_huffman(stbi__zhuffman * z, const stbi_uc * sizelist, int num)","[{'name': 'z', 'type': 'stbi__zhuffman *'}, {'name': 'sizelist', 'type': 'const stbi_uc *'}, {'name': 'num', 'type': 'int'}]",构建哈夫曼解码表用于数据解压,"static int stbi__zbuild_huffman(stbi__zhuffman *z, const stbi_uc *sizelist, int num)
{
   int i,k=0;
   int code, next_code[16], sizes[17];

   // DEFLATE spec for generating codes
   memset(sizes, 0, sizeof(sizes));
   memset(z->fast, 0, sizeof(z->fast));
   for (i=0; i < num; ++i)
      ++sizes[sizelist[i]];
   sizes[0] = 0;
   for (i=1; i < 16; ++i)
      if (sizes[i] > (1 << i))
         return stbi__err(""bad sizes"", ""Corrupt PNG"");
   code = 0;
   for (i=1; i < 16; ++i) {
      next_code[i] = code;
      z->firstcode[i] = (stbi__uint16) code;
      z->firstsymbol[i] = (stbi__uint16) k;
      code = (code + sizes[i]);
      if (sizes[i])
         if (code-1 >= (1 << i)) return stbi__err(""bad codelengths"",""Corrupt PNG"");
      z->maxcode[i] = code << (16-i); // preshift for inner loop
      code <<= 1;
      k += sizes[i];
   }
   z->maxcode[16] = 0x10000; // sentinel
   for (i=0; i < num; ++i) {
      int s = sizelist[i];
      if (s) {
         int c = next_code[s] - z->firstcode[s] + z->firstsymbol[s];
         stbi__uint16 fastv = (stbi__uint16) ((s << 9) | i);
         z->size [c] = (stbi_uc     ) s;
         z->value[c] = (stbi__uint16) i;
         if (s <= STBI__ZFAST_BITS) {
            int j = stbi__bit_reverse(next_code[s],s);
            while (j < (1 << STBI__ZFAST_BITS)) {
               z->fast[j] = fastv;
               j += (1 << s);
            }
         }
         ++next_code[s];
      }
   }
   return 1;
}","{'begin': {'line': 4124, 'column': 1}, 'end': {'line': 4169, 'column': 2}}",show_image.c,"['构建', '夫曼', '哈夫曼', '解码', '表', '用于', '数据', '解压']"
649,649,stbi__resample_row_generic,stbi_uc *,"stbi_uc * stbi__resample_row_generic(stbi_uc * out, stbi_uc * in_near, stbi_uc * in_far, int w, int hs)","[{'name': 'out', 'type': 'stbi_uc *'}, {'name': 'in_near', 'type': 'stbi_uc *'}, {'name': 'in_far', 'type': 'stbi_uc *'}, {'name': 'w', 'type': 'int'}, {'name': 'hs', 'type': 'int'}]",使用最近邻插值对图像行进行水平重采样,"static stbi_uc *stbi__resample_row_generic(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // resample with nearest-neighbor
   int i,j;
   STBI_NOTUSED(in_far);
   for (i=0; i < w; ++i)
      for (j=0; j < hs; ++j)
         out[i*hs+j] = in_near[i];
   return out;
}","{'begin': {'line': 3646, 'column': 1}, 'end': {'line': 3655, 'column': 2}}",show_image.c,"['使用', '最近', '邻', '插值', '对', '图像', '行', '进行', '水平', '重', '采样']"
650,650,stbi__YCbCr_to_RGB_row,void,"void stbi__YCbCr_to_RGB_row(stbi_uc * out, const stbi_uc * y, const stbi_uc * pcb, const stbi_uc * pcr, int count, int step)","[{'name': 'out', 'type': 'stbi_uc *'}, {'name': 'y', 'type': 'const stbi_uc *'}, {'name': 'pcb', 'type': 'const stbi_uc *'}, {'name': 'pcr', 'type': 'const stbi_uc *'}, {'name': 'count', 'type': 'int'}, {'name': 'step', 'type': 'int'}]",将YCbCr行数据转换为RGB格式,"static void stbi__YCbCr_to_RGB_row(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step)
{
   int i;
   for (i=0; i < count; ++i) {
      int y_fixed = (y[i] << 20) + (1<<19); // rounding
      int r,g,b;
      int cr = pcr[i] - 128;
      int cb = pcb[i] - 128;
      r = y_fixed +  cr* stbi__float2fixed(1.40200f);
      g = y_fixed + (cr*-stbi__float2fixed(0.71414f)) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);
      b = y_fixed                                     +   cb* stbi__float2fixed(1.77200f);
      r >>= 20;
      g >>= 20;
      b >>= 20;
      if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }
      if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }
      if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }
      out[0] = (stbi_uc)r;
      out[1] = (stbi_uc)g;
      out[2] = (stbi_uc)b;
      out[3] = 255;
      out += step;
   }
}","{'begin': {'line': 3660, 'column': 1}, 'end': {'line': 3683, 'column': 2}}",show_image.c,"['将', 'YCbCr', '行', '数据', '转换', '为', 'RGB', '格式']"
651,651,stbi__zeof,int,int stbi__zeof(stbi__zbuf * z),"[{'name': 'z', 'type': 'stbi__zbuf *'}]",通过比较缓冲区指针与结束位置，检测Z缓冲区是否已读取完毕,"static int stbi__zeof(stbi__zbuf *z)
{
   return (z->zbuffer >= z->zbuffer_end);
}","{'begin': {'line': 4192, 'column': 13}, 'end': {'line': 4195, 'column': 2}}",show_image.c,"['通过', '比较', '缓冲', '缓冲区', '指针', '与', '结束', '位置', '，', '检测', 'Z', '缓冲', '缓冲区', '是否', '已', '读取', '完毕']"
652,652,stbi__zget8,stbi_uc,stbi_uc stbi__zget8(stbi__zbuf * z),"[{'name': 'z', 'type': 'stbi__zbuf *'}]",从缓冲区读取下一个字节，若结束返回0,"static stbi_uc stbi__zget8(stbi__zbuf *z)
{
   return stbi__zeof(z) ? 0 : *z->zbuffer++;
}","{'begin': {'line': 4197, 'column': 13}, 'end': {'line': 4200, 'column': 2}}",show_image.c,"['从', '缓冲', '缓冲区', '读取', '下', '一个', '字节', '，', '若', '结束', '返回', '0']"
653,653,stbi__YCbCr_to_RGB_simd,void,"void stbi__YCbCr_to_RGB_simd(stbi_uc * out, const stbi_uc * y, const stbi_uc * pcb, const stbi_uc * pcr, int count, int step)","[{'name': 'out', 'type': 'stbi_uc *'}, {'name': 'y', 'type': 'const stbi_uc *'}, {'name': 'pcb', 'type': 'const stbi_uc *'}, {'name': 'pcr', 'type': 'const stbi_uc *'}, {'name': 'count', 'type': 'int'}, {'name': 'step', 'type': 'int'}]",使用SIMD优化将YCbCr转换为RGB，支持SSE2和NEON。,"static void stbi__YCbCr_to_RGB_simd(stbi_uc *out, stbi_uc const *y, stbi_uc const *pcb, stbi_uc const *pcr, int count, int step)
{
   int i = 0;

#ifdef STBI_SSE2
   // step == 3 is pretty ugly on the final interleave, and i'm not convinced
   // it's useful in practice (you wouldn't use it for textures, for example).
   // so just accelerate step == 4 case.
   if (step == 4) {
      // this is a fairly straightforward implementation and not super-optimized.
      __m128i signflip  = _mm_set1_epi8(-0x80);
      __m128i cr_const0 = _mm_set1_epi16(   (short) ( 1.40200f*4096.0f+0.5f));
      __m128i cr_const1 = _mm_set1_epi16( - (short) ( 0.71414f*4096.0f+0.5f));
      __m128i cb_const0 = _mm_set1_epi16( - (short) ( 0.34414f*4096.0f+0.5f));
      __m128i cb_const1 = _mm_set1_epi16(   (short) ( 1.77200f*4096.0f+0.5f));
      __m128i y_bias = _mm_set1_epi8((char) (unsigned char) 128);
      __m128i xw = _mm_set1_epi16(255); // alpha channel

      for (; i+7 < count; i += 8) {
         // load
         __m128i y_bytes = _mm_loadl_epi64((__m128i *) (y+i));
         __m128i cr_bytes = _mm_loadl_epi64((__m128i *) (pcr+i));
         __m128i cb_bytes = _mm_loadl_epi64((__m128i *) (pcb+i));
         __m128i cr_biased = _mm_xor_si128(cr_bytes, signflip); // -128
         __m128i cb_biased = _mm_xor_si128(cb_bytes, signflip); // -128

         // unpack to short (and left-shift cr, cb by 8)
         __m128i yw  = _mm_unpacklo_epi8(y_bias, y_bytes);
         __m128i crw = _mm_unpacklo_epi8(_mm_setzero_si128(), cr_biased);
         __m128i cbw = _mm_unpacklo_epi8(_mm_setzero_si128(), cb_biased);

         // color transform
         __m128i yws = _mm_srli_epi16(yw, 4);
         __m128i cr0 = _mm_mulhi_epi16(cr_const0, crw);
         __m128i cb0 = _mm_mulhi_epi16(cb_const0, cbw);
         __m128i cb1 = _mm_mulhi_epi16(cbw, cb_const1);
         __m128i cr1 = _mm_mulhi_epi16(crw, cr_const1);
         __m128i rws = _mm_add_epi16(cr0, yws);
         __m128i gwt = _mm_add_epi16(cb0, yws);
         __m128i bws = _mm_add_epi16(yws, cb1);
         __m128i gws = _mm_add_epi16(gwt, cr1);

         // descale
         __m128i rw = _mm_srai_epi16(rws, 4);
         __m128i bw = _mm_srai_epi16(bws, 4);
         __m128i gw = _mm_srai_epi16(gws, 4);

         // back to byte, set up for transpose
         __m128i brb = _mm_packus_epi16(rw, bw);
         __m128i gxb = _mm_packus_epi16(gw, xw);

         // transpose to interleave channels
         __m128i t0 = _mm_unpacklo_epi8(brb, gxb);
         __m128i t1 = _mm_unpackhi_epi8(brb, gxb);
         __m128i o0 = _mm_unpacklo_epi16(t0, t1);
         __m128i o1 = _mm_unpackhi_epi16(t0, t1);

         // store
         _mm_storeu_si128((__m128i *) (out + 0), o0);
         _mm_storeu_si128((__m128i *) (out + 16), o1);
         out += 32;
      }
   }
#endif

#ifdef STBI_NEON
   // in this version, step=3 support would be easy to add. but is there demand?
   if (step == 4) {
      // this is a fairly straightforward implementation and not super-optimized.
      uint8x8_t signflip = vdup_n_u8(0x80);
      int16x8_t cr_const0 = vdupq_n_s16(   (short) ( 1.40200f*4096.0f+0.5f));
      int16x8_t cr_const1 = vdupq_n_s16( - (short) ( 0.71414f*4096.0f+0.5f));
      int16x8_t cb_const0 = vdupq_n_s16( - (short) ( 0.34414f*4096.0f+0.5f));
      int16x8_t cb_const1 = vdupq_n_s16(   (short) ( 1.77200f*4096.0f+0.5f));

      for (; i+7 < count; i += 8) {
         // load
         uint8x8_t y_bytes  = vld1_u8(y + i);
         uint8x8_t cr_bytes = vld1_u8(pcr + i);
         uint8x8_t cb_bytes = vld1_u8(pcb + i);
         int8x8_t cr_biased = vreinterpret_s8_u8(vsub_u8(cr_bytes, signflip));
         int8x8_t cb_biased = vreinterpret_s8_u8(vsub_u8(cb_bytes, signflip));

         // expand to s16
         int16x8_t yws = vreinterpretq_s16_u16(vshll_n_u8(y_bytes, 4));
         int16x8_t crw = vshll_n_s8(cr_biased, 7);
         int16x8_t cbw = vshll_n_s8(cb_biased, 7);

         // color transform
         int16x8_t cr0 = vqdmulhq_s16(crw, cr_const0);
         int16x8_t cb0 = vqdmulhq_s16(cbw, cb_const0);
         int16x8_t cr1 = vqdmulhq_s16(crw, cr_const1);
         int16x8_t cb1 = vqdmulhq_s16(cbw, cb_const1);
         int16x8_t rws = vaddq_s16(yws, cr0);
         int16x8_t gws = vaddq_s16(vaddq_s16(yws, cb0), cr1);
         int16x8_t bws = vaddq_s16(yws, cb1);

         // undo scaling, round, convert to byte
         uint8x8x4_t o;
         o.val[0] = vqrshrun_n_s16(rws, 4);
         o.val[1] = vqrshrun_n_s16(gws, 4);
         o.val[2] = vqrshrun_n_s16(bws, 4);
         o.val[3] = vdup_n_u8(255);

         // store, interleaving r/g/b/a
         vst4_u8(out, o);
         out += 8*4;
      }
   }
#endif

   for (; i < count; ++i) {
      int y_fixed = (y[i] << 20) + (1<<19); // rounding
      int r,g,b;
      int cr = pcr[i] - 128;
      int cb = pcb[i] - 128;
      r = y_fixed + cr* stbi__float2fixed(1.40200f);
      g = y_fixed + cr*-stbi__float2fixed(0.71414f) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);
      b = y_fixed                                   +   cb* stbi__float2fixed(1.77200f);
      r >>= 20;
      g >>= 20;
      b >>= 20;
      if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }
      if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }
      if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }
      out[0] = (stbi_uc)r;
      out[1] = (stbi_uc)g;
      out[2] = (stbi_uc)b;
      out[3] = 255;
      out += step;
   }
}","{'begin': {'line': 3686, 'column': 1}, 'end': {'line': 3817, 'column': 2}}",show_image.c,"['使用', 'SIMD', '优化', '将', 'YCbCr', '转换', '为', 'RGB', '，', '支持', 'SSE2', '和', 'NEON', '。']"
654,654,stbi__fill_bits,void,void stbi__fill_bits(stbi__zbuf * z),"[{'name': 'z', 'type': 'stbi__zbuf *'}]",填充位缓冲区，确保足够解码位数,"static void stbi__fill_bits(stbi__zbuf *z)
{
   do {
      if (z->code_buffer >= (1U << z->num_bits)) {
        z->zbuffer = z->zbuffer_end;  /* treat this as EOF so we fail. */
        return;
      }
      z->code_buffer |= (unsigned int) stbi__zget8(z) << z->num_bits;
      z->num_bits += 8;
   } while (z->num_bits <= 24);
}","{'begin': {'line': 4202, 'column': 1}, 'end': {'line': 4212, 'column': 2}}",show_image.c,"['填充', '位', '缓冲', '缓冲区', '，', '确保', '足够', '解码', '位数']"
655,655,stbi__zreceive,unsigned int,"unsigned int stbi__zreceive(stbi__zbuf * z, int n)","[{'name': 'z', 'type': 'stbi__zbuf *'}, {'name': 'n', 'type': 'int'}]",从压缩数据流接收n位数据,"static unsigned int stbi__zreceive(stbi__zbuf *z, int n)
{
   unsigned int k;
   if (z->num_bits < n) stbi__fill_bits(z);
   k = z->code_buffer & ((1 << n) - 1);
   z->code_buffer >>= n;
   z->num_bits -= n;
   return k;
}","{'begin': {'line': 4214, 'column': 13}, 'end': {'line': 4222, 'column': 2}}",show_image.c,"['从', '压缩', '数据', '数据流', '接收', 'n', '位', '数据']"
656,656,stbi__zhuffman_decode_slowpath,int,"int stbi__zhuffman_decode_slowpath(stbi__zbuf * a, stbi__zhuffman * z)","[{'name': 'a', 'type': 'stbi__zbuf *'}, {'name': 'z', 'type': 'stbi__zhuffman *'}]",通过慢路径解码霍夫曼编码，处理超出快速表的情况,"static int stbi__zhuffman_decode_slowpath(stbi__zbuf *a, stbi__zhuffman *z)
{
   int b,s,k;
   // not resolved by fast table, so compute it the slow way
   // use jpeg approach, which requires MSbits at top
   k = stbi__bit_reverse(a->code_buffer, 16);
   for (s=STBI__ZFAST_BITS+1; ; ++s)
      if (k < z->maxcode[s])
         break;
   if (s >= 16) return -1; // invalid code!
   // code size is s, so:
   b = (k >> (16-s)) - z->firstcode[s] + z->firstsymbol[s];
   if (b >= STBI__ZNSYMS) return -1; // some data was corrupt somewhere!
   if (z->size[b] != s) return -1;  // was originally an assert, but report failure instead.
   a->code_buffer >>= s;
   a->num_bits -= s;
   return z->value[b];
}","{'begin': {'line': 4224, 'column': 1}, 'end': {'line': 4241, 'column': 2}}",show_image.c,"['通过', '慢', '路径', '解码', '夫曼', '霍夫曼', '编码', '，', '处理', '超出', '快速', '表', '的', '情况']"
657,657,stbi__setup_jpeg,void,void stbi__setup_jpeg(stbi__jpeg * j),"[{'name': 'j', 'type': 'stbi__jpeg *'}]",配置JPEG解码器函数指针，支持硬件优化。,"static void stbi__setup_jpeg(stbi__jpeg *j)
{
   j->idct_block_kernel = stbi__idct_block;
   j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_row;
   j->resample_row_hv_2_kernel = stbi__resample_row_hv_2;

#ifdef STBI_SSE2
   if (stbi__sse2_available()) {
      j->idct_block_kernel = stbi__idct_simd;
      j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
      j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
   }
#endif

#ifdef STBI_NEON
   j->idct_block_kernel = stbi__idct_simd;
   j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
   j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
#endif
}","{'begin': {'line': 3821, 'column': 1}, 'end': {'line': 3840, 'column': 2}}",show_image.c,"['配置', 'JPEG', '解码', '码器', '解码器', '函数', '指针', '函数指针', '，', '支持', '硬件', '优化', '。']"
658,658,stbi__zhuffman_decode,int,"int stbi__zhuffman_decode(stbi__zbuf * a, stbi__zhuffman * z)","[{'name': 'a', 'type': 'stbi__zbuf *'}, {'name': 'z', 'type': 'stbi__zhuffman *'}]",使用快速表解码霍夫曼编码，失败时调用慢速路径,"static int stbi__zhuffman_decode(stbi__zbuf *a, stbi__zhuffman *z)
{
   int b,s;
   if (a->num_bits < 16) {
      if (stbi__zeof(a)) {
         if (!a->hit_zeof_once) {
            // This is the first time we hit eof, insert 16 extra padding btis
            // to allow us to keep going; if we actually consume any of them
            // though, that is invalid data. This is caught later.
            a->hit_zeof_once = 1;
            a->num_bits += 16; // add 16 implicit zero bits
         } else {
            // We already inserted our extra 16 padding bits and are again
            // out, this stream is actually prematurely terminated.
            return -1;
         }
      } else {
         stbi__fill_bits(a);
      }
   }
   b = z->fast[a->code_buffer & STBI__ZFAST_MASK];
   if (b) {
      s = b >> 9;
      a->code_buffer >>= s;
      a->num_bits -= s;
      return b & 511;
   }
   return stbi__zhuffman_decode_slowpath(a, z);
}","{'begin': {'line': 4243, 'column': 13}, 'end': {'line': 4271, 'column': 2}}",show_image.c,"['使用', '快速', '表', '解码', '夫曼', '霍夫曼', '编码', '，', '失败', '时', '调用', '慢速', '路径']"
659,659,stbi__cleanup_jpeg,void,void stbi__cleanup_jpeg(stbi__jpeg * j),"[{'name': 'j', 'type': 'stbi__jpeg *'}]",释放JPEG解码后的组件资源,"static void stbi__cleanup_jpeg(stbi__jpeg *j)
{
   stbi__free_jpeg_components(j, j->s->img_n, 0);
}","{'begin': {'line': 3843, 'column': 1}, 'end': {'line': 3846, 'column': 2}}",show_image.c,"['释放', 'JPEG', '解码', '后', '的', '组件', '资源']"
660,660,stbi__blinn_8x8,stbi_uc,"stbi_uc stbi__blinn_8x8(stbi_uc x, stbi_uc y)","[{'name': 'x', 'type': 'stbi_uc'}, {'name': 'y', 'type': 'stbi_uc'}]",通过乘法和位移实现8位颜色快速混合,"static stbi_uc stbi__blinn_8x8(stbi_uc x, stbi_uc y)
{
   unsigned int t = x*y + 128;
   return (stbi_uc) ((t + (t >>8)) >> 8);
}","{'begin': {'line': 3859, 'column': 1}, 'end': {'line': 3863, 'column': 2}}",show_image.c,"['通过', '乘法', '和', '位移', '实现', '8', '位', '颜色', '快速', '混合']"
661,661,load_jpeg_image,stbi_uc *,"stbi_uc * load_jpeg_image(stbi__jpeg * z, int * out_x, int * out_y, int * comp, int req_comp)","[{'name': 'z', 'type': 'stbi__jpeg *'}, {'name': 'out_x', 'type': 'int *'}, {'name': 'out_y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",解码JPEG图像，处理颜色转换并返回像素数据。,"static stbi_uc *load_jpeg_image(stbi__jpeg *z, int *out_x, int *out_y, int *comp, int req_comp)
{
   int n, decode_n, is_rgb;
   z->s->img_n = 0; // make stbi__cleanup_jpeg safe

   // validate req_comp
   if (req_comp < 0 || req_comp > 4) return stbi__errpuc(""bad req_comp"", ""Internal error"");

   // load a jpeg image from whichever source, but leave in YCbCr format
   if (!stbi__decode_jpeg_image(z)) { stbi__cleanup_jpeg(z); return NULL; }

   // determine actual number of components to generate
   n = req_comp ? req_comp : z->s->img_n >= 3 ? 3 : 1;

   is_rgb = z->s->img_n == 3 && (z->rgb == 3 || (z->app14_color_transform == 0 && !z->jfif));

   if (z->s->img_n == 3 && n < 3 && !is_rgb)
      decode_n = 1;
   else
      decode_n = z->s->img_n;

   // nothing to do if no components requested; check this now to avoid
   // accessing uninitialized coutput[0] later
   if (decode_n <= 0) { stbi__cleanup_jpeg(z); return NULL; }

   // resample and color-convert
   {
      int k;
      unsigned int i,j;
      stbi_uc *output;
      stbi_uc *coutput[4] = { NULL, NULL, NULL, NULL };

      stbi__resample res_comp[4];

      for (k=0; k < decode_n; ++k) {
         stbi__resample *r = &res_comp[k];

         // allocate line buffer big enough for upsampling off the edges
         // with upsample factor of 4
         z->img_comp[k].linebuf = (stbi_uc *) stbi__malloc(z->s->img_x + 3);
         if (!z->img_comp[k].linebuf) { stbi__cleanup_jpeg(z); return stbi__errpuc(""outofmem"", ""Out of memory""); }

         r->hs      = z->img_h_max / z->img_comp[k].h;
         r->vs      = z->img_v_max / z->img_comp[k].v;
         r->ystep   = r->vs >> 1;
         r->w_lores = (z->s->img_x + r->hs-1) / r->hs;
         r->ypos    = 0;
         r->line0   = r->line1 = z->img_comp[k].data;

         if      (r->hs == 1 && r->vs == 1) r->resample = resample_row_1;
         else if (r->hs == 1 && r->vs == 2) r->resample = stbi__resample_row_v_2;
         else if (r->hs == 2 && r->vs == 1) r->resample = stbi__resample_row_h_2;
         else if (r->hs == 2 && r->vs == 2) r->resample = z->resample_row_hv_2_kernel;
         else                               r->resample = stbi__resample_row_generic;
      }

      // can't error after this so, this is safe
      output = (stbi_uc *) stbi__malloc_mad3(n, z->s->img_x, z->s->img_y, 1);
      if (!output) { stbi__cleanup_jpeg(z); return stbi__errpuc(""outofmem"", ""Out of memory""); }

      // now go ahead and resample
      for (j=0; j < z->s->img_y; ++j) {
         stbi_uc *out = output + n * z->s->img_x * j;
         for (k=0; k < decode_n; ++k) {
            stbi__resample *r = &res_comp[k];
            int y_bot = r->ystep >= (r->vs >> 1);
            coutput[k] = r->resample(z->img_comp[k].linebuf,
                                     y_bot ? r->line1 : r->line0,
                                     y_bot ? r->line0 : r->line1,
                                     r->w_lores, r->hs);
            if (++r->ystep >= r->vs) {
               r->ystep = 0;
               r->line0 = r->line1;
               if (++r->ypos < z->img_comp[k].y)
                  r->line1 += z->img_comp[k].w2;
            }
         }
         if (n >= 3) {
            stbi_uc *y = coutput[0];
            if (z->s->img_n == 3) {
               if (is_rgb) {
                  for (i=0; i < z->s->img_x; ++i) {
                     out[0] = y[i];
                     out[1] = coutput[1][i];
                     out[2] = coutput[2][i];
                     out[3] = 255;
                     out += n;
                  }
               } else {
                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
               }
            } else if (z->s->img_n == 4) {
               if (z->app14_color_transform == 0) { // CMYK
                  for (i=0; i < z->s->img_x; ++i) {
                     stbi_uc m = coutput[3][i];
                     out[0] = stbi__blinn_8x8(coutput[0][i], m);
                     out[1] = stbi__blinn_8x8(coutput[1][i], m);
                     out[2] = stbi__blinn_8x8(coutput[2][i], m);
                     out[3] = 255;
                     out += n;
                  }
               } else if (z->app14_color_transform == 2) { // YCCK
                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
                  for (i=0; i < z->s->img_x; ++i) {
                     stbi_uc m = coutput[3][i];
                     out[0] = stbi__blinn_8x8(255 - out[0], m);
                     out[1] = stbi__blinn_8x8(255 - out[1], m);
                     out[2] = stbi__blinn_8x8(255 - out[2], m);
                     out += n;
                  }
               } else { // YCbCr + alpha?  Ignore the fourth channel for now
                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
               }
            } else
               for (i=0; i < z->s->img_x; ++i) {
                  out[0] = out[1] = out[2] = y[i];
                  out[3] = 255; // not used if n==3
                  out += n;
               }
         } else {
            if (is_rgb) {
               if (n == 1)
                  for (i=0; i < z->s->img_x; ++i)
                     *out++ = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
               else {
                  for (i=0; i < z->s->img_x; ++i, out += 2) {
                     out[0] = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
                     out[1] = 255;
                  }
               }
            } else if (z->s->img_n == 4 && z->app14_color_transform == 0) {
               for (i=0; i < z->s->img_x; ++i) {
                  stbi_uc m = coutput[3][i];
                  stbi_uc r = stbi__blinn_8x8(coutput[0][i], m);
                  stbi_uc g = stbi__blinn_8x8(coutput[1][i], m);
                  stbi_uc b = stbi__blinn_8x8(coutput[2][i], m);
                  out[0] = stbi__compute_y(r, g, b);
                  out[1] = 255;
                  out += n;
               }
            } else if (z->s->img_n == 4 && z->app14_color_transform == 2) {
               for (i=0; i < z->s->img_x; ++i) {
                  out[0] = stbi__blinn_8x8(255 - coutput[0][i], coutput[3][i]);
                  out[1] = 255;
                  out += n;
               }
            } else {
               stbi_uc *y = coutput[0];
               if (n == 1)
                  for (i=0; i < z->s->img_x; ++i) out[i] = y[i];
               else
                  for (i=0; i < z->s->img_x; ++i) { *out++ = y[i]; *out++ = 255; }
            }
         }
      }
      stbi__cleanup_jpeg(z);
      *out_x = z->s->img_x;
      *out_y = z->s->img_y;
      if (comp) *comp = z->s->img_n >= 3 ? 3 : 1; // report original components, not output
      return output;
   }
}","{'begin': {'line': 3865, 'column': 1}, 'end': {'line': 4026, 'column': 2}}",show_image.c,"['解码', 'JPEG', '图像', '，', '处理', '颜色', '转换', '并', '返回', '像素', '数据', '。']"
662,662,stbi__zexpand,int,"int stbi__zexpand(stbi__zbuf * z, char * zout, int n)","[{'name': 'z', 'type': 'stbi__zbuf *'}, {'name': 'zout', 'type': 'char *'}, {'name': 'n', 'type': 'int'}]",动态扩展输出缓冲区内存以适应n字节数据,"static int stbi__zexpand(stbi__zbuf *z, char *zout, int n)  // need to make room for n bytes
{
   char *q;
   unsigned int cur, limit, old_limit;
   z->zout = zout;
   if (!z->z_expandable) return stbi__err(""output buffer limit"",""Corrupt PNG"");
   cur   = (unsigned int) (z->zout - z->zout_start);
   limit = old_limit = (unsigned) (z->zout_end - z->zout_start);
   if (UINT_MAX - cur < (unsigned) n) return stbi__err(""outofmem"", ""Out of memory"");
   while (cur + n > limit) {
      if(limit > UINT_MAX / 2) return stbi__err(""outofmem"", ""Out of memory"");
      limit *= 2;
   }
   q = (char *) STBI_REALLOC_SIZED(z->zout_start, old_limit, limit);
   STBI_NOTUSED(old_limit);
   if (q == NULL) return stbi__err(""outofmem"", ""Out of memory"");
   z->zout_start = q;
   z->zout       = q + cur;
   z->zout_end   = q + limit;
   return 1;
}","{'begin': {'line': 4273, 'column': 1}, 'end': {'line': 4293, 'column': 2}}",show_image.c,"['动态', '扩展', '输出', '缓冲', '缓冲区', '内存', '以', '适应', 'n', '字节', '数据']"
663,663,stbi__parse_huffman_block,int,int stbi__parse_huffman_block(stbi__zbuf * a),"[{'name': 'a', 'type': 'stbi__zbuf *'}]",解析霍夫曼编码块，实现数据解压,"static int stbi__parse_huffman_block(stbi__zbuf *a)
{
   char *zout = a->zout;
   for(;;) {
      int z = stbi__zhuffman_decode(a, &a->z_length);
      if (z < 256) {
         if (z < 0) return stbi__err(""bad huffman code"",""Corrupt PNG""); // error in huffman codes
         if (zout >= a->zout_end) {
            if (!stbi__zexpand(a, zout, 1)) return 0;
            zout = a->zout;
         }
         *zout++ = (char) z;
      } else {
         stbi_uc *p;
         int len,dist;
         if (z == 256) {
            a->zout = zout;
            if (a->hit_zeof_once && a->num_bits < 16) {
               // The first time we hit zeof, we inserted 16 extra zero bits into our bit
               // buffer so the decoder can just do its speculative decoding. But if we
               // actually consumed any of those bits (which is the case when num_bits < 16),
               // the stream actually read past the end so it is malformed.
               return stbi__err(""unexpected end"",""Corrupt PNG"");
            }
            return 1;
         }
         if (z >= 286) return stbi__err(""bad huffman code"",""Corrupt PNG""); // per DEFLATE, length codes 286 and 287 must not appear in compressed data
         z -= 257;
         len = stbi__zlength_base[z];
         if (stbi__zlength_extra[z]) len += stbi__zreceive(a, stbi__zlength_extra[z]);
         z = stbi__zhuffman_decode(a, &a->z_distance);
         if (z < 0 || z >= 30) return stbi__err(""bad huffman code"",""Corrupt PNG""); // per DEFLATE, distance codes 30 and 31 must not appear in compressed data
         dist = stbi__zdist_base[z];
         if (stbi__zdist_extra[z]) dist += stbi__zreceive(a, stbi__zdist_extra[z]);
         if (zout - a->zout_start < dist) return stbi__err(""bad dist"",""Corrupt PNG"");
         if (len > a->zout_end - zout) {
            if (!stbi__zexpand(a, zout, len)) return 0;
            zout = a->zout;
         }
         p = (stbi_uc *) (zout - dist);
         if (dist == 1) { // run of one byte; common in images.
            stbi_uc v = *p;
            if (len) { do *zout++ = v; while (--len); }
         } else {
            if (len) { do *zout++ = *p++; while (--len); }
         }
      }
   }
}","{'begin': {'line': 4309, 'column': 1}, 'end': {'line': 4357, 'column': 2}}",show_image.c,"['解析', '夫曼', '霍夫曼', '编码', '块', '，', '实现', '数据', '解压']"
664,664,stbi__compute_huffman_codes,int,int stbi__compute_huffman_codes(stbi__zbuf * a),"[{'name': 'a', 'type': 'stbi__zbuf *'}]",解析并构建霍夫曼编码表，用于解压缩数据,"static int stbi__compute_huffman_codes(stbi__zbuf *a)
{
   static const stbi_uc length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };
   stbi__zhuffman z_codelength;
   stbi_uc lencodes[286+32+137];//padding for maximum single op
   stbi_uc codelength_sizes[19];
   int i,n;

   int hlit  = stbi__zreceive(a,5) + 257;
   int hdist = stbi__zreceive(a,5) + 1;
   int hclen = stbi__zreceive(a,4) + 4;
   int ntot  = hlit + hdist;

   memset(codelength_sizes, 0, sizeof(codelength_sizes));
   for (i=0; i < hclen; ++i) {
      int s = stbi__zreceive(a,3);
      codelength_sizes[length_dezigzag[i]] = (stbi_uc) s;
   }
   if (!stbi__zbuild_huffman(&z_codelength, codelength_sizes, 19)) return 0;

   n = 0;
   while (n < ntot) {
      int c = stbi__zhuffman_decode(a, &z_codelength);
      if (c < 0 || c >= 19) return stbi__err(""bad codelengths"", ""Corrupt PNG"");
      if (c < 16)
         lencodes[n++] = (stbi_uc) c;
      else {
         stbi_uc fill = 0;
         if (c == 16) {
            c = stbi__zreceive(a,2)+3;
            if (n == 0) return stbi__err(""bad codelengths"", ""Corrupt PNG"");
            fill = lencodes[n-1];
         } else if (c == 17) {
            c = stbi__zreceive(a,3)+3;
         } else if (c == 18) {
            c = stbi__zreceive(a,7)+11;
         } else {
            return stbi__err(""bad codelengths"", ""Corrupt PNG"");
         }
         if (ntot - n < c) return stbi__err(""bad codelengths"", ""Corrupt PNG"");
         memset(lencodes+n, fill, c);
         n += c;
      }
   }
   if (n != ntot) return stbi__err(""bad codelengths"",""Corrupt PNG"");
   if (!stbi__zbuild_huffman(&a->z_length, lencodes, hlit)) return 0;
   if (!stbi__zbuild_huffman(&a->z_distance, lencodes+hlit, hdist)) return 0;
   return 1;
}","{'begin': {'line': 4359, 'column': 1}, 'end': {'line': 4407, 'column': 2}}",show_image.c,"['解析', '并', '构建', '夫曼', '霍夫曼', '编码', '表', '，', '用于', '解压', '压缩', '解压缩', '数据']"
665,665,stbi__parse_uncompressed_block,int,int stbi__parse_uncompressed_block(stbi__zbuf * a),"[{'name': 'a', 'type': 'stbi__zbuf *'}]",解析未压缩的zlib数据块并验证完整性,"static int stbi__parse_uncompressed_block(stbi__zbuf *a)
{
   stbi_uc header[4];
   int len,nlen,k;
   if (a->num_bits & 7)
      stbi__zreceive(a, a->num_bits & 7); // discard
   // drain the bit-packed data into header
   k = 0;
   while (a->num_bits > 0) {
      header[k++] = (stbi_uc) (a->code_buffer & 255); // suppress MSVC run-time check
      a->code_buffer >>= 8;
      a->num_bits -= 8;
   }
   if (a->num_bits < 0) return stbi__err(""zlib corrupt"",""Corrupt PNG"");
   // now fill header the normal way
   while (k < 4)
      header[k++] = stbi__zget8(a);
   len  = header[1] * 256 + header[0];
   nlen = header[3] * 256 + header[2];
   if (nlen != (len ^ 0xffff)) return stbi__err(""zlib corrupt"",""Corrupt PNG"");
   if (a->zbuffer + len > a->zbuffer_end) return stbi__err(""read past buffer"",""Corrupt PNG"");
   if (a->zout + len > a->zout_end)
      if (!stbi__zexpand(a, a->zout, len)) return 0;
   memcpy(a->zout, a->zbuffer, len);
   a->zbuffer += len;
   a->zout += len;
   return 1;
}","{'begin': {'line': 4409, 'column': 1}, 'end': {'line': 4436, 'column': 2}}",show_image.c,"['解析', '未', '压缩', '的', 'zlib', '数据', '块', '并', '验证', '完整', '完整性']"
666,666,stbi__parse_zlib_header,int,int stbi__parse_zlib_header(stbi__zbuf * a),"[{'name': 'a', 'type': 'stbi__zbuf *'}]",解析并验证zlib头信息，用于PNG处理,"static int stbi__parse_zlib_header(stbi__zbuf *a)
{
   int cmf   = stbi__zget8(a);
   int cm    = cmf & 15;
   /* int cinfo = cmf >> 4; */
   int flg   = stbi__zget8(a);
   if (stbi__zeof(a)) return stbi__err(""bad zlib header"",""Corrupt PNG""); // zlib spec
   if ((cmf*256+flg) % 31 != 0) return stbi__err(""bad zlib header"",""Corrupt PNG""); // zlib spec
   if (flg & 32) return stbi__err(""no preset dict"",""Corrupt PNG""); // preset dictionary not allowed in png
   if (cm != 8) return stbi__err(""bad compression"",""Corrupt PNG""); // DEFLATE required for png
   // window = 1 << (8 + cinfo)... but who cares, we fully buffer output
   return 1;
}","{'begin': {'line': 4438, 'column': 1}, 'end': {'line': 4450, 'column': 2}}",show_image.c,"['解析', '并', '验证', 'zlib', '头', '信息', '，', '用于', 'PNG', '处理']"
667,667,stbi__jpeg_load,void *,"void * stbi__jpeg_load(stbi__context * s, int * x, int * y, int * comp, int req_comp, stbi__result_info * ri)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'ri', 'type': 'stbi__result_info *'}]",加载JPEG图像到内存并解码,"static void *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   unsigned char* result;
   stbi__jpeg* j = (stbi__jpeg*) stbi__malloc(sizeof(stbi__jpeg));
   if (!j) return stbi__errpuc(""outofmem"", ""Out of memory"");
   memset(j, 0, sizeof(stbi__jpeg));
   STBI_NOTUSED(ri);
   j->s = s;
   stbi__setup_jpeg(j);
   result = load_jpeg_image(j, x,y,comp,req_comp);
   STBI_FREE(j);
   return result;
}","{'begin': {'line': 4028, 'column': 1}, 'end': {'line': 4040, 'column': 2}}",show_image.c,"['加载', 'JPEG', '图像', '到', '内存', '并', '解码']"
668,668,stbi__jpeg_test,int,int stbi__jpeg_test(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",检测输入是否为有效的JPEG图像,"static int stbi__jpeg_test(stbi__context *s)
{
   int r;
   stbi__jpeg* j = (stbi__jpeg*)stbi__malloc(sizeof(stbi__jpeg));
   if (!j) return stbi__err(""outofmem"", ""Out of memory"");
   memset(j, 0, sizeof(stbi__jpeg));
   j->s = s;
   stbi__setup_jpeg(j);
   r = stbi__decode_jpeg_header(j, STBI__SCAN_type);
   stbi__rewind(s);
   STBI_FREE(j);
   return r;
}","{'begin': {'line': 4042, 'column': 1}, 'end': {'line': 4054, 'column': 2}}",show_image.c,"['检测', '输入', '是否', '为', '有效', '的', 'JPEG', '图像']"
669,669,stbi__jpeg_info_raw,int,"int stbi__jpeg_info_raw(stbi__jpeg * j, int * x, int * y, int * comp)","[{'name': 'j', 'type': 'stbi__jpeg *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",解析JPEG头部信息并返回图像尺寸和通道数,"static int stbi__jpeg_info_raw(stbi__jpeg *j, int *x, int *y, int *comp)
{
   if (!stbi__decode_jpeg_header(j, STBI__SCAN_header)) {
      stbi__rewind( j->s );
      return 0;
   }
   if (x) *x = j->s->img_x;
   if (y) *y = j->s->img_y;
   if (comp) *comp = j->s->img_n >= 3 ? 3 : 1;
   return 1;
}","{'begin': {'line': 4056, 'column': 1}, 'end': {'line': 4066, 'column': 2}}",show_image.c,"['解析', 'JPEG', '头部', '信息', '并', '返回', '图像', '尺寸', '和', '通道', '数']"
670,670,stbi__jpeg_info,int,"int stbi__jpeg_info(stbi__context * s, int * x, int * y, int * comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",获取JPEG图片的尺寸和通道信息,"static int stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp)
{
   int result;
   stbi__jpeg* j = (stbi__jpeg*) (stbi__malloc(sizeof(stbi__jpeg)));
   if (!j) return stbi__err(""outofmem"", ""Out of memory"");
   memset(j, 0, sizeof(stbi__jpeg));
   j->s = s;
   result = stbi__jpeg_info_raw(j, x, y, comp);
   STBI_FREE(j);
   return result;
}","{'begin': {'line': 4068, 'column': 1}, 'end': {'line': 4078, 'column': 2}}",show_image.c,"['获取', 'JPEG', '图片', '的', '尺寸', '和', '通道', '信息']"
671,671,stbi__bitreverse16,int,int stbi__bitreverse16(int n),"[{'name': 'n', 'type': 'int'}]",反转16位整数的位顺序,"static int stbi__bitreverse16(int n)
{
  n = ((n & 0xAAAA) >>  1) | ((n & 0x5555) << 1);
  n = ((n & 0xCCCC) >>  2) | ((n & 0x3333) << 2);
  n = ((n & 0xF0F0) >>  4) | ((n & 0x0F0F) << 4);
  n = ((n & 0xFF00) >>  8) | ((n & 0x00FF) << 8);
  return n;
}","{'begin': {'line': 4107, 'column': 13}, 'end': {'line': 4114, 'column': 2}}",show_image.c,"['反转', '16', '位', '整数', '的', '位', '顺序']"
672,672,stbi__bit_reverse,int,"int stbi__bit_reverse(int v, int bits)","[{'name': 'v', 'type': 'int'}, {'name': 'bits', 'type': 'int'}]",按指定位数反转二进制位,"static int stbi__bit_reverse(int v, int bits)
{
   STBI_ASSERT(bits <= 16);
   // to bit reverse n bits, reverse 16 and shift
   // e.g. 11 bits, bit reverse and shift away 5
   return stbi__bitreverse16(v) >> (16-bits);
}","{'begin': {'line': 4116, 'column': 13}, 'end': {'line': 4122, 'column': 2}}",show_image.c,"['按', '指定', '位数', '反转', '进制', '二进制', '二进制位']"
673,673,stbi__parse_zlib,int,"int stbi__parse_zlib(stbi__zbuf * a, int parse_header)","[{'name': 'a', 'type': 'stbi__zbuf *'}, {'name': 'parse_header', 'type': 'int'}]",解析zlib压缩数据流，处理头部和压缩块。,"static int stbi__parse_zlib(stbi__zbuf *a, int parse_header)
{
   int final, type;
   if (parse_header)
      if (!stbi__parse_zlib_header(a)) return 0;
   a->num_bits = 0;
   a->code_buffer = 0;
   a->hit_zeof_once = 0;
   do {
      final = stbi__zreceive(a,1);
      type = stbi__zreceive(a,2);
      if (type == 0) {
         if (!stbi__parse_uncompressed_block(a)) return 0;
      } else if (type == 3) {
         return 0;
      } else {
         if (type == 1) {
            // use fixed code lengths
            if (!stbi__zbuild_huffman(&a->z_length  , stbi__zdefault_length  , STBI__ZNSYMS)) return 0;
            if (!stbi__zbuild_huffman(&a->z_distance, stbi__zdefault_distance,  32)) return 0;
         } else {
            if (!stbi__compute_huffman_codes(a)) return 0;
         }
         if (!stbi__parse_huffman_block(a)) return 0;
      }
   } while (!final);
   return 1;
}","{'begin': {'line': 4481, 'column': 1}, 'end': {'line': 4508, 'column': 2}}",show_image.c,"['解析', 'zlib', '压缩', '数据', '数据流', '，', '处理', '头部', '和', '压缩', '块', '。']"
674,674,stbi__zbuild_huffman,int,"int stbi__zbuild_huffman(stbi__zhuffman * z, const stbi_uc * sizelist, int num)","[{'name': 'z', 'type': 'stbi__zhuffman *'}, {'name': 'sizelist', 'type': 'const stbi_uc *'}, {'name': 'num', 'type': 'int'}]",构建哈夫曼解码表用于解压缩数据,"static int stbi__zbuild_huffman(stbi__zhuffman *z, const stbi_uc *sizelist, int num)
{
   int i,k=0;
   int code, next_code[16], sizes[17];

   // DEFLATE spec for generating codes
   memset(sizes, 0, sizeof(sizes));
   memset(z->fast, 0, sizeof(z->fast));
   for (i=0; i < num; ++i)
      ++sizes[sizelist[i]];
   sizes[0] = 0;
   for (i=1; i < 16; ++i)
      if (sizes[i] > (1 << i))
         return stbi__err(""bad sizes"", ""Corrupt PNG"");
   code = 0;
   for (i=1; i < 16; ++i) {
      next_code[i] = code;
      z->firstcode[i] = (stbi__uint16) code;
      z->firstsymbol[i] = (stbi__uint16) k;
      code = (code + sizes[i]);
      if (sizes[i])
         if (code-1 >= (1 << i)) return stbi__err(""bad codelengths"",""Corrupt PNG"");
      z->maxcode[i] = code << (16-i); // preshift for inner loop
      code <<= 1;
      k += sizes[i];
   }
   z->maxcode[16] = 0x10000; // sentinel
   for (i=0; i < num; ++i) {
      int s = sizelist[i];
      if (s) {
         int c = next_code[s] - z->firstcode[s] + z->firstsymbol[s];
         stbi__uint16 fastv = (stbi__uint16) ((s << 9) | i);
         z->size [c] = (stbi_uc     ) s;
         z->value[c] = (stbi__uint16) i;
         if (s <= STBI__ZFAST_BITS) {
            int j = stbi__bit_reverse(next_code[s],s);
            while (j < (1 << STBI__ZFAST_BITS)) {
               z->fast[j] = fastv;
               j += (1 << s);
            }
         }
         ++next_code[s];
      }
   }
   return 1;
}","{'begin': {'line': 4124, 'column': 1}, 'end': {'line': 4169, 'column': 2}}",show_image.c,"['构建', '夫曼', '哈夫曼', '解码', '表', '用于', '解压', '压缩', '解压缩', '数据']"
675,675,stbi__do_zlib,int,"int stbi__do_zlib(stbi__zbuf * a, char * obuf, int olen, int exp, int parse_header)","[{'name': 'a', 'type': 'stbi__zbuf *'}, {'name': 'obuf', 'type': 'char *'}, {'name': 'olen', 'type': 'int'}, {'name': 'exp', 'type': 'int'}, {'name': 'parse_header', 'type': 'int'}]",配置Zlib缓冲区并调用解压解析函数,"static int stbi__do_zlib(stbi__zbuf *a, char *obuf, int olen, int exp, int parse_header)
{
   a->zout_start = obuf;
   a->zout       = obuf;
   a->zout_end   = obuf + olen;
   a->z_expandable = exp;

   return stbi__parse_zlib(a, parse_header);
}","{'begin': {'line': 4510, 'column': 1}, 'end': {'line': 4518, 'column': 2}}",show_image.c,"['配置', 'Zlib', '缓冲', '缓冲区', '并', '调用', '解压', '解析', '函数']"
676,676,stbi_zlib_decode_malloc_guesssize,char *,"char * stbi_zlib_decode_malloc_guesssize(const char * buffer, int len, int initial_size, int * outlen)","[{'name': 'buffer', 'type': 'const char *'}, {'name': 'len', 'type': 'int'}, {'name': 'initial_size', 'type': 'int'}, {'name': 'outlen', 'type': 'int *'}]",使用猜测初始内存解压Zlib数据，返回解压结果,"STBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen)
{
   stbi__zbuf a;
   char *p = (char *) stbi__malloc(initial_size);
   if (p == NULL) return NULL;
   a.zbuffer = (stbi_uc *) buffer;
   a.zbuffer_end = (stbi_uc *) buffer + len;
   if (stbi__do_zlib(&a, p, initial_size, 1, 1)) {
      if (outlen) *outlen = (int) (a.zout - a.zout_start);
      return a.zout_start;
   } else {
      STBI_FREE(a.zout_start);
      return NULL;
   }
}","{'begin': {'line': 4520, 'column': 1}, 'end': {'line': 4534, 'column': 2}}",show_image.c,"['使用', '猜测', '初始', '内存', '解压', 'Zlib', '数据', '，', '返回', '解压', '结果']"
677,677,stbi_zlib_decode_malloc,char *,"char * stbi_zlib_decode_malloc(const char * buffer, int len, int * outlen)","[{'name': 'buffer', 'type': 'const char *'}, {'name': 'len', 'type': 'int'}, {'name': 'outlen', 'type': 'int *'}]",解压zlib数据到动态分配内存,"STBIDEF char *stbi_zlib_decode_malloc(char const *buffer, int len, int *outlen)
{
   return stbi_zlib_decode_malloc_guesssize(buffer, len, 16384, outlen);
}","{'begin': {'line': 4536, 'column': 1}, 'end': {'line': 4539, 'column': 2}}",show_image.c,"['解压', 'zlib', '数据', '到', '动态', '分配', '内存', '分配内存']"
678,678,stbi_zlib_decode_malloc_guesssize_headerflag,char *,"char * stbi_zlib_decode_malloc_guesssize_headerflag(const char * buffer, int len, int initial_size, int * outlen, int parse_header)","[{'name': 'buffer', 'type': 'const char *'}, {'name': 'len', 'type': 'int'}, {'name': 'initial_size', 'type': 'int'}, {'name': 'outlen', 'type': 'int *'}, {'name': 'parse_header', 'type': 'int'}]",使用zlib解压数据，动态分配内存并处理头部信息,"STBIDEF char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header)
{
   stbi__zbuf a;
   char *p = (char *) stbi__malloc(initial_size);
   if (p == NULL) return NULL;
   a.zbuffer = (stbi_uc *) buffer;
   a.zbuffer_end = (stbi_uc *) buffer + len;
   if (stbi__do_zlib(&a, p, initial_size, 1, parse_header)) {
      if (outlen) *outlen = (int) (a.zout - a.zout_start);
      return a.zout_start;
   } else {
      STBI_FREE(a.zout_start);
      return NULL;
   }
}","{'begin': {'line': 4541, 'column': 1}, 'end': {'line': 4555, 'column': 2}}",show_image.c,"['使用', 'zlib', '解压', '数据', '，', '动态', '分配', '内存', '分配内存', '并', '处理', '头部', '信息']"
679,679,stbi__zeof,int,int stbi__zeof(stbi__zbuf * z),"[{'name': 'z', 'type': 'stbi__zbuf *'}]",检查缓冲区是否已到末尾,"static int stbi__zeof(stbi__zbuf *z)
{
   return (z->zbuffer >= z->zbuffer_end);
}","{'begin': {'line': 4192, 'column': 13}, 'end': {'line': 4195, 'column': 2}}",show_image.c,"['检查', '缓冲', '缓冲区', '是否', '已到', '末尾']"
680,680,stbi__zget8,stbi_uc,stbi_uc stbi__zget8(stbi__zbuf * z),"[{'name': 'z', 'type': 'stbi__zbuf *'}]",从缓冲区读取下一个字节，若到末尾返回0,"static stbi_uc stbi__zget8(stbi__zbuf *z)
{
   return stbi__zeof(z) ? 0 : *z->zbuffer++;
}","{'begin': {'line': 4197, 'column': 13}, 'end': {'line': 4200, 'column': 2}}",show_image.c,"['从', '缓冲', '缓冲区', '读取', '下', '一个', '字节', '，', '若到', '末尾', '返回', '0']"
681,681,stbi__fill_bits,void,void stbi__fill_bits(stbi__zbuf * z),"[{'name': 'z', 'type': 'stbi__zbuf *'}]",填充位缓冲区至至少24位，用于解压数据流,"static void stbi__fill_bits(stbi__zbuf *z)
{
   do {
      if (z->code_buffer >= (1U << z->num_bits)) {
        z->zbuffer = z->zbuffer_end;  /* treat this as EOF so we fail. */
        return;
      }
      z->code_buffer |= (unsigned int) stbi__zget8(z) << z->num_bits;
      z->num_bits += 8;
   } while (z->num_bits <= 24);
}","{'begin': {'line': 4202, 'column': 1}, 'end': {'line': 4212, 'column': 2}}",show_image.c,"['填充', '位', '缓冲', '缓冲区', '至', '至少', '24', '位', '，', '用于', '解压', '数据', '数据流']"
682,682,stbi_zlib_decode_buffer,int,"int stbi_zlib_decode_buffer(char * obuffer, int olen, const char * ibuffer, int ilen)","[{'name': 'obuffer', 'type': 'char *'}, {'name': 'olen', 'type': 'int'}, {'name': 'ibuffer', 'type': 'const char *'}, {'name': 'ilen', 'type': 'int'}]",解压zlib数据到缓冲区，返回解压后长度或错误,"STBIDEF int stbi_zlib_decode_buffer(char *obuffer, int olen, char const *ibuffer, int ilen)
{
   stbi__zbuf a;
   a.zbuffer = (stbi_uc *) ibuffer;
   a.zbuffer_end = (stbi_uc *) ibuffer + ilen;
   if (stbi__do_zlib(&a, obuffer, olen, 0, 1))
      return (int) (a.zout - a.zout_start);
   else
      return -1;
}","{'begin': {'line': 4557, 'column': 1}, 'end': {'line': 4566, 'column': 2}}",show_image.c,"['解压', 'zlib', '数据', '到', '缓冲', '缓冲区', '，', '返回', '解压', '后', '长度', '或', '错误']"
683,683,stbi__zreceive,unsigned int,"unsigned int stbi__zreceive(stbi__zbuf * z, int n)","[{'name': 'z', 'type': 'stbi__zbuf *'}, {'name': 'n', 'type': 'int'}]",从压缩缓冲区接收n位数据,"static unsigned int stbi__zreceive(stbi__zbuf *z, int n)
{
   unsigned int k;
   if (z->num_bits < n) stbi__fill_bits(z);
   k = z->code_buffer & ((1 << n) - 1);
   z->code_buffer >>= n;
   z->num_bits -= n;
   return k;
}","{'begin': {'line': 4214, 'column': 13}, 'end': {'line': 4222, 'column': 2}}",show_image.c,"['从', '压缩', '缓冲', '缓冲区', '接收', 'n', '位', '数据']"
684,684,stbi_zlib_decode_noheader_malloc,char *,"char * stbi_zlib_decode_noheader_malloc(const char * buffer, int len, int * outlen)","[{'name': 'buffer', 'type': 'const char *'}, {'name': 'len', 'type': 'int'}, {'name': 'outlen', 'type': 'int *'}]",使用zlib解压无头数据并动态分配内存,"STBIDEF char *stbi_zlib_decode_noheader_malloc(char const *buffer, int len, int *outlen)
{
   stbi__zbuf a;
   char *p = (char *) stbi__malloc(16384);
   if (p == NULL) return NULL;
   a.zbuffer = (stbi_uc *) buffer;
   a.zbuffer_end = (stbi_uc *) buffer+len;
   if (stbi__do_zlib(&a, p, 16384, 1, 0)) {
      if (outlen) *outlen = (int) (a.zout - a.zout_start);
      return a.zout_start;
   } else {
      STBI_FREE(a.zout_start);
      return NULL;
   }
}","{'begin': {'line': 4568, 'column': 1}, 'end': {'line': 4582, 'column': 2}}",show_image.c,"['使用', 'zlib', '解压', '无头', '数据', '并', '动态', '分配', '内存', '分配内存']"
685,685,stbi__zhuffman_decode_slowpath,int,"int stbi__zhuffman_decode_slowpath(stbi__zbuf * a, stbi__zhuffman * z)","[{'name': 'a', 'type': 'stbi__zbuf *'}, {'name': 'z', 'type': 'stbi__zhuffman *'}]",使用慢路径解码霍夫曼编码，处理超出快速表的情况,"static int stbi__zhuffman_decode_slowpath(stbi__zbuf *a, stbi__zhuffman *z)
{
   int b,s,k;
   // not resolved by fast table, so compute it the slow way
   // use jpeg approach, which requires MSbits at top
   k = stbi__bit_reverse(a->code_buffer, 16);
   for (s=STBI__ZFAST_BITS+1; ; ++s)
      if (k < z->maxcode[s])
         break;
   if (s >= 16) return -1; // invalid code!
   // code size is s, so:
   b = (k >> (16-s)) - z->firstcode[s] + z->firstsymbol[s];
   if (b >= STBI__ZNSYMS) return -1; // some data was corrupt somewhere!
   if (z->size[b] != s) return -1;  // was originally an assert, but report failure instead.
   a->code_buffer >>= s;
   a->num_bits -= s;
   return z->value[b];
}","{'begin': {'line': 4224, 'column': 1}, 'end': {'line': 4241, 'column': 2}}",show_image.c,"['使用', '慢', '路径', '解码', '夫曼', '霍夫曼', '编码', '，', '处理', '超出', '快速', '表', '的', '情况']"
686,686,stbi_zlib_decode_noheader_buffer,int,"int stbi_zlib_decode_noheader_buffer(char * obuffer, int olen, const char * ibuffer, int ilen)","[{'name': 'obuffer', 'type': 'char *'}, {'name': 'olen', 'type': 'int'}, {'name': 'ibuffer', 'type': 'const char *'}, {'name': 'ilen', 'type': 'int'}]",无头zlib解压缓冲区数据,"STBIDEF int stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen)
{
   stbi__zbuf a;
   a.zbuffer = (stbi_uc *) ibuffer;
   a.zbuffer_end = (stbi_uc *) ibuffer + ilen;
   if (stbi__do_zlib(&a, obuffer, olen, 0, 0))
      return (int) (a.zout - a.zout_start);
   else
      return -1;
}","{'begin': {'line': 4584, 'column': 1}, 'end': {'line': 4593, 'column': 2}}",show_image.c,"['无头', 'zlib', '解压', '缓冲', '缓冲区', '数据']"
687,687,stbi__get_chunk_header,stbi__pngchunk,stbi__pngchunk stbi__get_chunk_header(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",读取PNG块头信息，包含长度和类型,"static stbi__pngchunk stbi__get_chunk_header(stbi__context *s)
{
   stbi__pngchunk c;
   c.length = stbi__get32be(s);
   c.type   = stbi__get32be(s);
   return c;
}","{'begin': {'line': 4613, 'column': 1}, 'end': {'line': 4619, 'column': 2}}",show_image.c,"['读取', 'PNG', '块头', '信息', '，', '包含', '长度', '和', '类型']"
688,688,stbi__zhuffman_decode,int,"int stbi__zhuffman_decode(stbi__zbuf * a, stbi__zhuffman * z)","[{'name': 'a', 'type': 'stbi__zbuf *'}, {'name': 'z', 'type': 'stbi__zhuffman *'}]",使用快速表解码霍夫曼编码，不足时调用慢路径,"static int stbi__zhuffman_decode(stbi__zbuf *a, stbi__zhuffman *z)
{
   int b,s;
   if (a->num_bits < 16) {
      if (stbi__zeof(a)) {
         if (!a->hit_zeof_once) {
            // This is the first time we hit eof, insert 16 extra padding btis
            // to allow us to keep going; if we actually consume any of them
            // though, that is invalid data. This is caught later.
            a->hit_zeof_once = 1;
            a->num_bits += 16; // add 16 implicit zero bits
         } else {
            // We already inserted our extra 16 padding bits and are again
            // out, this stream is actually prematurely terminated.
            return -1;
         }
      } else {
         stbi__fill_bits(a);
      }
   }
   b = z->fast[a->code_buffer & STBI__ZFAST_MASK];
   if (b) {
      s = b >> 9;
      a->code_buffer >>= s;
      a->num_bits -= s;
      return b & 511;
   }
   return stbi__zhuffman_decode_slowpath(a, z);
}","{'begin': {'line': 4243, 'column': 13}, 'end': {'line': 4271, 'column': 2}}",show_image.c,"['使用', '快速', '表', '解码', '夫曼', '霍夫曼', '编码', '，', '不足', '时', '调用', '慢', '路径']"
689,689,stbi__check_png_header,int,int stbi__check_png_header(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",验证输入是否为有效的PNG文件头,"static int stbi__check_png_header(stbi__context *s)
{
   static const stbi_uc png_sig[8] = { 137,80,78,71,13,10,26,10 };
   int i;
   for (i=0; i < 8; ++i)
      if (stbi__get8(s) != png_sig[i]) return stbi__err(""bad png sig"",""Not a PNG"");
   return 1;
}","{'begin': {'line': 4621, 'column': 1}, 'end': {'line': 4628, 'column': 2}}",show_image.c,"['验证', '输入', '是否', '为', '有效', '的', 'PNG', '文件', '头']"
690,690,stbi__paeth,int,"int stbi__paeth(int a, int b, int c)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}, {'name': 'c', 'type': 'int'}]",计算PNG的Paeth预测值，优化性能,"static int stbi__paeth(int a, int b, int c)
{
   // This formulation looks very different from the reference in the PNG spec, but is
   // actually equivalent and has favorable data dependencies and admits straightforward
   // generation of branch-free code, which helps performance significantly.
   int thresh = c*3 - (a + b);
   int lo = a < b ? a : b;
   int hi = a < b ? b : a;
   int t0 = (hi <= thresh) ? lo : c;
   int t1 = (thresh <= lo) ? hi : t0;
   return t1;
}","{'begin': {'line': 4657, 'column': 1}, 'end': {'line': 4668, 'column': 2}}",show_image.c,"['计算', 'PNG', '的', 'Paeth', '预测', '预测值', '，', '优化', '性能']"
691,691,stbi__zexpand,int,"int stbi__zexpand(stbi__zbuf * z, char * zout, int n)","[{'name': 'z', 'type': 'stbi__zbuf *'}, {'name': 'zout', 'type': 'char *'}, {'name': 'n', 'type': 'int'}]",动态扩展输出缓冲区，处理内存错误,"static int stbi__zexpand(stbi__zbuf *z, char *zout, int n)  // need to make room for n bytes
{
   char *q;
   unsigned int cur, limit, old_limit;
   z->zout = zout;
   if (!z->z_expandable) return stbi__err(""output buffer limit"",""Corrupt PNG"");
   cur   = (unsigned int) (z->zout - z->zout_start);
   limit = old_limit = (unsigned) (z->zout_end - z->zout_start);
   if (UINT_MAX - cur < (unsigned) n) return stbi__err(""outofmem"", ""Out of memory"");
   while (cur + n > limit) {
      if(limit > UINT_MAX / 2) return stbi__err(""outofmem"", ""Out of memory"");
      limit *= 2;
   }
   q = (char *) STBI_REALLOC_SIZED(z->zout_start, old_limit, limit);
   STBI_NOTUSED(old_limit);
   if (q == NULL) return stbi__err(""outofmem"", ""Out of memory"");
   z->zout_start = q;
   z->zout       = q + cur;
   z->zout_end   = q + limit;
   return 1;
}","{'begin': {'line': 4273, 'column': 1}, 'end': {'line': 4293, 'column': 2}}",show_image.c,"['动态', '扩展', '输出', '缓冲', '缓冲区', '，', '处理', '内存', '错误']"
692,692,stbi__create_png_alpha_expand8,void,"void stbi__create_png_alpha_expand8(stbi_uc * dest, stbi_uc * src, stbi__uint32 x, int img_n)","[{'name': 'dest', 'type': 'stbi_uc *'}, {'name': 'src', 'type': 'stbi_uc *'}, {'name': 'x', 'type': 'stbi__uint32'}, {'name': 'img_n', 'type': 'int'}]",将1或3通道图像扩展为带不透明Alpha的格式,"static void stbi__create_png_alpha_expand8(stbi_uc *dest, stbi_uc *src, stbi__uint32 x, int img_n)
{
   int i;
   // must process data backwards since we allow dest==src
   if (img_n == 1) {
      for (i=x-1; i >= 0; --i) {
         dest[i*2+1] = 255;
         dest[i*2+0] = src[i];
      }
   } else {
      STBI_ASSERT(img_n == 3);
      for (i=x-1; i >= 0; --i) {
         dest[i*4+3] = 255;
         dest[i*4+2] = src[i*3+2];
         dest[i*4+1] = src[i*3+1];
         dest[i*4+0] = src[i*3+0];
      }
   }
}","{'begin': {'line': 4675, 'column': 1}, 'end': {'line': 4693, 'column': 2}}",show_image.c,"['将', '1', '或', '3', '通道', '图像', '扩展', '为', '带', '不', '透明', 'Alpha', '的', '格式']"
693,693,stbi__parse_huffman_block,int,int stbi__parse_huffman_block(stbi__zbuf * a),"[{'name': 'a', 'type': 'stbi__zbuf *'}]",解析哈夫曼编码块，处理压缩数据流中的字面量和重复长度。,"static int stbi__parse_huffman_block(stbi__zbuf *a)
{
   char *zout = a->zout;
   for(;;) {
      int z = stbi__zhuffman_decode(a, &a->z_length);
      if (z < 256) {
         if (z < 0) return stbi__err(""bad huffman code"",""Corrupt PNG""); // error in huffman codes
         if (zout >= a->zout_end) {
            if (!stbi__zexpand(a, zout, 1)) return 0;
            zout = a->zout;
         }
         *zout++ = (char) z;
      } else {
         stbi_uc *p;
         int len,dist;
         if (z == 256) {
            a->zout = zout;
            if (a->hit_zeof_once && a->num_bits < 16) {
               // The first time we hit zeof, we inserted 16 extra zero bits into our bit
               // buffer so the decoder can just do its speculative decoding. But if we
               // actually consumed any of those bits (which is the case when num_bits < 16),
               // the stream actually read past the end so it is malformed.
               return stbi__err(""unexpected end"",""Corrupt PNG"");
            }
            return 1;
         }
         if (z >= 286) return stbi__err(""bad huffman code"",""Corrupt PNG""); // per DEFLATE, length codes 286 and 287 must not appear in compressed data
         z -= 257;
         len = stbi__zlength_base[z];
         if (stbi__zlength_extra[z]) len += stbi__zreceive(a, stbi__zlength_extra[z]);
         z = stbi__zhuffman_decode(a, &a->z_distance);
         if (z < 0 || z >= 30) return stbi__err(""bad huffman code"",""Corrupt PNG""); // per DEFLATE, distance codes 30 and 31 must not appear in compressed data
         dist = stbi__zdist_base[z];
         if (stbi__zdist_extra[z]) dist += stbi__zreceive(a, stbi__zdist_extra[z]);
         if (zout - a->zout_start < dist) return stbi__err(""bad dist"",""Corrupt PNG"");
         if (len > a->zout_end - zout) {
            if (!stbi__zexpand(a, zout, len)) return 0;
            zout = a->zout;
         }
         p = (stbi_uc *) (zout - dist);
         if (dist == 1) { // run of one byte; common in images.
            stbi_uc v = *p;
            if (len) { do *zout++ = v; while (--len); }
         } else {
            if (len) { do *zout++ = *p++; while (--len); }
         }
      }
   }
}","{'begin': {'line': 4309, 'column': 1}, 'end': {'line': 4357, 'column': 2}}",show_image.c,"['解析', '夫曼', '哈夫曼', '编码', '块', '，', '处理', '压缩', '数据', '数据流', '中', '的', '字面', '量', '和', '重复', '长度', '。']"
694,694,stbi__create_png_image_raw,int,"int stbi__create_png_image_raw(stbi__png * a, stbi_uc * raw, stbi__uint32 raw_len, int out_n, stbi__uint32 x, stbi__uint32 y, int depth, int color)","[{'name': 'a', 'type': 'stbi__png *'}, {'name': 'raw', 'type': 'stbi_uc *'}, {'name': 'raw_len', 'type': 'stbi__uint32'}, {'name': 'out_n', 'type': 'int'}, {'name': 'x', 'type': 'stbi__uint32'}, {'name': 'y', 'type': 'stbi__uint32'}, {'name': 'depth', 'type': 'int'}, {'name': 'color', 'type': 'int'}]",解码PNG原始数据，应用过滤器并转换位深。,"static int stbi__create_png_image_raw(stbi__png *a, stbi_uc *raw, stbi__uint32 raw_len, int out_n, stbi__uint32 x, stbi__uint32 y, int depth, int color)
{
   int bytes = (depth == 16 ? 2 : 1);
   stbi__context *s = a->s;
   stbi__uint32 i,j,stride = x*out_n*bytes;
   stbi__uint32 img_len, img_width_bytes;
   stbi_uc *filter_buf;
   int all_ok = 1;
   int k;
   int img_n = s->img_n; // copy it into a local for later

   int output_bytes = out_n*bytes;
   int filter_bytes = img_n*bytes;
   int width = x;

   STBI_ASSERT(out_n == s->img_n || out_n == s->img_n+1);
   a->out = (stbi_uc *) stbi__malloc_mad3(x, y, output_bytes, 0); // extra bytes to write off the end into
   if (!a->out) return stbi__err(""outofmem"", ""Out of memory"");

   // note: error exits here don't need to clean up a->out individually,
   // stbi__do_png always does on error.
   if (!stbi__mad3sizes_valid(img_n, x, depth, 7)) return stbi__err(""too large"", ""Corrupt PNG"");
   img_width_bytes = (((img_n * x * depth) + 7) >> 3);
   if (!stbi__mad2sizes_valid(img_width_bytes, y, img_width_bytes)) return stbi__err(""too large"", ""Corrupt PNG"");
   img_len = (img_width_bytes + 1) * y;

   // we used to check for exact match between raw_len and img_len on non-interlaced PNGs,
   // but issue #276 reported a PNG in the wild that had extra data at the end (all zeros),
   // so just check for raw_len < img_len always.
   if (raw_len < img_len) return stbi__err(""not enough pixels"",""Corrupt PNG"");

   // Allocate two scan lines worth of filter workspace buffer.
   filter_buf = (stbi_uc *) stbi__malloc_mad2(img_width_bytes, 2, 0);
   if (!filter_buf) return stbi__err(""outofmem"", ""Out of memory"");

   // Filtering for low-bit-depth images
   if (depth < 8) {
      filter_bytes = 1;
      width = img_width_bytes;
   }

   for (j=0; j < y; ++j) {
      // cur/prior filter buffers alternate
      stbi_uc *cur = filter_buf + (j & 1)*img_width_bytes;
      stbi_uc *prior = filter_buf + (~j & 1)*img_width_bytes;
      stbi_uc *dest = a->out + stride*j;
      int nk = width * filter_bytes;
      int filter = *raw++;

      // check filter type
      if (filter > 4) {
         all_ok = stbi__err(""invalid filter"",""Corrupt PNG"");
         break;
      }

      // if first row, use special filter that doesn't sample previous row
      if (j == 0) filter = first_row_filter[filter];

      // perform actual filtering
      switch (filter) {
      case STBI__F_none:
         memcpy(cur, raw, nk);
         break;
      case STBI__F_sub:
         memcpy(cur, raw, filter_bytes);
         for (k = filter_bytes; k < nk; ++k)
            cur[k] = STBI__BYTECAST(raw[k] + cur[k-filter_bytes]);
         break;
      case STBI__F_up:
         for (k = 0; k < nk; ++k)
            cur[k] = STBI__BYTECAST(raw[k] + prior[k]);
         break;
      case STBI__F_avg:
         for (k = 0; k < filter_bytes; ++k)
            cur[k] = STBI__BYTECAST(raw[k] + (prior[k]>>1));
         for (k = filter_bytes; k < nk; ++k)
            cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k-filter_bytes])>>1));
         break;
      case STBI__F_paeth:
         for (k = 0; k < filter_bytes; ++k)
            cur[k] = STBI__BYTECAST(raw[k] + prior[k]); // prior[k] == stbi__paeth(0,prior[k],0)
         for (k = filter_bytes; k < nk; ++k)
            cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes], prior[k], prior[k-filter_bytes]));
         break;
      case STBI__F_avg_first:
         memcpy(cur, raw, filter_bytes);
         for (k = filter_bytes; k < nk; ++k)
            cur[k] = STBI__BYTECAST(raw[k] + (cur[k-filter_bytes] >> 1));
         break;
      }

      raw += nk;

      // expand decoded bits in cur to dest, also adding an extra alpha channel if desired
      if (depth < 8) {
         stbi_uc scale = (color == 0) ? stbi__depth_scale_table[depth] : 1; // scale grayscale values to 0..255 range
         stbi_uc *in = cur;
         stbi_uc *out = dest;
         stbi_uc inb = 0;
         stbi__uint32 nsmp = x*img_n;

         // expand bits to bytes first
         if (depth == 4) {
            for (i=0; i < nsmp; ++i) {
               if ((i & 1) == 0) inb = *in++;
               *out++ = scale * (inb >> 4);
               inb <<= 4;
            }
         } else if (depth == 2) {
            for (i=0; i < nsmp; ++i) {
               if ((i & 3) == 0) inb = *in++;
               *out++ = scale * (inb >> 6);
               inb <<= 2;
            }
         } else {
            STBI_ASSERT(depth == 1);
            for (i=0; i < nsmp; ++i) {
               if ((i & 7) == 0) inb = *in++;
               *out++ = scale * (inb >> 7);
               inb <<= 1;
            }
         }

         // insert alpha=255 values if desired
         if (img_n != out_n)
            stbi__create_png_alpha_expand8(dest, dest, x, img_n);
      } else if (depth == 8) {
         if (img_n == out_n)
            memcpy(dest, cur, x*img_n);
         else
            stbi__create_png_alpha_expand8(dest, cur, x, img_n);
      } else if (depth == 16) {
         // convert the image data from big-endian to platform-native
         stbi__uint16 *dest16 = (stbi__uint16*)dest;
         stbi__uint32 nsmp = x*img_n;

         if (img_n == out_n) {
            for (i = 0; i < nsmp; ++i, ++dest16, cur += 2)
               *dest16 = (cur[0] << 8) | cur[1];
         } else {
            STBI_ASSERT(img_n+1 == out_n);
            if (img_n == 1) {
               for (i = 0; i < x; ++i, dest16 += 2, cur += 2) {
                  dest16[0] = (cur[0] << 8) | cur[1];
                  dest16[1] = 0xffff;
               }
            } else {
               STBI_ASSERT(img_n == 3);
               for (i = 0; i < x; ++i, dest16 += 4, cur += 6) {
                  dest16[0] = (cur[0] << 8) | cur[1];
                  dest16[1] = (cur[2] << 8) | cur[3];
                  dest16[2] = (cur[4] << 8) | cur[5];
                  dest16[3] = 0xffff;
               }
            }
         }
      }
   }

   STBI_FREE(filter_buf);
   if (!all_ok) return 0;

   return 1;
}","{'begin': {'line': 4696, 'column': 1}, 'end': {'line': 4859, 'column': 2}}",show_image.c,"['解码', 'PNG', '原始', '数据', '原始数据', '，', '应用', '过滤', '滤器', '过滤器', '并', '转换', '位深', '。']"
695,695,stbi__compute_huffman_codes,int,int stbi__compute_huffman_codes(stbi__zbuf * a),"[{'name': 'a', 'type': 'stbi__zbuf *'}]",解析并构建霍夫曼编码表用于数据解压,"static int stbi__compute_huffman_codes(stbi__zbuf *a)
{
   static const stbi_uc length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };
   stbi__zhuffman z_codelength;
   stbi_uc lencodes[286+32+137];//padding for maximum single op
   stbi_uc codelength_sizes[19];
   int i,n;

   int hlit  = stbi__zreceive(a,5) + 257;
   int hdist = stbi__zreceive(a,5) + 1;
   int hclen = stbi__zreceive(a,4) + 4;
   int ntot  = hlit + hdist;

   memset(codelength_sizes, 0, sizeof(codelength_sizes));
   for (i=0; i < hclen; ++i) {
      int s = stbi__zreceive(a,3);
      codelength_sizes[length_dezigzag[i]] = (stbi_uc) s;
   }
   if (!stbi__zbuild_huffman(&z_codelength, codelength_sizes, 19)) return 0;

   n = 0;
   while (n < ntot) {
      int c = stbi__zhuffman_decode(a, &z_codelength);
      if (c < 0 || c >= 19) return stbi__err(""bad codelengths"", ""Corrupt PNG"");
      if (c < 16)
         lencodes[n++] = (stbi_uc) c;
      else {
         stbi_uc fill = 0;
         if (c == 16) {
            c = stbi__zreceive(a,2)+3;
            if (n == 0) return stbi__err(""bad codelengths"", ""Corrupt PNG"");
            fill = lencodes[n-1];
         } else if (c == 17) {
            c = stbi__zreceive(a,3)+3;
         } else if (c == 18) {
            c = stbi__zreceive(a,7)+11;
         } else {
            return stbi__err(""bad codelengths"", ""Corrupt PNG"");
         }
         if (ntot - n < c) return stbi__err(""bad codelengths"", ""Corrupt PNG"");
         memset(lencodes+n, fill, c);
         n += c;
      }
   }
   if (n != ntot) return stbi__err(""bad codelengths"",""Corrupt PNG"");
   if (!stbi__zbuild_huffman(&a->z_length, lencodes, hlit)) return 0;
   if (!stbi__zbuild_huffman(&a->z_distance, lencodes+hlit, hdist)) return 0;
   return 1;
}","{'begin': {'line': 4359, 'column': 1}, 'end': {'line': 4407, 'column': 2}}",show_image.c,"['解析', '并', '构建', '夫曼', '霍夫曼', '编码', '表', '用于', '数据', '解压']"
696,696,stbi__parse_uncompressed_block,int,int stbi__parse_uncompressed_block(stbi__zbuf * a),"[{'name': 'a', 'type': 'stbi__zbuf *'}]",解析未压缩Zlib块并验证数据长度,"static int stbi__parse_uncompressed_block(stbi__zbuf *a)
{
   stbi_uc header[4];
   int len,nlen,k;
   if (a->num_bits & 7)
      stbi__zreceive(a, a->num_bits & 7); // discard
   // drain the bit-packed data into header
   k = 0;
   while (a->num_bits > 0) {
      header[k++] = (stbi_uc) (a->code_buffer & 255); // suppress MSVC run-time check
      a->code_buffer >>= 8;
      a->num_bits -= 8;
   }
   if (a->num_bits < 0) return stbi__err(""zlib corrupt"",""Corrupt PNG"");
   // now fill header the normal way
   while (k < 4)
      header[k++] = stbi__zget8(a);
   len  = header[1] * 256 + header[0];
   nlen = header[3] * 256 + header[2];
   if (nlen != (len ^ 0xffff)) return stbi__err(""zlib corrupt"",""Corrupt PNG"");
   if (a->zbuffer + len > a->zbuffer_end) return stbi__err(""read past buffer"",""Corrupt PNG"");
   if (a->zout + len > a->zout_end)
      if (!stbi__zexpand(a, a->zout, len)) return 0;
   memcpy(a->zout, a->zbuffer, len);
   a->zbuffer += len;
   a->zout += len;
   return 1;
}","{'begin': {'line': 4409, 'column': 1}, 'end': {'line': 4436, 'column': 2}}",show_image.c,"['解析', '未', '压缩', 'Zlib', '块', '并', '验证', '数据', '长度']"
697,697,stbi__parse_zlib_header,int,int stbi__parse_zlib_header(stbi__zbuf * a),"[{'name': 'a', 'type': 'stbi__zbuf *'}]",解析并验证zlib头，确保符合PNG规范,"static int stbi__parse_zlib_header(stbi__zbuf *a)
{
   int cmf   = stbi__zget8(a);
   int cm    = cmf & 15;
   /* int cinfo = cmf >> 4; */
   int flg   = stbi__zget8(a);
   if (stbi__zeof(a)) return stbi__err(""bad zlib header"",""Corrupt PNG""); // zlib spec
   if ((cmf*256+flg) % 31 != 0) return stbi__err(""bad zlib header"",""Corrupt PNG""); // zlib spec
   if (flg & 32) return stbi__err(""no preset dict"",""Corrupt PNG""); // preset dictionary not allowed in png
   if (cm != 8) return stbi__err(""bad compression"",""Corrupt PNG""); // DEFLATE required for png
   // window = 1 << (8 + cinfo)... but who cares, we fully buffer output
   return 1;
}","{'begin': {'line': 4438, 'column': 1}, 'end': {'line': 4450, 'column': 2}}",show_image.c,"['解析', '并', '验证', 'zlib', '头', '，', '确保', '符合', 'PNG', '规范']"
698,698,stbi__create_png_image,int,"int stbi__create_png_image(stbi__png * a, stbi_uc * image_data, stbi__uint32 image_data_len, int out_n, int depth, int color, int interlaced)","[{'name': 'a', 'type': 'stbi__png *'}, {'name': 'image_data', 'type': 'stbi_uc *'}, {'name': 'image_data_len', 'type': 'stbi__uint32'}, {'name': 'out_n', 'type': 'int'}, {'name': 'depth', 'type': 'int'}, {'name': 'color', 'type': 'int'}, {'name': 'interlaced', 'type': 'int'}]",解码PNG图像数据，处理隔行扫描,"static int stbi__create_png_image(stbi__png *a, stbi_uc *image_data, stbi__uint32 image_data_len, int out_n, int depth, int color, int interlaced)
{
   int bytes = (depth == 16 ? 2 : 1);
   int out_bytes = out_n * bytes;
   stbi_uc *final;
   int p;
   if (!interlaced)
      return stbi__create_png_image_raw(a, image_data, image_data_len, out_n, a->s->img_x, a->s->img_y, depth, color);

   // de-interlacing
   final = (stbi_uc *) stbi__malloc_mad3(a->s->img_x, a->s->img_y, out_bytes, 0);
   if (!final) return stbi__err(""outofmem"", ""Out of memory"");
   for (p=0; p < 7; ++p) {
      int xorig[] = { 0,4,0,2,0,1,0 };
      int yorig[] = { 0,0,4,0,2,0,1 };
      int xspc[]  = { 8,8,4,4,2,2,1 };
      int yspc[]  = { 8,8,8,4,4,2,2 };
      int i,j,x,y;
      // pass1_x[4] = 0, pass1_x[5] = 1, pass1_x[12] = 1
      x = (a->s->img_x - xorig[p] + xspc[p]-1) / xspc[p];
      y = (a->s->img_y - yorig[p] + yspc[p]-1) / yspc[p];
      if (x && y) {
         stbi__uint32 img_len = ((((a->s->img_n * x * depth) + 7) >> 3) + 1) * y;
         if (!stbi__create_png_image_raw(a, image_data, image_data_len, out_n, x, y, depth, color)) {
            STBI_FREE(final);
            return 0;
         }
         for (j=0; j < y; ++j) {
            for (i=0; i < x; ++i) {
               int out_y = j*yspc[p]+yorig[p];
               int out_x = i*xspc[p]+xorig[p];
               memcpy(final + out_y*a->s->img_x*out_bytes + out_x*out_bytes,
                      a->out + (j*x+i)*out_bytes, out_bytes);
            }
         }
         STBI_FREE(a->out);
         image_data += img_len;
         image_data_len -= img_len;
      }
   }
   a->out = final;

   return 1;
}","{'begin': {'line': 4861, 'column': 1}, 'end': {'line': 4904, 'column': 2}}",show_image.c,"['解码', 'PNG', '图像', '数据', '，', '处理', '隔行', '扫描', '隔行扫描']"
699,699,stbi__parse_zlib,int,"int stbi__parse_zlib(stbi__zbuf * a, int parse_header)","[{'name': 'a', 'type': 'stbi__zbuf *'}, {'name': 'parse_header', 'type': 'int'}]",解析Zlib数据流并解压各区块,"static int stbi__parse_zlib(stbi__zbuf *a, int parse_header)
{
   int final, type;
   if (parse_header)
      if (!stbi__parse_zlib_header(a)) return 0;
   a->num_bits = 0;
   a->code_buffer = 0;
   a->hit_zeof_once = 0;
   do {
      final = stbi__zreceive(a,1);
      type = stbi__zreceive(a,2);
      if (type == 0) {
         if (!stbi__parse_uncompressed_block(a)) return 0;
      } else if (type == 3) {
         return 0;
      } else {
         if (type == 1) {
            // use fixed code lengths
            if (!stbi__zbuild_huffman(&a->z_length  , stbi__zdefault_length  , STBI__ZNSYMS)) return 0;
            if (!stbi__zbuild_huffman(&a->z_distance, stbi__zdefault_distance,  32)) return 0;
         } else {
            if (!stbi__compute_huffman_codes(a)) return 0;
         }
         if (!stbi__parse_huffman_block(a)) return 0;
      }
   } while (!final);
   return 1;
}","{'begin': {'line': 4481, 'column': 1}, 'end': {'line': 4508, 'column': 2}}",show_image.c,"['解析', 'Zlib', '数据', '数据流', '并', '解压', '各区', '块']"
700,700,stbi__compute_transparency,int,"int stbi__compute_transparency(stbi__png * z, stbi_uc[3] tc, int out_n)","[{'name': 'z', 'type': 'stbi__png *'}, {'name': 'tc', 'type': 'stbi_uc[3]'}, {'name': 'out_n', 'type': 'int'}]",根据指定颜色值计算像素透明度，支持2/4通道输出,"static int stbi__compute_transparency(stbi__png *z, stbi_uc tc[3], int out_n)
{
   stbi__context *s = z->s;
   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
   stbi_uc *p = z->out;

   // compute color-based transparency, assuming we've
   // already got 255 as the alpha value in the output
   STBI_ASSERT(out_n == 2 || out_n == 4);

   if (out_n == 2) {
      for (i=0; i < pixel_count; ++i) {
         p[1] = (p[0] == tc[0] ? 0 : 255);
         p += 2;
      }
   } else {
      for (i=0; i < pixel_count; ++i) {
         if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
            p[3] = 0;
         p += 4;
      }
   }
   return 1;
}","{'begin': {'line': 4906, 'column': 1}, 'end': {'line': 4929, 'column': 2}}",show_image.c,"['根据', '指定', '颜色', '值', '计算', '像素', '透明', '明度', '透明度', '，', '支持', '2', '/', '4', '通道', '输出']"
701,701,stbi__do_zlib,int,"int stbi__do_zlib(stbi__zbuf * a, char * obuf, int olen, int exp, int parse_header)","[{'name': 'a', 'type': 'stbi__zbuf *'}, {'name': 'obuf', 'type': 'char *'}, {'name': 'olen', 'type': 'int'}, {'name': 'exp', 'type': 'int'}, {'name': 'parse_header', 'type': 'int'}]",初始化zlib缓冲区并调用解析函数,"static int stbi__do_zlib(stbi__zbuf *a, char *obuf, int olen, int exp, int parse_header)
{
   a->zout_start = obuf;
   a->zout       = obuf;
   a->zout_end   = obuf + olen;
   a->z_expandable = exp;

   return stbi__parse_zlib(a, parse_header);
}","{'begin': {'line': 4510, 'column': 1}, 'end': {'line': 4518, 'column': 2}}",show_image.c,"['初始', '初始化', 'zlib', '缓冲', '缓冲区', '并', '调用', '解析', '函数']"
702,702,stbi_zlib_decode_malloc_guesssize,char *,"char * stbi_zlib_decode_malloc_guesssize(const char * buffer, int len, int initial_size, int * outlen)","[{'name': 'buffer', 'type': 'const char *'}, {'name': 'len', 'type': 'int'}, {'name': 'initial_size', 'type': 'int'}, {'name': 'outlen', 'type': 'int *'}]",解码zlib数据，动态调整缓冲区并返回解压结果,"STBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen)
{
   stbi__zbuf a;
   char *p = (char *) stbi__malloc(initial_size);
   if (p == NULL) return NULL;
   a.zbuffer = (stbi_uc *) buffer;
   a.zbuffer_end = (stbi_uc *) buffer + len;
   if (stbi__do_zlib(&a, p, initial_size, 1, 1)) {
      if (outlen) *outlen = (int) (a.zout - a.zout_start);
      return a.zout_start;
   } else {
      STBI_FREE(a.zout_start);
      return NULL;
   }
}","{'begin': {'line': 4520, 'column': 1}, 'end': {'line': 4534, 'column': 2}}",show_image.c,"['解码', 'zlib', '数据', '，', '动态', '调整', '缓冲', '缓冲区', '并', '返回', '解压', '结果']"
703,703,stbi__compute_transparency16,int,"int stbi__compute_transparency16(stbi__png * z, stbi__uint16[3] tc, int out_n)","[{'name': 'z', 'type': 'stbi__png *'}, {'name': 'tc', 'type': 'stbi__uint16[3]'}, {'name': 'out_n', 'type': 'int'}]",根据指定颜色设置16位透明通道,"static int stbi__compute_transparency16(stbi__png *z, stbi__uint16 tc[3], int out_n)
{
   stbi__context *s = z->s;
   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
   stbi__uint16 *p = (stbi__uint16*) z->out;

   // compute color-based transparency, assuming we've
   // already got 65535 as the alpha value in the output
   STBI_ASSERT(out_n == 2 || out_n == 4);

   if (out_n == 2) {
      for (i = 0; i < pixel_count; ++i) {
         p[1] = (p[0] == tc[0] ? 0 : 65535);
         p += 2;
      }
   } else {
      for (i = 0; i < pixel_count; ++i) {
         if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
            p[3] = 0;
         p += 4;
      }
   }
   return 1;
}","{'begin': {'line': 4931, 'column': 1}, 'end': {'line': 4954, 'column': 2}}",show_image.c,"['根据', '指定', '颜色', '设置', '16', '位', '透明', '通道']"
704,704,stbi_zlib_decode_malloc,char *,"char * stbi_zlib_decode_malloc(const char * buffer, int len, int * outlen)","[{'name': 'buffer', 'type': 'const char *'}, {'name': 'len', 'type': 'int'}, {'name': 'outlen', 'type': 'int *'}]",解压zlib数据并分配内存返回,"STBIDEF char *stbi_zlib_decode_malloc(char const *buffer, int len, int *outlen)
{
   return stbi_zlib_decode_malloc_guesssize(buffer, len, 16384, outlen);
}","{'begin': {'line': 4536, 'column': 1}, 'end': {'line': 4539, 'column': 2}}",show_image.c,"['解压', 'zlib', '数据', '并', '分配', '内存', '分配内存', '返回']"
705,705,stbi_zlib_decode_malloc_guesssize_headerflag,char *,"char * stbi_zlib_decode_malloc_guesssize_headerflag(const char * buffer, int len, int initial_size, int * outlen, int parse_header)","[{'name': 'buffer', 'type': 'const char *'}, {'name': 'len', 'type': 'int'}, {'name': 'initial_size', 'type': 'int'}, {'name': 'outlen', 'type': 'int *'}, {'name': 'parse_header', 'type': 'int'}]",解码zlib数据并分配内存，支持头部解析,"STBIDEF char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header)
{
   stbi__zbuf a;
   char *p = (char *) stbi__malloc(initial_size);
   if (p == NULL) return NULL;
   a.zbuffer = (stbi_uc *) buffer;
   a.zbuffer_end = (stbi_uc *) buffer + len;
   if (stbi__do_zlib(&a, p, initial_size, 1, parse_header)) {
      if (outlen) *outlen = (int) (a.zout - a.zout_start);
      return a.zout_start;
   } else {
      STBI_FREE(a.zout_start);
      return NULL;
   }
}","{'begin': {'line': 4541, 'column': 1}, 'end': {'line': 4555, 'column': 2}}",show_image.c,"['解码', 'zlib', '数据', '并', '分配', '内存', '分配内存', '，', '支持', '头部', '解析']"
706,706,stbi_zlib_decode_buffer,int,"int stbi_zlib_decode_buffer(char * obuffer, int olen, const char * ibuffer, int ilen)","[{'name': 'obuffer', 'type': 'char *'}, {'name': 'olen', 'type': 'int'}, {'name': 'ibuffer', 'type': 'const char *'}, {'name': 'ilen', 'type': 'int'}]",解码Zlib压缩数据到指定缓冲区,"STBIDEF int stbi_zlib_decode_buffer(char *obuffer, int olen, char const *ibuffer, int ilen)
{
   stbi__zbuf a;
   a.zbuffer = (stbi_uc *) ibuffer;
   a.zbuffer_end = (stbi_uc *) ibuffer + ilen;
   if (stbi__do_zlib(&a, obuffer, olen, 0, 1))
      return (int) (a.zout - a.zout_start);
   else
      return -1;
}","{'begin': {'line': 4557, 'column': 1}, 'end': {'line': 4566, 'column': 2}}",show_image.c,"['解码', 'Zlib', '压缩', '数据', '到', '指定', '缓冲', '缓冲区']"
707,707,stbi__expand_png_palette,int,"int stbi__expand_png_palette(stbi__png * a, stbi_uc * palette, int len, int pal_img_n)","[{'name': 'a', 'type': 'stbi__png *'}, {'name': 'palette', 'type': 'stbi_uc *'}, {'name': 'len', 'type': 'int'}, {'name': 'pal_img_n', 'type': 'int'}]",将PNG调色板索引转换为RGB/RGBA像素数据,"static int stbi__expand_png_palette(stbi__png *a, stbi_uc *palette, int len, int pal_img_n)
{
   stbi__uint32 i, pixel_count = a->s->img_x * a->s->img_y;
   stbi_uc *p, *temp_out, *orig = a->out;

   p = (stbi_uc *) stbi__malloc_mad2(pixel_count, pal_img_n, 0);
   if (p == NULL) return stbi__err(""outofmem"", ""Out of memory"");

   // between here and free(out) below, exitting would leak
   temp_out = p;

   if (pal_img_n == 3) {
      for (i=0; i < pixel_count; ++i) {
         int n = orig[i]*4;
         p[0] = palette[n  ];
         p[1] = palette[n+1];
         p[2] = palette[n+2];
         p += 3;
      }
   } else {
      for (i=0; i < pixel_count; ++i) {
         int n = orig[i]*4;
         p[0] = palette[n  ];
         p[1] = palette[n+1];
         p[2] = palette[n+2];
         p[3] = palette[n+3];
         p += 4;
      }
   }
   STBI_FREE(a->out);
   a->out = temp_out;

   STBI_NOTUSED(len);

   return 1;
}","{'begin': {'line': 4956, 'column': 1}, 'end': {'line': 4991, 'column': 2}}",show_image.c,"['将', 'PNG', '调色', '调色板', '索引', '转换', '为', 'RGB', '/', 'RGBA', '像素', '数据']"
708,708,stbi_zlib_decode_noheader_malloc,char *,"char * stbi_zlib_decode_noheader_malloc(const char * buffer, int len, int * outlen)","[{'name': 'buffer', 'type': 'const char *'}, {'name': 'len', 'type': 'int'}, {'name': 'outlen', 'type': 'int *'}]",解压zlib数据（无头），动态分配内存,"STBIDEF char *stbi_zlib_decode_noheader_malloc(char const *buffer, int len, int *outlen)
{
   stbi__zbuf a;
   char *p = (char *) stbi__malloc(16384);
   if (p == NULL) return NULL;
   a.zbuffer = (stbi_uc *) buffer;
   a.zbuffer_end = (stbi_uc *) buffer+len;
   if (stbi__do_zlib(&a, p, 16384, 1, 0)) {
      if (outlen) *outlen = (int) (a.zout - a.zout_start);
      return a.zout_start;
   } else {
      STBI_FREE(a.zout_start);
      return NULL;
   }
}","{'begin': {'line': 4568, 'column': 1}, 'end': {'line': 4582, 'column': 2}}",show_image.c,"['解压', 'zlib', '数据', '（', '无头', '）', '，', '动态', '分配', '内存', '分配内存']"
709,709,stbi_zlib_decode_noheader_buffer,int,"int stbi_zlib_decode_noheader_buffer(char * obuffer, int olen, const char * ibuffer, int ilen)","[{'name': 'obuffer', 'type': 'char *'}, {'name': 'olen', 'type': 'int'}, {'name': 'ibuffer', 'type': 'const char *'}, {'name': 'ilen', 'type': 'int'}]",解压无头信息的zlib数据到缓冲区,"STBIDEF int stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen)
{
   stbi__zbuf a;
   a.zbuffer = (stbi_uc *) ibuffer;
   a.zbuffer_end = (stbi_uc *) ibuffer + ilen;
   if (stbi__do_zlib(&a, obuffer, olen, 0, 0))
      return (int) (a.zout - a.zout_start);
   else
      return -1;
}","{'begin': {'line': 4584, 'column': 1}, 'end': {'line': 4593, 'column': 2}}",show_image.c,"['解压', '无头', '信息', '的', 'zlib', '数据', '到', '缓冲', '缓冲区']"
710,710,stbi__get_chunk_header,stbi__pngchunk,stbi__pngchunk stbi__get_chunk_header(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",读取PNG块的头部信息（长度和类型）,"static stbi__pngchunk stbi__get_chunk_header(stbi__context *s)
{
   stbi__pngchunk c;
   c.length = stbi__get32be(s);
   c.type   = stbi__get32be(s);
   return c;
}","{'begin': {'line': 4613, 'column': 1}, 'end': {'line': 4619, 'column': 2}}",show_image.c,"['读取', 'PNG', '块', '的', '头部', '信息', '（', '长度', '和', '类型', '）']"
711,711,stbi_set_unpremultiply_on_load,void,void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply),"[{'name': 'flag_true_if_should_unpremultiply', 'type': 'int'}]",设置加载时是否解除预乘处理,"STBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply)
{
   stbi__unpremultiply_on_load_global = flag_true_if_should_unpremultiply;
}","{'begin': {'line': 4996, 'column': 1}, 'end': {'line': 4999, 'column': 2}}",show_image.c,"['设置', '加载', '时', '是否', '解除', '预乘', '处理']"
712,712,stbi_convert_iphone_png_to_rgb,void,void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert),"[{'name': 'flag_true_if_should_convert', 'type': 'int'}]",设置iPhone PNG转RGB的全局标志,"STBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert)
{
   stbi__de_iphone_flag_global = flag_true_if_should_convert;
}","{'begin': {'line': 5001, 'column': 1}, 'end': {'line': 5004, 'column': 2}}",show_image.c,"['设置', 'iPhone', ' ', 'PNG', '转', 'RGB', '的', '全局', '标志']"
713,713,stbi__check_png_header,int,int stbi__check_png_header(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",验证输入流是否为有效的PNG文件头,"static int stbi__check_png_header(stbi__context *s)
{
   static const stbi_uc png_sig[8] = { 137,80,78,71,13,10,26,10 };
   int i;
   for (i=0; i < 8; ++i)
      if (stbi__get8(s) != png_sig[i]) return stbi__err(""bad png sig"",""Not a PNG"");
   return 1;
}","{'begin': {'line': 4621, 'column': 1}, 'end': {'line': 4628, 'column': 2}}",show_image.c,"['验证', '输入', '流', '是否', '为', '有效', '的', 'PNG', '文件', '头']"
714,714,stbi_set_unpremultiply_on_load_thread,void,void stbi_set_unpremultiply_on_load_thread(int flag_true_if_should_unpremultiply),"[{'name': 'flag_true_if_should_unpremultiply', 'type': 'int'}]",设置加载时取消预乘的线程标志,"STBIDEF void stbi_set_unpremultiply_on_load_thread(int flag_true_if_should_unpremultiply)
{
   stbi__unpremultiply_on_load_local = flag_true_if_should_unpremultiply;
   stbi__unpremultiply_on_load_set = 1;
}","{'begin': {'line': 5013, 'column': 1}, 'end': {'line': 5017, 'column': 2}}",show_image.c,"['设置', '加载', '时', '取消', '预乘', '的', '线程', '标志']"
715,715,stbi_convert_iphone_png_to_rgb_thread,void,void stbi_convert_iphone_png_to_rgb_thread(int flag_true_if_should_convert),"[{'name': 'flag_true_if_should_convert', 'type': 'int'}]",设置iPhone PNG转RGB的线程转换标志,"STBIDEF void stbi_convert_iphone_png_to_rgb_thread(int flag_true_if_should_convert)
{
   stbi__de_iphone_flag_local = flag_true_if_should_convert;
   stbi__de_iphone_flag_set = 1;
}","{'begin': {'line': 5019, 'column': 1}, 'end': {'line': 5023, 'column': 2}}",show_image.c,"['设置', 'iPhone', ' ', 'PNG', '转', 'RGB', '的', '线程', '转换', '标志']"
716,716,stbi__de_iphone,void,void stbi__de_iphone(stbi__png * z),"[{'name': 'z', 'type': 'stbi__png *'}]",将BGR转换为RGB，支持去预乘处理,"static void stbi__de_iphone(stbi__png *z)
{
   stbi__context *s = z->s;
   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
   stbi_uc *p = z->out;

   if (s->img_out_n == 3) {  // convert bgr to rgb
      for (i=0; i < pixel_count; ++i) {
         stbi_uc t = p[0];
         p[0] = p[2];
         p[2] = t;
         p += 3;
      }
   } else {
      STBI_ASSERT(s->img_out_n == 4);
      if (stbi__unpremultiply_on_load) {
         // convert bgr to rgb and unpremultiply
         for (i=0; i < pixel_count; ++i) {
            stbi_uc a = p[3];
            stbi_uc t = p[0];
            if (a) {
               stbi_uc half = a / 2;
               p[0] = (p[2] * 255 + half) / a;
               p[1] = (p[1] * 255 + half) / a;
               p[2] = ( t   * 255 + half) / a;
            } else {
               p[0] = p[2];
               p[2] = t;
            }
            p += 4;
         }
      } else {
         // convert bgr to rgb
         for (i=0; i < pixel_count; ++i) {
            stbi_uc t = p[0];
            p[0] = p[2];
            p[2] = t;
            p += 4;
         }
      }
   }
}","{'begin': {'line': 5033, 'column': 1}, 'end': {'line': 5074, 'column': 2}}",show_image.c,"['将', 'BGR', '转换', '为', 'RGB', '，', '支持', '去', '预乘', '处理']"
717,717,stbi__paeth,int,"int stbi__paeth(int a, int b, int c)","[{'name': 'a', 'type': 'int'}, {'name': 'b', 'type': 'int'}, {'name': 'c', 'type': 'int'}]",计算Paeth预测值，用于PNG滤波优化,"static int stbi__paeth(int a, int b, int c)
{
   // This formulation looks very different from the reference in the PNG spec, but is
   // actually equivalent and has favorable data dependencies and admits straightforward
   // generation of branch-free code, which helps performance significantly.
   int thresh = c*3 - (a + b);
   int lo = a < b ? a : b;
   int hi = a < b ? b : a;
   int t0 = (hi <= thresh) ? lo : c;
   int t1 = (thresh <= lo) ? hi : t0;
   return t1;
}","{'begin': {'line': 4657, 'column': 1}, 'end': {'line': 4668, 'column': 2}}",show_image.c,"['计算', 'Paeth', '预测', '预测值', '，', '用于', 'PNG', '滤波', '优化']"
718,718,stbi__create_png_alpha_expand8,void,"void stbi__create_png_alpha_expand8(stbi_uc * dest, stbi_uc * src, stbi__uint32 x, int img_n)","[{'name': 'dest', 'type': 'stbi_uc *'}, {'name': 'src', 'type': 'stbi_uc *'}, {'name': 'x', 'type': 'stbi__uint32'}, {'name': 'img_n', 'type': 'int'}]",将1或3通道图像数据扩展为含全透明alpha通道的2或4通道数据,"static void stbi__create_png_alpha_expand8(stbi_uc *dest, stbi_uc *src, stbi__uint32 x, int img_n)
{
   int i;
   // must process data backwards since we allow dest==src
   if (img_n == 1) {
      for (i=x-1; i >= 0; --i) {
         dest[i*2+1] = 255;
         dest[i*2+0] = src[i];
      }
   } else {
      STBI_ASSERT(img_n == 3);
      for (i=x-1; i >= 0; --i) {
         dest[i*4+3] = 255;
         dest[i*4+2] = src[i*3+2];
         dest[i*4+1] = src[i*3+1];
         dest[i*4+0] = src[i*3+0];
      }
   }
}","{'begin': {'line': 4675, 'column': 1}, 'end': {'line': 4693, 'column': 2}}",show_image.c,"['将', '1', '或', '3', '通道', '图像', '数据', '扩展', '为', '含', '透明', '全透明', 'alpha', '通道', '的', '2', '或', '4', '通道', '数据']"
719,719,stbi__parse_png_file,int,"int stbi__parse_png_file(stbi__png * z, int scan, int req_comp)","[{'name': 'z', 'type': 'stbi__png *'}, {'name': 'scan', 'type': 'int'}, {'name': 'req_comp', 'type': 'int'}]",解析PNG文件结构并处理数据块,"static int stbi__parse_png_file(stbi__png *z, int scan, int req_comp)
{
   stbi_uc palette[1024], pal_img_n=0;
   stbi_uc has_trans=0, tc[3]={0};
   stbi__uint16 tc16[3];
   stbi__uint32 ioff=0, idata_limit=0, i, pal_len=0;
   int first=1,k,interlace=0, color=0, is_iphone=0;
   stbi__context *s = z->s;

   z->expanded = NULL;
   z->idata = NULL;
   z->out = NULL;

   if (!stbi__check_png_header(s)) return 0;

   if (scan == STBI__SCAN_type) return 1;

   for (;;) {
      stbi__pngchunk c = stbi__get_chunk_header(s);
      switch (c.type) {
         case STBI__PNG_TYPE('C','g','B','I'):
            is_iphone = 1;
            stbi__skip(s, c.length);
            break;
         case STBI__PNG_TYPE('I','H','D','R'): {
            int comp,filter;
            if (!first) return stbi__err(""multiple IHDR"",""Corrupt PNG"");
            first = 0;
            if (c.length != 13) return stbi__err(""bad IHDR len"",""Corrupt PNG"");
            s->img_x = stbi__get32be(s);
            s->img_y = stbi__get32be(s);
            if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err(""too large"",""Very large image (corrupt?)"");
            if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err(""too large"",""Very large image (corrupt?)"");
            z->depth = stbi__get8(s);  if (z->depth != 1 && z->depth != 2 && z->depth != 4 && z->depth != 8 && z->depth != 16)  return stbi__err(""1/2/4/8/16-bit only"",""PNG not supported: 1/2/4/8/16-bit only"");
            color = stbi__get8(s);  if (color > 6)         return stbi__err(""bad ctype"",""Corrupt PNG"");
            if (color == 3 && z->depth == 16)                  return stbi__err(""bad ctype"",""Corrupt PNG"");
            if (color == 3) pal_img_n = 3; else if (color & 1) return stbi__err(""bad ctype"",""Corrupt PNG"");
            comp  = stbi__get8(s);  if (comp) return stbi__err(""bad comp method"",""Corrupt PNG"");
            filter= stbi__get8(s);  if (filter) return stbi__err(""bad filter method"",""Corrupt PNG"");
            interlace = stbi__get8(s); if (interlace>1) return stbi__err(""bad interlace method"",""Corrupt PNG"");
            if (!s->img_x || !s->img_y) return stbi__err(""0-pixel image"",""Corrupt PNG"");
            if (!pal_img_n) {
               s->img_n = (color & 2 ? 3 : 1) + (color & 4 ? 1 : 0);
               if ((1 << 30) / s->img_x / s->img_n < s->img_y) return stbi__err(""too large"", ""Image too large to decode"");
            } else {
               // if paletted, then pal_n is our final components, and
               // img_n is # components to decompress/filter.
               s->img_n = 1;
               if ((1 << 30) / s->img_x / 4 < s->img_y) return stbi__err(""too large"",""Corrupt PNG"");
            }
            // even with SCAN_header, have to scan to see if we have a tRNS
            break;
         }

         case STBI__PNG_TYPE('P','L','T','E'):  {
            if (first) return stbi__err(""first not IHDR"", ""Corrupt PNG"");
            if (c.length > 256*3) return stbi__err(""invalid PLTE"",""Corrupt PNG"");
            pal_len = c.length / 3;
            if (pal_len * 3 != c.length) return stbi__err(""invalid PLTE"",""Corrupt PNG"");
            for (i=0; i < pal_len; ++i) {
               palette[i*4+0] = stbi__get8(s);
               palette[i*4+1] = stbi__get8(s);
               palette[i*4+2] = stbi__get8(s);
               palette[i*4+3] = 255;
            }
            break;
         }

         case STBI__PNG_TYPE('t','R','N','S'): {
            if (first) return stbi__err(""first not IHDR"", ""Corrupt PNG"");
            if (z->idata) return stbi__err(""tRNS after IDAT"",""Corrupt PNG"");
            if (pal_img_n) {
               if (scan == STBI__SCAN_header) { s->img_n = 4; return 1; }
               if (pal_len == 0) return stbi__err(""tRNS before PLTE"",""Corrupt PNG"");
               if (c.length > pal_len) return stbi__err(""bad tRNS len"",""Corrupt PNG"");
               pal_img_n = 4;
               for (i=0; i < c.length; ++i)
                  palette[i*4+3] = stbi__get8(s);
            } else {
               if (!(s->img_n & 1)) return stbi__err(""tRNS with alpha"",""Corrupt PNG"");
               if (c.length != (stbi__uint32) s->img_n*2) return stbi__err(""bad tRNS len"",""Corrupt PNG"");
               has_trans = 1;
               // non-paletted with tRNS = constant alpha. if header-scanning, we can stop now.
               if (scan == STBI__SCAN_header) { ++s->img_n; return 1; }
               if (z->depth == 16) {
                  for (k = 0; k < s->img_n && k < 3; ++k) // extra loop test to suppress false GCC warning
                     tc16[k] = (stbi__uint16)stbi__get16be(s); // copy the values as-is
               } else {
                  for (k = 0; k < s->img_n && k < 3; ++k)
                     tc[k] = (stbi_uc)(stbi__get16be(s) & 255) * stbi__depth_scale_table[z->depth]; // non 8-bit images will be larger
               }
            }
            break;
         }

         case STBI__PNG_TYPE('I','D','A','T'): {
            if (first) return stbi__err(""first not IHDR"", ""Corrupt PNG"");
            if (pal_img_n && !pal_len) return stbi__err(""no PLTE"",""Corrupt PNG"");
            if (scan == STBI__SCAN_header) {
               // header scan definitely stops at first IDAT
               if (pal_img_n)
                  s->img_n = pal_img_n;
               return 1;
            }
            if (c.length > (1u << 30)) return stbi__err(""IDAT size limit"", ""IDAT section larger than 2^30 bytes"");
            if ((int)(ioff + c.length) < (int)ioff) return 0;
            if (ioff + c.length > idata_limit) {
               stbi__uint32 idata_limit_old = idata_limit;
               stbi_uc *p;
               if (idata_limit == 0) idata_limit = c.length > 4096 ? c.length : 4096;
               while (ioff + c.length > idata_limit)
                  idata_limit *= 2;
               STBI_NOTUSED(idata_limit_old);
               p = (stbi_uc *) STBI_REALLOC_SIZED(z->idata, idata_limit_old, idata_limit); if (p == NULL) return stbi__err(""outofmem"", ""Out of memory"");
               z->idata = p;
            }
            if (!stbi__getn(s, z->idata+ioff,c.length)) return stbi__err(""outofdata"",""Corrupt PNG"");
            ioff += c.length;
            break;
         }

         case STBI__PNG_TYPE('I','E','N','D'): {
            stbi__uint32 raw_len, bpl;
            if (first) return stbi__err(""first not IHDR"", ""Corrupt PNG"");
            if (scan != STBI__SCAN_load) return 1;
            if (z->idata == NULL) return stbi__err(""no IDAT"",""Corrupt PNG"");
            // initial guess for decoded data size to avoid unnecessary reallocs
            bpl = (s->img_x * z->depth + 7) / 8; // bytes per line, per component
            raw_len = bpl * s->img_y * s->img_n /* pixels */ + s->img_y /* filter mode per row */;
            z->expanded = (stbi_uc *) stbi_zlib_decode_malloc_guesssize_headerflag((char *) z->idata, ioff, raw_len, (int *) &raw_len, !is_iphone);
            if (z->expanded == NULL) return 0; // zlib should set error
            STBI_FREE(z->idata); z->idata = NULL;
            if ((req_comp == s->img_n+1 && req_comp != 3 && !pal_img_n) || has_trans)
               s->img_out_n = s->img_n+1;
            else
               s->img_out_n = s->img_n;
            if (!stbi__create_png_image(z, z->expanded, raw_len, s->img_out_n, z->depth, color, interlace)) return 0;
            if (has_trans) {
               if (z->depth == 16) {
                  if (!stbi__compute_transparency16(z, tc16, s->img_out_n)) return 0;
               } else {
                  if (!stbi__compute_transparency(z, tc, s->img_out_n)) return 0;
               }
            }
            if (is_iphone && stbi__de_iphone_flag && s->img_out_n > 2)
               stbi__de_iphone(z);
            if (pal_img_n) {
               // pal_img_n == 3 or 4
               s->img_n = pal_img_n; // record the actual colors we had
               s->img_out_n = pal_img_n;
               if (req_comp >= 3) s->img_out_n = req_comp;
               if (!stbi__expand_png_palette(z, palette, pal_len, s->img_out_n))
                  return 0;
            } else if (has_trans) {
               // non-paletted image with tRNS -> source image has (constant) alpha
               ++s->img_n;
            }
            STBI_FREE(z->expanded); z->expanded = NULL;
            // end of PNG chunk, read and skip CRC
            stbi__get32be(s);
            return 1;
         }

         default:
            // if critical, fail
            if (first) return stbi__err(""first not IHDR"", ""Corrupt PNG"");
            if ((c.type & (1 << 29)) == 0) {
               #ifndef STBI_NO_FAILURE_STRINGS
               // not threadsafe
               static char invalid_chunk[] = ""XXXX PNG chunk not known"";
               invalid_chunk[0] = STBI__BYTECAST(c.type >> 24);
               invalid_chunk[1] = STBI__BYTECAST(c.type >> 16);
               invalid_chunk[2] = STBI__BYTECAST(c.type >>  8);
               invalid_chunk[3] = STBI__BYTECAST(c.type >>  0);
               #endif
               return stbi__err(invalid_chunk, ""PNG not supported: unknown PNG chunk type"");
            }
            stbi__skip(s, c.length);
            break;
      }
      // end of PNG chunk, read and skip CRC
      stbi__get32be(s);
   }
}","{'begin': {'line': 5078, 'column': 1}, 'end': {'line': 5261, 'column': 2}}",show_image.c,"['解析', 'PNG', '文件', '结构', '并', '处理', '数据', '块']"
720,720,stbi__create_png_image_raw,int,"int stbi__create_png_image_raw(stbi__png * a, stbi_uc * raw, stbi__uint32 raw_len, int out_n, stbi__uint32 x, stbi__uint32 y, int depth, int color)","[{'name': 'a', 'type': 'stbi__png *'}, {'name': 'raw', 'type': 'stbi_uc *'}, {'name': 'raw_len', 'type': 'stbi__uint32'}, {'name': 'out_n', 'type': 'int'}, {'name': 'x', 'type': 'stbi__uint32'}, {'name': 'y', 'type': 'stbi__uint32'}, {'name': 'depth', 'type': 'int'}, {'name': 'color', 'type': 'int'}]",解码原始PNG数据并应用过滤器生成图像,"static int stbi__create_png_image_raw(stbi__png *a, stbi_uc *raw, stbi__uint32 raw_len, int out_n, stbi__uint32 x, stbi__uint32 y, int depth, int color)
{
   int bytes = (depth == 16 ? 2 : 1);
   stbi__context *s = a->s;
   stbi__uint32 i,j,stride = x*out_n*bytes;
   stbi__uint32 img_len, img_width_bytes;
   stbi_uc *filter_buf;
   int all_ok = 1;
   int k;
   int img_n = s->img_n; // copy it into a local for later

   int output_bytes = out_n*bytes;
   int filter_bytes = img_n*bytes;
   int width = x;

   STBI_ASSERT(out_n == s->img_n || out_n == s->img_n+1);
   a->out = (stbi_uc *) stbi__malloc_mad3(x, y, output_bytes, 0); // extra bytes to write off the end into
   if (!a->out) return stbi__err(""outofmem"", ""Out of memory"");

   // note: error exits here don't need to clean up a->out individually,
   // stbi__do_png always does on error.
   if (!stbi__mad3sizes_valid(img_n, x, depth, 7)) return stbi__err(""too large"", ""Corrupt PNG"");
   img_width_bytes = (((img_n * x * depth) + 7) >> 3);
   if (!stbi__mad2sizes_valid(img_width_bytes, y, img_width_bytes)) return stbi__err(""too large"", ""Corrupt PNG"");
   img_len = (img_width_bytes + 1) * y;

   // we used to check for exact match between raw_len and img_len on non-interlaced PNGs,
   // but issue #276 reported a PNG in the wild that had extra data at the end (all zeros),
   // so just check for raw_len < img_len always.
   if (raw_len < img_len) return stbi__err(""not enough pixels"",""Corrupt PNG"");

   // Allocate two scan lines worth of filter workspace buffer.
   filter_buf = (stbi_uc *) stbi__malloc_mad2(img_width_bytes, 2, 0);
   if (!filter_buf) return stbi__err(""outofmem"", ""Out of memory"");

   // Filtering for low-bit-depth images
   if (depth < 8) {
      filter_bytes = 1;
      width = img_width_bytes;
   }

   for (j=0; j < y; ++j) {
      // cur/prior filter buffers alternate
      stbi_uc *cur = filter_buf + (j & 1)*img_width_bytes;
      stbi_uc *prior = filter_buf + (~j & 1)*img_width_bytes;
      stbi_uc *dest = a->out + stride*j;
      int nk = width * filter_bytes;
      int filter = *raw++;

      // check filter type
      if (filter > 4) {
         all_ok = stbi__err(""invalid filter"",""Corrupt PNG"");
         break;
      }

      // if first row, use special filter that doesn't sample previous row
      if (j == 0) filter = first_row_filter[filter];

      // perform actual filtering
      switch (filter) {
      case STBI__F_none:
         memcpy(cur, raw, nk);
         break;
      case STBI__F_sub:
         memcpy(cur, raw, filter_bytes);
         for (k = filter_bytes; k < nk; ++k)
            cur[k] = STBI__BYTECAST(raw[k] + cur[k-filter_bytes]);
         break;
      case STBI__F_up:
         for (k = 0; k < nk; ++k)
            cur[k] = STBI__BYTECAST(raw[k] + prior[k]);
         break;
      case STBI__F_avg:
         for (k = 0; k < filter_bytes; ++k)
            cur[k] = STBI__BYTECAST(raw[k] + (prior[k]>>1));
         for (k = filter_bytes; k < nk; ++k)
            cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k-filter_bytes])>>1));
         break;
      case STBI__F_paeth:
         for (k = 0; k < filter_bytes; ++k)
            cur[k] = STBI__BYTECAST(raw[k] + prior[k]); // prior[k] == stbi__paeth(0,prior[k],0)
         for (k = filter_bytes; k < nk; ++k)
            cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes], prior[k], prior[k-filter_bytes]));
         break;
      case STBI__F_avg_first:
         memcpy(cur, raw, filter_bytes);
         for (k = filter_bytes; k < nk; ++k)
            cur[k] = STBI__BYTECAST(raw[k] + (cur[k-filter_bytes] >> 1));
         break;
      }

      raw += nk;

      // expand decoded bits in cur to dest, also adding an extra alpha channel if desired
      if (depth < 8) {
         stbi_uc scale = (color == 0) ? stbi__depth_scale_table[depth] : 1; // scale grayscale values to 0..255 range
         stbi_uc *in = cur;
         stbi_uc *out = dest;
         stbi_uc inb = 0;
         stbi__uint32 nsmp = x*img_n;

         // expand bits to bytes first
         if (depth == 4) {
            for (i=0; i < nsmp; ++i) {
               if ((i & 1) == 0) inb = *in++;
               *out++ = scale * (inb >> 4);
               inb <<= 4;
            }
         } else if (depth == 2) {
            for (i=0; i < nsmp; ++i) {
               if ((i & 3) == 0) inb = *in++;
               *out++ = scale * (inb >> 6);
               inb <<= 2;
            }
         } else {
            STBI_ASSERT(depth == 1);
            for (i=0; i < nsmp; ++i) {
               if ((i & 7) == 0) inb = *in++;
               *out++ = scale * (inb >> 7);
               inb <<= 1;
            }
         }

         // insert alpha=255 values if desired
         if (img_n != out_n)
            stbi__create_png_alpha_expand8(dest, dest, x, img_n);
      } else if (depth == 8) {
         if (img_n == out_n)
            memcpy(dest, cur, x*img_n);
         else
            stbi__create_png_alpha_expand8(dest, cur, x, img_n);
      } else if (depth == 16) {
         // convert the image data from big-endian to platform-native
         stbi__uint16 *dest16 = (stbi__uint16*)dest;
         stbi__uint32 nsmp = x*img_n;

         if (img_n == out_n) {
            for (i = 0; i < nsmp; ++i, ++dest16, cur += 2)
               *dest16 = (cur[0] << 8) | cur[1];
         } else {
            STBI_ASSERT(img_n+1 == out_n);
            if (img_n == 1) {
               for (i = 0; i < x; ++i, dest16 += 2, cur += 2) {
                  dest16[0] = (cur[0] << 8) | cur[1];
                  dest16[1] = 0xffff;
               }
            } else {
               STBI_ASSERT(img_n == 3);
               for (i = 0; i < x; ++i, dest16 += 4, cur += 6) {
                  dest16[0] = (cur[0] << 8) | cur[1];
                  dest16[1] = (cur[2] << 8) | cur[3];
                  dest16[2] = (cur[4] << 8) | cur[5];
                  dest16[3] = 0xffff;
               }
            }
         }
      }
   }

   STBI_FREE(filter_buf);
   if (!all_ok) return 0;

   return 1;
}","{'begin': {'line': 4696, 'column': 1}, 'end': {'line': 4859, 'column': 2}}",show_image.c,"['解码', '原始', 'PNG', '数据', '并', '应用', '过滤', '滤器', '过滤器', '生成', '图像']"
721,721,stbi__do_png,void *,"void * stbi__do_png(stbi__png * p, int * x, int * y, int * n, int req_comp, stbi__result_info * ri)","[{'name': 'p', 'type': 'stbi__png *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'n', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'ri', 'type': 'stbi__result_info *'}]",解析PNG图像，处理格式转换并返回解码数据。,"static void *stbi__do_png(stbi__png *p, int *x, int *y, int *n, int req_comp, stbi__result_info *ri)
{
   void *result=NULL;
   if (req_comp < 0 || req_comp > 4) return stbi__errpuc(""bad req_comp"", ""Internal error"");
   if (stbi__parse_png_file(p, STBI__SCAN_load, req_comp)) {
      if (p->depth <= 8)
         ri->bits_per_channel = 8;
      else if (p->depth == 16)
         ri->bits_per_channel = 16;
      else
         return stbi__errpuc(""bad bits_per_channel"", ""PNG not supported: unsupported color depth"");
      result = p->out;
      p->out = NULL;
      if (req_comp && req_comp != p->s->img_out_n) {
         if (ri->bits_per_channel == 8)
            result = stbi__convert_format((unsigned char *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
         else
            result = stbi__convert_format16((stbi__uint16 *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
         p->s->img_out_n = req_comp;
         if (result == NULL) return result;
      }
      *x = p->s->img_x;
      *y = p->s->img_y;
      if (n) *n = p->s->img_n;
   }
   STBI_FREE(p->out);      p->out      = NULL;
   STBI_FREE(p->expanded); p->expanded = NULL;
   STBI_FREE(p->idata);    p->idata    = NULL;

   return result;
}","{'begin': {'line': 5263, 'column': 1}, 'end': {'line': 5293, 'column': 2}}",show_image.c,"['解析', 'PNG', '图像', '，', '处理', '格式', '转换', '并', '返回', '解码', '数据', '。']"
722,722,stbi__create_png_image,int,"int stbi__create_png_image(stbi__png * a, stbi_uc * image_data, stbi__uint32 image_data_len, int out_n, int depth, int color, int interlaced)","[{'name': 'a', 'type': 'stbi__png *'}, {'name': 'image_data', 'type': 'stbi_uc *'}, {'name': 'image_data_len', 'type': 'stbi__uint32'}, {'name': 'out_n', 'type': 'int'}, {'name': 'depth', 'type': 'int'}, {'name': 'color', 'type': 'int'}, {'name': 'interlaced', 'type': 'int'}]",生成PNG图像数据，处理隔行扫描解码,"static int stbi__create_png_image(stbi__png *a, stbi_uc *image_data, stbi__uint32 image_data_len, int out_n, int depth, int color, int interlaced)
{
   int bytes = (depth == 16 ? 2 : 1);
   int out_bytes = out_n * bytes;
   stbi_uc *final;
   int p;
   if (!interlaced)
      return stbi__create_png_image_raw(a, image_data, image_data_len, out_n, a->s->img_x, a->s->img_y, depth, color);

   // de-interlacing
   final = (stbi_uc *) stbi__malloc_mad3(a->s->img_x, a->s->img_y, out_bytes, 0);
   if (!final) return stbi__err(""outofmem"", ""Out of memory"");
   for (p=0; p < 7; ++p) {
      int xorig[] = { 0,4,0,2,0,1,0 };
      int yorig[] = { 0,0,4,0,2,0,1 };
      int xspc[]  = { 8,8,4,4,2,2,1 };
      int yspc[]  = { 8,8,8,4,4,2,2 };
      int i,j,x,y;
      // pass1_x[4] = 0, pass1_x[5] = 1, pass1_x[12] = 1
      x = (a->s->img_x - xorig[p] + xspc[p]-1) / xspc[p];
      y = (a->s->img_y - yorig[p] + yspc[p]-1) / yspc[p];
      if (x && y) {
         stbi__uint32 img_len = ((((a->s->img_n * x * depth) + 7) >> 3) + 1) * y;
         if (!stbi__create_png_image_raw(a, image_data, image_data_len, out_n, x, y, depth, color)) {
            STBI_FREE(final);
            return 0;
         }
         for (j=0; j < y; ++j) {
            for (i=0; i < x; ++i) {
               int out_y = j*yspc[p]+yorig[p];
               int out_x = i*xspc[p]+xorig[p];
               memcpy(final + out_y*a->s->img_x*out_bytes + out_x*out_bytes,
                      a->out + (j*x+i)*out_bytes, out_bytes);
            }
         }
         STBI_FREE(a->out);
         image_data += img_len;
         image_data_len -= img_len;
      }
   }
   a->out = final;

   return 1;
}","{'begin': {'line': 4861, 'column': 1}, 'end': {'line': 4904, 'column': 2}}",show_image.c,"['生成', 'PNG', '图像', '数据', '，', '处理', '隔行', '扫描', '隔行扫描', '解码']"
723,723,stbi__png_load,void *,"void * stbi__png_load(stbi__context * s, int * x, int * y, int * comp, int req_comp, stbi__result_info * ri)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'ri', 'type': 'stbi__result_info *'}]",加载并解析PNG图像数据,"static void *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   stbi__png p;
   p.s = s;
   return stbi__do_png(&p, x,y,comp,req_comp, ri);
}","{'begin': {'line': 5295, 'column': 1}, 'end': {'line': 5300, 'column': 2}}",show_image.c,"['加载', '并', '解析', 'PNG', '图像', '数据']"
724,724,stbi__png_test,int,int stbi__png_test(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",验证PNG文件头并重置流位置,"static int stbi__png_test(stbi__context *s)
{
   int r;
   r = stbi__check_png_header(s);
   stbi__rewind(s);
   return r;
}","{'begin': {'line': 5302, 'column': 1}, 'end': {'line': 5308, 'column': 2}}",show_image.c,"['验证', 'PNG', '文件', '头', '并', '重置', '流', '位置']"
725,725,stbi__png_info_raw,int,"int stbi__png_info_raw(stbi__png * p, int * x, int * y, int * comp)","[{'name': 'p', 'type': 'stbi__png *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",解析PNG图像头部信息并获取尺寸及通道数,"static int stbi__png_info_raw(stbi__png *p, int *x, int *y, int *comp)
{
   if (!stbi__parse_png_file(p, STBI__SCAN_header, 0)) {
      stbi__rewind( p->s );
      return 0;
   }
   if (x) *x = p->s->img_x;
   if (y) *y = p->s->img_y;
   if (comp) *comp = p->s->img_n;
   return 1;
}","{'begin': {'line': 5310, 'column': 1}, 'end': {'line': 5320, 'column': 2}}",show_image.c,"['解析', 'PNG', '图像', '头部', '信息', '并', '获取', '尺寸', '及', '通道', '数']"
726,726,stbi__png_info,int,"int stbi__png_info(stbi__context * s, int * x, int * y, int * comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",获取PNG图像尺寸及通道信息,"static int stbi__png_info(stbi__context *s, int *x, int *y, int *comp)
{
   stbi__png p;
   p.s = s;
   return stbi__png_info_raw(&p, x, y, comp);
}","{'begin': {'line': 5322, 'column': 1}, 'end': {'line': 5327, 'column': 2}}",show_image.c,"['获取', 'PNG', '图像', '尺寸', '及', '通道', '信息']"
727,727,stbi__png_is16,int,int stbi__png_is16(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",检测PNG是否为16位深度,"static int stbi__png_is16(stbi__context *s)
{
   stbi__png p;
   p.s = s;
   if (!stbi__png_info_raw(&p, NULL, NULL, NULL))
	   return 0;
   if (p.depth != 16) {
      stbi__rewind(p.s);
      return 0;
   }
   return 1;
}","{'begin': {'line': 5329, 'column': 1}, 'end': {'line': 5340, 'column': 2}}",show_image.c,"['检测', 'PNG', '是否', '为', '16', '位', '深度']"
728,728,stbi__bmp_test_raw,int,int stbi__bmp_test_raw(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",验证BMP文件头的有效性,"static int stbi__bmp_test_raw(stbi__context *s)
{
   int r;
   int sz;
   if (stbi__get8(s) != 'B') return 0;
   if (stbi__get8(s) != 'M') return 0;
   stbi__get32le(s); // discard filesize
   stbi__get16le(s); // discard reserved
   stbi__get16le(s); // discard reserved
   stbi__get32le(s); // discard data offset
   sz = stbi__get32le(s);
   r = (sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124);
   return r;
}","{'begin': {'line': 5346, 'column': 1}, 'end': {'line': 5359, 'column': 2}}",show_image.c,"['验证', 'BMP', '文件', '头', '的', '有效', '有效性']"
729,729,stbi__compute_transparency,int,"int stbi__compute_transparency(stbi__png * z, stbi_uc[3] tc, int out_n)","[{'name': 'z', 'type': 'stbi__png *'}, {'name': 'tc', 'type': 'stbi_uc[3]'}, {'name': 'out_n', 'type': 'int'}]",根据指定颜色计算PNG图像透明度并更新透明通道,"static int stbi__compute_transparency(stbi__png *z, stbi_uc tc[3], int out_n)
{
   stbi__context *s = z->s;
   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
   stbi_uc *p = z->out;

   // compute color-based transparency, assuming we've
   // already got 255 as the alpha value in the output
   STBI_ASSERT(out_n == 2 || out_n == 4);

   if (out_n == 2) {
      for (i=0; i < pixel_count; ++i) {
         p[1] = (p[0] == tc[0] ? 0 : 255);
         p += 2;
      }
   } else {
      for (i=0; i < pixel_count; ++i) {
         if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
            p[3] = 0;
         p += 4;
      }
   }
   return 1;
}","{'begin': {'line': 4906, 'column': 1}, 'end': {'line': 4929, 'column': 2}}",show_image.c,"['根据', '指定', '颜色', '计算', 'PNG', '图像', '透明', '明度', '透明度', '并', '更新', '透明', '通道']"
730,730,stbi__bmp_test,int,int stbi__bmp_test(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",检测输入流是否为BMP格式并重置流指针,"static int stbi__bmp_test(stbi__context *s)
{
   int r = stbi__bmp_test_raw(s);
   stbi__rewind(s);
   return r;
}","{'begin': {'line': 5361, 'column': 1}, 'end': {'line': 5366, 'column': 2}}",show_image.c,"['检测', '输入', '流', '是否', '为', 'BMP', '格式', '并', '重置', '流', '指针']"
731,731,stbi__high_bit,int,int stbi__high_bit(unsigned int z),"[{'name': 'z', 'type': 'unsigned int'}]",计算无符号整数最高有效位的位置,"static int stbi__high_bit(unsigned int z)
{
   int n=0;
   if (z == 0) return -1;
   if (z >= 0x10000) { n += 16; z >>= 16; }
   if (z >= 0x00100) { n +=  8; z >>=  8; }
   if (z >= 0x00010) { n +=  4; z >>=  4; }
   if (z >= 0x00004) { n +=  2; z >>=  2; }
   if (z >= 0x00002) { n +=  1;/* >>=  1;*/ }
   return n;
}","{'begin': {'line': 5370, 'column': 1}, 'end': {'line': 5380, 'column': 2}}",show_image.c,"['计算', '无', '符号', '整数', '最高', '有效', '位', '的', '位置']"
732,732,stbi__bitcount,int,int stbi__bitcount(unsigned int a),"[{'name': 'a', 'type': 'unsigned int'}]",计算无符号整数二进制中1的个数,"static int stbi__bitcount(unsigned int a)
{
   a = (a & 0x55555555) + ((a >>  1) & 0x55555555); // max 2
   a = (a & 0x33333333) + ((a >>  2) & 0x33333333); // max 4
   a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits
   a = (a + (a >> 8)); // max 16 per 8 bits
   a = (a + (a >> 16)); // max 32 per 8 bits
   return a & 0xff;
}","{'begin': {'line': 5382, 'column': 1}, 'end': {'line': 5390, 'column': 2}}",show_image.c,"['计算', '无', '符号', '整数', '进制', '二进制', '中', '1', '的', '个数']"
733,733,stbi__compute_transparency16,int,"int stbi__compute_transparency16(stbi__png * z, stbi__uint16[3] tc, int out_n)","[{'name': 'z', 'type': 'stbi__png *'}, {'name': 'tc', 'type': 'stbi__uint16[3]'}, {'name': 'out_n', 'type': 'int'}]",根据指定颜色值设置16位图像的透明度,"static int stbi__compute_transparency16(stbi__png *z, stbi__uint16 tc[3], int out_n)
{
   stbi__context *s = z->s;
   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
   stbi__uint16 *p = (stbi__uint16*) z->out;

   // compute color-based transparency, assuming we've
   // already got 65535 as the alpha value in the output
   STBI_ASSERT(out_n == 2 || out_n == 4);

   if (out_n == 2) {
      for (i = 0; i < pixel_count; ++i) {
         p[1] = (p[0] == tc[0] ? 0 : 65535);
         p += 2;
      }
   } else {
      for (i = 0; i < pixel_count; ++i) {
         if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
            p[3] = 0;
         p += 4;
      }
   }
   return 1;
}","{'begin': {'line': 4931, 'column': 1}, 'end': {'line': 4954, 'column': 2}}",show_image.c,"['根据', '指定', '颜色', '值', '设置', '16', '位', '图像', '的', '透明', '明度', '透明度']"
734,734,stbi__shiftsigned,int,"int stbi__shiftsigned(unsigned int v, int shift, int bits)","[{'name': 'v', 'type': 'unsigned int'}, {'name': 'shift', 'type': 'int'}, {'name': 'bits', 'type': 'int'}]",通过位移和查表乘法调整无符号整数值,"static int stbi__shiftsigned(unsigned int v, int shift, int bits)
{
   static unsigned int mul_table[9] = {
      0,
      0xff/*0b11111111*/, 0x55/*0b01010101*/, 0x49/*0b01001001*/, 0x11/*0b00010001*/,
      0x21/*0b00100001*/, 0x41/*0b01000001*/, 0x81/*0b10000001*/, 0x01/*0b00000001*/,
   };
   static unsigned int shift_table[9] = {
      0, 0,0,1,0,2,4,6,0,
   };
   if (shift < 0)
      v <<= -shift;
   else
      v >>= shift;
   STBI_ASSERT(v < 256);
   v >>= (8-bits);
   STBI_ASSERT(bits >= 0 && bits <= 8);
   return (int) ((unsigned) v * mul_table[bits]) >> shift_table[bits];
}","{'begin': {'line': 5395, 'column': 1}, 'end': {'line': 5413, 'column': 2}}",show_image.c,"['通过', '位移', '和', '查表', '乘法', '调整', '无', '符号', '整数', '值']"
735,735,stbi__expand_png_palette,int,"int stbi__expand_png_palette(stbi__png * a, stbi_uc * palette, int len, int pal_img_n)","[{'name': 'a', 'type': 'stbi__png *'}, {'name': 'palette', 'type': 'stbi_uc *'}, {'name': 'len', 'type': 'int'}, {'name': 'pal_img_n', 'type': 'int'}]",将PNG调色板索引转换为RGB(A)颜色数据,"static int stbi__expand_png_palette(stbi__png *a, stbi_uc *palette, int len, int pal_img_n)
{
   stbi__uint32 i, pixel_count = a->s->img_x * a->s->img_y;
   stbi_uc *p, *temp_out, *orig = a->out;

   p = (stbi_uc *) stbi__malloc_mad2(pixel_count, pal_img_n, 0);
   if (p == NULL) return stbi__err(""outofmem"", ""Out of memory"");

   // between here and free(out) below, exitting would leak
   temp_out = p;

   if (pal_img_n == 3) {
      for (i=0; i < pixel_count; ++i) {
         int n = orig[i]*4;
         p[0] = palette[n  ];
         p[1] = palette[n+1];
         p[2] = palette[n+2];
         p += 3;
      }
   } else {
      for (i=0; i < pixel_count; ++i) {
         int n = orig[i]*4;
         p[0] = palette[n  ];
         p[1] = palette[n+1];
         p[2] = palette[n+2];
         p[3] = palette[n+3];
         p += 4;
      }
   }
   STBI_FREE(a->out);
   a->out = temp_out;

   STBI_NOTUSED(len);

   return 1;
}","{'begin': {'line': 4956, 'column': 1}, 'end': {'line': 4991, 'column': 2}}",show_image.c,"['将', 'PNG', '调色', '调色板', '索引', '转换', '为', 'RGB', '(', 'A', ')', '颜色', '数据']"
736,736,stbi__bmp_set_mask_defaults,int,"int stbi__bmp_set_mask_defaults(stbi__bmp_data * info, int compress)","[{'name': 'info', 'type': 'stbi__bmp_data *'}, {'name': 'compress', 'type': 'int'}]",根据压缩类型和位深设置BMP颜色掩码,"static int stbi__bmp_set_mask_defaults(stbi__bmp_data *info, int compress)
{
   // BI_BITFIELDS specifies masks explicitly, don't override
   if (compress == 3)
      return 1;

   if (compress == 0) {
      if (info->bpp == 16) {
         info->mr = 31u << 10;
         info->mg = 31u <<  5;
         info->mb = 31u <<  0;
      } else if (info->bpp == 32) {
         info->mr = 0xffu << 16;
         info->mg = 0xffu <<  8;
         info->mb = 0xffu <<  0;
         info->ma = 0xffu << 24;
         info->all_a = 0; // if all_a is 0 at end, then we loaded alpha channel but it was all 0
      } else {
         // otherwise, use defaults, which is all-0
         info->mr = info->mg = info->mb = info->ma = 0;
      }
      return 1;
   }
   return 0; // error
}","{'begin': {'line': 5422, 'column': 1}, 'end': {'line': 5446, 'column': 2}}",show_image.c,"['根据', '压缩', '类型', '和', '位深', '设置', 'BMP', '颜色', '掩码']"
737,737,stbi_set_unpremultiply_on_load,void,void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply),"[{'name': 'flag_true_if_should_unpremultiply', 'type': 'int'}]",设置加载时是否解除预乘Alpha通道,"STBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply)
{
   stbi__unpremultiply_on_load_global = flag_true_if_should_unpremultiply;
}","{'begin': {'line': 4996, 'column': 1}, 'end': {'line': 4999, 'column': 2}}",show_image.c,"['设置', '加载', '时', '是否', '解除', '预乘', 'Alpha', '通道']"
738,738,stbi_convert_iphone_png_to_rgb,void,void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert),"[{'name': 'flag_true_if_should_convert', 'type': 'int'}]",设置iPhone PNG到RGB的转换标志,"STBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert)
{
   stbi__de_iphone_flag_global = flag_true_if_should_convert;
}","{'begin': {'line': 5001, 'column': 1}, 'end': {'line': 5004, 'column': 2}}",show_image.c,"['设置', 'iPhone', ' ', 'PNG', '到', 'RGB', '的', '转换', '标志']"
739,739,stbi__bmp_parse_header,void *,"void * stbi__bmp_parse_header(stbi__context * s, stbi__bmp_data * info)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'info', 'type': 'stbi__bmp_data *'}]",解析BMP文件头并验证有效性,"static void *stbi__bmp_parse_header(stbi__context *s, stbi__bmp_data *info)
{
   int hsz;
   if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') return stbi__errpuc(""not BMP"", ""Corrupt BMP"");
   stbi__get32le(s); // discard filesize
   stbi__get16le(s); // discard reserved
   stbi__get16le(s); // discard reserved
   info->offset = stbi__get32le(s);
   info->hsz = hsz = stbi__get32le(s);
   info->mr = info->mg = info->mb = info->ma = 0;
   info->extra_read = 14;

   if (info->offset < 0) return stbi__errpuc(""bad BMP"", ""bad BMP"");

   if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108 && hsz != 124) return stbi__errpuc(""unknown BMP"", ""BMP type not supported: unknown"");
   if (hsz == 12) {
      s->img_x = stbi__get16le(s);
      s->img_y = stbi__get16le(s);
   } else {
      s->img_x = stbi__get32le(s);
      s->img_y = stbi__get32le(s);
   }
   if (stbi__get16le(s) != 1) return stbi__errpuc(""bad BMP"", ""bad BMP"");
   info->bpp = stbi__get16le(s);
   if (hsz != 12) {
      int compress = stbi__get32le(s);
      if (compress == 1 || compress == 2) return stbi__errpuc(""BMP RLE"", ""BMP type not supported: RLE"");
      if (compress >= 4) return stbi__errpuc(""BMP JPEG/PNG"", ""BMP type not supported: unsupported compression""); // this includes PNG/JPEG modes
      if (compress == 3 && info->bpp != 16 && info->bpp != 32) return stbi__errpuc(""bad BMP"", ""bad BMP""); // bitfields requires 16 or 32 bits/pixel
      stbi__get32le(s); // discard sizeof
      stbi__get32le(s); // discard hres
      stbi__get32le(s); // discard vres
      stbi__get32le(s); // discard colorsused
      stbi__get32le(s); // discard max important
      if (hsz == 40 || hsz == 56) {
         if (hsz == 56) {
            stbi__get32le(s);
            stbi__get32le(s);
            stbi__get32le(s);
            stbi__get32le(s);
         }
         if (info->bpp == 16 || info->bpp == 32) {
            if (compress == 0) {
               stbi__bmp_set_mask_defaults(info, compress);
            } else if (compress == 3) {
               info->mr = stbi__get32le(s);
               info->mg = stbi__get32le(s);
               info->mb = stbi__get32le(s);
               info->extra_read += 12;
               // not documented, but generated by photoshop and handled by mspaint
               if (info->mr == info->mg && info->mg == info->mb) {
                  // ?!?!?
                  return stbi__errpuc(""bad BMP"", ""bad BMP"");
               }
            } else
               return stbi__errpuc(""bad BMP"", ""bad BMP"");
         }
      } else {
         // V4/V5 header
         int i;
         if (hsz != 108 && hsz != 124)
            return stbi__errpuc(""bad BMP"", ""bad BMP"");
         info->mr = stbi__get32le(s);
         info->mg = stbi__get32le(s);
         info->mb = stbi__get32le(s);
         info->ma = stbi__get32le(s);
         if (compress != 3) // override mr/mg/mb unless in BI_BITFIELDS mode, as per docs
            stbi__bmp_set_mask_defaults(info, compress);
         stbi__get32le(s); // discard color space
         for (i=0; i < 12; ++i)
            stbi__get32le(s); // discard color space parameters
         if (hsz == 124) {
            stbi__get32le(s); // discard rendering intent
            stbi__get32le(s); // discard offset of profile data
            stbi__get32le(s); // discard size of profile data
            stbi__get32le(s); // discard reserved
         }
      }
   }
   return (void *) 1;
}","{'begin': {'line': 5448, 'column': 1}, 'end': {'line': 5528, 'column': 2}}",show_image.c,"['解析', 'BMP', '文件', '头', '并', '验证', '有效', '有效性']"
740,740,stbi_set_unpremultiply_on_load_thread,void,void stbi_set_unpremultiply_on_load_thread(int flag_true_if_should_unpremultiply),"[{'name': 'flag_true_if_should_unpremultiply', 'type': 'int'}]",设置加载时取消预乘Alpha的线程标志,"STBIDEF void stbi_set_unpremultiply_on_load_thread(int flag_true_if_should_unpremultiply)
{
   stbi__unpremultiply_on_load_local = flag_true_if_should_unpremultiply;
   stbi__unpremultiply_on_load_set = 1;
}","{'begin': {'line': 5013, 'column': 1}, 'end': {'line': 5017, 'column': 2}}",show_image.c,"['设置', '加载', '时', '取消', '预乘', 'Alpha', '的', '线程', '标志']"
741,741,stbi_convert_iphone_png_to_rgb_thread,void,void stbi_convert_iphone_png_to_rgb_thread(int flag_true_if_should_convert),"[{'name': 'flag_true_if_should_convert', 'type': 'int'}]",设置iPhone PNG转RGB的线程处理标志,"STBIDEF void stbi_convert_iphone_png_to_rgb_thread(int flag_true_if_should_convert)
{
   stbi__de_iphone_flag_local = flag_true_if_should_convert;
   stbi__de_iphone_flag_set = 1;
}","{'begin': {'line': 5019, 'column': 1}, 'end': {'line': 5023, 'column': 2}}",show_image.c,"['设置', 'iPhone', ' ', 'PNG', '转', 'RGB', '的', '线程', '处理', '标志']"
742,742,stbi__de_iphone,void,void stbi__de_iphone(stbi__png * z),"[{'name': 'z', 'type': 'stbi__png *'}]",将BGR转换为RGB，可选反预乘处理,"static void stbi__de_iphone(stbi__png *z)
{
   stbi__context *s = z->s;
   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
   stbi_uc *p = z->out;

   if (s->img_out_n == 3) {  // convert bgr to rgb
      for (i=0; i < pixel_count; ++i) {
         stbi_uc t = p[0];
         p[0] = p[2];
         p[2] = t;
         p += 3;
      }
   } else {
      STBI_ASSERT(s->img_out_n == 4);
      if (stbi__unpremultiply_on_load) {
         // convert bgr to rgb and unpremultiply
         for (i=0; i < pixel_count; ++i) {
            stbi_uc a = p[3];
            stbi_uc t = p[0];
            if (a) {
               stbi_uc half = a / 2;
               p[0] = (p[2] * 255 + half) / a;
               p[1] = (p[1] * 255 + half) / a;
               p[2] = ( t   * 255 + half) / a;
            } else {
               p[0] = p[2];
               p[2] = t;
            }
            p += 4;
         }
      } else {
         // convert bgr to rgb
         for (i=0; i < pixel_count; ++i) {
            stbi_uc t = p[0];
            p[0] = p[2];
            p[2] = t;
            p += 4;
         }
      }
   }
}","{'begin': {'line': 5033, 'column': 1}, 'end': {'line': 5074, 'column': 2}}",show_image.c,"['将', 'BGR', '转换', '为', 'RGB', '，', '可选', '可选反', '预乘', '处理']"
743,743,stbi__parse_png_file,int,"int stbi__parse_png_file(stbi__png * z, int scan, int req_comp)","[{'name': 'z', 'type': 'stbi__png *'}, {'name': 'scan', 'type': 'int'}, {'name': 'req_comp', 'type': 'int'}]",解析PNG文件数据块并解码图像,"static int stbi__parse_png_file(stbi__png *z, int scan, int req_comp)
{
   stbi_uc palette[1024], pal_img_n=0;
   stbi_uc has_trans=0, tc[3]={0};
   stbi__uint16 tc16[3];
   stbi__uint32 ioff=0, idata_limit=0, i, pal_len=0;
   int first=1,k,interlace=0, color=0, is_iphone=0;
   stbi__context *s = z->s;

   z->expanded = NULL;
   z->idata = NULL;
   z->out = NULL;

   if (!stbi__check_png_header(s)) return 0;

   if (scan == STBI__SCAN_type) return 1;

   for (;;) {
      stbi__pngchunk c = stbi__get_chunk_header(s);
      switch (c.type) {
         case STBI__PNG_TYPE('C','g','B','I'):
            is_iphone = 1;
            stbi__skip(s, c.length);
            break;
         case STBI__PNG_TYPE('I','H','D','R'): {
            int comp,filter;
            if (!first) return stbi__err(""multiple IHDR"",""Corrupt PNG"");
            first = 0;
            if (c.length != 13) return stbi__err(""bad IHDR len"",""Corrupt PNG"");
            s->img_x = stbi__get32be(s);
            s->img_y = stbi__get32be(s);
            if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err(""too large"",""Very large image (corrupt?)"");
            if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err(""too large"",""Very large image (corrupt?)"");
            z->depth = stbi__get8(s);  if (z->depth != 1 && z->depth != 2 && z->depth != 4 && z->depth != 8 && z->depth != 16)  return stbi__err(""1/2/4/8/16-bit only"",""PNG not supported: 1/2/4/8/16-bit only"");
            color = stbi__get8(s);  if (color > 6)         return stbi__err(""bad ctype"",""Corrupt PNG"");
            if (color == 3 && z->depth == 16)                  return stbi__err(""bad ctype"",""Corrupt PNG"");
            if (color == 3) pal_img_n = 3; else if (color & 1) return stbi__err(""bad ctype"",""Corrupt PNG"");
            comp  = stbi__get8(s);  if (comp) return stbi__err(""bad comp method"",""Corrupt PNG"");
            filter= stbi__get8(s);  if (filter) return stbi__err(""bad filter method"",""Corrupt PNG"");
            interlace = stbi__get8(s); if (interlace>1) return stbi__err(""bad interlace method"",""Corrupt PNG"");
            if (!s->img_x || !s->img_y) return stbi__err(""0-pixel image"",""Corrupt PNG"");
            if (!pal_img_n) {
               s->img_n = (color & 2 ? 3 : 1) + (color & 4 ? 1 : 0);
               if ((1 << 30) / s->img_x / s->img_n < s->img_y) return stbi__err(""too large"", ""Image too large to decode"");
            } else {
               // if paletted, then pal_n is our final components, and
               // img_n is # components to decompress/filter.
               s->img_n = 1;
               if ((1 << 30) / s->img_x / 4 < s->img_y) return stbi__err(""too large"",""Corrupt PNG"");
            }
            // even with SCAN_header, have to scan to see if we have a tRNS
            break;
         }

         case STBI__PNG_TYPE('P','L','T','E'):  {
            if (first) return stbi__err(""first not IHDR"", ""Corrupt PNG"");
            if (c.length > 256*3) return stbi__err(""invalid PLTE"",""Corrupt PNG"");
            pal_len = c.length / 3;
            if (pal_len * 3 != c.length) return stbi__err(""invalid PLTE"",""Corrupt PNG"");
            for (i=0; i < pal_len; ++i) {
               palette[i*4+0] = stbi__get8(s);
               palette[i*4+1] = stbi__get8(s);
               palette[i*4+2] = stbi__get8(s);
               palette[i*4+3] = 255;
            }
            break;
         }

         case STBI__PNG_TYPE('t','R','N','S'): {
            if (first) return stbi__err(""first not IHDR"", ""Corrupt PNG"");
            if (z->idata) return stbi__err(""tRNS after IDAT"",""Corrupt PNG"");
            if (pal_img_n) {
               if (scan == STBI__SCAN_header) { s->img_n = 4; return 1; }
               if (pal_len == 0) return stbi__err(""tRNS before PLTE"",""Corrupt PNG"");
               if (c.length > pal_len) return stbi__err(""bad tRNS len"",""Corrupt PNG"");
               pal_img_n = 4;
               for (i=0; i < c.length; ++i)
                  palette[i*4+3] = stbi__get8(s);
            } else {
               if (!(s->img_n & 1)) return stbi__err(""tRNS with alpha"",""Corrupt PNG"");
               if (c.length != (stbi__uint32) s->img_n*2) return stbi__err(""bad tRNS len"",""Corrupt PNG"");
               has_trans = 1;
               // non-paletted with tRNS = constant alpha. if header-scanning, we can stop now.
               if (scan == STBI__SCAN_header) { ++s->img_n; return 1; }
               if (z->depth == 16) {
                  for (k = 0; k < s->img_n && k < 3; ++k) // extra loop test to suppress false GCC warning
                     tc16[k] = (stbi__uint16)stbi__get16be(s); // copy the values as-is
               } else {
                  for (k = 0; k < s->img_n && k < 3; ++k)
                     tc[k] = (stbi_uc)(stbi__get16be(s) & 255) * stbi__depth_scale_table[z->depth]; // non 8-bit images will be larger
               }
            }
            break;
         }

         case STBI__PNG_TYPE('I','D','A','T'): {
            if (first) return stbi__err(""first not IHDR"", ""Corrupt PNG"");
            if (pal_img_n && !pal_len) return stbi__err(""no PLTE"",""Corrupt PNG"");
            if (scan == STBI__SCAN_header) {
               // header scan definitely stops at first IDAT
               if (pal_img_n)
                  s->img_n = pal_img_n;
               return 1;
            }
            if (c.length > (1u << 30)) return stbi__err(""IDAT size limit"", ""IDAT section larger than 2^30 bytes"");
            if ((int)(ioff + c.length) < (int)ioff) return 0;
            if (ioff + c.length > idata_limit) {
               stbi__uint32 idata_limit_old = idata_limit;
               stbi_uc *p;
               if (idata_limit == 0) idata_limit = c.length > 4096 ? c.length : 4096;
               while (ioff + c.length > idata_limit)
                  idata_limit *= 2;
               STBI_NOTUSED(idata_limit_old);
               p = (stbi_uc *) STBI_REALLOC_SIZED(z->idata, idata_limit_old, idata_limit); if (p == NULL) return stbi__err(""outofmem"", ""Out of memory"");
               z->idata = p;
            }
            if (!stbi__getn(s, z->idata+ioff,c.length)) return stbi__err(""outofdata"",""Corrupt PNG"");
            ioff += c.length;
            break;
         }

         case STBI__PNG_TYPE('I','E','N','D'): {
            stbi__uint32 raw_len, bpl;
            if (first) return stbi__err(""first not IHDR"", ""Corrupt PNG"");
            if (scan != STBI__SCAN_load) return 1;
            if (z->idata == NULL) return stbi__err(""no IDAT"",""Corrupt PNG"");
            // initial guess for decoded data size to avoid unnecessary reallocs
            bpl = (s->img_x * z->depth + 7) / 8; // bytes per line, per component
            raw_len = bpl * s->img_y * s->img_n /* pixels */ + s->img_y /* filter mode per row */;
            z->expanded = (stbi_uc *) stbi_zlib_decode_malloc_guesssize_headerflag((char *) z->idata, ioff, raw_len, (int *) &raw_len, !is_iphone);
            if (z->expanded == NULL) return 0; // zlib should set error
            STBI_FREE(z->idata); z->idata = NULL;
            if ((req_comp == s->img_n+1 && req_comp != 3 && !pal_img_n) || has_trans)
               s->img_out_n = s->img_n+1;
            else
               s->img_out_n = s->img_n;
            if (!stbi__create_png_image(z, z->expanded, raw_len, s->img_out_n, z->depth, color, interlace)) return 0;
            if (has_trans) {
               if (z->depth == 16) {
                  if (!stbi__compute_transparency16(z, tc16, s->img_out_n)) return 0;
               } else {
                  if (!stbi__compute_transparency(z, tc, s->img_out_n)) return 0;
               }
            }
            if (is_iphone && stbi__de_iphone_flag && s->img_out_n > 2)
               stbi__de_iphone(z);
            if (pal_img_n) {
               // pal_img_n == 3 or 4
               s->img_n = pal_img_n; // record the actual colors we had
               s->img_out_n = pal_img_n;
               if (req_comp >= 3) s->img_out_n = req_comp;
               if (!stbi__expand_png_palette(z, palette, pal_len, s->img_out_n))
                  return 0;
            } else if (has_trans) {
               // non-paletted image with tRNS -> source image has (constant) alpha
               ++s->img_n;
            }
            STBI_FREE(z->expanded); z->expanded = NULL;
            // end of PNG chunk, read and skip CRC
            stbi__get32be(s);
            return 1;
         }

         default:
            // if critical, fail
            if (first) return stbi__err(""first not IHDR"", ""Corrupt PNG"");
            if ((c.type & (1 << 29)) == 0) {
               #ifndef STBI_NO_FAILURE_STRINGS
               // not threadsafe
               static char invalid_chunk[] = ""XXXX PNG chunk not known"";
               invalid_chunk[0] = STBI__BYTECAST(c.type >> 24);
               invalid_chunk[1] = STBI__BYTECAST(c.type >> 16);
               invalid_chunk[2] = STBI__BYTECAST(c.type >>  8);
               invalid_chunk[3] = STBI__BYTECAST(c.type >>  0);
               #endif
               return stbi__err(invalid_chunk, ""PNG not supported: unknown PNG chunk type"");
            }
            stbi__skip(s, c.length);
            break;
      }
      // end of PNG chunk, read and skip CRC
      stbi__get32be(s);
   }
}","{'begin': {'line': 5078, 'column': 1}, 'end': {'line': 5261, 'column': 2}}",show_image.c,"['解析', 'PNG', '文件', '数据', '块', '并', '解码', '图像']"
744,744,stbi__bmp_load,void *,"void * stbi__bmp_load(stbi__context * s, int * x, int * y, int * comp, int req_comp, stbi__result_info * ri)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'ri', 'type': 'stbi__result_info *'}]",解析BMP图像数据，处理调色板及像素格式，返回解码后的像素数组。,"static void *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   stbi_uc *out;
   unsigned int mr=0,mg=0,mb=0,ma=0, all_a;
   stbi_uc pal[256][4];
   int psize=0,i,j,width;
   int flip_vertically, pad, target;
   stbi__bmp_data info;
   STBI_NOTUSED(ri);

   info.all_a = 255;
   if (stbi__bmp_parse_header(s, &info) == NULL)
      return NULL; // error code already set

   flip_vertically = ((int) s->img_y) > 0;
   s->img_y = abs((int) s->img_y);

   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc(""too large"",""Very large image (corrupt?)"");
   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc(""too large"",""Very large image (corrupt?)"");

   mr = info.mr;
   mg = info.mg;
   mb = info.mb;
   ma = info.ma;
   all_a = info.all_a;

   if (info.hsz == 12) {
      if (info.bpp < 24)
         psize = (info.offset - info.extra_read - 24) / 3;
   } else {
      if (info.bpp < 16)
         psize = (info.offset - info.extra_read - info.hsz) >> 2;
   }
   if (psize == 0) {
      // accept some number of extra bytes after the header, but if the offset points either to before
      // the header ends or implies a large amount of extra data, reject the file as malformed
      int bytes_read_so_far = s->callback_already_read + (int)(s->img_buffer - s->img_buffer_original);
      int header_limit = 1024; // max we actually read is below 256 bytes currently.
      int extra_data_limit = 256*4; // what ordinarily goes here is a palette; 256 entries*4 bytes is its max size.
      if (bytes_read_so_far <= 0 || bytes_read_so_far > header_limit) {
         return stbi__errpuc(""bad header"", ""Corrupt BMP"");
      }
      // we established that bytes_read_so_far is positive and sensible.
      // the first half of this test rejects offsets that are either too small positives, or
      // negative, and guarantees that info.offset >= bytes_read_so_far > 0. this in turn
      // ensures the number computed in the second half of the test can't overflow.
      if (info.offset < bytes_read_so_far || info.offset - bytes_read_so_far > extra_data_limit) {
         return stbi__errpuc(""bad offset"", ""Corrupt BMP"");
      } else {
         stbi__skip(s, info.offset - bytes_read_so_far);
      }
   }

   if (info.bpp == 24 && ma == 0xff000000)
      s->img_n = 3;
   else
      s->img_n = ma ? 4 : 3;
   if (req_comp && req_comp >= 3) // we can directly decode 3 or 4
      target = req_comp;
   else
      target = s->img_n; // if they want monochrome, we'll post-convert

   // sanity-check size
   if (!stbi__mad3sizes_valid(target, s->img_x, s->img_y, 0))
      return stbi__errpuc(""too large"", ""Corrupt BMP"");

   out = (stbi_uc *) stbi__malloc_mad3(target, s->img_x, s->img_y, 0);
   if (!out) return stbi__errpuc(""outofmem"", ""Out of memory"");
   if (info.bpp < 16) {
      int z=0;
      if (psize == 0 || psize > 256) { STBI_FREE(out); return stbi__errpuc(""invalid"", ""Corrupt BMP""); }
      for (i=0; i < psize; ++i) {
         pal[i][2] = stbi__get8(s);
         pal[i][1] = stbi__get8(s);
         pal[i][0] = stbi__get8(s);
         if (info.hsz != 12) stbi__get8(s);
         pal[i][3] = 255;
      }
      stbi__skip(s, info.offset - info.extra_read - info.hsz - psize * (info.hsz == 12 ? 3 : 4));
      if (info.bpp == 1) width = (s->img_x + 7) >> 3;
      else if (info.bpp == 4) width = (s->img_x + 1) >> 1;
      else if (info.bpp == 8) width = s->img_x;
      else { STBI_FREE(out); return stbi__errpuc(""bad bpp"", ""Corrupt BMP""); }
      pad = (-width)&3;
      if (info.bpp == 1) {
         for (j=0; j < (int) s->img_y; ++j) {
            int bit_offset = 7, v = stbi__get8(s);
            for (i=0; i < (int) s->img_x; ++i) {
               int color = (v>>bit_offset)&0x1;
               out[z++] = pal[color][0];
               out[z++] = pal[color][1];
               out[z++] = pal[color][2];
               if (target == 4) out[z++] = 255;
               if (i+1 == (int) s->img_x) break;
               if((--bit_offset) < 0) {
                  bit_offset = 7;
                  v = stbi__get8(s);
               }
            }
            stbi__skip(s, pad);
         }
      } else {
         for (j=0; j < (int) s->img_y; ++j) {
            for (i=0; i < (int) s->img_x; i += 2) {
               int v=stbi__get8(s),v2=0;
               if (info.bpp == 4) {
                  v2 = v & 15;
                  v >>= 4;
               }
               out[z++] = pal[v][0];
               out[z++] = pal[v][1];
               out[z++] = pal[v][2];
               if (target == 4) out[z++] = 255;
               if (i+1 == (int) s->img_x) break;
               v = (info.bpp == 8) ? stbi__get8(s) : v2;
               out[z++] = pal[v][0];
               out[z++] = pal[v][1];
               out[z++] = pal[v][2];
               if (target == 4) out[z++] = 255;
            }
            stbi__skip(s, pad);
         }
      }
   } else {
      int rshift=0,gshift=0,bshift=0,ashift=0,rcount=0,gcount=0,bcount=0,acount=0;
      int z = 0;
      int easy=0;
      stbi__skip(s, info.offset - info.extra_read - info.hsz);
      if (info.bpp == 24) width = 3 * s->img_x;
      else if (info.bpp == 16) width = 2*s->img_x;
      else /* bpp = 32 and pad = 0 */ width=0;
      pad = (-width) & 3;
      if (info.bpp == 24) {
         easy = 1;
      } else if (info.bpp == 32) {
         if (mb == 0xff && mg == 0xff00 && mr == 0x00ff0000 && ma == 0xff000000)
            easy = 2;
      }
      if (!easy) {
         if (!mr || !mg || !mb) { STBI_FREE(out); return stbi__errpuc(""bad masks"", ""Corrupt BMP""); }
         // right shift amt to put high bit in position #7
         rshift = stbi__high_bit(mr)-7; rcount = stbi__bitcount(mr);
         gshift = stbi__high_bit(mg)-7; gcount = stbi__bitcount(mg);
         bshift = stbi__high_bit(mb)-7; bcount = stbi__bitcount(mb);
         ashift = stbi__high_bit(ma)-7; acount = stbi__bitcount(ma);
         if (rcount > 8 || gcount > 8 || bcount > 8 || acount > 8) { STBI_FREE(out); return stbi__errpuc(""bad masks"", ""Corrupt BMP""); }
      }
      for (j=0; j < (int) s->img_y; ++j) {
         if (easy) {
            for (i=0; i < (int) s->img_x; ++i) {
               unsigned char a;
               out[z+2] = stbi__get8(s);
               out[z+1] = stbi__get8(s);
               out[z+0] = stbi__get8(s);
               z += 3;
               a = (easy == 2 ? stbi__get8(s) : 255);
               all_a |= a;
               if (target == 4) out[z++] = a;
            }
         } else {
            int bpp = info.bpp;
            for (i=0; i < (int) s->img_x; ++i) {
               stbi__uint32 v = (bpp == 16 ? (stbi__uint32) stbi__get16le(s) : stbi__get32le(s));
               unsigned int a;
               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mr, rshift, rcount));
               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mg, gshift, gcount));
               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mb, bshift, bcount));
               a = (ma ? stbi__shiftsigned(v & ma, ashift, acount) : 255);
               all_a |= a;
               if (target == 4) out[z++] = STBI__BYTECAST(a);
            }
         }
         stbi__skip(s, pad);
      }
   }

   // if alpha channel is all 0s, replace with all 255s
   if (target == 4 && all_a == 0)
      for (i=4*s->img_x*s->img_y-1; i >= 0; i -= 4)
         out[i] = 255;

   if (flip_vertically) {
      stbi_uc t;
      for (j=0; j < (int) s->img_y>>1; ++j) {
         stbi_uc *p1 = out +      j     *s->img_x*target;
         stbi_uc *p2 = out + (s->img_y-1-j)*s->img_x*target;
         for (i=0; i < (int) s->img_x*target; ++i) {
            t = p1[i]; p1[i] = p2[i]; p2[i] = t;
         }
      }
   }

   if (req_comp && req_comp != target) {
      out = stbi__convert_format(out, target, req_comp, s->img_x, s->img_y);
      if (out == NULL) return out; // stbi__convert_format frees input on failure
   }

   *x = s->img_x;
   *y = s->img_y;
   if (comp) *comp = s->img_n;
   return out;
}","{'begin': {'line': 5531, 'column': 1}, 'end': {'line': 5732, 'column': 2}}",show_image.c,"['解析', 'BMP', '图像', '数据', '，', '处理', '调色', '调色板', '及', '像素', '格式', '，', '返回', '解码', '后', '的', '像素', '数组', '。']"
745,745,stbi__tga_get_comp,int,"int stbi__tga_get_comp(int bits_per_pixel, int is_grey, int * is_rgb16)","[{'name': 'bits_per_pixel', 'type': 'int'}, {'name': 'is_grey', 'type': 'int'}, {'name': 'is_rgb16', 'type': 'int *'}]",根据像素位数和灰度标识确定TGA图像组件类型及RGB16标志,"static int stbi__tga_get_comp(int bits_per_pixel, int is_grey, int* is_rgb16)
{
   // only RGB or RGBA (incl. 16bit) or grey allowed
   if (is_rgb16) *is_rgb16 = 0;
   switch(bits_per_pixel) {
      case 8:  return STBI_grey;
      case 16: if(is_grey) return STBI_grey_alpha;
               // fallthrough
      case 15: if(is_rgb16) *is_rgb16 = 1;
               return STBI_rgb;
      case 24: // fallthrough
      case 32: return bits_per_pixel/8;
      default: return 0;
   }
}","{'begin': {'line': 5739, 'column': 1}, 'end': {'line': 5753, 'column': 2}}",show_image.c,"['根据', '像素', '位数', '和', '灰度', '标识', '确定', 'TGA', '图像', '组件', '类型', '及', 'RGB16', '标志']"
746,746,stbi__tga_info,int,"int stbi__tga_info(stbi__context * s, int * x, int * y, int * comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",解析并验证TGA图像头信息，获取尺寸及通道数,"static int stbi__tga_info(stbi__context *s, int *x, int *y, int *comp)
{
    int tga_w, tga_h, tga_comp, tga_image_type, tga_bits_per_pixel, tga_colormap_bpp;
    int sz, tga_colormap_type;
    stbi__get8(s);                   // discard Offset
    tga_colormap_type = stbi__get8(s); // colormap type
    if( tga_colormap_type > 1 ) {
        stbi__rewind(s);
        return 0;      // only RGB or indexed allowed
    }
    tga_image_type = stbi__get8(s); // image type
    if ( tga_colormap_type == 1 ) { // colormapped (paletted) image
        if (tga_image_type != 1 && tga_image_type != 9) {
            stbi__rewind(s);
            return 0;
        }
        stbi__skip(s,4);       // skip index of first colormap entry and number of entries
        sz = stbi__get8(s);    //   check bits per palette color entry
        if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) {
            stbi__rewind(s);
            return 0;
        }
        stbi__skip(s,4);       // skip image x and y origin
        tga_colormap_bpp = sz;
    } else { // ""normal"" image w/o colormap - only RGB or grey allowed, +/- RLE
        if ( (tga_image_type != 2) && (tga_image_type != 3) && (tga_image_type != 10) && (tga_image_type != 11) ) {
            stbi__rewind(s);
            return 0; // only RGB or grey allowed, +/- RLE
        }
        stbi__skip(s,9); // skip colormap specification and image x/y origin
        tga_colormap_bpp = 0;
    }
    tga_w = stbi__get16le(s);
    if( tga_w < 1 ) {
        stbi__rewind(s);
        return 0;   // test width
    }
    tga_h = stbi__get16le(s);
    if( tga_h < 1 ) {
        stbi__rewind(s);
        return 0;   // test height
    }
    tga_bits_per_pixel = stbi__get8(s); // bits per pixel
    stbi__get8(s); // ignore alpha bits
    if (tga_colormap_bpp != 0) {
        if((tga_bits_per_pixel != 8) && (tga_bits_per_pixel != 16)) {
            // when using a colormap, tga_bits_per_pixel is the size of the indexes
            // I don't think anything but 8 or 16bit indexes makes sense
            stbi__rewind(s);
            return 0;
        }
        tga_comp = stbi__tga_get_comp(tga_colormap_bpp, 0, NULL);
    } else {
        tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3) || (tga_image_type == 11), NULL);
    }
    if(!tga_comp) {
      stbi__rewind(s);
      return 0;
    }
    if (x) *x = tga_w;
    if (y) *y = tga_h;
    if (comp) *comp = tga_comp;
    return 1;                   // seems to have passed everything
}","{'begin': {'line': 5755, 'column': 1}, 'end': {'line': 5818, 'column': 2}}",show_image.c,"['解析', '并', '验证', 'TGA', '图像', '头', '信息', '，', '获取', '尺寸', '及', '通道', '数']"
747,747,stbi__do_png,void *,"void * stbi__do_png(stbi__png * p, int * x, int * y, int * n, int req_comp, stbi__result_info * ri)","[{'name': 'p', 'type': 'stbi__png *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'n', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'ri', 'type': 'stbi__result_info *'}]",解析PNG图像数据并转换格式,"static void *stbi__do_png(stbi__png *p, int *x, int *y, int *n, int req_comp, stbi__result_info *ri)
{
   void *result=NULL;
   if (req_comp < 0 || req_comp > 4) return stbi__errpuc(""bad req_comp"", ""Internal error"");
   if (stbi__parse_png_file(p, STBI__SCAN_load, req_comp)) {
      if (p->depth <= 8)
         ri->bits_per_channel = 8;
      else if (p->depth == 16)
         ri->bits_per_channel = 16;
      else
         return stbi__errpuc(""bad bits_per_channel"", ""PNG not supported: unsupported color depth"");
      result = p->out;
      p->out = NULL;
      if (req_comp && req_comp != p->s->img_out_n) {
         if (ri->bits_per_channel == 8)
            result = stbi__convert_format((unsigned char *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
         else
            result = stbi__convert_format16((stbi__uint16 *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
         p->s->img_out_n = req_comp;
         if (result == NULL) return result;
      }
      *x = p->s->img_x;
      *y = p->s->img_y;
      if (n) *n = p->s->img_n;
   }
   STBI_FREE(p->out);      p->out      = NULL;
   STBI_FREE(p->expanded); p->expanded = NULL;
   STBI_FREE(p->idata);    p->idata    = NULL;

   return result;
}","{'begin': {'line': 5263, 'column': 1}, 'end': {'line': 5293, 'column': 2}}",show_image.c,"['解析', 'PNG', '图像', '数据', '并', '转换', '格式']"
748,748,stbi__tga_test,int,int stbi__tga_test(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",验证TGA图像格式的有效性,"static int stbi__tga_test(stbi__context *s)
{
   int res = 0;
   int sz, tga_color_type;
   stbi__get8(s);      //   discard Offset
   tga_color_type = stbi__get8(s);   //   color type
   if ( tga_color_type > 1 ) goto errorEnd;   //   only RGB or indexed allowed
   sz = stbi__get8(s);   //   image type
   if ( tga_color_type == 1 ) { // colormapped (paletted) image
      if (sz != 1 && sz != 9) goto errorEnd; // colortype 1 demands image type 1 or 9
      stbi__skip(s,4);       // skip index of first colormap entry and number of entries
      sz = stbi__get8(s);    //   check bits per palette color entry
      if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;
      stbi__skip(s,4);       // skip image x and y origin
   } else { // ""normal"" image w/o colormap
      if ( (sz != 2) && (sz != 3) && (sz != 10) && (sz != 11) ) goto errorEnd; // only RGB or grey allowed, +/- RLE
      stbi__skip(s,9); // skip colormap specification and image x/y origin
   }
   if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test width
   if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test height
   sz = stbi__get8(s);   //   bits per pixel
   if ( (tga_color_type == 1) && (sz != 8) && (sz != 16) ) goto errorEnd; // for colormapped images, bpp is size of an index
   if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;

   res = 1; // if we got this far, everything's good and we can return 1 instead of 0

errorEnd:
   stbi__rewind(s);
   return res;
}","{'begin': {'line': 5820, 'column': 1}, 'end': {'line': 5849, 'column': 2}}",show_image.c,"['验证', 'TGA', '图像', '格式', '图像格式', '的', '有效', '有效性']"
749,749,stbi__png_load,void *,"void * stbi__png_load(stbi__context * s, int * x, int * y, int * comp, int req_comp, stbi__result_info * ri)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'ri', 'type': 'stbi__result_info *'}]",加载PNG图像数据，调用内部处理函数,"static void *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   stbi__png p;
   p.s = s;
   return stbi__do_png(&p, x,y,comp,req_comp, ri);
}","{'begin': {'line': 5295, 'column': 1}, 'end': {'line': 5300, 'column': 2}}",show_image.c,"['加载', 'PNG', '图像', '数据', '，', '调用', '内部', '处理', '函数', '处理函数']"
750,750,stbi__png_test,int,int stbi__png_test(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",检测输入是否为有效PNG图像,"static int stbi__png_test(stbi__context *s)
{
   int r;
   r = stbi__check_png_header(s);
   stbi__rewind(s);
   return r;
}","{'begin': {'line': 5302, 'column': 1}, 'end': {'line': 5308, 'column': 2}}",show_image.c,"['检测', '输入', '是否', '为', '有效', 'PNG', '图像']"
751,751,stbi__png_info_raw,int,"int stbi__png_info_raw(stbi__png * p, int * x, int * y, int * comp)","[{'name': 'p', 'type': 'stbi__png *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",提取PNG图像尺寸及通道信息,"static int stbi__png_info_raw(stbi__png *p, int *x, int *y, int *comp)
{
   if (!stbi__parse_png_file(p, STBI__SCAN_header, 0)) {
      stbi__rewind( p->s );
      return 0;
   }
   if (x) *x = p->s->img_x;
   if (y) *y = p->s->img_y;
   if (comp) *comp = p->s->img_n;
   return 1;
}","{'begin': {'line': 5310, 'column': 1}, 'end': {'line': 5320, 'column': 2}}",show_image.c,"['提取', 'PNG', '图像', '尺寸', '及', '通道', '信息']"
752,752,stbi__tga_read_rgb16,void,"void stbi__tga_read_rgb16(stbi__context * s, stbi_uc * out)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'out', 'type': 'stbi_uc *'}]",读取16位TGA RGB数据并转换为8位格式,"static void stbi__tga_read_rgb16(stbi__context *s, stbi_uc* out)
{
   stbi__uint16 px = (stbi__uint16)stbi__get16le(s);
   stbi__uint16 fiveBitMask = 31;
   // we have 3 channels with 5bits each
   int r = (px >> 10) & fiveBitMask;
   int g = (px >> 5) & fiveBitMask;
   int b = px & fiveBitMask;
   // Note that this saves the data in RGB(A) order, so it doesn't need to be swapped later
   out[0] = (stbi_uc)((r * 255)/31);
   out[1] = (stbi_uc)((g * 255)/31);
   out[2] = (stbi_uc)((b * 255)/31);

   // some people claim that the most significant bit might be used for alpha
   // (possibly if an alpha-bit is set in the ""image descriptor byte"")
   // but that only made 16bit test images completely translucent..
   // so let's treat all 15 and 16bit TGAs as RGB with no alpha.
}","{'begin': {'line': 5852, 'column': 1}, 'end': {'line': 5869, 'column': 2}}",show_image.c,"['读取', '16', '位', 'TGA', ' ', 'RGB', '数据', '并', '转换', '为', '8', '位', '格式']"
753,753,stbi__png_info,int,"int stbi__png_info(stbi__context * s, int * x, int * y, int * comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",解析PNG图像尺寸及通道信息,"static int stbi__png_info(stbi__context *s, int *x, int *y, int *comp)
{
   stbi__png p;
   p.s = s;
   return stbi__png_info_raw(&p, x, y, comp);
}","{'begin': {'line': 5322, 'column': 1}, 'end': {'line': 5327, 'column': 2}}",show_image.c,"['解析', 'PNG', '图像', '尺寸', '及', '通道', '信息']"
754,754,stbi__png_is16,int,int stbi__png_is16(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",检查PNG图像是否为16位深度,"static int stbi__png_is16(stbi__context *s)
{
   stbi__png p;
   p.s = s;
   if (!stbi__png_info_raw(&p, NULL, NULL, NULL))
	   return 0;
   if (p.depth != 16) {
      stbi__rewind(p.s);
      return 0;
   }
   return 1;
}","{'begin': {'line': 5329, 'column': 1}, 'end': {'line': 5340, 'column': 2}}",show_image.c,"['检查', 'PNG', '图像', '是否', '为', '16', '位', '深度']"
755,755,stbi__bmp_test_raw,int,int stbi__bmp_test_raw(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",检测输入流是否为有效BMP格式,"static int stbi__bmp_test_raw(stbi__context *s)
{
   int r;
   int sz;
   if (stbi__get8(s) != 'B') return 0;
   if (stbi__get8(s) != 'M') return 0;
   stbi__get32le(s); // discard filesize
   stbi__get16le(s); // discard reserved
   stbi__get16le(s); // discard reserved
   stbi__get32le(s); // discard data offset
   sz = stbi__get32le(s);
   r = (sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124);
   return r;
}","{'begin': {'line': 5346, 'column': 1}, 'end': {'line': 5359, 'column': 2}}",show_image.c,"['检测', '输入', '流', '是否', '为', '有效', 'BMP', '格式']"
756,756,stbi__tga_load,void *,"void * stbi__tga_load(stbi__context * s, int * x, int * y, int * comp, int req_comp, stbi__result_info * ri)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'ri', 'type': 'stbi__result_info *'}]",加载并解析TGA图像，支持RLE压缩和调色板，转换格式。,"static void *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   //   read in the TGA header stuff
   int tga_offset = stbi__get8(s);
   int tga_indexed = stbi__get8(s);
   int tga_image_type = stbi__get8(s);
   int tga_is_RLE = 0;
   int tga_palette_start = stbi__get16le(s);
   int tga_palette_len = stbi__get16le(s);
   int tga_palette_bits = stbi__get8(s);
   int tga_x_origin = stbi__get16le(s);
   int tga_y_origin = stbi__get16le(s);
   int tga_width = stbi__get16le(s);
   int tga_height = stbi__get16le(s);
   int tga_bits_per_pixel = stbi__get8(s);
   int tga_comp, tga_rgb16=0;
   int tga_inverted = stbi__get8(s);
   // int tga_alpha_bits = tga_inverted & 15; // the 4 lowest bits - unused (useless?)
   //   image data
   unsigned char *tga_data;
   unsigned char *tga_palette = NULL;
   int i, j;
   unsigned char raw_data[4] = {0};
   int RLE_count = 0;
   int RLE_repeating = 0;
   int read_next_pixel = 1;
   STBI_NOTUSED(ri);
   STBI_NOTUSED(tga_x_origin); // @TODO
   STBI_NOTUSED(tga_y_origin); // @TODO

   if (tga_height > STBI_MAX_DIMENSIONS) return stbi__errpuc(""too large"",""Very large image (corrupt?)"");
   if (tga_width > STBI_MAX_DIMENSIONS) return stbi__errpuc(""too large"",""Very large image (corrupt?)"");

   //   do a tiny bit of precessing
   if ( tga_image_type >= 8 )
   {
      tga_image_type -= 8;
      tga_is_RLE = 1;
   }
   tga_inverted = 1 - ((tga_inverted >> 5) & 1);

   //   If I'm paletted, then I'll use the number of bits from the palette
   if ( tga_indexed ) tga_comp = stbi__tga_get_comp(tga_palette_bits, 0, &tga_rgb16);
   else tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3), &tga_rgb16);

   if(!tga_comp) // shouldn't really happen, stbi__tga_test() should have ensured basic consistency
      return stbi__errpuc(""bad format"", ""Can't find out TGA pixelformat"");

   //   tga info
   *x = tga_width;
   *y = tga_height;
   if (comp) *comp = tga_comp;

   if (!stbi__mad3sizes_valid(tga_width, tga_height, tga_comp, 0))
      return stbi__errpuc(""too large"", ""Corrupt TGA"");

   tga_data = (unsigned char*)stbi__malloc_mad3(tga_width, tga_height, tga_comp, 0);
   if (!tga_data) return stbi__errpuc(""outofmem"", ""Out of memory"");

   // skip to the data's starting position (offset usually = 0)
   stbi__skip(s, tga_offset );

   if ( !tga_indexed && !tga_is_RLE && !tga_rgb16 ) {
      for (i=0; i < tga_height; ++i) {
         int row = tga_inverted ? tga_height -i - 1 : i;
         stbi_uc *tga_row = tga_data + row*tga_width*tga_comp;
         stbi__getn(s, tga_row, tga_width * tga_comp);
      }
   } else  {
      //   do I need to load a palette?
      if ( tga_indexed)
      {
         if (tga_palette_len == 0) {  /* you have to have at least one entry! */
            STBI_FREE(tga_data);
            return stbi__errpuc(""bad palette"", ""Corrupt TGA"");
         }

         //   any data to skip? (offset usually = 0)
         stbi__skip(s, tga_palette_start );
         //   load the palette
         tga_palette = (unsigned char*)stbi__malloc_mad2(tga_palette_len, tga_comp, 0);
         if (!tga_palette) {
            STBI_FREE(tga_data);
            return stbi__errpuc(""outofmem"", ""Out of memory"");
         }
         if (tga_rgb16) {
            stbi_uc *pal_entry = tga_palette;
            STBI_ASSERT(tga_comp == STBI_rgb);
            for (i=0; i < tga_palette_len; ++i) {
               stbi__tga_read_rgb16(s, pal_entry);
               pal_entry += tga_comp;
            }
         } else if (!stbi__getn(s, tga_palette, tga_palette_len * tga_comp)) {
               STBI_FREE(tga_data);
               STBI_FREE(tga_palette);
               return stbi__errpuc(""bad palette"", ""Corrupt TGA"");
         }
      }
      //   load the data
      for (i=0; i < tga_width * tga_height; ++i)
      {
         //   if I'm in RLE mode, do I need to get a RLE stbi__pngchunk?
         if ( tga_is_RLE )
         {
            if ( RLE_count == 0 )
            {
               //   yep, get the next byte as a RLE command
               int RLE_cmd = stbi__get8(s);
               RLE_count = 1 + (RLE_cmd & 127);
               RLE_repeating = RLE_cmd >> 7;
               read_next_pixel = 1;
            } else if ( !RLE_repeating )
            {
               read_next_pixel = 1;
            }
         } else
         {
            read_next_pixel = 1;
         }
         //   OK, if I need to read a pixel, do it now
         if ( read_next_pixel )
         {
            //   load however much data we did have
            if ( tga_indexed )
            {
               // read in index, then perform the lookup
               int pal_idx = (tga_bits_per_pixel == 8) ? stbi__get8(s) : stbi__get16le(s);
               if ( pal_idx >= tga_palette_len ) {
                  // invalid index
                  pal_idx = 0;
               }
               pal_idx *= tga_comp;
               for (j = 0; j < tga_comp; ++j) {
                  raw_data[j] = tga_palette[pal_idx+j];
               }
            } else if(tga_rgb16) {
               STBI_ASSERT(tga_comp == STBI_rgb);
               stbi__tga_read_rgb16(s, raw_data);
            } else {
               //   read in the data raw
               for (j = 0; j < tga_comp; ++j) {
                  raw_data[j] = stbi__get8(s);
               }
            }
            //   clear the reading flag for the next pixel
            read_next_pixel = 0;
         } // end of reading a pixel

         // copy data
         for (j = 0; j < tga_comp; ++j)
           tga_data[i*tga_comp+j] = raw_data[j];

         //   in case we're in RLE mode, keep counting down
         --RLE_count;
      }
      //   do I need to invert the image?
      if ( tga_inverted )
      {
         for (j = 0; j*2 < tga_height; ++j)
         {
            int index1 = j * tga_width * tga_comp;
            int index2 = (tga_height - 1 - j) * tga_width * tga_comp;
            for (i = tga_width * tga_comp; i > 0; --i)
            {
               unsigned char temp = tga_data[index1];
               tga_data[index1] = tga_data[index2];
               tga_data[index2] = temp;
               ++index1;
               ++index2;
            }
         }
      }
      //   clear my palette, if I had one
      if ( tga_palette != NULL )
      {
         STBI_FREE( tga_palette );
      }
   }

   // swap RGB - if the source data was RGB16, it already is in the right order
   if (tga_comp >= 3 && !tga_rgb16)
   {
      unsigned char* tga_pixel = tga_data;
      for (i=0; i < tga_width * tga_height; ++i)
      {
         unsigned char temp = tga_pixel[0];
         tga_pixel[0] = tga_pixel[2];
         tga_pixel[2] = temp;
         tga_pixel += tga_comp;
      }
   }

   // convert to target component count
   if (req_comp && req_comp != tga_comp)
      tga_data = stbi__convert_format(tga_data, tga_comp, req_comp, tga_width, tga_height);

   //   the things I do to get rid of an error message, and yet keep
   //   Microsoft's C compilers happy... [8^(
   tga_palette_start = tga_palette_len = tga_palette_bits =
         tga_x_origin = tga_y_origin = 0;
   STBI_NOTUSED(tga_palette_start);
   //   OK, done
   return tga_data;
}","{'begin': {'line': 5871, 'column': 1}, 'end': {'line': 6074, 'column': 2}}",show_image.c,"['加载', '并', '解析', 'TGA', '图像', '，', '支持', 'RLE', '压缩', '和', '调色', '调色板', '，', '转换', '格式', '。']"
757,757,stbi__bmp_test,int,int stbi__bmp_test(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",检测BMP图像格式并重置流位置,"static int stbi__bmp_test(stbi__context *s)
{
   int r = stbi__bmp_test_raw(s);
   stbi__rewind(s);
   return r;
}","{'begin': {'line': 5361, 'column': 1}, 'end': {'line': 5366, 'column': 2}}",show_image.c,"['检测', 'BMP', '图像', '格式', '图像格式', '并', '重置', '流', '位置']"
758,758,stbi__high_bit,int,int stbi__high_bit(unsigned int z),"[{'name': 'z', 'type': 'unsigned int'}]",计算无符号整数最高有效位的位置,"static int stbi__high_bit(unsigned int z)
{
   int n=0;
   if (z == 0) return -1;
   if (z >= 0x10000) { n += 16; z >>= 16; }
   if (z >= 0x00100) { n +=  8; z >>=  8; }
   if (z >= 0x00010) { n +=  4; z >>=  4; }
   if (z >= 0x00004) { n +=  2; z >>=  2; }
   if (z >= 0x00002) { n +=  1;/* >>=  1;*/ }
   return n;
}","{'begin': {'line': 5370, 'column': 1}, 'end': {'line': 5380, 'column': 2}}",show_image.c,"['计算', '无', '符号', '整数', '最高', '有效', '位', '的', '位置']"
759,759,stbi__bitcount,int,int stbi__bitcount(unsigned int a),"[{'name': 'a', 'type': 'unsigned int'}]",计算无符号整数二进制中1的个数,"static int stbi__bitcount(unsigned int a)
{
   a = (a & 0x55555555) + ((a >>  1) & 0x55555555); // max 2
   a = (a & 0x33333333) + ((a >>  2) & 0x33333333); // max 4
   a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits
   a = (a + (a >> 8)); // max 16 per 8 bits
   a = (a + (a >> 16)); // max 32 per 8 bits
   return a & 0xff;
}","{'begin': {'line': 5382, 'column': 1}, 'end': {'line': 5390, 'column': 2}}",show_image.c,"['计算', '无', '符号', '整数', '进制', '二进制', '中', '1', '的', '个数']"
760,760,stbi__shiftsigned,int,"int stbi__shiftsigned(unsigned int v, int shift, int bits)","[{'name': 'v', 'type': 'unsigned int'}, {'name': 'shift', 'type': 'int'}, {'name': 'bits', 'type': 'int'}]",根据位移和位数调整值，使用预定义表处理,"static int stbi__shiftsigned(unsigned int v, int shift, int bits)
{
   static unsigned int mul_table[9] = {
      0,
      0xff/*0b11111111*/, 0x55/*0b01010101*/, 0x49/*0b01001001*/, 0x11/*0b00010001*/,
      0x21/*0b00100001*/, 0x41/*0b01000001*/, 0x81/*0b10000001*/, 0x01/*0b00000001*/,
   };
   static unsigned int shift_table[9] = {
      0, 0,0,1,0,2,4,6,0,
   };
   if (shift < 0)
      v <<= -shift;
   else
      v >>= shift;
   STBI_ASSERT(v < 256);
   v >>= (8-bits);
   STBI_ASSERT(bits >= 0 && bits <= 8);
   return (int) ((unsigned) v * mul_table[bits]) >> shift_table[bits];
}","{'begin': {'line': 5395, 'column': 1}, 'end': {'line': 5413, 'column': 2}}",show_image.c,"['根据', '位移', '和', '位数', '调整', '值', '，', '使用', '预定', '义', '处理', '表处理']"
761,761,stbi__bmp_set_mask_defaults,int,"int stbi__bmp_set_mask_defaults(stbi__bmp_data * info, int compress)","[{'name': 'info', 'type': 'stbi__bmp_data *'}, {'name': 'compress', 'type': 'int'}]",根据压缩类型和位深设置BMP颜色掩码默认值,"static int stbi__bmp_set_mask_defaults(stbi__bmp_data *info, int compress)
{
   // BI_BITFIELDS specifies masks explicitly, don't override
   if (compress == 3)
      return 1;

   if (compress == 0) {
      if (info->bpp == 16) {
         info->mr = 31u << 10;
         info->mg = 31u <<  5;
         info->mb = 31u <<  0;
      } else if (info->bpp == 32) {
         info->mr = 0xffu << 16;
         info->mg = 0xffu <<  8;
         info->mb = 0xffu <<  0;
         info->ma = 0xffu << 24;
         info->all_a = 0; // if all_a is 0 at end, then we loaded alpha channel but it was all 0
      } else {
         // otherwise, use defaults, which is all-0
         info->mr = info->mg = info->mb = info->ma = 0;
      }
      return 1;
   }
   return 0; // error
}","{'begin': {'line': 5422, 'column': 1}, 'end': {'line': 5446, 'column': 2}}",show_image.c,"['根据', '压缩', '类型', '和', '位深', '设置', 'BMP', '颜色', '掩码', '默认', '默认值']"
762,762,stbi__psd_test,int,int stbi__psd_test(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",检测是否为PSD格式文件并回退指针,"static int stbi__psd_test(stbi__context *s)
{
   int r = (stbi__get32be(s) == 0x38425053);
   stbi__rewind(s);
   return r;
}","{'begin': {'line': 6081, 'column': 1}, 'end': {'line': 6086, 'column': 2}}",show_image.c,"['检测', '是否', '为', 'PSD', '格式', '文件', '格式文件', '并', '回退', '指针']"
763,763,stbi__bmp_parse_header,void *,"void * stbi__bmp_parse_header(stbi__context * s, stbi__bmp_data * info)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'info', 'type': 'stbi__bmp_data *'}]",解析并验证BMP文件头信息,"static void *stbi__bmp_parse_header(stbi__context *s, stbi__bmp_data *info)
{
   int hsz;
   if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') return stbi__errpuc(""not BMP"", ""Corrupt BMP"");
   stbi__get32le(s); // discard filesize
   stbi__get16le(s); // discard reserved
   stbi__get16le(s); // discard reserved
   info->offset = stbi__get32le(s);
   info->hsz = hsz = stbi__get32le(s);
   info->mr = info->mg = info->mb = info->ma = 0;
   info->extra_read = 14;

   if (info->offset < 0) return stbi__errpuc(""bad BMP"", ""bad BMP"");

   if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108 && hsz != 124) return stbi__errpuc(""unknown BMP"", ""BMP type not supported: unknown"");
   if (hsz == 12) {
      s->img_x = stbi__get16le(s);
      s->img_y = stbi__get16le(s);
   } else {
      s->img_x = stbi__get32le(s);
      s->img_y = stbi__get32le(s);
   }
   if (stbi__get16le(s) != 1) return stbi__errpuc(""bad BMP"", ""bad BMP"");
   info->bpp = stbi__get16le(s);
   if (hsz != 12) {
      int compress = stbi__get32le(s);
      if (compress == 1 || compress == 2) return stbi__errpuc(""BMP RLE"", ""BMP type not supported: RLE"");
      if (compress >= 4) return stbi__errpuc(""BMP JPEG/PNG"", ""BMP type not supported: unsupported compression""); // this includes PNG/JPEG modes
      if (compress == 3 && info->bpp != 16 && info->bpp != 32) return stbi__errpuc(""bad BMP"", ""bad BMP""); // bitfields requires 16 or 32 bits/pixel
      stbi__get32le(s); // discard sizeof
      stbi__get32le(s); // discard hres
      stbi__get32le(s); // discard vres
      stbi__get32le(s); // discard colorsused
      stbi__get32le(s); // discard max important
      if (hsz == 40 || hsz == 56) {
         if (hsz == 56) {
            stbi__get32le(s);
            stbi__get32le(s);
            stbi__get32le(s);
            stbi__get32le(s);
         }
         if (info->bpp == 16 || info->bpp == 32) {
            if (compress == 0) {
               stbi__bmp_set_mask_defaults(info, compress);
            } else if (compress == 3) {
               info->mr = stbi__get32le(s);
               info->mg = stbi__get32le(s);
               info->mb = stbi__get32le(s);
               info->extra_read += 12;
               // not documented, but generated by photoshop and handled by mspaint
               if (info->mr == info->mg && info->mg == info->mb) {
                  // ?!?!?
                  return stbi__errpuc(""bad BMP"", ""bad BMP"");
               }
            } else
               return stbi__errpuc(""bad BMP"", ""bad BMP"");
         }
      } else {
         // V4/V5 header
         int i;
         if (hsz != 108 && hsz != 124)
            return stbi__errpuc(""bad BMP"", ""bad BMP"");
         info->mr = stbi__get32le(s);
         info->mg = stbi__get32le(s);
         info->mb = stbi__get32le(s);
         info->ma = stbi__get32le(s);
         if (compress != 3) // override mr/mg/mb unless in BI_BITFIELDS mode, as per docs
            stbi__bmp_set_mask_defaults(info, compress);
         stbi__get32le(s); // discard color space
         for (i=0; i < 12; ++i)
            stbi__get32le(s); // discard color space parameters
         if (hsz == 124) {
            stbi__get32le(s); // discard rendering intent
            stbi__get32le(s); // discard offset of profile data
            stbi__get32le(s); // discard size of profile data
            stbi__get32le(s); // discard reserved
         }
      }
   }
   return (void *) 1;
}","{'begin': {'line': 5448, 'column': 1}, 'end': {'line': 5528, 'column': 2}}",show_image.c,"['解析', '并', '验证', 'BMP', '文件', '头', '信息']"
764,764,stbi__psd_decode_rle,int,"int stbi__psd_decode_rle(stbi__context * s, stbi_uc * p, int pixelCount)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'p', 'type': 'stbi_uc *'}, {'name': 'pixelCount', 'type': 'int'}]",解码PSD图像的RLE压缩数据，处理逐像素复制与重复填充。,"static int stbi__psd_decode_rle(stbi__context *s, stbi_uc *p, int pixelCount)
{
   int count, nleft, len;

   count = 0;
   while ((nleft = pixelCount - count) > 0) {
      len = stbi__get8(s);
      if (len == 128) {
         // No-op.
      } else if (len < 128) {
         // Copy next len+1 bytes literally.
         len++;
         if (len > nleft) return 0; // corrupt data
         count += len;
         while (len) {
            *p = stbi__get8(s);
            p += 4;
            len--;
         }
      } else if (len > 128) {
         stbi_uc   val;
         // Next -len+1 bytes in the dest are replicated from next source byte.
         // (Interpret len as a negative 8-bit int.)
         len = 257 - len;
         if (len > nleft) return 0; // corrupt data
         val = stbi__get8(s);
         count += len;
         while (len) {
            *p = val;
            p += 4;
            len--;
         }
      }
   }

   return 1;
}","{'begin': {'line': 6088, 'column': 1}, 'end': {'line': 6124, 'column': 2}}",show_image.c,"['解码', 'PSD', '图像', '的', 'RLE', '压缩', '数据', '，', '处理', '逐', '像素', '复制', '与', '重复', '填充', '。']"
765,765,stbi__psd_load,void *,"void * stbi__psd_load(stbi__context * s, int * x, int * y, int * comp, int req_comp, stbi__result_info * ri, int bpc)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'ri', 'type': 'stbi__result_info *'}, {'name': 'bpc', 'type': 'int'}]",加载并解析PSD图像文件，处理压缩及格式转换。,"static void *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)
{
   int pixelCount;
   int channelCount, compression;
   int channel, i;
   int bitdepth;
   int w,h;
   stbi_uc *out;
   STBI_NOTUSED(ri);

   // Check identifier
   if (stbi__get32be(s) != 0x38425053)   // ""8BPS""
      return stbi__errpuc(""not PSD"", ""Corrupt PSD image"");

   // Check file type version.
   if (stbi__get16be(s) != 1)
      return stbi__errpuc(""wrong version"", ""Unsupported version of PSD image"");

   // Skip 6 reserved bytes.
   stbi__skip(s, 6 );

   // Read the number of channels (R, G, B, A, etc).
   channelCount = stbi__get16be(s);
   if (channelCount < 0 || channelCount > 16)
      return stbi__errpuc(""wrong channel count"", ""Unsupported number of channels in PSD image"");

   // Read the rows and columns of the image.
   h = stbi__get32be(s);
   w = stbi__get32be(s);

   if (h > STBI_MAX_DIMENSIONS) return stbi__errpuc(""too large"",""Very large image (corrupt?)"");
   if (w > STBI_MAX_DIMENSIONS) return stbi__errpuc(""too large"",""Very large image (corrupt?)"");

   // Make sure the depth is 8 bits.
   bitdepth = stbi__get16be(s);
   if (bitdepth != 8 && bitdepth != 16)
      return stbi__errpuc(""unsupported bit depth"", ""PSD bit depth is not 8 or 16 bit"");

   // Make sure the color mode is RGB.
   // Valid options are:
   //   0: Bitmap
   //   1: Grayscale
   //   2: Indexed color
   //   3: RGB color
   //   4: CMYK color
   //   7: Multichannel
   //   8: Duotone
   //   9: Lab color
   if (stbi__get16be(s) != 3)
      return stbi__errpuc(""wrong color format"", ""PSD is not in RGB color format"");

   // Skip the Mode Data.  (It's the palette for indexed color; other info for other modes.)
   stbi__skip(s,stbi__get32be(s) );

   // Skip the image resources.  (resolution, pen tool paths, etc)
   stbi__skip(s, stbi__get32be(s) );

   // Skip the reserved data.
   stbi__skip(s, stbi__get32be(s) );

   // Find out if the data is compressed.
   // Known values:
   //   0: no compression
   //   1: RLE compressed
   compression = stbi__get16be(s);
   if (compression > 1)
      return stbi__errpuc(""bad compression"", ""PSD has an unknown compression format"");

   // Check size
   if (!stbi__mad3sizes_valid(4, w, h, 0))
      return stbi__errpuc(""too large"", ""Corrupt PSD"");

   // Create the destination image.

   if (!compression && bitdepth == 16 && bpc == 16) {
      out = (stbi_uc *) stbi__malloc_mad3(8, w, h, 0);
      ri->bits_per_channel = 16;
   } else
      out = (stbi_uc *) stbi__malloc(4 * w*h);

   if (!out) return stbi__errpuc(""outofmem"", ""Out of memory"");
   pixelCount = w*h;

   // Initialize the data to zero.
   //memset( out, 0, pixelCount * 4 );

   // Finally, the image data.
   if (compression) {
      // RLE as used by .PSD and .TIFF
      // Loop until you get the number of unpacked bytes you are expecting:
      //     Read the next source byte into n.
      //     If n is between 0 and 127 inclusive, copy the next n+1 bytes literally.
      //     Else if n is between -127 and -1 inclusive, copy the next byte -n+1 times.
      //     Else if n is 128, noop.
      // Endloop

      // The RLE-compressed data is preceded by a 2-byte data count for each row in the data,
      // which we're going to just skip.
      stbi__skip(s, h * channelCount * 2 );

      // Read the RLE data by channel.
      for (channel = 0; channel < 4; channel++) {
         stbi_uc *p;

         p = out+channel;
         if (channel >= channelCount) {
            // Fill this channel with default data.
            for (i = 0; i < pixelCount; i++, p += 4)
               *p = (channel == 3 ? 255 : 0);
         } else {
            // Read the RLE data.
            if (!stbi__psd_decode_rle(s, p, pixelCount)) {
               STBI_FREE(out);
               return stbi__errpuc(""corrupt"", ""bad RLE data"");
            }
         }
      }

   } else {
      // We're at the raw image data.  It's each channel in order (Red, Green, Blue, Alpha, ...)
      // where each channel consists of an 8-bit (or 16-bit) value for each pixel in the image.

      // Read the data by channel.
      for (channel = 0; channel < 4; channel++) {
         if (channel >= channelCount) {
            // Fill this channel with default data.
            if (bitdepth == 16 && bpc == 16) {
               stbi__uint16 *q = ((stbi__uint16 *) out) + channel;
               stbi__uint16 val = channel == 3 ? 65535 : 0;
               for (i = 0; i < pixelCount; i++, q += 4)
                  *q = val;
            } else {
               stbi_uc *p = out+channel;
               stbi_uc val = channel == 3 ? 255 : 0;
               for (i = 0; i < pixelCount; i++, p += 4)
                  *p = val;
            }
         } else {
            if (ri->bits_per_channel == 16) {    // output bpc
               stbi__uint16 *q = ((stbi__uint16 *) out) + channel;
               for (i = 0; i < pixelCount; i++, q += 4)
                  *q = (stbi__uint16) stbi__get16be(s);
            } else {
               stbi_uc *p = out+channel;
               if (bitdepth == 16) {  // input bpc
                  for (i = 0; i < pixelCount; i++, p += 4)
                     *p = (stbi_uc) (stbi__get16be(s) >> 8);
               } else {
                  for (i = 0; i < pixelCount; i++, p += 4)
                     *p = stbi__get8(s);
               }
            }
         }
      }
   }

   // remove weird white matte from PSD
   if (channelCount >= 4) {
      if (ri->bits_per_channel == 16) {
         for (i=0; i < w*h; ++i) {
            stbi__uint16 *pixel = (stbi__uint16 *) out + 4*i;
            if (pixel[3] != 0 && pixel[3] != 65535) {
               float a = pixel[3] / 65535.0f;
               float ra = 1.0f / a;
               float inv_a = 65535.0f * (1 - ra);
               pixel[0] = (stbi__uint16) (pixel[0]*ra + inv_a);
               pixel[1] = (stbi__uint16) (pixel[1]*ra + inv_a);
               pixel[2] = (stbi__uint16) (pixel[2]*ra + inv_a);
            }
         }
      } else {
         for (i=0; i < w*h; ++i) {
            unsigned char *pixel = out + 4*i;
            if (pixel[3] != 0 && pixel[3] != 255) {
               float a = pixel[3] / 255.0f;
               float ra = 1.0f / a;
               float inv_a = 255.0f * (1 - ra);
               pixel[0] = (unsigned char) (pixel[0]*ra + inv_a);
               pixel[1] = (unsigned char) (pixel[1]*ra + inv_a);
               pixel[2] = (unsigned char) (pixel[2]*ra + inv_a);
            }
         }
      }
   }

   // convert to desired output format
   if (req_comp && req_comp != 4) {
      if (ri->bits_per_channel == 16)
         out = (stbi_uc *) stbi__convert_format16((stbi__uint16 *) out, 4, req_comp, w, h);
      else
         out = stbi__convert_format(out, 4, req_comp, w, h);
      if (out == NULL) return out; // stbi__convert_format frees input on failure
   }

   if (comp) *comp = 4;
   *y = h;
   *x = w;

   return out;
}","{'begin': {'line': 6126, 'column': 1}, 'end': {'line': 6325, 'column': 2}}",show_image.c,"['加载', '并', '解析', 'PSD', '图像', '文件', '图像文件', '，', '处理', '压缩', '及', '格式', '转换', '。']"
766,766,stbi__bmp_load,void *,"void * stbi__bmp_load(stbi__context * s, int * x, int * y, int * comp, int req_comp, stbi__result_info * ri)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'ri', 'type': 'stbi__result_info *'}]",加载并解码BMP图像数据，处理调色板与像素格式转换,"static void *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   stbi_uc *out;
   unsigned int mr=0,mg=0,mb=0,ma=0, all_a;
   stbi_uc pal[256][4];
   int psize=0,i,j,width;
   int flip_vertically, pad, target;
   stbi__bmp_data info;
   STBI_NOTUSED(ri);

   info.all_a = 255;
   if (stbi__bmp_parse_header(s, &info) == NULL)
      return NULL; // error code already set

   flip_vertically = ((int) s->img_y) > 0;
   s->img_y = abs((int) s->img_y);

   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc(""too large"",""Very large image (corrupt?)"");
   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc(""too large"",""Very large image (corrupt?)"");

   mr = info.mr;
   mg = info.mg;
   mb = info.mb;
   ma = info.ma;
   all_a = info.all_a;

   if (info.hsz == 12) {
      if (info.bpp < 24)
         psize = (info.offset - info.extra_read - 24) / 3;
   } else {
      if (info.bpp < 16)
         psize = (info.offset - info.extra_read - info.hsz) >> 2;
   }
   if (psize == 0) {
      // accept some number of extra bytes after the header, but if the offset points either to before
      // the header ends or implies a large amount of extra data, reject the file as malformed
      int bytes_read_so_far = s->callback_already_read + (int)(s->img_buffer - s->img_buffer_original);
      int header_limit = 1024; // max we actually read is below 256 bytes currently.
      int extra_data_limit = 256*4; // what ordinarily goes here is a palette; 256 entries*4 bytes is its max size.
      if (bytes_read_so_far <= 0 || bytes_read_so_far > header_limit) {
         return stbi__errpuc(""bad header"", ""Corrupt BMP"");
      }
      // we established that bytes_read_so_far is positive and sensible.
      // the first half of this test rejects offsets that are either too small positives, or
      // negative, and guarantees that info.offset >= bytes_read_so_far > 0. this in turn
      // ensures the number computed in the second half of the test can't overflow.
      if (info.offset < bytes_read_so_far || info.offset - bytes_read_so_far > extra_data_limit) {
         return stbi__errpuc(""bad offset"", ""Corrupt BMP"");
      } else {
         stbi__skip(s, info.offset - bytes_read_so_far);
      }
   }

   if (info.bpp == 24 && ma == 0xff000000)
      s->img_n = 3;
   else
      s->img_n = ma ? 4 : 3;
   if (req_comp && req_comp >= 3) // we can directly decode 3 or 4
      target = req_comp;
   else
      target = s->img_n; // if they want monochrome, we'll post-convert

   // sanity-check size
   if (!stbi__mad3sizes_valid(target, s->img_x, s->img_y, 0))
      return stbi__errpuc(""too large"", ""Corrupt BMP"");

   out = (stbi_uc *) stbi__malloc_mad3(target, s->img_x, s->img_y, 0);
   if (!out) return stbi__errpuc(""outofmem"", ""Out of memory"");
   if (info.bpp < 16) {
      int z=0;
      if (psize == 0 || psize > 256) { STBI_FREE(out); return stbi__errpuc(""invalid"", ""Corrupt BMP""); }
      for (i=0; i < psize; ++i) {
         pal[i][2] = stbi__get8(s);
         pal[i][1] = stbi__get8(s);
         pal[i][0] = stbi__get8(s);
         if (info.hsz != 12) stbi__get8(s);
         pal[i][3] = 255;
      }
      stbi__skip(s, info.offset - info.extra_read - info.hsz - psize * (info.hsz == 12 ? 3 : 4));
      if (info.bpp == 1) width = (s->img_x + 7) >> 3;
      else if (info.bpp == 4) width = (s->img_x + 1) >> 1;
      else if (info.bpp == 8) width = s->img_x;
      else { STBI_FREE(out); return stbi__errpuc(""bad bpp"", ""Corrupt BMP""); }
      pad = (-width)&3;
      if (info.bpp == 1) {
         for (j=0; j < (int) s->img_y; ++j) {
            int bit_offset = 7, v = stbi__get8(s);
            for (i=0; i < (int) s->img_x; ++i) {
               int color = (v>>bit_offset)&0x1;
               out[z++] = pal[color][0];
               out[z++] = pal[color][1];
               out[z++] = pal[color][2];
               if (target == 4) out[z++] = 255;
               if (i+1 == (int) s->img_x) break;
               if((--bit_offset) < 0) {
                  bit_offset = 7;
                  v = stbi__get8(s);
               }
            }
            stbi__skip(s, pad);
         }
      } else {
         for (j=0; j < (int) s->img_y; ++j) {
            for (i=0; i < (int) s->img_x; i += 2) {
               int v=stbi__get8(s),v2=0;
               if (info.bpp == 4) {
                  v2 = v & 15;
                  v >>= 4;
               }
               out[z++] = pal[v][0];
               out[z++] = pal[v][1];
               out[z++] = pal[v][2];
               if (target == 4) out[z++] = 255;
               if (i+1 == (int) s->img_x) break;
               v = (info.bpp == 8) ? stbi__get8(s) : v2;
               out[z++] = pal[v][0];
               out[z++] = pal[v][1];
               out[z++] = pal[v][2];
               if (target == 4) out[z++] = 255;
            }
            stbi__skip(s, pad);
         }
      }
   } else {
      int rshift=0,gshift=0,bshift=0,ashift=0,rcount=0,gcount=0,bcount=0,acount=0;
      int z = 0;
      int easy=0;
      stbi__skip(s, info.offset - info.extra_read - info.hsz);
      if (info.bpp == 24) width = 3 * s->img_x;
      else if (info.bpp == 16) width = 2*s->img_x;
      else /* bpp = 32 and pad = 0 */ width=0;
      pad = (-width) & 3;
      if (info.bpp == 24) {
         easy = 1;
      } else if (info.bpp == 32) {
         if (mb == 0xff && mg == 0xff00 && mr == 0x00ff0000 && ma == 0xff000000)
            easy = 2;
      }
      if (!easy) {
         if (!mr || !mg || !mb) { STBI_FREE(out); return stbi__errpuc(""bad masks"", ""Corrupt BMP""); }
         // right shift amt to put high bit in position #7
         rshift = stbi__high_bit(mr)-7; rcount = stbi__bitcount(mr);
         gshift = stbi__high_bit(mg)-7; gcount = stbi__bitcount(mg);
         bshift = stbi__high_bit(mb)-7; bcount = stbi__bitcount(mb);
         ashift = stbi__high_bit(ma)-7; acount = stbi__bitcount(ma);
         if (rcount > 8 || gcount > 8 || bcount > 8 || acount > 8) { STBI_FREE(out); return stbi__errpuc(""bad masks"", ""Corrupt BMP""); }
      }
      for (j=0; j < (int) s->img_y; ++j) {
         if (easy) {
            for (i=0; i < (int) s->img_x; ++i) {
               unsigned char a;
               out[z+2] = stbi__get8(s);
               out[z+1] = stbi__get8(s);
               out[z+0] = stbi__get8(s);
               z += 3;
               a = (easy == 2 ? stbi__get8(s) : 255);
               all_a |= a;
               if (target == 4) out[z++] = a;
            }
         } else {
            int bpp = info.bpp;
            for (i=0; i < (int) s->img_x; ++i) {
               stbi__uint32 v = (bpp == 16 ? (stbi__uint32) stbi__get16le(s) : stbi__get32le(s));
               unsigned int a;
               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mr, rshift, rcount));
               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mg, gshift, gcount));
               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mb, bshift, bcount));
               a = (ma ? stbi__shiftsigned(v & ma, ashift, acount) : 255);
               all_a |= a;
               if (target == 4) out[z++] = STBI__BYTECAST(a);
            }
         }
         stbi__skip(s, pad);
      }
   }

   // if alpha channel is all 0s, replace with all 255s
   if (target == 4 && all_a == 0)
      for (i=4*s->img_x*s->img_y-1; i >= 0; i -= 4)
         out[i] = 255;

   if (flip_vertically) {
      stbi_uc t;
      for (j=0; j < (int) s->img_y>>1; ++j) {
         stbi_uc *p1 = out +      j     *s->img_x*target;
         stbi_uc *p2 = out + (s->img_y-1-j)*s->img_x*target;
         for (i=0; i < (int) s->img_x*target; ++i) {
            t = p1[i]; p1[i] = p2[i]; p2[i] = t;
         }
      }
   }

   if (req_comp && req_comp != target) {
      out = stbi__convert_format(out, target, req_comp, s->img_x, s->img_y);
      if (out == NULL) return out; // stbi__convert_format frees input on failure
   }

   *x = s->img_x;
   *y = s->img_y;
   if (comp) *comp = s->img_n;
   return out;
}","{'begin': {'line': 5531, 'column': 1}, 'end': {'line': 5732, 'column': 2}}",show_image.c,"['加载', '并', '解码', 'BMP', '图像', '数据', '，', '处理', '调色', '调色板', '与', '像素', '格式', '转换']"
767,767,stbi__pic_is4,int,"int stbi__pic_is4(stbi__context * s, const char * str)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'str', 'type': 'const char *'}]",检查输入流前四个字节是否匹配指定字符串,"static int stbi__pic_is4(stbi__context *s,const char *str)
{
   int i;
   for (i=0; i<4; ++i)
      if (stbi__get8(s) != (stbi_uc)str[i])
         return 0;

   return 1;
}","{'begin': {'line': 6336, 'column': 1}, 'end': {'line': 6344, 'column': 2}}",show_image.c,"['检查', '输入', '流前', '四个', '字节', '是否', '匹配', '指定', '字符', '字符串']"
768,768,stbi__pic_test_core,int,int stbi__pic_test_core(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",验证输入是否为PIC图像格式,"static int stbi__pic_test_core(stbi__context *s)
{
   int i;

   if (!stbi__pic_is4(s,""\x53\x80\xF6\x34""))
      return 0;

   for(i=0;i<84;++i)
      stbi__get8(s);

   if (!stbi__pic_is4(s,""PICT""))
      return 0;

   return 1;
}","{'begin': {'line': 6346, 'column': 1}, 'end': {'line': 6360, 'column': 2}}",show_image.c,"['验证', '输入', '是否', '为', 'PIC', '图像', '格式', '图像格式']"
769,769,stbi__readval,stbi_uc *,"stbi_uc * stbi__readval(stbi__context * s, int channel, stbi_uc * dest)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'channel', 'type': 'int'}, {'name': 'dest', 'type': 'stbi_uc *'}]",根据通道掩码读取最多4字节数据到目标缓冲区,"static stbi_uc *stbi__readval(stbi__context *s, int channel, stbi_uc *dest)
{
   int mask=0x80, i;

   for (i=0; i<4; ++i, mask>>=1) {
      if (channel & mask) {
         if (stbi__at_eof(s)) return stbi__errpuc(""bad file"",""PIC file too short"");
         dest[i]=stbi__get8(s);
      }
   }

   return dest;
}","{'begin': {'line': 6367, 'column': 1}, 'end': {'line': 6379, 'column': 2}}",show_image.c,"['根据', '通道', '掩码', '读取', '最多', '4', '字节', '数据', '到', '目标', '缓冲', '缓冲区']"
770,770,stbi__copyval,void,"void stbi__copyval(int channel, stbi_uc * dest, const stbi_uc * src)","[{'name': 'channel', 'type': 'int'}, {'name': 'dest', 'type': 'stbi_uc *'}, {'name': 'src', 'type': 'const stbi_uc *'}]",根据通道掩码复制指定通道数据,"static void stbi__copyval(int channel,stbi_uc *dest,const stbi_uc *src)
{
   int mask=0x80,i;

   for (i=0;i<4; ++i, mask>>=1)
      if (channel&mask)
         dest[i]=src[i];
}","{'begin': {'line': 6381, 'column': 1}, 'end': {'line': 6388, 'column': 2}}",show_image.c,"['根据', '通道', '掩码', '复制', '指定', '通道', '数据']"
771,771,stbi__pic_load_core,stbi_uc *,"stbi_uc * stbi__pic_load_core(stbi__context * s, int width, int height, int * comp, stbi_uc * result)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'width', 'type': 'int'}, {'name': 'height', 'type': 'int'}, {'name': 'comp', 'type': 'int *'}, {'name': 'result', 'type': 'stbi_uc *'}]",加载PIC图片，处理多数据包及RLE压缩数据。,"static stbi_uc *stbi__pic_load_core(stbi__context *s,int width,int height,int *comp, stbi_uc *result)
{
   int act_comp=0,num_packets=0,y,chained;
   stbi__pic_packet packets[10];

   // this will (should...) cater for even some bizarre stuff like having data
    // for the same channel in multiple packets.
   do {
      stbi__pic_packet *packet;

      if (num_packets==sizeof(packets)/sizeof(packets[0]))
         return stbi__errpuc(""bad format"",""too many packets"");

      packet = &packets[num_packets++];

      chained = stbi__get8(s);
      packet->size    = stbi__get8(s);
      packet->type    = stbi__get8(s);
      packet->channel = stbi__get8(s);

      act_comp |= packet->channel;

      if (stbi__at_eof(s))          return stbi__errpuc(""bad file"",""file too short (reading packets)"");
      if (packet->size != 8)  return stbi__errpuc(""bad format"",""packet isn't 8bpp"");
   } while (chained);

   *comp = (act_comp & 0x10 ? 4 : 3); // has alpha channel?

   for(y=0; y<height; ++y) {
      int packet_idx;

      for(packet_idx=0; packet_idx < num_packets; ++packet_idx) {
         stbi__pic_packet *packet = &packets[packet_idx];
         stbi_uc *dest = result+y*width*4;

         switch (packet->type) {
            default:
               return stbi__errpuc(""bad format"",""packet has bad compression type"");

            case 0: {//uncompressed
               int x;

               for(x=0;x<width;++x, dest+=4)
                  if (!stbi__readval(s,packet->channel,dest))
                     return 0;
               break;
            }

            case 1://Pure RLE
               {
                  int left=width, i;

                  while (left>0) {
                     stbi_uc count,value[4];

                     count=stbi__get8(s);
                     if (stbi__at_eof(s))   return stbi__errpuc(""bad file"",""file too short (pure read count)"");

                     if (count > left)
                        count = (stbi_uc) left;

                     if (!stbi__readval(s,packet->channel,value))  return 0;

                     for(i=0; i<count; ++i,dest+=4)
                        stbi__copyval(packet->channel,dest,value);
                     left -= count;
                  }
               }
               break;

            case 2: {//Mixed RLE
               int left=width;
               while (left>0) {
                  int count = stbi__get8(s), i;
                  if (stbi__at_eof(s))  return stbi__errpuc(""bad file"",""file too short (mixed read count)"");

                  if (count >= 128) { // Repeated
                     stbi_uc value[4];

                     if (count==128)
                        count = stbi__get16be(s);
                     else
                        count -= 127;
                     if (count > left)
                        return stbi__errpuc(""bad file"",""scanline overrun"");

                     if (!stbi__readval(s,packet->channel,value))
                        return 0;

                     for(i=0;i<count;++i, dest += 4)
                        stbi__copyval(packet->channel,dest,value);
                  } else { // Raw
                     ++count;
                     if (count>left) return stbi__errpuc(""bad file"",""scanline overrun"");

                     for(i=0;i<count;++i, dest+=4)
                        if (!stbi__readval(s,packet->channel,dest))
                           return 0;
                  }
                  left-=count;
               }
               break;
            }
         }
      }
   }

   return result;
}","{'begin': {'line': 6390, 'column': 1}, 'end': {'line': 6498, 'column': 2}}",show_image.c,"['加载', 'PIC', '图片', '，', '处理', '多', '数据', '数据包', '及', 'RLE', '压缩', '数据', '。']"
772,772,stbi__pic_load,void *,"void * stbi__pic_load(stbi__context * s, int * px, int * py, int * comp, int req_comp, stbi__result_info * ri)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'px', 'type': 'int *'}, {'name': 'py', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'ri', 'type': 'stbi__result_info *'}]",加载并解码PIC格式图像，返回像素数据。,"static void *stbi__pic_load(stbi__context *s,int *px,int *py,int *comp,int req_comp, stbi__result_info *ri)
{
   stbi_uc *result;
   int i, x,y, internal_comp;
   STBI_NOTUSED(ri);

   if (!comp) comp = &internal_comp;

   for (i=0; i<92; ++i)
      stbi__get8(s);

   x = stbi__get16be(s);
   y = stbi__get16be(s);

   if (y > STBI_MAX_DIMENSIONS) return stbi__errpuc(""too large"",""Very large image (corrupt?)"");
   if (x > STBI_MAX_DIMENSIONS) return stbi__errpuc(""too large"",""Very large image (corrupt?)"");

   if (stbi__at_eof(s))  return stbi__errpuc(""bad file"",""file too short (pic header)"");
   if (!stbi__mad3sizes_valid(x, y, 4, 0)) return stbi__errpuc(""too large"", ""PIC image too large to decode"");

   stbi__get32be(s); //skip `ratio'
   stbi__get16be(s); //skip `fields'
   stbi__get16be(s); //skip `pad'

   // intermediate buffer is RGBA
   result = (stbi_uc *) stbi__malloc_mad3(x, y, 4, 0);
   if (!result) return stbi__errpuc(""outofmem"", ""Out of memory"");
   memset(result, 0xff, x*y*4);

   if (!stbi__pic_load_core(s,x,y,comp, result)) {
      STBI_FREE(result);
      result=0;
   }
   *px = x;
   *py = y;
   if (req_comp == 0) req_comp = *comp;
   result=stbi__convert_format(result,4,req_comp,x,y);

   return result;
}","{'begin': {'line': 6500, 'column': 1}, 'end': {'line': 6539, 'column': 2}}",show_image.c,"['加载', '并', '解码', 'PIC', '格式', '图像', '，', '返回', '像素', '数据', '。']"
773,773,stbi__pic_test,int,int stbi__pic_test(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",测试输入流是否为PIC格式并重置位置,"static int stbi__pic_test(stbi__context *s)
{
   int r = stbi__pic_test_core(s);
   stbi__rewind(s);
   return r;
}","{'begin': {'line': 6541, 'column': 1}, 'end': {'line': 6546, 'column': 2}}",show_image.c,"['测试', '输入', '流', '是否', '为', 'PIC', '格式', '并', '重置', '位置']"
774,774,stbi__gif_test_raw,int,int stbi__gif_test_raw(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",检测输入流是否为GIF格式,"static int stbi__gif_test_raw(stbi__context *s)
{
   int sz;
   if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8') return 0;
   sz = stbi__get8(s);
   if (sz != '9' && sz != '7') return 0;
   if (stbi__get8(s) != 'a') return 0;
   return 1;
}","{'begin': {'line': 6580, 'column': 1}, 'end': {'line': 6588, 'column': 2}}",show_image.c,"['检测', '输入', '流', '是否', '为', 'GIF', '格式']"
775,775,stbi__tga_get_comp,int,"int stbi__tga_get_comp(int bits_per_pixel, int is_grey, int * is_rgb16)","[{'name': 'bits_per_pixel', 'type': 'int'}, {'name': 'is_grey', 'type': 'int'}, {'name': 'is_rgb16', 'type': 'int *'}]",根据像素位数和灰度标志确定TGA图像格式，可能设置RGB16标志,"static int stbi__tga_get_comp(int bits_per_pixel, int is_grey, int* is_rgb16)
{
   // only RGB or RGBA (incl. 16bit) or grey allowed
   if (is_rgb16) *is_rgb16 = 0;
   switch(bits_per_pixel) {
      case 8:  return STBI_grey;
      case 16: if(is_grey) return STBI_grey_alpha;
               // fallthrough
      case 15: if(is_rgb16) *is_rgb16 = 1;
               return STBI_rgb;
      case 24: // fallthrough
      case 32: return bits_per_pixel/8;
      default: return 0;
   }
}","{'begin': {'line': 5739, 'column': 1}, 'end': {'line': 5753, 'column': 2}}",show_image.c,"['根据', '像素', '位数', '和', '灰度', '标志', '确定', 'TGA', '图像', '格式', '图像格式', '，', '可能', '设置', 'RGB16', '标志']"
776,776,stbi__gif_test,int,int stbi__gif_test(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",测试是否为GIF格式并重置流指针,"static int stbi__gif_test(stbi__context *s)
{
   int r = stbi__gif_test_raw(s);
   stbi__rewind(s);
   return r;
}","{'begin': {'line': 6590, 'column': 1}, 'end': {'line': 6595, 'column': 2}}",show_image.c,"['测试', '是否', '为', 'GIF', '格式', '并', '重置', '流', '指针']"
777,777,stbi__tga_info,int,"int stbi__tga_info(stbi__context * s, int * x, int * y, int * comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",解析TGA图像信息并验证有效性,"static int stbi__tga_info(stbi__context *s, int *x, int *y, int *comp)
{
    int tga_w, tga_h, tga_comp, tga_image_type, tga_bits_per_pixel, tga_colormap_bpp;
    int sz, tga_colormap_type;
    stbi__get8(s);                   // discard Offset
    tga_colormap_type = stbi__get8(s); // colormap type
    if( tga_colormap_type > 1 ) {
        stbi__rewind(s);
        return 0;      // only RGB or indexed allowed
    }
    tga_image_type = stbi__get8(s); // image type
    if ( tga_colormap_type == 1 ) { // colormapped (paletted) image
        if (tga_image_type != 1 && tga_image_type != 9) {
            stbi__rewind(s);
            return 0;
        }
        stbi__skip(s,4);       // skip index of first colormap entry and number of entries
        sz = stbi__get8(s);    //   check bits per palette color entry
        if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) {
            stbi__rewind(s);
            return 0;
        }
        stbi__skip(s,4);       // skip image x and y origin
        tga_colormap_bpp = sz;
    } else { // ""normal"" image w/o colormap - only RGB or grey allowed, +/- RLE
        if ( (tga_image_type != 2) && (tga_image_type != 3) && (tga_image_type != 10) && (tga_image_type != 11) ) {
            stbi__rewind(s);
            return 0; // only RGB or grey allowed, +/- RLE
        }
        stbi__skip(s,9); // skip colormap specification and image x/y origin
        tga_colormap_bpp = 0;
    }
    tga_w = stbi__get16le(s);
    if( tga_w < 1 ) {
        stbi__rewind(s);
        return 0;   // test width
    }
    tga_h = stbi__get16le(s);
    if( tga_h < 1 ) {
        stbi__rewind(s);
        return 0;   // test height
    }
    tga_bits_per_pixel = stbi__get8(s); // bits per pixel
    stbi__get8(s); // ignore alpha bits
    if (tga_colormap_bpp != 0) {
        if((tga_bits_per_pixel != 8) && (tga_bits_per_pixel != 16)) {
            // when using a colormap, tga_bits_per_pixel is the size of the indexes
            // I don't think anything but 8 or 16bit indexes makes sense
            stbi__rewind(s);
            return 0;
        }
        tga_comp = stbi__tga_get_comp(tga_colormap_bpp, 0, NULL);
    } else {
        tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3) || (tga_image_type == 11), NULL);
    }
    if(!tga_comp) {
      stbi__rewind(s);
      return 0;
    }
    if (x) *x = tga_w;
    if (y) *y = tga_h;
    if (comp) *comp = tga_comp;
    return 1;                   // seems to have passed everything
}","{'begin': {'line': 5755, 'column': 1}, 'end': {'line': 5818, 'column': 2}}",show_image.c,"['解析', 'TGA', '图像', '信息', '并', '验证', '有效', '有效性']"
778,778,stbi__gif_parse_colortable,void,"void stbi__gif_parse_colortable(stbi__context * s, stbi_uc[256][4] pal, int num_entries, int transp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'pal', 'type': 'stbi_uc[256][4]'}, {'name': 'num_entries', 'type': 'int'}, {'name': 'transp', 'type': 'int'}]",解析GIF颜色表并设置透明度,"static void stbi__gif_parse_colortable(stbi__context *s, stbi_uc pal[256][4], int num_entries, int transp)
{
   int i;
   for (i=0; i < num_entries; ++i) {
      pal[i][2] = stbi__get8(s);
      pal[i][1] = stbi__get8(s);
      pal[i][0] = stbi__get8(s);
      pal[i][3] = transp == i ? 0 : 255;
   }
}","{'begin': {'line': 6597, 'column': 1}, 'end': {'line': 6606, 'column': 2}}",show_image.c,"['解析', 'GIF', '颜色', '表并', '设置', '透明', '明度', '透明度']"
779,779,stbi__gif_header,int,"int stbi__gif_header(stbi__context * s, stbi__gif * g, int * comp, int is_info)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'g', 'type': 'stbi__gif *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'is_info', 'type': 'int'}]",解析GIF文件头信息，验证格式并提取基本参数,"static int stbi__gif_header(stbi__context *s, stbi__gif *g, int *comp, int is_info)
{
   stbi_uc version;
   if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8')
      return stbi__err(""not GIF"", ""Corrupt GIF"");

   version = stbi__get8(s);
   if (version != '7' && version != '9')    return stbi__err(""not GIF"", ""Corrupt GIF"");
   if (stbi__get8(s) != 'a')                return stbi__err(""not GIF"", ""Corrupt GIF"");

   stbi__g_failure_reason = """";
   g->w = stbi__get16le(s);
   g->h = stbi__get16le(s);
   g->flags = stbi__get8(s);
   g->bgindex = stbi__get8(s);
   g->ratio = stbi__get8(s);
   g->transparent = -1;

   if (g->w > STBI_MAX_DIMENSIONS) return stbi__err(""too large"",""Very large image (corrupt?)"");
   if (g->h > STBI_MAX_DIMENSIONS) return stbi__err(""too large"",""Very large image (corrupt?)"");

   if (comp != 0) *comp = 4;  // can't actually tell whether it's 3 or 4 until we parse the comments

   if (is_info) return 1;

   if (g->flags & 0x80)
      stbi__gif_parse_colortable(s,g->pal, 2 << (g->flags & 7), -1);

   return 1;
}","{'begin': {'line': 6608, 'column': 1}, 'end': {'line': 6637, 'column': 2}}",show_image.c,"['解析', 'GIF', '文件', '头', '信息', '，', '验证', '格式', '并', '提取', '基本', '本参', '参数', '基本参数']"
780,780,stbi__tga_test,int,int stbi__tga_test(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",验证输入流是否为有效TGA图像,"static int stbi__tga_test(stbi__context *s)
{
   int res = 0;
   int sz, tga_color_type;
   stbi__get8(s);      //   discard Offset
   tga_color_type = stbi__get8(s);   //   color type
   if ( tga_color_type > 1 ) goto errorEnd;   //   only RGB or indexed allowed
   sz = stbi__get8(s);   //   image type
   if ( tga_color_type == 1 ) { // colormapped (paletted) image
      if (sz != 1 && sz != 9) goto errorEnd; // colortype 1 demands image type 1 or 9
      stbi__skip(s,4);       // skip index of first colormap entry and number of entries
      sz = stbi__get8(s);    //   check bits per palette color entry
      if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;
      stbi__skip(s,4);       // skip image x and y origin
   } else { // ""normal"" image w/o colormap
      if ( (sz != 2) && (sz != 3) && (sz != 10) && (sz != 11) ) goto errorEnd; // only RGB or grey allowed, +/- RLE
      stbi__skip(s,9); // skip colormap specification and image x/y origin
   }
   if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test width
   if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test height
   sz = stbi__get8(s);   //   bits per pixel
   if ( (tga_color_type == 1) && (sz != 8) && (sz != 16) ) goto errorEnd; // for colormapped images, bpp is size of an index
   if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;

   res = 1; // if we got this far, everything's good and we can return 1 instead of 0

errorEnd:
   stbi__rewind(s);
   return res;
}","{'begin': {'line': 5820, 'column': 1}, 'end': {'line': 5849, 'column': 2}}",show_image.c,"['验证', '输入', '流', '是否', '为', '有效', 'TGA', '图像']"
781,781,stbi__gif_info_raw,int,"int stbi__gif_info_raw(stbi__context * s, int * x, int * y, int * comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",解析GIF图像基本信息，返回宽高及通道数,"static int stbi__gif_info_raw(stbi__context *s, int *x, int *y, int *comp)
{
   stbi__gif* g = (stbi__gif*) stbi__malloc(sizeof(stbi__gif));
   if (!g) return stbi__err(""outofmem"", ""Out of memory"");
   if (!stbi__gif_header(s, g, comp, 1)) {
      STBI_FREE(g);
      stbi__rewind( s );
      return 0;
   }
   if (x) *x = g->w;
   if (y) *y = g->h;
   STBI_FREE(g);
   return 1;
}","{'begin': {'line': 6639, 'column': 1}, 'end': {'line': 6652, 'column': 2}}",show_image.c,"['解析', 'GIF', '图像', '基本', '信息', '，', '返回', '宽高及', '通道', '数']"
782,782,stbi__out_gif_code,void,"void stbi__out_gif_code(stbi__gif * g, stbi__uint16 code)","[{'name': 'g', 'type': 'stbi__gif *'}, {'name': 'code', 'type': 'stbi__uint16'}]",递归解码GIF LZW编码，填充颜色数据,"static void stbi__out_gif_code(stbi__gif *g, stbi__uint16 code)
{
   stbi_uc *p, *c;
   int idx;

   // recurse to decode the prefixes, since the linked-list is backwards,
   // and working backwards through an interleaved image would be nasty
   if (g->codes[code].prefix >= 0)
      stbi__out_gif_code(g, g->codes[code].prefix);

   if (g->cur_y >= g->max_y) return;

   idx = g->cur_x + g->cur_y;
   p = &g->out[idx];
   g->history[idx / 4] = 1;

   c = &g->color_table[g->codes[code].suffix * 4];
   if (c[3] > 128) { // don't render transparent pixels;
      p[0] = c[2];
      p[1] = c[1];
      p[2] = c[0];
      p[3] = c[3];
   }
   g->cur_x += 4;

   if (g->cur_x >= g->max_x) {
      g->cur_x = g->start_x;
      g->cur_y += g->step;

      while (g->cur_y >= g->max_y && g->parse > 0) {
         g->step = (1 << g->parse) * g->line_size;
         g->cur_y = g->start_y + (g->step >> 1);
         --g->parse;
      }
   }
}","{'begin': {'line': 6654, 'column': 1}, 'end': {'line': 6689, 'column': 2}}",show_image.c,"['递归', '解码', 'GIF', ' ', 'LZW', '编码', '，', '填充', '颜色', '数据']"
783,783,stbi__tga_read_rgb16,void,"void stbi__tga_read_rgb16(stbi__context * s, stbi_uc * out)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'out', 'type': 'stbi_uc *'}]",将16位RGB565数据转换为24位RGB888格式,"static void stbi__tga_read_rgb16(stbi__context *s, stbi_uc* out)
{
   stbi__uint16 px = (stbi__uint16)stbi__get16le(s);
   stbi__uint16 fiveBitMask = 31;
   // we have 3 channels with 5bits each
   int r = (px >> 10) & fiveBitMask;
   int g = (px >> 5) & fiveBitMask;
   int b = px & fiveBitMask;
   // Note that this saves the data in RGB(A) order, so it doesn't need to be swapped later
   out[0] = (stbi_uc)((r * 255)/31);
   out[1] = (stbi_uc)((g * 255)/31);
   out[2] = (stbi_uc)((b * 255)/31);

   // some people claim that the most significant bit might be used for alpha
   // (possibly if an alpha-bit is set in the ""image descriptor byte"")
   // but that only made 16bit test images completely translucent..
   // so let's treat all 15 and 16bit TGAs as RGB with no alpha.
}","{'begin': {'line': 5852, 'column': 1}, 'end': {'line': 5869, 'column': 2}}",show_image.c,"['将', '16', '位', 'RGB565', '数据', '转换', '为', '24', '位', 'RGB888', '格式']"
784,784,stbi__tga_load,void *,"void * stbi__tga_load(stbi__context * s, int * x, int * y, int * comp, int req_comp, stbi__result_info * ri)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'ri', 'type': 'stbi__result_info *'}]",加载并解码TGA图像，处理调色板、RLE压缩及格式转换。,"static void *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   //   read in the TGA header stuff
   int tga_offset = stbi__get8(s);
   int tga_indexed = stbi__get8(s);
   int tga_image_type = stbi__get8(s);
   int tga_is_RLE = 0;
   int tga_palette_start = stbi__get16le(s);
   int tga_palette_len = stbi__get16le(s);
   int tga_palette_bits = stbi__get8(s);
   int tga_x_origin = stbi__get16le(s);
   int tga_y_origin = stbi__get16le(s);
   int tga_width = stbi__get16le(s);
   int tga_height = stbi__get16le(s);
   int tga_bits_per_pixel = stbi__get8(s);
   int tga_comp, tga_rgb16=0;
   int tga_inverted = stbi__get8(s);
   // int tga_alpha_bits = tga_inverted & 15; // the 4 lowest bits - unused (useless?)
   //   image data
   unsigned char *tga_data;
   unsigned char *tga_palette = NULL;
   int i, j;
   unsigned char raw_data[4] = {0};
   int RLE_count = 0;
   int RLE_repeating = 0;
   int read_next_pixel = 1;
   STBI_NOTUSED(ri);
   STBI_NOTUSED(tga_x_origin); // @TODO
   STBI_NOTUSED(tga_y_origin); // @TODO

   if (tga_height > STBI_MAX_DIMENSIONS) return stbi__errpuc(""too large"",""Very large image (corrupt?)"");
   if (tga_width > STBI_MAX_DIMENSIONS) return stbi__errpuc(""too large"",""Very large image (corrupt?)"");

   //   do a tiny bit of precessing
   if ( tga_image_type >= 8 )
   {
      tga_image_type -= 8;
      tga_is_RLE = 1;
   }
   tga_inverted = 1 - ((tga_inverted >> 5) & 1);

   //   If I'm paletted, then I'll use the number of bits from the palette
   if ( tga_indexed ) tga_comp = stbi__tga_get_comp(tga_palette_bits, 0, &tga_rgb16);
   else tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3), &tga_rgb16);

   if(!tga_comp) // shouldn't really happen, stbi__tga_test() should have ensured basic consistency
      return stbi__errpuc(""bad format"", ""Can't find out TGA pixelformat"");

   //   tga info
   *x = tga_width;
   *y = tga_height;
   if (comp) *comp = tga_comp;

   if (!stbi__mad3sizes_valid(tga_width, tga_height, tga_comp, 0))
      return stbi__errpuc(""too large"", ""Corrupt TGA"");

   tga_data = (unsigned char*)stbi__malloc_mad3(tga_width, tga_height, tga_comp, 0);
   if (!tga_data) return stbi__errpuc(""outofmem"", ""Out of memory"");

   // skip to the data's starting position (offset usually = 0)
   stbi__skip(s, tga_offset );

   if ( !tga_indexed && !tga_is_RLE && !tga_rgb16 ) {
      for (i=0; i < tga_height; ++i) {
         int row = tga_inverted ? tga_height -i - 1 : i;
         stbi_uc *tga_row = tga_data + row*tga_width*tga_comp;
         stbi__getn(s, tga_row, tga_width * tga_comp);
      }
   } else  {
      //   do I need to load a palette?
      if ( tga_indexed)
      {
         if (tga_palette_len == 0) {  /* you have to have at least one entry! */
            STBI_FREE(tga_data);
            return stbi__errpuc(""bad palette"", ""Corrupt TGA"");
         }

         //   any data to skip? (offset usually = 0)
         stbi__skip(s, tga_palette_start );
         //   load the palette
         tga_palette = (unsigned char*)stbi__malloc_mad2(tga_palette_len, tga_comp, 0);
         if (!tga_palette) {
            STBI_FREE(tga_data);
            return stbi__errpuc(""outofmem"", ""Out of memory"");
         }
         if (tga_rgb16) {
            stbi_uc *pal_entry = tga_palette;
            STBI_ASSERT(tga_comp == STBI_rgb);
            for (i=0; i < tga_palette_len; ++i) {
               stbi__tga_read_rgb16(s, pal_entry);
               pal_entry += tga_comp;
            }
         } else if (!stbi__getn(s, tga_palette, tga_palette_len * tga_comp)) {
               STBI_FREE(tga_data);
               STBI_FREE(tga_palette);
               return stbi__errpuc(""bad palette"", ""Corrupt TGA"");
         }
      }
      //   load the data
      for (i=0; i < tga_width * tga_height; ++i)
      {
         //   if I'm in RLE mode, do I need to get a RLE stbi__pngchunk?
         if ( tga_is_RLE )
         {
            if ( RLE_count == 0 )
            {
               //   yep, get the next byte as a RLE command
               int RLE_cmd = stbi__get8(s);
               RLE_count = 1 + (RLE_cmd & 127);
               RLE_repeating = RLE_cmd >> 7;
               read_next_pixel = 1;
            } else if ( !RLE_repeating )
            {
               read_next_pixel = 1;
            }
         } else
         {
            read_next_pixel = 1;
         }
         //   OK, if I need to read a pixel, do it now
         if ( read_next_pixel )
         {
            //   load however much data we did have
            if ( tga_indexed )
            {
               // read in index, then perform the lookup
               int pal_idx = (tga_bits_per_pixel == 8) ? stbi__get8(s) : stbi__get16le(s);
               if ( pal_idx >= tga_palette_len ) {
                  // invalid index
                  pal_idx = 0;
               }
               pal_idx *= tga_comp;
               for (j = 0; j < tga_comp; ++j) {
                  raw_data[j] = tga_palette[pal_idx+j];
               }
            } else if(tga_rgb16) {
               STBI_ASSERT(tga_comp == STBI_rgb);
               stbi__tga_read_rgb16(s, raw_data);
            } else {
               //   read in the data raw
               for (j = 0; j < tga_comp; ++j) {
                  raw_data[j] = stbi__get8(s);
               }
            }
            //   clear the reading flag for the next pixel
            read_next_pixel = 0;
         } // end of reading a pixel

         // copy data
         for (j = 0; j < tga_comp; ++j)
           tga_data[i*tga_comp+j] = raw_data[j];

         //   in case we're in RLE mode, keep counting down
         --RLE_count;
      }
      //   do I need to invert the image?
      if ( tga_inverted )
      {
         for (j = 0; j*2 < tga_height; ++j)
         {
            int index1 = j * tga_width * tga_comp;
            int index2 = (tga_height - 1 - j) * tga_width * tga_comp;
            for (i = tga_width * tga_comp; i > 0; --i)
            {
               unsigned char temp = tga_data[index1];
               tga_data[index1] = tga_data[index2];
               tga_data[index2] = temp;
               ++index1;
               ++index2;
            }
         }
      }
      //   clear my palette, if I had one
      if ( tga_palette != NULL )
      {
         STBI_FREE( tga_palette );
      }
   }

   // swap RGB - if the source data was RGB16, it already is in the right order
   if (tga_comp >= 3 && !tga_rgb16)
   {
      unsigned char* tga_pixel = tga_data;
      for (i=0; i < tga_width * tga_height; ++i)
      {
         unsigned char temp = tga_pixel[0];
         tga_pixel[0] = tga_pixel[2];
         tga_pixel[2] = temp;
         tga_pixel += tga_comp;
      }
   }

   // convert to target component count
   if (req_comp && req_comp != tga_comp)
      tga_data = stbi__convert_format(tga_data, tga_comp, req_comp, tga_width, tga_height);

   //   the things I do to get rid of an error message, and yet keep
   //   Microsoft's C compilers happy... [8^(
   tga_palette_start = tga_palette_len = tga_palette_bits =
         tga_x_origin = tga_y_origin = 0;
   STBI_NOTUSED(tga_palette_start);
   //   OK, done
   return tga_data;
}","{'begin': {'line': 5871, 'column': 1}, 'end': {'line': 6074, 'column': 2}}",show_image.c,"['加载', '并', '解码', 'TGA', '图像', '，', '处理', '调色', '调色板', '、', 'RLE', '压缩', '及', '格式', '转换', '。']"
785,785,stbi__process_gif_raster,stbi_uc *,"stbi_uc * stbi__process_gif_raster(stbi__context * s, stbi__gif * g)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'g', 'type': 'stbi__gif *'}]",解码GIF的LZW压缩栅格数据,"static stbi_uc *stbi__process_gif_raster(stbi__context *s, stbi__gif *g)
{
   stbi_uc lzw_cs;
   stbi__int32 len, init_code;
   stbi__uint32 first;
   stbi__int32 codesize, codemask, avail, oldcode, bits, valid_bits, clear;
   stbi__gif_lzw *p;

   lzw_cs = stbi__get8(s);
   if (lzw_cs > 12) return NULL;
   clear = 1 << lzw_cs;
   first = 1;
   codesize = lzw_cs + 1;
   codemask = (1 << codesize) - 1;
   bits = 0;
   valid_bits = 0;
   for (init_code = 0; init_code < clear; init_code++) {
      g->codes[init_code].prefix = -1;
      g->codes[init_code].first = (stbi_uc) init_code;
      g->codes[init_code].suffix = (stbi_uc) init_code;
   }

   // support no starting clear code
   avail = clear+2;
   oldcode = -1;

   len = 0;
   for(;;) {
      if (valid_bits < codesize) {
         if (len == 0) {
            len = stbi__get8(s); // start new block
            if (len == 0)
               return g->out;
         }
         --len;
         bits |= (stbi__int32) stbi__get8(s) << valid_bits;
         valid_bits += 8;
      } else {
         stbi__int32 code = bits & codemask;
         bits >>= codesize;
         valid_bits -= codesize;
         // @OPTIMIZE: is there some way we can accelerate the non-clear path?
         if (code == clear) {  // clear code
            codesize = lzw_cs + 1;
            codemask = (1 << codesize) - 1;
            avail = clear + 2;
            oldcode = -1;
            first = 0;
         } else if (code == clear + 1) { // end of stream code
            stbi__skip(s, len);
            while ((len = stbi__get8(s)) > 0)
               stbi__skip(s,len);
            return g->out;
         } else if (code <= avail) {
            if (first) {
               return stbi__errpuc(""no clear code"", ""Corrupt GIF"");
            }

            if (oldcode >= 0) {
               p = &g->codes[avail++];
               if (avail > 8192) {
                  return stbi__errpuc(""too many codes"", ""Corrupt GIF"");
               }

               p->prefix = (stbi__int16) oldcode;
               p->first = g->codes[oldcode].first;
               p->suffix = (code == avail) ? p->first : g->codes[code].first;
            } else if (code == avail)
               return stbi__errpuc(""illegal code in raster"", ""Corrupt GIF"");

            stbi__out_gif_code(g, (stbi__uint16) code);

            if ((avail & codemask) == 0 && avail <= 0x0FFF) {
               codesize++;
               codemask = (1 << codesize) - 1;
            }

            oldcode = code;
         } else {
            return stbi__errpuc(""illegal code in raster"", ""Corrupt GIF"");
         }
      }
   }
}","{'begin': {'line': 6691, 'column': 1}, 'end': {'line': 6774, 'column': 2}}",show_image.c,"['解码', 'GIF', '的', 'LZW', '压缩', '栅格', '数据', '栅格数据']"
786,786,stbi__gif_load_next,stbi_uc *,"stbi_uc * stbi__gif_load_next(stbi__context * s, stbi__gif * g, int * comp, int req_comp, stbi_uc * two_back)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'g', 'type': 'stbi__gif *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'two_back', 'type': 'stbi_uc *'}]",逐帧加载并处理GIF图像，管理透明背景与帧恢复,"static stbi_uc *stbi__gif_load_next(stbi__context *s, stbi__gif *g, int *comp, int req_comp, stbi_uc *two_back)
{
   int dispose;
   int first_frame;
   int pi;
   int pcount;
   STBI_NOTUSED(req_comp);

   // on first frame, any non-written pixels get the background colour (non-transparent)
   first_frame = 0;
   if (g->out == 0) {
      if (!stbi__gif_header(s, g, comp,0)) return 0; // stbi__g_failure_reason set by stbi__gif_header
      if (!stbi__mad3sizes_valid(4, g->w, g->h, 0))
         return stbi__errpuc(""too large"", ""GIF image is too large"");
      pcount = g->w * g->h;
      g->out = (stbi_uc *) stbi__malloc(4 * pcount);
      g->background = (stbi_uc *) stbi__malloc(4 * pcount);
      g->history = (stbi_uc *) stbi__malloc(pcount);
      if (!g->out || !g->background || !g->history)
         return stbi__errpuc(""outofmem"", ""Out of memory"");

      // image is treated as ""transparent"" at the start - ie, nothing overwrites the current background;
      // background colour is only used for pixels that are not rendered first frame, after that ""background""
      // color refers to the color that was there the previous frame.
      memset(g->out, 0x00, 4 * pcount);
      memset(g->background, 0x00, 4 * pcount); // state of the background (starts transparent)
      memset(g->history, 0x00, pcount);        // pixels that were affected previous frame
      first_frame = 1;
   } else {
      // second frame - how do we dispose of the previous one?
      dispose = (g->eflags & 0x1C) >> 2;
      pcount = g->w * g->h;

      if ((dispose == 3) && (two_back == 0)) {
         dispose = 2; // if I don't have an image to revert back to, default to the old background
      }

      if (dispose == 3) { // use previous graphic
         for (pi = 0; pi < pcount; ++pi) {
            if (g->history[pi]) {
               memcpy( &g->out[pi * 4], &two_back[pi * 4], 4 );
            }
         }
      } else if (dispose == 2) {
         // restore what was changed last frame to background before that frame;
         for (pi = 0; pi < pcount; ++pi) {
            if (g->history[pi]) {
               memcpy( &g->out[pi * 4], &g->background[pi * 4], 4 );
            }
         }
      } else {
         // This is a non-disposal case eithe way, so just
         // leave the pixels as is, and they will become the new background
         // 1: do not dispose
         // 0:  not specified.
      }

      // background is what out is after the undoing of the previou frame;
      memcpy( g->background, g->out, 4 * g->w * g->h );
   }

   // clear my history;
   memset( g->history, 0x00, g->w * g->h );        // pixels that were affected previous frame

   for (;;) {
      int tag = stbi__get8(s);
      switch (tag) {
         case 0x2C: /* Image Descriptor */
         {
            stbi__int32 x, y, w, h;
            stbi_uc *o;

            x = stbi__get16le(s);
            y = stbi__get16le(s);
            w = stbi__get16le(s);
            h = stbi__get16le(s);
            if (((x + w) > (g->w)) || ((y + h) > (g->h)))
               return stbi__errpuc(""bad Image Descriptor"", ""Corrupt GIF"");

            g->line_size = g->w * 4;
            g->start_x = x * 4;
            g->start_y = y * g->line_size;
            g->max_x   = g->start_x + w * 4;
            g->max_y   = g->start_y + h * g->line_size;
            g->cur_x   = g->start_x;
            g->cur_y   = g->start_y;

            // if the width of the specified rectangle is 0, that means
            // we may not see *any* pixels or the image is malformed;
            // to make sure this is caught, move the current y down to
            // max_y (which is what out_gif_code checks).
            if (w == 0)
               g->cur_y = g->max_y;

            g->lflags = stbi__get8(s);

            if (g->lflags & 0x40) {
               g->step = 8 * g->line_size; // first interlaced spacing
               g->parse = 3;
            } else {
               g->step = g->line_size;
               g->parse = 0;
            }

            if (g->lflags & 0x80) {
               stbi__gif_parse_colortable(s,g->lpal, 2 << (g->lflags & 7), g->eflags & 0x01 ? g->transparent : -1);
               g->color_table = (stbi_uc *) g->lpal;
            } else if (g->flags & 0x80) {
               g->color_table = (stbi_uc *) g->pal;
            } else
               return stbi__errpuc(""missing color table"", ""Corrupt GIF"");

            o = stbi__process_gif_raster(s, g);
            if (!o) return NULL;

            // if this was the first frame,
            pcount = g->w * g->h;
            if (first_frame && (g->bgindex > 0)) {
               // if first frame, any pixel not drawn to gets the background color
               for (pi = 0; pi < pcount; ++pi) {
                  if (g->history[pi] == 0) {
                     g->pal[g->bgindex][3] = 255; // just in case it was made transparent, undo that; It will be reset next frame if need be;
                     memcpy( &g->out[pi * 4], &g->pal[g->bgindex], 4 );
                  }
               }
            }

            return o;
         }

         case 0x21: // Comment Extension.
         {
            int len;
            int ext = stbi__get8(s);
            if (ext == 0xF9) { // Graphic Control Extension.
               len = stbi__get8(s);
               if (len == 4) {
                  g->eflags = stbi__get8(s);
                  g->delay = 10 * stbi__get16le(s); // delay - 1/100th of a second, saving as 1/1000ths.

                  // unset old transparent
                  if (g->transparent >= 0) {
                     g->pal[g->transparent][3] = 255;
                  }
                  if (g->eflags & 0x01) {
                     g->transparent = stbi__get8(s);
                     if (g->transparent >= 0) {
                        g->pal[g->transparent][3] = 0;
                     }
                  } else {
                     // don't need transparent
                     stbi__skip(s, 1);
                     g->transparent = -1;
                  }
               } else {
                  stbi__skip(s, len);
                  break;
               }
            }
            while ((len = stbi__get8(s)) != 0) {
               stbi__skip(s, len);
            }
            break;
         }

         case 0x3B: // gif stream termination code
            return (stbi_uc *) s; // using '1' causes warning on some compilers

         default:
            return stbi__errpuc(""unknown code"", ""Corrupt GIF"");
      }
   }
}","{'begin': {'line': 6778, 'column': 1}, 'end': {'line': 6950, 'column': 2}}",show_image.c,"['逐帧', '加载', '并', '处理', 'GIF', '图像', '，', '管理', '透明', '背景', '与', '帧', '恢复']"
787,787,stbi__psd_test,int,int stbi__psd_test(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",检测输入是否为PSD文件，并重置流位置。,"static int stbi__psd_test(stbi__context *s)
{
   int r = (stbi__get32be(s) == 0x38425053);
   stbi__rewind(s);
   return r;
}","{'begin': {'line': 6081, 'column': 1}, 'end': {'line': 6086, 'column': 2}}",show_image.c,"['检测', '输入', '是否', '为', 'PSD', '文件', '，', '并', '重置', '流', '位置', '。']"
788,788,stbi__psd_decode_rle,int,"int stbi__psd_decode_rle(stbi__context * s, stbi_uc * p, int pixelCount)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'p', 'type': 'stbi_uc *'}, {'name': 'pixelCount', 'type': 'int'}]",解码PSD文件的RLE压缩像素数据。,"static int stbi__psd_decode_rle(stbi__context *s, stbi_uc *p, int pixelCount)
{
   int count, nleft, len;

   count = 0;
   while ((nleft = pixelCount - count) > 0) {
      len = stbi__get8(s);
      if (len == 128) {
         // No-op.
      } else if (len < 128) {
         // Copy next len+1 bytes literally.
         len++;
         if (len > nleft) return 0; // corrupt data
         count += len;
         while (len) {
            *p = stbi__get8(s);
            p += 4;
            len--;
         }
      } else if (len > 128) {
         stbi_uc   val;
         // Next -len+1 bytes in the dest are replicated from next source byte.
         // (Interpret len as a negative 8-bit int.)
         len = 257 - len;
         if (len > nleft) return 0; // corrupt data
         val = stbi__get8(s);
         count += len;
         while (len) {
            *p = val;
            p += 4;
            len--;
         }
      }
   }

   return 1;
}","{'begin': {'line': 6088, 'column': 1}, 'end': {'line': 6124, 'column': 2}}",show_image.c,"['解码', 'PSD', '文件', '的', 'RLE', '压缩', '像素', '数据', '。']"
789,789,stbi__psd_load,void *,"void * stbi__psd_load(stbi__context * s, int * x, int * y, int * comp, int req_comp, stbi__result_info * ri, int bpc)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'ri', 'type': 'stbi__result_info *'}, {'name': 'bpc', 'type': 'int'}]",加载并解析PSD图像，支持RGB模式和压缩处理。,"static void *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)
{
   int pixelCount;
   int channelCount, compression;
   int channel, i;
   int bitdepth;
   int w,h;
   stbi_uc *out;
   STBI_NOTUSED(ri);

   // Check identifier
   if (stbi__get32be(s) != 0x38425053)   // ""8BPS""
      return stbi__errpuc(""not PSD"", ""Corrupt PSD image"");

   // Check file type version.
   if (stbi__get16be(s) != 1)
      return stbi__errpuc(""wrong version"", ""Unsupported version of PSD image"");

   // Skip 6 reserved bytes.
   stbi__skip(s, 6 );

   // Read the number of channels (R, G, B, A, etc).
   channelCount = stbi__get16be(s);
   if (channelCount < 0 || channelCount > 16)
      return stbi__errpuc(""wrong channel count"", ""Unsupported number of channels in PSD image"");

   // Read the rows and columns of the image.
   h = stbi__get32be(s);
   w = stbi__get32be(s);

   if (h > STBI_MAX_DIMENSIONS) return stbi__errpuc(""too large"",""Very large image (corrupt?)"");
   if (w > STBI_MAX_DIMENSIONS) return stbi__errpuc(""too large"",""Very large image (corrupt?)"");

   // Make sure the depth is 8 bits.
   bitdepth = stbi__get16be(s);
   if (bitdepth != 8 && bitdepth != 16)
      return stbi__errpuc(""unsupported bit depth"", ""PSD bit depth is not 8 or 16 bit"");

   // Make sure the color mode is RGB.
   // Valid options are:
   //   0: Bitmap
   //   1: Grayscale
   //   2: Indexed color
   //   3: RGB color
   //   4: CMYK color
   //   7: Multichannel
   //   8: Duotone
   //   9: Lab color
   if (stbi__get16be(s) != 3)
      return stbi__errpuc(""wrong color format"", ""PSD is not in RGB color format"");

   // Skip the Mode Data.  (It's the palette for indexed color; other info for other modes.)
   stbi__skip(s,stbi__get32be(s) );

   // Skip the image resources.  (resolution, pen tool paths, etc)
   stbi__skip(s, stbi__get32be(s) );

   // Skip the reserved data.
   stbi__skip(s, stbi__get32be(s) );

   // Find out if the data is compressed.
   // Known values:
   //   0: no compression
   //   1: RLE compressed
   compression = stbi__get16be(s);
   if (compression > 1)
      return stbi__errpuc(""bad compression"", ""PSD has an unknown compression format"");

   // Check size
   if (!stbi__mad3sizes_valid(4, w, h, 0))
      return stbi__errpuc(""too large"", ""Corrupt PSD"");

   // Create the destination image.

   if (!compression && bitdepth == 16 && bpc == 16) {
      out = (stbi_uc *) stbi__malloc_mad3(8, w, h, 0);
      ri->bits_per_channel = 16;
   } else
      out = (stbi_uc *) stbi__malloc(4 * w*h);

   if (!out) return stbi__errpuc(""outofmem"", ""Out of memory"");
   pixelCount = w*h;

   // Initialize the data to zero.
   //memset( out, 0, pixelCount * 4 );

   // Finally, the image data.
   if (compression) {
      // RLE as used by .PSD and .TIFF
      // Loop until you get the number of unpacked bytes you are expecting:
      //     Read the next source byte into n.
      //     If n is between 0 and 127 inclusive, copy the next n+1 bytes literally.
      //     Else if n is between -127 and -1 inclusive, copy the next byte -n+1 times.
      //     Else if n is 128, noop.
      // Endloop

      // The RLE-compressed data is preceded by a 2-byte data count for each row in the data,
      // which we're going to just skip.
      stbi__skip(s, h * channelCount * 2 );

      // Read the RLE data by channel.
      for (channel = 0; channel < 4; channel++) {
         stbi_uc *p;

         p = out+channel;
         if (channel >= channelCount) {
            // Fill this channel with default data.
            for (i = 0; i < pixelCount; i++, p += 4)
               *p = (channel == 3 ? 255 : 0);
         } else {
            // Read the RLE data.
            if (!stbi__psd_decode_rle(s, p, pixelCount)) {
               STBI_FREE(out);
               return stbi__errpuc(""corrupt"", ""bad RLE data"");
            }
         }
      }

   } else {
      // We're at the raw image data.  It's each channel in order (Red, Green, Blue, Alpha, ...)
      // where each channel consists of an 8-bit (or 16-bit) value for each pixel in the image.

      // Read the data by channel.
      for (channel = 0; channel < 4; channel++) {
         if (channel >= channelCount) {
            // Fill this channel with default data.
            if (bitdepth == 16 && bpc == 16) {
               stbi__uint16 *q = ((stbi__uint16 *) out) + channel;
               stbi__uint16 val = channel == 3 ? 65535 : 0;
               for (i = 0; i < pixelCount; i++, q += 4)
                  *q = val;
            } else {
               stbi_uc *p = out+channel;
               stbi_uc val = channel == 3 ? 255 : 0;
               for (i = 0; i < pixelCount; i++, p += 4)
                  *p = val;
            }
         } else {
            if (ri->bits_per_channel == 16) {    // output bpc
               stbi__uint16 *q = ((stbi__uint16 *) out) + channel;
               for (i = 0; i < pixelCount; i++, q += 4)
                  *q = (stbi__uint16) stbi__get16be(s);
            } else {
               stbi_uc *p = out+channel;
               if (bitdepth == 16) {  // input bpc
                  for (i = 0; i < pixelCount; i++, p += 4)
                     *p = (stbi_uc) (stbi__get16be(s) >> 8);
               } else {
                  for (i = 0; i < pixelCount; i++, p += 4)
                     *p = stbi__get8(s);
               }
            }
         }
      }
   }

   // remove weird white matte from PSD
   if (channelCount >= 4) {
      if (ri->bits_per_channel == 16) {
         for (i=0; i < w*h; ++i) {
            stbi__uint16 *pixel = (stbi__uint16 *) out + 4*i;
            if (pixel[3] != 0 && pixel[3] != 65535) {
               float a = pixel[3] / 65535.0f;
               float ra = 1.0f / a;
               float inv_a = 65535.0f * (1 - ra);
               pixel[0] = (stbi__uint16) (pixel[0]*ra + inv_a);
               pixel[1] = (stbi__uint16) (pixel[1]*ra + inv_a);
               pixel[2] = (stbi__uint16) (pixel[2]*ra + inv_a);
            }
         }
      } else {
         for (i=0; i < w*h; ++i) {
            unsigned char *pixel = out + 4*i;
            if (pixel[3] != 0 && pixel[3] != 255) {
               float a = pixel[3] / 255.0f;
               float ra = 1.0f / a;
               float inv_a = 255.0f * (1 - ra);
               pixel[0] = (unsigned char) (pixel[0]*ra + inv_a);
               pixel[1] = (unsigned char) (pixel[1]*ra + inv_a);
               pixel[2] = (unsigned char) (pixel[2]*ra + inv_a);
            }
         }
      }
   }

   // convert to desired output format
   if (req_comp && req_comp != 4) {
      if (ri->bits_per_channel == 16)
         out = (stbi_uc *) stbi__convert_format16((stbi__uint16 *) out, 4, req_comp, w, h);
      else
         out = stbi__convert_format(out, 4, req_comp, w, h);
      if (out == NULL) return out; // stbi__convert_format frees input on failure
   }

   if (comp) *comp = 4;
   *y = h;
   *x = w;

   return out;
}","{'begin': {'line': 6126, 'column': 1}, 'end': {'line': 6325, 'column': 2}}",show_image.c,"['加载', '并', '解析', 'PSD', '图像', '，', '支持', 'RGB', '模式', '和', '压缩', '处理', '。']"
790,790,stbi__load_gif_main_outofmem,void *,"void * stbi__load_gif_main_outofmem(stbi__gif * g, stbi_uc * out, int ** delays)","[{'name': 'g', 'type': 'stbi__gif *'}, {'name': 'out', 'type': 'stbi_uc *'}, {'name': 'delays', 'type': 'int **'}]",释放内存并返回内存不足错误,"static void *stbi__load_gif_main_outofmem(stbi__gif *g, stbi_uc *out, int **delays)
{
   STBI_FREE(g->out);
   STBI_FREE(g->history);
   STBI_FREE(g->background);

   if (out) STBI_FREE(out);
   if (delays && *delays) STBI_FREE(*delays);
   return stbi__errpuc(""outofmem"", ""Out of memory"");
}","{'begin': {'line': 6952, 'column': 1}, 'end': {'line': 6961, 'column': 2}}",show_image.c,"['释放', '内存', '并', '返回', '内存', '不足', '内存不足', '错误']"
791,791,stbi__load_gif_main,void *,"void * stbi__load_gif_main(stbi__context * s, int ** delays, int * x, int * y, int * z, int * comp, int req_comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'delays', 'type': 'int **'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'z', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",加载GIF图像，支持多帧动画并处理延迟,"static void *stbi__load_gif_main(stbi__context *s, int **delays, int *x, int *y, int *z, int *comp, int req_comp)
{
   if (stbi__gif_test(s)) {
      int layers = 0;
      stbi_uc *u = 0;
      stbi_uc *out = 0;
      stbi_uc *two_back = 0;
      stbi__gif g;
      int stride;
      int out_size = 0;
      int delays_size = 0;

      STBI_NOTUSED(out_size);
      STBI_NOTUSED(delays_size);

      memset(&g, 0, sizeof(g));
      if (delays) {
         *delays = 0;
      }

      do {
         u = stbi__gif_load_next(s, &g, comp, req_comp, two_back);
         if (u == (stbi_uc *) s) u = 0;  // end of animated gif marker

         if (u) {
            *x = g.w;
            *y = g.h;
            ++layers;
            stride = g.w * g.h * 4;

            if (out) {
               void *tmp = (stbi_uc*) STBI_REALLOC_SIZED( out, out_size, layers * stride );
               if (!tmp)
                  return stbi__load_gif_main_outofmem(&g, out, delays);
               else {
                   out = (stbi_uc*) tmp;
                   out_size = layers * stride;
               }

               if (delays) {
                  int *new_delays = (int*) STBI_REALLOC_SIZED( *delays, delays_size, sizeof(int) * layers );
                  if (!new_delays)
                     return stbi__load_gif_main_outofmem(&g, out, delays);
                  *delays = new_delays;
                  delays_size = layers * sizeof(int);
               }
            } else {
               out = (stbi_uc*)stbi__malloc( layers * stride );
               if (!out)
                  return stbi__load_gif_main_outofmem(&g, out, delays);
               out_size = layers * stride;
               if (delays) {
                  *delays = (int*) stbi__malloc( layers * sizeof(int) );
                  if (!*delays)
                     return stbi__load_gif_main_outofmem(&g, out, delays);
                  delays_size = layers * sizeof(int);
               }
            }
            memcpy( out + ((layers - 1) * stride), u, stride );
            if (layers >= 2) {
               two_back = out - 2 * stride;
            }

            if (delays) {
               (*delays)[layers - 1U] = g.delay;
            }
         }
      } while (u != 0);

      // free temp buffer;
      STBI_FREE(g.out);
      STBI_FREE(g.history);
      STBI_FREE(g.background);

      // do the final conversion after loading everything;
      if (req_comp && req_comp != 4)
         out = stbi__convert_format(out, 4, req_comp, layers * g.w, g.h);

      *z = layers;
      return out;
   } else {
      return stbi__errpuc(""not GIF"", ""Image was not as a gif type."");
   }
}","{'begin': {'line': 6963, 'column': 1}, 'end': {'line': 7046, 'column': 2}}",show_image.c,"['加载', 'GIF', '图像', '，', '支持', '多', '帧', '动画', '并', '处理', '延迟']"
792,792,stbi__pic_is4,int,"int stbi__pic_is4(stbi__context * s, const char * str)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'str', 'type': 'const char *'}]",检查输入流前4字节是否与指定字符串匹配,"static int stbi__pic_is4(stbi__context *s,const char *str)
{
   int i;
   for (i=0; i<4; ++i)
      if (stbi__get8(s) != (stbi_uc)str[i])
         return 0;

   return 1;
}","{'begin': {'line': 6336, 'column': 1}, 'end': {'line': 6344, 'column': 2}}",show_image.c,"['检查', '输入', '流前', '4', '字节', '是否', '与', '指定', '字符', '字符串', '匹配']"
793,793,stbi__gif_load,void *,"void * stbi__gif_load(stbi__context * s, int * x, int * y, int * comp, int req_comp, stbi__result_info * ri)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'ri', 'type': 'stbi__result_info *'}]",加载并处理GIF图像数据，支持格式转换。,"static void *stbi__gif_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   stbi_uc *u = 0;
   stbi__gif g;
   memset(&g, 0, sizeof(g));
   STBI_NOTUSED(ri);

   u = stbi__gif_load_next(s, &g, comp, req_comp, 0);
   if (u == (stbi_uc *) s) u = 0;  // end of animated gif marker
   if (u) {
      *x = g.w;
      *y = g.h;

      // moved conversion to after successful load so that the same
      // can be done for multiple frames.
      if (req_comp && req_comp != 4)
         u = stbi__convert_format(u, 4, req_comp, g.w, g.h);
   } else if (g.out) {
      // if there was an error and we allocated an image buffer, free it!
      STBI_FREE(g.out);
   }

   // free buffers needed for multiple frame loading;
   STBI_FREE(g.history);
   STBI_FREE(g.background);

   return u;
}","{'begin': {'line': 7048, 'column': 1}, 'end': {'line': 7075, 'column': 2}}",show_image.c,"['加载', '并', '处理', 'GIF', '图像', '数据', '，', '支持', '格式', '转换', '。']"
794,794,stbi__pic_test_core,int,int stbi__pic_test_core(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",检测输入是否为PIC格式图片,"static int stbi__pic_test_core(stbi__context *s)
{
   int i;

   if (!stbi__pic_is4(s,""\x53\x80\xF6\x34""))
      return 0;

   for(i=0;i<84;++i)
      stbi__get8(s);

   if (!stbi__pic_is4(s,""PICT""))
      return 0;

   return 1;
}","{'begin': {'line': 6346, 'column': 1}, 'end': {'line': 6360, 'column': 2}}",show_image.c,"['检测', '输入', '是否', '为', 'PIC', '格式', '图片']"
795,795,stbi__gif_info,int,"int stbi__gif_info(stbi__context * s, int * x, int * y, int * comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",调用stbi__gif_info_raw获取GIF图像信息,"static int stbi__gif_info(stbi__context *s, int *x, int *y, int *comp)
{
   return stbi__gif_info_raw(s,x,y,comp);
}","{'begin': {'line': 7077, 'column': 1}, 'end': {'line': 7080, 'column': 2}}",show_image.c,"['调用', 'stbi', '__', 'gif', '_', 'info', '_', 'raw', '获取', 'GIF', '图像', '信息']"
796,796,stbi__hdr_test_core,int,"int stbi__hdr_test_core(stbi__context * s, const char * signature)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'signature', 'type': 'const char *'}]",验证输入流是否匹配指定签名,"static int stbi__hdr_test_core(stbi__context *s, const char *signature)
{
   int i;
   for (i=0; signature[i]; ++i)
      if (stbi__get8(s) != signature[i])
          return 0;
   stbi__rewind(s);
   return 1;
}","{'begin': {'line': 7087, 'column': 1}, 'end': {'line': 7095, 'column': 2}}",show_image.c,"['验证', '输入', '流', '是否', '匹配', '指定', '签名']"
797,797,stbi__readval,stbi_uc *,"stbi_uc * stbi__readval(stbi__context * s, int channel, stbi_uc * dest)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'channel', 'type': 'int'}, {'name': 'dest', 'type': 'stbi_uc *'}]",根据通道掩码读取最多4字节到目标数组,"static stbi_uc *stbi__readval(stbi__context *s, int channel, stbi_uc *dest)
{
   int mask=0x80, i;

   for (i=0; i<4; ++i, mask>>=1) {
      if (channel & mask) {
         if (stbi__at_eof(s)) return stbi__errpuc(""bad file"",""PIC file too short"");
         dest[i]=stbi__get8(s);
      }
   }

   return dest;
}","{'begin': {'line': 6367, 'column': 1}, 'end': {'line': 6379, 'column': 2}}",show_image.c,"['根据', '通道', '掩码', '读取', '最多', '4', '字节', '到', '目标', '数组']"
798,798,stbi__copyval,void,"void stbi__copyval(int channel, stbi_uc * dest, const stbi_uc * src)","[{'name': 'channel', 'type': 'int'}, {'name': 'dest', 'type': 'stbi_uc *'}, {'name': 'src', 'type': 'const stbi_uc *'}]",根据通道掩码选择性复制四个通道的值,"static void stbi__copyval(int channel,stbi_uc *dest,const stbi_uc *src)
{
   int mask=0x80,i;

   for (i=0;i<4; ++i, mask>>=1)
      if (channel&mask)
         dest[i]=src[i];
}","{'begin': {'line': 6381, 'column': 1}, 'end': {'line': 6388, 'column': 2}}",show_image.c,"['根据', '通道', '掩码', '选择', '选择性', '复制', '四个', '通道', '的', '值']"
799,799,stbi__hdr_test,int,int stbi__hdr_test(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",测试HDR文件头是否为RADIANCE或RGBE格式,"static int stbi__hdr_test(stbi__context* s)
{
   int r = stbi__hdr_test_core(s, ""#?RADIANCE\n"");
   stbi__rewind(s);
   if(!r) {
       r = stbi__hdr_test_core(s, ""#?RGBE\n"");
       stbi__rewind(s);
   }
   return r;
}","{'begin': {'line': 7097, 'column': 1}, 'end': {'line': 7106, 'column': 2}}",show_image.c,"['测试', 'HDR', '文件', '头', '是否', '为', 'RADIANCE', '或', 'RGBE', '格式']"
800,800,stbi__hdr_gettoken,char *,"char * stbi__hdr_gettoken(stbi__context * z, char * buffer)","[{'name': 'z', 'type': 'stbi__context *'}, {'name': 'buffer', 'type': 'char *'}]",逐行读取HDR数据到缓冲区,"static char *stbi__hdr_gettoken(stbi__context *z, char *buffer)
{
   int len=0;
   char c = '\0';

   c = (char) stbi__get8(z);

   while (!stbi__at_eof(z) && c != '\n') {
      buffer[len++] = c;
      if (len == STBI__HDR_BUFLEN-1) {
         // flush to end of line
         while (!stbi__at_eof(z) && stbi__get8(z) != '\n')
            ;
         break;
      }
      c = (char) stbi__get8(z);
   }

   buffer[len] = 0;
   return buffer;
}","{'begin': {'line': 7109, 'column': 1}, 'end': {'line': 7129, 'column': 2}}",show_image.c,"['逐行', '读取', 'HDR', '数据', '到', '缓冲', '缓冲区']"
801,801,stbi__pic_load_core,stbi_uc *,"stbi_uc * stbi__pic_load_core(stbi__context * s, int width, int height, int * comp, stbi_uc * result)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'width', 'type': 'int'}, {'name': 'height', 'type': 'int'}, {'name': 'comp', 'type': 'int *'}, {'name': 'result', 'type': 'stbi_uc *'}]",解析PIC图像数据包并解码生成图像,"static stbi_uc *stbi__pic_load_core(stbi__context *s,int width,int height,int *comp, stbi_uc *result)
{
   int act_comp=0,num_packets=0,y,chained;
   stbi__pic_packet packets[10];

   // this will (should...) cater for even some bizarre stuff like having data
    // for the same channel in multiple packets.
   do {
      stbi__pic_packet *packet;

      if (num_packets==sizeof(packets)/sizeof(packets[0]))
         return stbi__errpuc(""bad format"",""too many packets"");

      packet = &packets[num_packets++];

      chained = stbi__get8(s);
      packet->size    = stbi__get8(s);
      packet->type    = stbi__get8(s);
      packet->channel = stbi__get8(s);

      act_comp |= packet->channel;

      if (stbi__at_eof(s))          return stbi__errpuc(""bad file"",""file too short (reading packets)"");
      if (packet->size != 8)  return stbi__errpuc(""bad format"",""packet isn't 8bpp"");
   } while (chained);

   *comp = (act_comp & 0x10 ? 4 : 3); // has alpha channel?

   for(y=0; y<height; ++y) {
      int packet_idx;

      for(packet_idx=0; packet_idx < num_packets; ++packet_idx) {
         stbi__pic_packet *packet = &packets[packet_idx];
         stbi_uc *dest = result+y*width*4;

         switch (packet->type) {
            default:
               return stbi__errpuc(""bad format"",""packet has bad compression type"");

            case 0: {//uncompressed
               int x;

               for(x=0;x<width;++x, dest+=4)
                  if (!stbi__readval(s,packet->channel,dest))
                     return 0;
               break;
            }

            case 1://Pure RLE
               {
                  int left=width, i;

                  while (left>0) {
                     stbi_uc count,value[4];

                     count=stbi__get8(s);
                     if (stbi__at_eof(s))   return stbi__errpuc(""bad file"",""file too short (pure read count)"");

                     if (count > left)
                        count = (stbi_uc) left;

                     if (!stbi__readval(s,packet->channel,value))  return 0;

                     for(i=0; i<count; ++i,dest+=4)
                        stbi__copyval(packet->channel,dest,value);
                     left -= count;
                  }
               }
               break;

            case 2: {//Mixed RLE
               int left=width;
               while (left>0) {
                  int count = stbi__get8(s), i;
                  if (stbi__at_eof(s))  return stbi__errpuc(""bad file"",""file too short (mixed read count)"");

                  if (count >= 128) { // Repeated
                     stbi_uc value[4];

                     if (count==128)
                        count = stbi__get16be(s);
                     else
                        count -= 127;
                     if (count > left)
                        return stbi__errpuc(""bad file"",""scanline overrun"");

                     if (!stbi__readval(s,packet->channel,value))
                        return 0;

                     for(i=0;i<count;++i, dest += 4)
                        stbi__copyval(packet->channel,dest,value);
                  } else { // Raw
                     ++count;
                     if (count>left) return stbi__errpuc(""bad file"",""scanline overrun"");

                     for(i=0;i<count;++i, dest+=4)
                        if (!stbi__readval(s,packet->channel,dest))
                           return 0;
                  }
                  left-=count;
               }
               break;
            }
         }
      }
   }

   return result;
}","{'begin': {'line': 6390, 'column': 1}, 'end': {'line': 6498, 'column': 2}}",show_image.c,"['解析', 'PIC', '图像', '数据', '数据包', '并', '解码', '生成', '图像']"
802,802,stbi__hdr_convert,void,"void stbi__hdr_convert(float * output, stbi_uc * input, int req_comp)","[{'name': 'output', 'type': 'float *'}, {'name': 'input', 'type': 'stbi_uc *'}, {'name': 'req_comp', 'type': 'int'}]",将HDR输入转换为指定通道数的浮点数组,"static void stbi__hdr_convert(float *output, stbi_uc *input, int req_comp)
{
   if ( input[3] != 0 ) {
      float f1;
      // Exponent
      f1 = (float) ldexp(1.0f, input[3] - (int)(128 + 8));
      if (req_comp <= 2)
         output[0] = (input[0] + input[1] + input[2]) * f1 / 3;
      else {
         output[0] = input[0] * f1;
         output[1] = input[1] * f1;
         output[2] = input[2] * f1;
      }
      if (req_comp == 2) output[1] = 1;
      if (req_comp == 4) output[3] = 1;
   } else {
      switch (req_comp) {
         case 4: output[3] = 1; /* fallthrough */
         case 3: output[0] = output[1] = output[2] = 0;
                 break;
         case 2: output[1] = 1; /* fallthrough */
         case 1: output[0] = 0;
                 break;
      }
   }
}","{'begin': {'line': 7131, 'column': 1}, 'end': {'line': 7156, 'column': 2}}",show_image.c,"['将', 'HDR', '输入', '转换', '为', '指定', '通道', '数', '的', '浮点', '数组']"
803,803,stbi__hdr_load,float *,"float * stbi__hdr_load(stbi__context * s, int * x, int * y, int * comp, int req_comp, stbi__result_info * ri)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'ri', 'type': 'stbi__result_info *'}]",加载并解码HDR图像数据，支持RLE编码,"static float *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   char buffer[STBI__HDR_BUFLEN];
   char *token;
   int valid = 0;
   int width, height;
   stbi_uc *scanline;
   float *hdr_data;
   int len;
   unsigned char count, value;
   int i, j, k, c1,c2, z;
   const char *headerToken;
   STBI_NOTUSED(ri);

   // Check identifier
   headerToken = stbi__hdr_gettoken(s,buffer);
   if (strcmp(headerToken, ""#?RADIANCE"") != 0 && strcmp(headerToken, ""#?RGBE"") != 0)
      return stbi__errpf(""not HDR"", ""Corrupt HDR image"");

   // Parse header
   for(;;) {
      token = stbi__hdr_gettoken(s,buffer);
      if (token[0] == 0) break;
      if (strcmp(token, ""FORMAT=32-bit_rle_rgbe"") == 0) valid = 1;
   }

   if (!valid)    return stbi__errpf(""unsupported format"", ""Unsupported HDR format"");

   // Parse width and height
   // can't use sscanf() if we're not using stdio!
   token = stbi__hdr_gettoken(s,buffer);
   if (strncmp(token, ""-Y "", 3))  return stbi__errpf(""unsupported data layout"", ""Unsupported HDR format"");
   token += 3;
   height = (int) strtol(token, &token, 10);
   while (*token == ' ') ++token;
   if (strncmp(token, ""+X "", 3))  return stbi__errpf(""unsupported data layout"", ""Unsupported HDR format"");
   token += 3;
   width = (int) strtol(token, NULL, 10);

   if (height > STBI_MAX_DIMENSIONS) return stbi__errpf(""too large"",""Very large image (corrupt?)"");
   if (width > STBI_MAX_DIMENSIONS) return stbi__errpf(""too large"",""Very large image (corrupt?)"");

   *x = width;
   *y = height;

   if (comp) *comp = 3;
   if (req_comp == 0) req_comp = 3;

   if (!stbi__mad4sizes_valid(width, height, req_comp, sizeof(float), 0))
      return stbi__errpf(""too large"", ""HDR image is too large"");

   // Read data
   hdr_data = (float *) stbi__malloc_mad4(width, height, req_comp, sizeof(float), 0);
   if (!hdr_data)
      return stbi__errpf(""outofmem"", ""Out of memory"");

   // Load image data
   // image data is stored as some number of sca
   if ( width < 8 || width >= 32768) {
      // Read flat data
      for (j=0; j < height; ++j) {
         for (i=0; i < width; ++i) {
            stbi_uc rgbe[4];
           main_decode_loop:
            stbi__getn(s, rgbe, 4);
            stbi__hdr_convert(hdr_data + j * width * req_comp + i * req_comp, rgbe, req_comp);
         }
      }
   } else {
      // Read RLE-encoded data
      scanline = NULL;

      for (j = 0; j < height; ++j) {
         c1 = stbi__get8(s);
         c2 = stbi__get8(s);
         len = stbi__get8(s);
         if (c1 != 2 || c2 != 2 || (len & 0x80)) {
            // not run-length encoded, so we have to actually use THIS data as a decoded
            // pixel (note this can't be a valid pixel--one of RGB must be >= 128)
            stbi_uc rgbe[4];
            rgbe[0] = (stbi_uc) c1;
            rgbe[1] = (stbi_uc) c2;
            rgbe[2] = (stbi_uc) len;
            rgbe[3] = (stbi_uc) stbi__get8(s);
            stbi__hdr_convert(hdr_data, rgbe, req_comp);
            i = 1;
            j = 0;
            STBI_FREE(scanline);
            goto main_decode_loop; // yes, this makes no sense
         }
         len <<= 8;
         len |= stbi__get8(s);
         if (len != width) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(""invalid decoded scanline length"", ""corrupt HDR""); }
         if (scanline == NULL) {
            scanline = (stbi_uc *) stbi__malloc_mad2(width, 4, 0);
            if (!scanline) {
               STBI_FREE(hdr_data);
               return stbi__errpf(""outofmem"", ""Out of memory"");
            }
         }

         for (k = 0; k < 4; ++k) {
            int nleft;
            i = 0;
            while ((nleft = width - i) > 0) {
               count = stbi__get8(s);
               if (count > 128) {
                  // Run
                  value = stbi__get8(s);
                  count -= 128;
                  if ((count == 0) || (count > nleft)) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(""corrupt"", ""bad RLE data in HDR""); }
                  for (z = 0; z < count; ++z)
                     scanline[i++ * 4 + k] = value;
               } else {
                  // Dump
                  if ((count == 0) || (count > nleft)) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(""corrupt"", ""bad RLE data in HDR""); }
                  for (z = 0; z < count; ++z)
                     scanline[i++ * 4 + k] = stbi__get8(s);
               }
            }
         }
         for (i=0; i < width; ++i)
            stbi__hdr_convert(hdr_data+(j*width + i)*req_comp, scanline + i*4, req_comp);
      }
      if (scanline)
         STBI_FREE(scanline);
   }

   return hdr_data;
}","{'begin': {'line': 7158, 'column': 1}, 'end': {'line': 7287, 'column': 2}}",show_image.c,"['加载', '并', '解码', 'HDR', '图像', '数据', '，', '支持', 'RLE', '编码']"
804,804,stbi__pic_load,void *,"void * stbi__pic_load(stbi__context * s, int * px, int * py, int * comp, int req_comp, stbi__result_info * ri)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'px', 'type': 'int *'}, {'name': 'py', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'ri', 'type': 'stbi__result_info *'}]",加载并解码PIC格式图像，返回像素数据,"static void *stbi__pic_load(stbi__context *s,int *px,int *py,int *comp,int req_comp, stbi__result_info *ri)
{
   stbi_uc *result;
   int i, x,y, internal_comp;
   STBI_NOTUSED(ri);

   if (!comp) comp = &internal_comp;

   for (i=0; i<92; ++i)
      stbi__get8(s);

   x = stbi__get16be(s);
   y = stbi__get16be(s);

   if (y > STBI_MAX_DIMENSIONS) return stbi__errpuc(""too large"",""Very large image (corrupt?)"");
   if (x > STBI_MAX_DIMENSIONS) return stbi__errpuc(""too large"",""Very large image (corrupt?)"");

   if (stbi__at_eof(s))  return stbi__errpuc(""bad file"",""file too short (pic header)"");
   if (!stbi__mad3sizes_valid(x, y, 4, 0)) return stbi__errpuc(""too large"", ""PIC image too large to decode"");

   stbi__get32be(s); //skip `ratio'
   stbi__get16be(s); //skip `fields'
   stbi__get16be(s); //skip `pad'

   // intermediate buffer is RGBA
   result = (stbi_uc *) stbi__malloc_mad3(x, y, 4, 0);
   if (!result) return stbi__errpuc(""outofmem"", ""Out of memory"");
   memset(result, 0xff, x*y*4);

   if (!stbi__pic_load_core(s,x,y,comp, result)) {
      STBI_FREE(result);
      result=0;
   }
   *px = x;
   *py = y;
   if (req_comp == 0) req_comp = *comp;
   result=stbi__convert_format(result,4,req_comp,x,y);

   return result;
}","{'begin': {'line': 6500, 'column': 1}, 'end': {'line': 6539, 'column': 2}}",show_image.c,"['加载', '并', '解码', 'PIC', '格式', '图像', '，', '返回', '像素', '数据']"
805,805,stbi__pic_test,int,int stbi__pic_test(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",测试输入是否为PIC格式并重置流位置,"static int stbi__pic_test(stbi__context *s)
{
   int r = stbi__pic_test_core(s);
   stbi__rewind(s);
   return r;
}","{'begin': {'line': 6541, 'column': 1}, 'end': {'line': 6546, 'column': 2}}",show_image.c,"['测试', '输入', '是否', '为', 'PIC', '格式', '并', '重置', '流', '位置']"
806,806,stbi__gif_test_raw,int,int stbi__gif_test_raw(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",检测输入流是否为GIF格式,"static int stbi__gif_test_raw(stbi__context *s)
{
   int sz;
   if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8') return 0;
   sz = stbi__get8(s);
   if (sz != '9' && sz != '7') return 0;
   if (stbi__get8(s) != 'a') return 0;
   return 1;
}","{'begin': {'line': 6580, 'column': 1}, 'end': {'line': 6588, 'column': 2}}",show_image.c,"['检测', '输入', '流', '是否', '为', 'GIF', '格式']"
807,807,stbi__gif_test,int,int stbi__gif_test(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",检测输入流是否为GIF图像并重置位置,"static int stbi__gif_test(stbi__context *s)
{
   int r = stbi__gif_test_raw(s);
   stbi__rewind(s);
   return r;
}","{'begin': {'line': 6590, 'column': 1}, 'end': {'line': 6595, 'column': 2}}",show_image.c,"['检测', '输入', '流', '是否', '为', 'GIF', '图像', '并', '重置', '位置']"
808,808,stbi__gif_parse_colortable,void,"void stbi__gif_parse_colortable(stbi__context * s, stbi_uc[256][4] pal, int num_entries, int transp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'pal', 'type': 'stbi_uc[256][4]'}, {'name': 'num_entries', 'type': 'int'}, {'name': 'transp', 'type': 'int'}]",解析GIF颜色表并设置透明度,"static void stbi__gif_parse_colortable(stbi__context *s, stbi_uc pal[256][4], int num_entries, int transp)
{
   int i;
   for (i=0; i < num_entries; ++i) {
      pal[i][2] = stbi__get8(s);
      pal[i][1] = stbi__get8(s);
      pal[i][0] = stbi__get8(s);
      pal[i][3] = transp == i ? 0 : 255;
   }
}","{'begin': {'line': 6597, 'column': 1}, 'end': {'line': 6606, 'column': 2}}",show_image.c,"['解析', 'GIF', '颜色', '表并', '设置', '透明', '明度', '透明度']"
809,809,stbi__gif_header,int,"int stbi__gif_header(stbi__context * s, stbi__gif * g, int * comp, int is_info)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'g', 'type': 'stbi__gif *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'is_info', 'type': 'int'}]",解析GIF头信息，验证格式并提取参数,"static int stbi__gif_header(stbi__context *s, stbi__gif *g, int *comp, int is_info)
{
   stbi_uc version;
   if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8')
      return stbi__err(""not GIF"", ""Corrupt GIF"");

   version = stbi__get8(s);
   if (version != '7' && version != '9')    return stbi__err(""not GIF"", ""Corrupt GIF"");
   if (stbi__get8(s) != 'a')                return stbi__err(""not GIF"", ""Corrupt GIF"");

   stbi__g_failure_reason = """";
   g->w = stbi__get16le(s);
   g->h = stbi__get16le(s);
   g->flags = stbi__get8(s);
   g->bgindex = stbi__get8(s);
   g->ratio = stbi__get8(s);
   g->transparent = -1;

   if (g->w > STBI_MAX_DIMENSIONS) return stbi__err(""too large"",""Very large image (corrupt?)"");
   if (g->h > STBI_MAX_DIMENSIONS) return stbi__err(""too large"",""Very large image (corrupt?)"");

   if (comp != 0) *comp = 4;  // can't actually tell whether it's 3 or 4 until we parse the comments

   if (is_info) return 1;

   if (g->flags & 0x80)
      stbi__gif_parse_colortable(s,g->pal, 2 << (g->flags & 7), -1);

   return 1;
}","{'begin': {'line': 6608, 'column': 1}, 'end': {'line': 6637, 'column': 2}}",show_image.c,"['解析', 'GIF', '头', '信息', '，', '验证', '格式', '并', '提取', '参数']"
810,810,stbi__hdr_info,int,"int stbi__hdr_info(stbi__context * s, int * x, int * y, int * comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",解析HDR图像头信息，获取宽高及通道数,"static int stbi__hdr_info(stbi__context *s, int *x, int *y, int *comp)
{
   char buffer[STBI__HDR_BUFLEN];
   char *token;
   int valid = 0;
   int dummy;

   if (!x) x = &dummy;
   if (!y) y = &dummy;
   if (!comp) comp = &dummy;

   if (stbi__hdr_test(s) == 0) {
       stbi__rewind( s );
       return 0;
   }

   for(;;) {
      token = stbi__hdr_gettoken(s,buffer);
      if (token[0] == 0) break;
      if (strcmp(token, ""FORMAT=32-bit_rle_rgbe"") == 0) valid = 1;
   }

   if (!valid) {
       stbi__rewind( s );
       return 0;
   }
   token = stbi__hdr_gettoken(s,buffer);
   if (strncmp(token, ""-Y "", 3)) {
       stbi__rewind( s );
       return 0;
   }
   token += 3;
   *y = (int) strtol(token, &token, 10);
   while (*token == ' ') ++token;
   if (strncmp(token, ""+X "", 3)) {
       stbi__rewind( s );
       return 0;
   }
   token += 3;
   *x = (int) strtol(token, NULL, 10);
   *comp = 3;
   return 1;
}","{'begin': {'line': 7289, 'column': 1}, 'end': {'line': 7331, 'column': 2}}",show_image.c,"['解析', 'HDR', '图像', '头', '信息', '，', '获取', '宽高及', '通道', '数']"
811,811,stbi__bmp_info,int,"int stbi__bmp_info(stbi__context * s, int * x, int * y, int * comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",解析BMP图像头信息，获取尺寸和通道数,"static int stbi__bmp_info(stbi__context *s, int *x, int *y, int *comp)
{
   void *p;
   stbi__bmp_data info;

   info.all_a = 255;
   p = stbi__bmp_parse_header(s, &info);
   if (p == NULL) {
      stbi__rewind( s );
      return 0;
   }
   if (x) *x = s->img_x;
   if (y) *y = s->img_y;
   if (comp) {
      if (info.bpp == 24 && info.ma == 0xff000000)
         *comp = 3;
      else
         *comp = info.ma ? 4 : 3;
   }
   return 1;
}","{'begin': {'line': 7335, 'column': 1}, 'end': {'line': 7355, 'column': 2}}",show_image.c,"['解析', 'BMP', '图像', '头', '信息', '，', '获取', '尺寸', '和', '通道', '数']"
812,812,stbi__gif_info_raw,int,"int stbi__gif_info_raw(stbi__context * s, int * x, int * y, int * comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",解析GIF图像头部信息，获取宽高和通道数,"static int stbi__gif_info_raw(stbi__context *s, int *x, int *y, int *comp)
{
   stbi__gif* g = (stbi__gif*) stbi__malloc(sizeof(stbi__gif));
   if (!g) return stbi__err(""outofmem"", ""Out of memory"");
   if (!stbi__gif_header(s, g, comp, 1)) {
      STBI_FREE(g);
      stbi__rewind( s );
      return 0;
   }
   if (x) *x = g->w;
   if (y) *y = g->h;
   STBI_FREE(g);
   return 1;
}","{'begin': {'line': 6639, 'column': 1}, 'end': {'line': 6652, 'column': 2}}",show_image.c,"['解析', 'GIF', '图像', '头部', '信息', '，', '获取', '宽高', '和', '通道', '数']"
813,813,stbi__out_gif_code,void,"void stbi__out_gif_code(stbi__gif * g, stbi__uint16 code)","[{'name': 'g', 'type': 'stbi__gif *'}, {'name': 'code', 'type': 'stbi__uint16'}]",递归解码GIF LZW编码并更新像素颜色,"static void stbi__out_gif_code(stbi__gif *g, stbi__uint16 code)
{
   stbi_uc *p, *c;
   int idx;

   // recurse to decode the prefixes, since the linked-list is backwards,
   // and working backwards through an interleaved image would be nasty
   if (g->codes[code].prefix >= 0)
      stbi__out_gif_code(g, g->codes[code].prefix);

   if (g->cur_y >= g->max_y) return;

   idx = g->cur_x + g->cur_y;
   p = &g->out[idx];
   g->history[idx / 4] = 1;

   c = &g->color_table[g->codes[code].suffix * 4];
   if (c[3] > 128) { // don't render transparent pixels;
      p[0] = c[2];
      p[1] = c[1];
      p[2] = c[0];
      p[3] = c[3];
   }
   g->cur_x += 4;

   if (g->cur_x >= g->max_x) {
      g->cur_x = g->start_x;
      g->cur_y += g->step;

      while (g->cur_y >= g->max_y && g->parse > 0) {
         g->step = (1 << g->parse) * g->line_size;
         g->cur_y = g->start_y + (g->step >> 1);
         --g->parse;
      }
   }
}","{'begin': {'line': 6654, 'column': 1}, 'end': {'line': 6689, 'column': 2}}",show_image.c,"['递归', '解码', 'GIF', ' ', 'LZW', '编码', '并', '更新', '像素', '颜色']"
814,814,stbi__psd_info,int,"int stbi__psd_info(stbi__context * s, int * x, int * y, int * comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",解析PSD图像头部信息，获取宽高及通道数,"static int stbi__psd_info(stbi__context *s, int *x, int *y, int *comp)
{
   int channelCount, dummy, depth;
   if (!x) x = &dummy;
   if (!y) y = &dummy;
   if (!comp) comp = &dummy;
   if (stbi__get32be(s) != 0x38425053) {
       stbi__rewind( s );
       return 0;
   }
   if (stbi__get16be(s) != 1) {
       stbi__rewind( s );
       return 0;
   }
   stbi__skip(s, 6);
   channelCount = stbi__get16be(s);
   if (channelCount < 0 || channelCount > 16) {
       stbi__rewind( s );
       return 0;
   }
   *y = stbi__get32be(s);
   *x = stbi__get32be(s);
   depth = stbi__get16be(s);
   if (depth != 8 && depth != 16) {
       stbi__rewind( s );
       return 0;
   }
   if (stbi__get16be(s) != 3) {
       stbi__rewind( s );
       return 0;
   }
   *comp = 4;
   return 1;
}","{'begin': {'line': 7359, 'column': 1}, 'end': {'line': 7392, 'column': 2}}",show_image.c,"['解析', 'PSD', '图像', '头部', '信息', '，', '获取', '宽高及', '通道', '数']"
815,815,stbi__process_gif_raster,stbi_uc *,"stbi_uc * stbi__process_gif_raster(stbi__context * s, stbi__gif * g)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'g', 'type': 'stbi__gif *'}]",解码GIF的LZW压缩数据，生成图像输出,"static stbi_uc *stbi__process_gif_raster(stbi__context *s, stbi__gif *g)
{
   stbi_uc lzw_cs;
   stbi__int32 len, init_code;
   stbi__uint32 first;
   stbi__int32 codesize, codemask, avail, oldcode, bits, valid_bits, clear;
   stbi__gif_lzw *p;

   lzw_cs = stbi__get8(s);
   if (lzw_cs > 12) return NULL;
   clear = 1 << lzw_cs;
   first = 1;
   codesize = lzw_cs + 1;
   codemask = (1 << codesize) - 1;
   bits = 0;
   valid_bits = 0;
   for (init_code = 0; init_code < clear; init_code++) {
      g->codes[init_code].prefix = -1;
      g->codes[init_code].first = (stbi_uc) init_code;
      g->codes[init_code].suffix = (stbi_uc) init_code;
   }

   // support no starting clear code
   avail = clear+2;
   oldcode = -1;

   len = 0;
   for(;;) {
      if (valid_bits < codesize) {
         if (len == 0) {
            len = stbi__get8(s); // start new block
            if (len == 0)
               return g->out;
         }
         --len;
         bits |= (stbi__int32) stbi__get8(s) << valid_bits;
         valid_bits += 8;
      } else {
         stbi__int32 code = bits & codemask;
         bits >>= codesize;
         valid_bits -= codesize;
         // @OPTIMIZE: is there some way we can accelerate the non-clear path?
         if (code == clear) {  // clear code
            codesize = lzw_cs + 1;
            codemask = (1 << codesize) - 1;
            avail = clear + 2;
            oldcode = -1;
            first = 0;
         } else if (code == clear + 1) { // end of stream code
            stbi__skip(s, len);
            while ((len = stbi__get8(s)) > 0)
               stbi__skip(s,len);
            return g->out;
         } else if (code <= avail) {
            if (first) {
               return stbi__errpuc(""no clear code"", ""Corrupt GIF"");
            }

            if (oldcode >= 0) {
               p = &g->codes[avail++];
               if (avail > 8192) {
                  return stbi__errpuc(""too many codes"", ""Corrupt GIF"");
               }

               p->prefix = (stbi__int16) oldcode;
               p->first = g->codes[oldcode].first;
               p->suffix = (code == avail) ? p->first : g->codes[code].first;
            } else if (code == avail)
               return stbi__errpuc(""illegal code in raster"", ""Corrupt GIF"");

            stbi__out_gif_code(g, (stbi__uint16) code);

            if ((avail & codemask) == 0 && avail <= 0x0FFF) {
               codesize++;
               codemask = (1 << codesize) - 1;
            }

            oldcode = code;
         } else {
            return stbi__errpuc(""illegal code in raster"", ""Corrupt GIF"");
         }
      }
   }
}","{'begin': {'line': 6691, 'column': 1}, 'end': {'line': 6774, 'column': 2}}",show_image.c,"['解码', 'GIF', '的', 'LZW', '压缩', '数据', '，', '生成', '图像', '输出']"
816,816,stbi__psd_is16,int,int stbi__psd_is16(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",检查PSD文件是否为16位深度,"static int stbi__psd_is16(stbi__context *s)
{
   int channelCount, depth;
   if (stbi__get32be(s) != 0x38425053) {
       stbi__rewind( s );
       return 0;
   }
   if (stbi__get16be(s) != 1) {
       stbi__rewind( s );
       return 0;
   }
   stbi__skip(s, 6);
   channelCount = stbi__get16be(s);
   if (channelCount < 0 || channelCount > 16) {
       stbi__rewind( s );
       return 0;
   }
   STBI_NOTUSED(stbi__get32be(s));
   STBI_NOTUSED(stbi__get32be(s));
   depth = stbi__get16be(s);
   if (depth != 16) {
       stbi__rewind( s );
       return 0;
   }
   return 1;
}","{'begin': {'line': 7394, 'column': 1}, 'end': {'line': 7419, 'column': 2}}",show_image.c,"['检查', 'PSD', '文件', '是否', '为', '16', '位', '深度']"
817,817,stbi__pic_info,int,"int stbi__pic_info(stbi__context * s, int * x, int * y, int * comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",解析PIC图片信息，获取尺寸和通道数,"static int stbi__pic_info(stbi__context *s, int *x, int *y, int *comp)
{
   int act_comp=0,num_packets=0,chained,dummy;
   stbi__pic_packet packets[10];

   if (!x) x = &dummy;
   if (!y) y = &dummy;
   if (!comp) comp = &dummy;

   if (!stbi__pic_is4(s,""\x53\x80\xF6\x34"")) {
      stbi__rewind(s);
      return 0;
   }

   stbi__skip(s, 88);

   *x = stbi__get16be(s);
   *y = stbi__get16be(s);
   if (stbi__at_eof(s)) {
      stbi__rewind( s);
      return 0;
   }
   if ( (*x) != 0 && (1 << 28) / (*x) < (*y)) {
      stbi__rewind( s );
      return 0;
   }

   stbi__skip(s, 8);

   do {
      stbi__pic_packet *packet;

      if (num_packets==sizeof(packets)/sizeof(packets[0]))
         return 0;

      packet = &packets[num_packets++];
      chained = stbi__get8(s);
      packet->size    = stbi__get8(s);
      packet->type    = stbi__get8(s);
      packet->channel = stbi__get8(s);
      act_comp |= packet->channel;

      if (stbi__at_eof(s)) {
          stbi__rewind( s );
          return 0;
      }
      if (packet->size != 8) {
          stbi__rewind( s );
          return 0;
      }
   } while (chained);

   *comp = (act_comp & 0x10 ? 4 : 3);

   return 1;
}","{'begin': {'line': 7423, 'column': 1}, 'end': {'line': 7478, 'column': 2}}",show_image.c,"['解析', 'PIC', '图片', '信息', '，', '获取', '尺寸', '和', '通道', '数']"
818,818,stbi__gif_load_next,stbi_uc *,"stbi_uc * stbi__gif_load_next(stbi__context * s, stbi__gif * g, int * comp, int req_comp, stbi_uc * two_back)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'g', 'type': 'stbi__gif *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'two_back', 'type': 'stbi_uc *'}]",逐帧加载GIF图像，处理透明背景和帧恢复,"static stbi_uc *stbi__gif_load_next(stbi__context *s, stbi__gif *g, int *comp, int req_comp, stbi_uc *two_back)
{
   int dispose;
   int first_frame;
   int pi;
   int pcount;
   STBI_NOTUSED(req_comp);

   // on first frame, any non-written pixels get the background colour (non-transparent)
   first_frame = 0;
   if (g->out == 0) {
      if (!stbi__gif_header(s, g, comp,0)) return 0; // stbi__g_failure_reason set by stbi__gif_header
      if (!stbi__mad3sizes_valid(4, g->w, g->h, 0))
         return stbi__errpuc(""too large"", ""GIF image is too large"");
      pcount = g->w * g->h;
      g->out = (stbi_uc *) stbi__malloc(4 * pcount);
      g->background = (stbi_uc *) stbi__malloc(4 * pcount);
      g->history = (stbi_uc *) stbi__malloc(pcount);
      if (!g->out || !g->background || !g->history)
         return stbi__errpuc(""outofmem"", ""Out of memory"");

      // image is treated as ""transparent"" at the start - ie, nothing overwrites the current background;
      // background colour is only used for pixels that are not rendered first frame, after that ""background""
      // color refers to the color that was there the previous frame.
      memset(g->out, 0x00, 4 * pcount);
      memset(g->background, 0x00, 4 * pcount); // state of the background (starts transparent)
      memset(g->history, 0x00, pcount);        // pixels that were affected previous frame
      first_frame = 1;
   } else {
      // second frame - how do we dispose of the previous one?
      dispose = (g->eflags & 0x1C) >> 2;
      pcount = g->w * g->h;

      if ((dispose == 3) && (two_back == 0)) {
         dispose = 2; // if I don't have an image to revert back to, default to the old background
      }

      if (dispose == 3) { // use previous graphic
         for (pi = 0; pi < pcount; ++pi) {
            if (g->history[pi]) {
               memcpy( &g->out[pi * 4], &two_back[pi * 4], 4 );
            }
         }
      } else if (dispose == 2) {
         // restore what was changed last frame to background before that frame;
         for (pi = 0; pi < pcount; ++pi) {
            if (g->history[pi]) {
               memcpy( &g->out[pi * 4], &g->background[pi * 4], 4 );
            }
         }
      } else {
         // This is a non-disposal case eithe way, so just
         // leave the pixels as is, and they will become the new background
         // 1: do not dispose
         // 0:  not specified.
      }

      // background is what out is after the undoing of the previou frame;
      memcpy( g->background, g->out, 4 * g->w * g->h );
   }

   // clear my history;
   memset( g->history, 0x00, g->w * g->h );        // pixels that were affected previous frame

   for (;;) {
      int tag = stbi__get8(s);
      switch (tag) {
         case 0x2C: /* Image Descriptor */
         {
            stbi__int32 x, y, w, h;
            stbi_uc *o;

            x = stbi__get16le(s);
            y = stbi__get16le(s);
            w = stbi__get16le(s);
            h = stbi__get16le(s);
            if (((x + w) > (g->w)) || ((y + h) > (g->h)))
               return stbi__errpuc(""bad Image Descriptor"", ""Corrupt GIF"");

            g->line_size = g->w * 4;
            g->start_x = x * 4;
            g->start_y = y * g->line_size;
            g->max_x   = g->start_x + w * 4;
            g->max_y   = g->start_y + h * g->line_size;
            g->cur_x   = g->start_x;
            g->cur_y   = g->start_y;

            // if the width of the specified rectangle is 0, that means
            // we may not see *any* pixels or the image is malformed;
            // to make sure this is caught, move the current y down to
            // max_y (which is what out_gif_code checks).
            if (w == 0)
               g->cur_y = g->max_y;

            g->lflags = stbi__get8(s);

            if (g->lflags & 0x40) {
               g->step = 8 * g->line_size; // first interlaced spacing
               g->parse = 3;
            } else {
               g->step = g->line_size;
               g->parse = 0;
            }

            if (g->lflags & 0x80) {
               stbi__gif_parse_colortable(s,g->lpal, 2 << (g->lflags & 7), g->eflags & 0x01 ? g->transparent : -1);
               g->color_table = (stbi_uc *) g->lpal;
            } else if (g->flags & 0x80) {
               g->color_table = (stbi_uc *) g->pal;
            } else
               return stbi__errpuc(""missing color table"", ""Corrupt GIF"");

            o = stbi__process_gif_raster(s, g);
            if (!o) return NULL;

            // if this was the first frame,
            pcount = g->w * g->h;
            if (first_frame && (g->bgindex > 0)) {
               // if first frame, any pixel not drawn to gets the background color
               for (pi = 0; pi < pcount; ++pi) {
                  if (g->history[pi] == 0) {
                     g->pal[g->bgindex][3] = 255; // just in case it was made transparent, undo that; It will be reset next frame if need be;
                     memcpy( &g->out[pi * 4], &g->pal[g->bgindex], 4 );
                  }
               }
            }

            return o;
         }

         case 0x21: // Comment Extension.
         {
            int len;
            int ext = stbi__get8(s);
            if (ext == 0xF9) { // Graphic Control Extension.
               len = stbi__get8(s);
               if (len == 4) {
                  g->eflags = stbi__get8(s);
                  g->delay = 10 * stbi__get16le(s); // delay - 1/100th of a second, saving as 1/1000ths.

                  // unset old transparent
                  if (g->transparent >= 0) {
                     g->pal[g->transparent][3] = 255;
                  }
                  if (g->eflags & 0x01) {
                     g->transparent = stbi__get8(s);
                     if (g->transparent >= 0) {
                        g->pal[g->transparent][3] = 0;
                     }
                  } else {
                     // don't need transparent
                     stbi__skip(s, 1);
                     g->transparent = -1;
                  }
               } else {
                  stbi__skip(s, len);
                  break;
               }
            }
            while ((len = stbi__get8(s)) != 0) {
               stbi__skip(s, len);
            }
            break;
         }

         case 0x3B: // gif stream termination code
            return (stbi_uc *) s; // using '1' causes warning on some compilers

         default:
            return stbi__errpuc(""unknown code"", ""Corrupt GIF"");
      }
   }
}","{'begin': {'line': 6778, 'column': 1}, 'end': {'line': 6950, 'column': 2}}",show_image.c,"['逐帧', '加载', 'GIF', '图像', '，', '处理', '透明', '背景', '和', '帧', '恢复']"
819,819,stbi__pnm_test,int,int stbi__pnm_test(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",检测输入流是否为PNM格式,"static int      stbi__pnm_test(stbi__context *s)
{
   char p, t;
   p = (char) stbi__get8(s);
   t = (char) stbi__get8(s);
   if (p != 'P' || (t != '5' && t != '6')) {
       stbi__rewind( s );
       return 0;
   }
   return 1;
}","{'begin': {'line': 7494, 'column': 1}, 'end': {'line': 7504, 'column': 2}}",show_image.c,"['检测', '输入', '流', '是否', '为', 'PNM', '格式']"
820,820,stbi__pnm_load,void *,"void * stbi__pnm_load(stbi__context * s, int * x, int * y, int * comp, int req_comp, stbi__result_info * ri)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'ri', 'type': 'stbi__result_info *'}]",加载并处理PNM图像数据，支持通道转换和尺寸验证,"static void *stbi__pnm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   stbi_uc *out;
   STBI_NOTUSED(ri);

   ri->bits_per_channel = stbi__pnm_info(s, (int *)&s->img_x, (int *)&s->img_y, (int *)&s->img_n);
   if (ri->bits_per_channel == 0)
      return 0;

   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc(""too large"",""Very large image (corrupt?)"");
   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc(""too large"",""Very large image (corrupt?)"");

   *x = s->img_x;
   *y = s->img_y;
   if (comp) *comp = s->img_n;

   if (!stbi__mad4sizes_valid(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0))
      return stbi__errpuc(""too large"", ""PNM too large"");

   out = (stbi_uc *) stbi__malloc_mad4(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0);
   if (!out) return stbi__errpuc(""outofmem"", ""Out of memory"");
   if (!stbi__getn(s, out, s->img_n * s->img_x * s->img_y * (ri->bits_per_channel / 8))) {
      STBI_FREE(out);
      return stbi__errpuc(""bad PNM"", ""PNM file truncated"");
   }

   if (req_comp && req_comp != s->img_n) {
      if (ri->bits_per_channel == 16) {
         out = (stbi_uc *) stbi__convert_format16((stbi__uint16 *) out, s->img_n, req_comp, s->img_x, s->img_y);
      } else {
         out = stbi__convert_format(out, s->img_n, req_comp, s->img_x, s->img_y);
      }
      if (out == NULL) return out; // stbi__convert_format frees input on failure
   }
   return out;
}","{'begin': {'line': 7506, 'column': 1}, 'end': {'line': 7541, 'column': 2}}",show_image.c,"['加载', '并', '处理', 'PNM', '图像', '数据', '，', '支持', '通道', '转换', '和', '尺寸', '验证']"
821,821,stbi__pnm_isspace,int,int stbi__pnm_isspace(char c),"[{'name': 'c', 'type': 'char'}]",检查字符是否为空白字符（空格、制表符等）,"static int      stbi__pnm_isspace(char c)
{
   return c == ' ' || c == '\t' || c == '\n' || c == '\v' || c == '\f' || c == '\r';
}","{'begin': {'line': 7543, 'column': 1}, 'end': {'line': 7546, 'column': 2}}",show_image.c,"['检查', '字符', '是否', '为', '空白', '字符', '（', '空格', '、', '制表', '制表符', '等', '）']"
822,822,stbi__pnm_skip_whitespace,void,"void stbi__pnm_skip_whitespace(stbi__context * s, char * c)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'c', 'type': 'char *'}]",跳过PNM文件中的空白和注释,"static void     stbi__pnm_skip_whitespace(stbi__context *s, char *c)
{
   for (;;) {
      while (!stbi__at_eof(s) && stbi__pnm_isspace(*c))
         *c = (char) stbi__get8(s);

      if (stbi__at_eof(s) || *c != '#')
         break;

      while (!stbi__at_eof(s) && *c != '\n' && *c != '\r' )
         *c = (char) stbi__get8(s);
   }
}","{'begin': {'line': 7548, 'column': 1}, 'end': {'line': 7560, 'column': 2}}",show_image.c,"['跳过', 'PNM', '文件', '中', '的', '空白', '和', '注释']"
823,823,stbi__pnm_isdigit,int,int stbi__pnm_isdigit(char c),"[{'name': 'c', 'type': 'char'}]",检查字符是否为数字字符,"static int      stbi__pnm_isdigit(char c)
{
   return c >= '0' && c <= '9';
}","{'begin': {'line': 7562, 'column': 1}, 'end': {'line': 7565, 'column': 2}}",show_image.c,"['检查', '字符', '是否', '为', '数字', '字符']"
824,824,stbi__pnm_getinteger,int,"int stbi__pnm_getinteger(stbi__context * s, char * c)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'c', 'type': 'char *'}]",解析PNM头部整数并处理溢出,"static int      stbi__pnm_getinteger(stbi__context *s, char *c)
{
   int value = 0;

   while (!stbi__at_eof(s) && stbi__pnm_isdigit(*c)) {
      value = value*10 + (*c - '0');
      *c = (char) stbi__get8(s);
      if((value > 214748364) || (value == 214748364 && *c > '7'))
          return stbi__err(""integer parse overflow"", ""Parsing an integer in the PPM header overflowed a 32-bit int"");
   }

   return value;
}","{'begin': {'line': 7567, 'column': 1}, 'end': {'line': 7579, 'column': 2}}",show_image.c,"['解析', 'PNM', '头部', '整数', '并', '处理', '溢出']"
825,825,stbi__load_gif_main_outofmem,void *,"void * stbi__load_gif_main_outofmem(stbi__gif * g, stbi_uc * out, int ** delays)","[{'name': 'g', 'type': 'stbi__gif *'}, {'name': 'out', 'type': 'stbi_uc *'}, {'name': 'delays', 'type': 'int **'}]",内存不足时释放资源并返回错误信息,"static void *stbi__load_gif_main_outofmem(stbi__gif *g, stbi_uc *out, int **delays)
{
   STBI_FREE(g->out);
   STBI_FREE(g->history);
   STBI_FREE(g->background);

   if (out) STBI_FREE(out);
   if (delays && *delays) STBI_FREE(*delays);
   return stbi__errpuc(""outofmem"", ""Out of memory"");
}","{'begin': {'line': 6952, 'column': 1}, 'end': {'line': 6961, 'column': 2}}",show_image.c,"['内存', '不足', '内存不足', '时', '释放', '资源', '并', '返回', '错误', '误信', '信息', '错误信息']"
826,826,stbi__pnm_info,int,"int stbi__pnm_info(stbi__context * s, int * x, int * y, int * comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",解析PNM图像头信息，获取宽高、通道数及位深。,"static int      stbi__pnm_info(stbi__context *s, int *x, int *y, int *comp)
{
   int maxv, dummy;
   char c, p, t;

   if (!x) x = &dummy;
   if (!y) y = &dummy;
   if (!comp) comp = &dummy;

   stbi__rewind(s);

   // Get identifier
   p = (char) stbi__get8(s);
   t = (char) stbi__get8(s);
   if (p != 'P' || (t != '5' && t != '6')) {
       stbi__rewind(s);
       return 0;
   }

   *comp = (t == '6') ? 3 : 1;  // '5' is 1-component .pgm; '6' is 3-component .ppm

   c = (char) stbi__get8(s);
   stbi__pnm_skip_whitespace(s, &c);

   *x = stbi__pnm_getinteger(s, &c); // read width
   if(*x == 0)
       return stbi__err(""invalid width"", ""PPM image header had zero or overflowing width"");
   stbi__pnm_skip_whitespace(s, &c);

   *y = stbi__pnm_getinteger(s, &c); // read height
   if (*y == 0)
       return stbi__err(""invalid width"", ""PPM image header had zero or overflowing width"");
   stbi__pnm_skip_whitespace(s, &c);

   maxv = stbi__pnm_getinteger(s, &c);  // read max value
   if (maxv > 65535)
      return stbi__err(""max value > 65535"", ""PPM image supports only 8-bit and 16-bit images"");
   else if (maxv > 255)
      return 16;
   else
      return 8;
}","{'begin': {'line': 7581, 'column': 1}, 'end': {'line': 7622, 'column': 2}}",show_image.c,"['解析', 'PNM', '图像', '头', '信息', '，', '获取', '宽高', '、', '通道', '数及', '位深', '。']"
827,827,stbi__load_gif_main,void *,"void * stbi__load_gif_main(stbi__context * s, int ** delays, int * x, int * y, int * z, int * comp, int req_comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'delays', 'type': 'int **'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'z', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}]",加载GIF图像数据，支持多帧和延迟时间。,"static void *stbi__load_gif_main(stbi__context *s, int **delays, int *x, int *y, int *z, int *comp, int req_comp)
{
   if (stbi__gif_test(s)) {
      int layers = 0;
      stbi_uc *u = 0;
      stbi_uc *out = 0;
      stbi_uc *two_back = 0;
      stbi__gif g;
      int stride;
      int out_size = 0;
      int delays_size = 0;

      STBI_NOTUSED(out_size);
      STBI_NOTUSED(delays_size);

      memset(&g, 0, sizeof(g));
      if (delays) {
         *delays = 0;
      }

      do {
         u = stbi__gif_load_next(s, &g, comp, req_comp, two_back);
         if (u == (stbi_uc *) s) u = 0;  // end of animated gif marker

         if (u) {
            *x = g.w;
            *y = g.h;
            ++layers;
            stride = g.w * g.h * 4;

            if (out) {
               void *tmp = (stbi_uc*) STBI_REALLOC_SIZED( out, out_size, layers * stride );
               if (!tmp)
                  return stbi__load_gif_main_outofmem(&g, out, delays);
               else {
                   out = (stbi_uc*) tmp;
                   out_size = layers * stride;
               }

               if (delays) {
                  int *new_delays = (int*) STBI_REALLOC_SIZED( *delays, delays_size, sizeof(int) * layers );
                  if (!new_delays)
                     return stbi__load_gif_main_outofmem(&g, out, delays);
                  *delays = new_delays;
                  delays_size = layers * sizeof(int);
               }
            } else {
               out = (stbi_uc*)stbi__malloc( layers * stride );
               if (!out)
                  return stbi__load_gif_main_outofmem(&g, out, delays);
               out_size = layers * stride;
               if (delays) {
                  *delays = (int*) stbi__malloc( layers * sizeof(int) );
                  if (!*delays)
                     return stbi__load_gif_main_outofmem(&g, out, delays);
                  delays_size = layers * sizeof(int);
               }
            }
            memcpy( out + ((layers - 1) * stride), u, stride );
            if (layers >= 2) {
               two_back = out - 2 * stride;
            }

            if (delays) {
               (*delays)[layers - 1U] = g.delay;
            }
         }
      } while (u != 0);

      // free temp buffer;
      STBI_FREE(g.out);
      STBI_FREE(g.history);
      STBI_FREE(g.background);

      // do the final conversion after loading everything;
      if (req_comp && req_comp != 4)
         out = stbi__convert_format(out, 4, req_comp, layers * g.w, g.h);

      *z = layers;
      return out;
   } else {
      return stbi__errpuc(""not GIF"", ""Image was not as a gif type."");
   }
}","{'begin': {'line': 6963, 'column': 1}, 'end': {'line': 7046, 'column': 2}}",show_image.c,"['加载', 'GIF', '图像', '数据', '，', '支持', '多', '帧', '和', '延迟', '时间', '延迟时间', '。']"
828,828,stbi__pnm_is16,int,int stbi__pnm_is16(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",检查PNM图像是否为16位格式,"static int stbi__pnm_is16(stbi__context *s)
{
   if (stbi__pnm_info(s, NULL, NULL, NULL) == 16)
	   return 1;
   return 0;
}","{'begin': {'line': 7624, 'column': 1}, 'end': {'line': 7629, 'column': 2}}",show_image.c,"['检查', 'PNM', '图像', '是否', '为', '16', '位', '格式']"
829,829,stbi__info_main,int,"int stbi__info_main(stbi__context * s, int * x, int * y, int * comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",检测图像类型并返回尺寸和通道信息,"static int stbi__info_main(stbi__context *s, int *x, int *y, int *comp)
{
   #ifndef STBI_NO_JPEG
   if (stbi__jpeg_info(s, x, y, comp)) return 1;
   #endif

   #ifndef STBI_NO_PNG
   if (stbi__png_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_GIF
   if (stbi__gif_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_BMP
   if (stbi__bmp_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_PSD
   if (stbi__psd_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_PIC
   if (stbi__pic_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_PNM
   if (stbi__pnm_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_HDR
   if (stbi__hdr_info(s, x, y, comp))  return 1;
   #endif

   // test tga last because it's a crappy test!
   #ifndef STBI_NO_TGA
   if (stbi__tga_info(s, x, y, comp))
       return 1;
   #endif
   return stbi__err(""unknown image type"", ""Image not of any known type, or corrupt"");
}","{'begin': {'line': 7632, 'column': 1}, 'end': {'line': 7672, 'column': 2}}",show_image.c,"['检测', '图像', '类型', '并', '返回', '尺寸', '和', '通道', '信息']"
830,830,stbi__is_16_main,int,int stbi__is_16_main(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",检查图像是否为16位格式,"static int stbi__is_16_main(stbi__context *s)
{
   #ifndef STBI_NO_PNG
   if (stbi__png_is16(s))  return 1;
   #endif

   #ifndef STBI_NO_PSD
   if (stbi__psd_is16(s))  return 1;
   #endif

   #ifndef STBI_NO_PNM
   if (stbi__pnm_is16(s))  return 1;
   #endif
   return 0;
}","{'begin': {'line': 7674, 'column': 1}, 'end': {'line': 7688, 'column': 2}}",show_image.c,"['检查', '图像', '是否', '为', '16', '位', '格式']"
831,831,stbi_info,int,"int stbi_info(const char * filename, int * x, int * y, int * comp)","[{'name': 'filename', 'type': 'const char *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",获取图像文件信息（尺寸和通道数）,"STBIDEF int stbi_info(char const *filename, int *x, int *y, int *comp)
{
    FILE *f = stbi__fopen(filename, ""rb"");
    int result;
    if (!f) return stbi__err(""can't fopen"", ""Unable to open file"");
    result = stbi_info_from_file(f, x, y, comp);
    fclose(f);
    return result;
}","{'begin': {'line': 7691, 'column': 1}, 'end': {'line': 7699, 'column': 2}}",show_image.c,"['获取', '图像', '文件', '图像文件', '信息', '（', '尺寸', '和', '通道', '数', '）']"
832,832,stbi__gif_load,void *,"void * stbi__gif_load(stbi__context * s, int * x, int * y, int * comp, int req_comp, stbi__result_info * ri)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'ri', 'type': 'stbi__result_info *'}]",加载GIF图像数据，返回解码后的像素指针,"static void *stbi__gif_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   stbi_uc *u = 0;
   stbi__gif g;
   memset(&g, 0, sizeof(g));
   STBI_NOTUSED(ri);

   u = stbi__gif_load_next(s, &g, comp, req_comp, 0);
   if (u == (stbi_uc *) s) u = 0;  // end of animated gif marker
   if (u) {
      *x = g.w;
      *y = g.h;

      // moved conversion to after successful load so that the same
      // can be done for multiple frames.
      if (req_comp && req_comp != 4)
         u = stbi__convert_format(u, 4, req_comp, g.w, g.h);
   } else if (g.out) {
      // if there was an error and we allocated an image buffer, free it!
      STBI_FREE(g.out);
   }

   // free buffers needed for multiple frame loading;
   STBI_FREE(g.history);
   STBI_FREE(g.background);

   return u;
}","{'begin': {'line': 7048, 'column': 1}, 'end': {'line': 7075, 'column': 2}}",show_image.c,"['加载', 'GIF', '图像', '数据', '，', '返回', '解码', '后', '的', '像素', '指针']"
833,833,stbi_info_from_file,int,"int stbi_info_from_file(FILE * f, int * x, int * y, int * comp)","[{'name': 'f', 'type': 'FILE *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",获取图像文件信息并保持文件指针位置,"STBIDEF int stbi_info_from_file(FILE *f, int *x, int *y, int *comp)
{
   int r;
   stbi__context s;
   long pos = ftell(f);
   stbi__start_file(&s, f);
   r = stbi__info_main(&s,x,y,comp);
   fseek(f,pos,SEEK_SET);
   return r;
}","{'begin': {'line': 7701, 'column': 1}, 'end': {'line': 7710, 'column': 2}}",show_image.c,"['获取', '图像', '文件', '图像文件', '信息', '并', '保持', '文件', '指针', '位置']"
834,834,stbi_is_16_bit,int,int stbi_is_16_bit(const char * filename),"[{'name': 'filename', 'type': 'const char *'}]",检查文件是否为16位图像,"STBIDEF int stbi_is_16_bit(char const *filename)
{
    FILE *f = stbi__fopen(filename, ""rb"");
    int result;
    if (!f) return stbi__err(""can't fopen"", ""Unable to open file"");
    result = stbi_is_16_bit_from_file(f);
    fclose(f);
    return result;
}","{'begin': {'line': 7712, 'column': 1}, 'end': {'line': 7720, 'column': 2}}",show_image.c,"['检查', '文件', '是否', '为', '16', '位', '图像']"
835,835,stbi_is_16_bit_from_file,int,int stbi_is_16_bit_from_file(FILE * f),"[{'name': 'f', 'type': 'FILE *'}]",检测文件是否为16位格式，不改变文件指针位置,"STBIDEF int stbi_is_16_bit_from_file(FILE *f)
{
   int r;
   stbi__context s;
   long pos = ftell(f);
   stbi__start_file(&s, f);
   r = stbi__is_16_main(&s);
   fseek(f,pos,SEEK_SET);
   return r;
}","{'begin': {'line': 7722, 'column': 1}, 'end': {'line': 7731, 'column': 2}}",show_image.c,"['检测', '文件', '是否', '为', '16', '位', '格式', '，', '不', '改变', '文件', '指针', '位置']"
836,836,stbi__gif_info,int,"int stbi__gif_info(stbi__context * s, int * x, int * y, int * comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",获取GIF图像的尺寸和通道信息,"static int stbi__gif_info(stbi__context *s, int *x, int *y, int *comp)
{
   return stbi__gif_info_raw(s,x,y,comp);
}","{'begin': {'line': 7077, 'column': 1}, 'end': {'line': 7080, 'column': 2}}",show_image.c,"['获取', 'GIF', '图像', '的', '尺寸', '和', '通道', '信息']"
837,837,stbi__hdr_test_core,int,"int stbi__hdr_test_core(stbi__context * s, const char * signature)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'signature', 'type': 'const char *'}]",检测输入流是否以指定签名开头,"static int stbi__hdr_test_core(stbi__context *s, const char *signature)
{
   int i;
   for (i=0; signature[i]; ++i)
      if (stbi__get8(s) != signature[i])
          return 0;
   stbi__rewind(s);
   return 1;
}","{'begin': {'line': 7087, 'column': 1}, 'end': {'line': 7095, 'column': 2}}",show_image.c,"['检测', '输入', '流', '是否', '以', '指定', '签名', '开头']"
838,838,stbi_info_from_memory,int,"int stbi_info_from_memory(const stbi_uc * buffer, int len, int * x, int * y, int * comp)","[{'name': 'buffer', 'type': 'const stbi_uc *'}, {'name': 'len', 'type': 'int'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",从内存读取图像信息（尺寸、通道数）,"STBIDEF int stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__info_main(&s,x,y,comp);
}","{'begin': {'line': 7734, 'column': 1}, 'end': {'line': 7739, 'column': 2}}",show_image.c,"['从', '内存', '读取', '图像', '信息', '（', '尺寸', '、', '通道', '数', '）']"
839,839,stbi__hdr_test,int,int stbi__hdr_test(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",测试HDR文件格式，检查RADIANCE或RGBE标识。,"static int stbi__hdr_test(stbi__context* s)
{
   int r = stbi__hdr_test_core(s, ""#?RADIANCE\n"");
   stbi__rewind(s);
   if(!r) {
       r = stbi__hdr_test_core(s, ""#?RGBE\n"");
       stbi__rewind(s);
   }
   return r;
}","{'begin': {'line': 7097, 'column': 1}, 'end': {'line': 7106, 'column': 2}}",show_image.c,"['测试', 'HDR', '文件', '格式', '文件格式', '，', '检查', 'RADIANCE', '或', 'RGBE', '标识', '。']"
840,840,stbi_info_from_callbacks,int,"int stbi_info_from_callbacks(const stbi_io_callbacks * c, void * user, int * x, int * y, int * comp)","[{'name': 'c', 'type': 'const stbi_io_callbacks *'}, {'name': 'user', 'type': 'void *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",通过回调获取图像尺寸和通道数,"STBIDEF int stbi_info_from_callbacks(stbi_io_callbacks const *c, void *user, int *x, int *y, int *comp)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) c, user);
   return stbi__info_main(&s,x,y,comp);
}","{'begin': {'line': 7741, 'column': 1}, 'end': {'line': 7746, 'column': 2}}",show_image.c,"['通过', '回调', '获取', '图像', '尺寸', '和', '通道', '数']"
841,841,stbi__hdr_gettoken,char *,"char * stbi__hdr_gettoken(stbi__context * z, char * buffer)","[{'name': 'z', 'type': 'stbi__context *'}, {'name': 'buffer', 'type': 'char *'}]",读取HDR文件中的一行数据到缓冲区,"static char *stbi__hdr_gettoken(stbi__context *z, char *buffer)
{
   int len=0;
   char c = '\0';

   c = (char) stbi__get8(z);

   while (!stbi__at_eof(z) && c != '\n') {
      buffer[len++] = c;
      if (len == STBI__HDR_BUFLEN-1) {
         // flush to end of line
         while (!stbi__at_eof(z) && stbi__get8(z) != '\n')
            ;
         break;
      }
      c = (char) stbi__get8(z);
   }

   buffer[len] = 0;
   return buffer;
}","{'begin': {'line': 7109, 'column': 1}, 'end': {'line': 7129, 'column': 2}}",show_image.c,"['读取', 'HDR', '文件', '中', '的', '一行', '数据', '到', '缓冲', '缓冲区']"
842,842,stbi_is_16_bit_from_memory,int,"int stbi_is_16_bit_from_memory(const stbi_uc * buffer, int len)","[{'name': 'buffer', 'type': 'const stbi_uc *'}, {'name': 'len', 'type': 'int'}]",检测内存缓冲区中的图像是否为16位,"STBIDEF int stbi_is_16_bit_from_memory(stbi_uc const *buffer, int len)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__is_16_main(&s);
}","{'begin': {'line': 7748, 'column': 1}, 'end': {'line': 7753, 'column': 2}}",show_image.c,"['检测', '内存', '缓冲', '缓冲区', '中', '的', '图像', '是否', '为', '16', '位']"
843,843,stbi__hdr_convert,void,"void stbi__hdr_convert(float * output, stbi_uc * input, int req_comp)","[{'name': 'output', 'type': 'float *'}, {'name': 'input', 'type': 'stbi_uc *'}, {'name': 'req_comp', 'type': 'int'}]",将HDR图像数据转换为指定通道的浮点格式。,"static void stbi__hdr_convert(float *output, stbi_uc *input, int req_comp)
{
   if ( input[3] != 0 ) {
      float f1;
      // Exponent
      f1 = (float) ldexp(1.0f, input[3] - (int)(128 + 8));
      if (req_comp <= 2)
         output[0] = (input[0] + input[1] + input[2]) * f1 / 3;
      else {
         output[0] = input[0] * f1;
         output[1] = input[1] * f1;
         output[2] = input[2] * f1;
      }
      if (req_comp == 2) output[1] = 1;
      if (req_comp == 4) output[3] = 1;
   } else {
      switch (req_comp) {
         case 4: output[3] = 1; /* fallthrough */
         case 3: output[0] = output[1] = output[2] = 0;
                 break;
         case 2: output[1] = 1; /* fallthrough */
         case 1: output[0] = 0;
                 break;
      }
   }
}","{'begin': {'line': 7131, 'column': 1}, 'end': {'line': 7156, 'column': 2}}",show_image.c,"['将', 'HDR', '图像', '数据', '转换', '为', '指定', '通道', '的', '浮点', '格式', '。']"
844,844,stbi_is_16_bit_from_callbacks,int,"int stbi_is_16_bit_from_callbacks(const stbi_io_callbacks * c, void * user)","[{'name': 'c', 'type': 'const stbi_io_callbacks *'}, {'name': 'user', 'type': 'void *'}]",通过回调函数检查图像是否为16位,"STBIDEF int stbi_is_16_bit_from_callbacks(stbi_io_callbacks const *c, void *user)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) c, user);
   return stbi__is_16_main(&s);
}","{'begin': {'line': 7755, 'column': 1}, 'end': {'line': 7760, 'column': 2}}",show_image.c,"['通过', '回调', '函数', '检查', '图像', '是否', '为', '16', '位']"
845,845,stbi__hdr_load,float *,"float * stbi__hdr_load(stbi__context * s, int * x, int * y, int * comp, int req_comp, stbi__result_info * ri)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'ri', 'type': 'stbi__result_info *'}]",加载并解码HDR图像数据，返回浮点数组,"static float *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   char buffer[STBI__HDR_BUFLEN];
   char *token;
   int valid = 0;
   int width, height;
   stbi_uc *scanline;
   float *hdr_data;
   int len;
   unsigned char count, value;
   int i, j, k, c1,c2, z;
   const char *headerToken;
   STBI_NOTUSED(ri);

   // Check identifier
   headerToken = stbi__hdr_gettoken(s,buffer);
   if (strcmp(headerToken, ""#?RADIANCE"") != 0 && strcmp(headerToken, ""#?RGBE"") != 0)
      return stbi__errpf(""not HDR"", ""Corrupt HDR image"");

   // Parse header
   for(;;) {
      token = stbi__hdr_gettoken(s,buffer);
      if (token[0] == 0) break;
      if (strcmp(token, ""FORMAT=32-bit_rle_rgbe"") == 0) valid = 1;
   }

   if (!valid)    return stbi__errpf(""unsupported format"", ""Unsupported HDR format"");

   // Parse width and height
   // can't use sscanf() if we're not using stdio!
   token = stbi__hdr_gettoken(s,buffer);
   if (strncmp(token, ""-Y "", 3))  return stbi__errpf(""unsupported data layout"", ""Unsupported HDR format"");
   token += 3;
   height = (int) strtol(token, &token, 10);
   while (*token == ' ') ++token;
   if (strncmp(token, ""+X "", 3))  return stbi__errpf(""unsupported data layout"", ""Unsupported HDR format"");
   token += 3;
   width = (int) strtol(token, NULL, 10);

   if (height > STBI_MAX_DIMENSIONS) return stbi__errpf(""too large"",""Very large image (corrupt?)"");
   if (width > STBI_MAX_DIMENSIONS) return stbi__errpf(""too large"",""Very large image (corrupt?)"");

   *x = width;
   *y = height;

   if (comp) *comp = 3;
   if (req_comp == 0) req_comp = 3;

   if (!stbi__mad4sizes_valid(width, height, req_comp, sizeof(float), 0))
      return stbi__errpf(""too large"", ""HDR image is too large"");

   // Read data
   hdr_data = (float *) stbi__malloc_mad4(width, height, req_comp, sizeof(float), 0);
   if (!hdr_data)
      return stbi__errpf(""outofmem"", ""Out of memory"");

   // Load image data
   // image data is stored as some number of sca
   if ( width < 8 || width >= 32768) {
      // Read flat data
      for (j=0; j < height; ++j) {
         for (i=0; i < width; ++i) {
            stbi_uc rgbe[4];
           main_decode_loop:
            stbi__getn(s, rgbe, 4);
            stbi__hdr_convert(hdr_data + j * width * req_comp + i * req_comp, rgbe, req_comp);
         }
      }
   } else {
      // Read RLE-encoded data
      scanline = NULL;

      for (j = 0; j < height; ++j) {
         c1 = stbi__get8(s);
         c2 = stbi__get8(s);
         len = stbi__get8(s);
         if (c1 != 2 || c2 != 2 || (len & 0x80)) {
            // not run-length encoded, so we have to actually use THIS data as a decoded
            // pixel (note this can't be a valid pixel--one of RGB must be >= 128)
            stbi_uc rgbe[4];
            rgbe[0] = (stbi_uc) c1;
            rgbe[1] = (stbi_uc) c2;
            rgbe[2] = (stbi_uc) len;
            rgbe[3] = (stbi_uc) stbi__get8(s);
            stbi__hdr_convert(hdr_data, rgbe, req_comp);
            i = 1;
            j = 0;
            STBI_FREE(scanline);
            goto main_decode_loop; // yes, this makes no sense
         }
         len <<= 8;
         len |= stbi__get8(s);
         if (len != width) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(""invalid decoded scanline length"", ""corrupt HDR""); }
         if (scanline == NULL) {
            scanline = (stbi_uc *) stbi__malloc_mad2(width, 4, 0);
            if (!scanline) {
               STBI_FREE(hdr_data);
               return stbi__errpf(""outofmem"", ""Out of memory"");
            }
         }

         for (k = 0; k < 4; ++k) {
            int nleft;
            i = 0;
            while ((nleft = width - i) > 0) {
               count = stbi__get8(s);
               if (count > 128) {
                  // Run
                  value = stbi__get8(s);
                  count -= 128;
                  if ((count == 0) || (count > nleft)) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(""corrupt"", ""bad RLE data in HDR""); }
                  for (z = 0; z < count; ++z)
                     scanline[i++ * 4 + k] = value;
               } else {
                  // Dump
                  if ((count == 0) || (count > nleft)) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(""corrupt"", ""bad RLE data in HDR""); }
                  for (z = 0; z < count; ++z)
                     scanline[i++ * 4 + k] = stbi__get8(s);
               }
            }
         }
         for (i=0; i < width; ++i)
            stbi__hdr_convert(hdr_data+(j*width + i)*req_comp, scanline + i*4, req_comp);
      }
      if (scanline)
         STBI_FREE(scanline);
   }

   return hdr_data;
}","{'begin': {'line': 7158, 'column': 1}, 'end': {'line': 7287, 'column': 2}}",show_image.c,"['加载', '并', '解码', 'HDR', '图像', '数据', '，', '返回', '浮点', '数组']"
846,846,stbi__hdr_info,int,"int stbi__hdr_info(stbi__context * s, int * x, int * y, int * comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",解析HDR图像头信息，获取尺寸和通道数,"static int stbi__hdr_info(stbi__context *s, int *x, int *y, int *comp)
{
   char buffer[STBI__HDR_BUFLEN];
   char *token;
   int valid = 0;
   int dummy;

   if (!x) x = &dummy;
   if (!y) y = &dummy;
   if (!comp) comp = &dummy;

   if (stbi__hdr_test(s) == 0) {
       stbi__rewind( s );
       return 0;
   }

   for(;;) {
      token = stbi__hdr_gettoken(s,buffer);
      if (token[0] == 0) break;
      if (strcmp(token, ""FORMAT=32-bit_rle_rgbe"") == 0) valid = 1;
   }

   if (!valid) {
       stbi__rewind( s );
       return 0;
   }
   token = stbi__hdr_gettoken(s,buffer);
   if (strncmp(token, ""-Y "", 3)) {
       stbi__rewind( s );
       return 0;
   }
   token += 3;
   *y = (int) strtol(token, &token, 10);
   while (*token == ' ') ++token;
   if (strncmp(token, ""+X "", 3)) {
       stbi__rewind( s );
       return 0;
   }
   token += 3;
   *x = (int) strtol(token, NULL, 10);
   *comp = 3;
   return 1;
}","{'begin': {'line': 7289, 'column': 1}, 'end': {'line': 7331, 'column': 2}}",show_image.c,"['解析', 'HDR', '图像', '头', '信息', '，', '获取', '尺寸', '和', '通道', '数']"
847,847,stbi__bmp_info,int,"int stbi__bmp_info(stbi__context * s, int * x, int * y, int * comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",解析BMP图像头信息，获取宽高和通道数,"static int stbi__bmp_info(stbi__context *s, int *x, int *y, int *comp)
{
   void *p;
   stbi__bmp_data info;

   info.all_a = 255;
   p = stbi__bmp_parse_header(s, &info);
   if (p == NULL) {
      stbi__rewind( s );
      return 0;
   }
   if (x) *x = s->img_x;
   if (y) *y = s->img_y;
   if (comp) {
      if (info.bpp == 24 && info.ma == 0xff000000)
         *comp = 3;
      else
         *comp = info.ma ? 4 : 3;
   }
   return 1;
}","{'begin': {'line': 7335, 'column': 1}, 'end': {'line': 7355, 'column': 2}}",show_image.c,"['解析', 'BMP', '图像', '头', '信息', '，', '获取', '宽高', '和', '通道', '数']"
848,848,stbi__psd_info,int,"int stbi__psd_info(stbi__context * s, int * x, int * y, int * comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",解析PSD文件头信息，获取宽高及通道数,"static int stbi__psd_info(stbi__context *s, int *x, int *y, int *comp)
{
   int channelCount, dummy, depth;
   if (!x) x = &dummy;
   if (!y) y = &dummy;
   if (!comp) comp = &dummy;
   if (stbi__get32be(s) != 0x38425053) {
       stbi__rewind( s );
       return 0;
   }
   if (stbi__get16be(s) != 1) {
       stbi__rewind( s );
       return 0;
   }
   stbi__skip(s, 6);
   channelCount = stbi__get16be(s);
   if (channelCount < 0 || channelCount > 16) {
       stbi__rewind( s );
       return 0;
   }
   *y = stbi__get32be(s);
   *x = stbi__get32be(s);
   depth = stbi__get16be(s);
   if (depth != 8 && depth != 16) {
       stbi__rewind( s );
       return 0;
   }
   if (stbi__get16be(s) != 3) {
       stbi__rewind( s );
       return 0;
   }
   *comp = 4;
   return 1;
}","{'begin': {'line': 7359, 'column': 1}, 'end': {'line': 7392, 'column': 2}}",show_image.c,"['解析', 'PSD', '文件', '头', '信息', '，', '获取', '宽高及', '通道', '数']"
849,849,stbi__psd_is16,int,int stbi__psd_is16(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",检查PSD图像是否为16位深度,"static int stbi__psd_is16(stbi__context *s)
{
   int channelCount, depth;
   if (stbi__get32be(s) != 0x38425053) {
       stbi__rewind( s );
       return 0;
   }
   if (stbi__get16be(s) != 1) {
       stbi__rewind( s );
       return 0;
   }
   stbi__skip(s, 6);
   channelCount = stbi__get16be(s);
   if (channelCount < 0 || channelCount > 16) {
       stbi__rewind( s );
       return 0;
   }
   STBI_NOTUSED(stbi__get32be(s));
   STBI_NOTUSED(stbi__get32be(s));
   depth = stbi__get16be(s);
   if (depth != 16) {
       stbi__rewind( s );
       return 0;
   }
   return 1;
}","{'begin': {'line': 7394, 'column': 1}, 'end': {'line': 7419, 'column': 2}}",show_image.c,"['检查', 'PSD', '图像', '是否', '为', '16', '位', '深度']"
850,850,stbi__pic_info,int,"int stbi__pic_info(stbi__context * s, int * x, int * y, int * comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",解析PIC图片信息，获取宽高及通道数,"static int stbi__pic_info(stbi__context *s, int *x, int *y, int *comp)
{
   int act_comp=0,num_packets=0,chained,dummy;
   stbi__pic_packet packets[10];

   if (!x) x = &dummy;
   if (!y) y = &dummy;
   if (!comp) comp = &dummy;

   if (!stbi__pic_is4(s,""\x53\x80\xF6\x34"")) {
      stbi__rewind(s);
      return 0;
   }

   stbi__skip(s, 88);

   *x = stbi__get16be(s);
   *y = stbi__get16be(s);
   if (stbi__at_eof(s)) {
      stbi__rewind( s);
      return 0;
   }
   if ( (*x) != 0 && (1 << 28) / (*x) < (*y)) {
      stbi__rewind( s );
      return 0;
   }

   stbi__skip(s, 8);

   do {
      stbi__pic_packet *packet;

      if (num_packets==sizeof(packets)/sizeof(packets[0]))
         return 0;

      packet = &packets[num_packets++];
      chained = stbi__get8(s);
      packet->size    = stbi__get8(s);
      packet->type    = stbi__get8(s);
      packet->channel = stbi__get8(s);
      act_comp |= packet->channel;

      if (stbi__at_eof(s)) {
          stbi__rewind( s );
          return 0;
      }
      if (packet->size != 8) {
          stbi__rewind( s );
          return 0;
      }
   } while (chained);

   *comp = (act_comp & 0x10 ? 4 : 3);

   return 1;
}","{'begin': {'line': 7423, 'column': 1}, 'end': {'line': 7478, 'column': 2}}",show_image.c,"['解析', 'PIC', '图片', '信息', '，', '获取', '宽高及', '通道', '数']"
851,851,stbi__pnm_test,int,int stbi__pnm_test(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",检查输入是否为PNM格式文件,"static int      stbi__pnm_test(stbi__context *s)
{
   char p, t;
   p = (char) stbi__get8(s);
   t = (char) stbi__get8(s);
   if (p != 'P' || (t != '5' && t != '6')) {
       stbi__rewind( s );
       return 0;
   }
   return 1;
}","{'begin': {'line': 7494, 'column': 1}, 'end': {'line': 7504, 'column': 2}}",show_image.c,"['检查', '输入', '是否', '为', 'PNM', '格式', '文件', '格式文件']"
852,852,stbi__pnm_load,void *,"void * stbi__pnm_load(stbi__context * s, int * x, int * y, int * comp, int req_comp, stbi__result_info * ri)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}, {'name': 'req_comp', 'type': 'int'}, {'name': 'ri', 'type': 'stbi__result_info *'}]",加载并转换PNM图像数据，处理尺寸及通道数,"static void *stbi__pnm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   stbi_uc *out;
   STBI_NOTUSED(ri);

   ri->bits_per_channel = stbi__pnm_info(s, (int *)&s->img_x, (int *)&s->img_y, (int *)&s->img_n);
   if (ri->bits_per_channel == 0)
      return 0;

   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc(""too large"",""Very large image (corrupt?)"");
   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc(""too large"",""Very large image (corrupt?)"");

   *x = s->img_x;
   *y = s->img_y;
   if (comp) *comp = s->img_n;

   if (!stbi__mad4sizes_valid(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0))
      return stbi__errpuc(""too large"", ""PNM too large"");

   out = (stbi_uc *) stbi__malloc_mad4(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0);
   if (!out) return stbi__errpuc(""outofmem"", ""Out of memory"");
   if (!stbi__getn(s, out, s->img_n * s->img_x * s->img_y * (ri->bits_per_channel / 8))) {
      STBI_FREE(out);
      return stbi__errpuc(""bad PNM"", ""PNM file truncated"");
   }

   if (req_comp && req_comp != s->img_n) {
      if (ri->bits_per_channel == 16) {
         out = (stbi_uc *) stbi__convert_format16((stbi__uint16 *) out, s->img_n, req_comp, s->img_x, s->img_y);
      } else {
         out = stbi__convert_format(out, s->img_n, req_comp, s->img_x, s->img_y);
      }
      if (out == NULL) return out; // stbi__convert_format frees input on failure
   }
   return out;
}","{'begin': {'line': 7506, 'column': 1}, 'end': {'line': 7541, 'column': 2}}",show_image.c,"['加载', '并', '转换', 'PNM', '图像', '数据', '，', '处理', '尺寸', '及', '通道', '数']"
853,853,stbi__pnm_isspace,int,int stbi__pnm_isspace(char c),"[{'name': 'c', 'type': 'char'}]",判断字符是否为空白字符,"static int      stbi__pnm_isspace(char c)
{
   return c == ' ' || c == '\t' || c == '\n' || c == '\v' || c == '\f' || c == '\r';
}","{'begin': {'line': 7543, 'column': 1}, 'end': {'line': 7546, 'column': 2}}",show_image.c,"['判断', '字符', '是否', '为', '空白', '字符']"
854,854,stbi__pnm_skip_whitespace,void,"void stbi__pnm_skip_whitespace(stbi__context * s, char * c)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'c', 'type': 'char *'}]",跳过PNM文件中的空白和注释,"static void     stbi__pnm_skip_whitespace(stbi__context *s, char *c)
{
   for (;;) {
      while (!stbi__at_eof(s) && stbi__pnm_isspace(*c))
         *c = (char) stbi__get8(s);

      if (stbi__at_eof(s) || *c != '#')
         break;

      while (!stbi__at_eof(s) && *c != '\n' && *c != '\r' )
         *c = (char) stbi__get8(s);
   }
}","{'begin': {'line': 7548, 'column': 1}, 'end': {'line': 7560, 'column': 2}}",show_image.c,"['跳过', 'PNM', '文件', '中', '的', '空白', '和', '注释']"
855,855,stbi__pnm_isdigit,int,int stbi__pnm_isdigit(char c),"[{'name': 'c', 'type': 'char'}]",检查字符是否为数字字符。,"static int      stbi__pnm_isdigit(char c)
{
   return c >= '0' && c <= '9';
}","{'begin': {'line': 7562, 'column': 1}, 'end': {'line': 7565, 'column': 2}}",show_image.c,"['检查', '字符', '是否', '为', '数字', '字符', '。']"
856,856,stbi__pnm_getinteger,int,"int stbi__pnm_getinteger(stbi__context * s, char * c)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'c', 'type': 'char *'}]",解析PNM格式中的整数并检查32位溢出,"static int      stbi__pnm_getinteger(stbi__context *s, char *c)
{
   int value = 0;

   while (!stbi__at_eof(s) && stbi__pnm_isdigit(*c)) {
      value = value*10 + (*c - '0');
      *c = (char) stbi__get8(s);
      if((value > 214748364) || (value == 214748364 && *c > '7'))
          return stbi__err(""integer parse overflow"", ""Parsing an integer in the PPM header overflowed a 32-bit int"");
   }

   return value;
}","{'begin': {'line': 7567, 'column': 1}, 'end': {'line': 7579, 'column': 2}}",show_image.c,"['解析', 'PNM', '格式', '中', '的', '整数', '并', '检查', '32', '位', '溢出']"
857,857,stbi__pnm_info,int,"int stbi__pnm_info(stbi__context * s, int * x, int * y, int * comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",解析PNM图像头部信息，获取宽高、通道及位深,"static int      stbi__pnm_info(stbi__context *s, int *x, int *y, int *comp)
{
   int maxv, dummy;
   char c, p, t;

   if (!x) x = &dummy;
   if (!y) y = &dummy;
   if (!comp) comp = &dummy;

   stbi__rewind(s);

   // Get identifier
   p = (char) stbi__get8(s);
   t = (char) stbi__get8(s);
   if (p != 'P' || (t != '5' && t != '6')) {
       stbi__rewind(s);
       return 0;
   }

   *comp = (t == '6') ? 3 : 1;  // '5' is 1-component .pgm; '6' is 3-component .ppm

   c = (char) stbi__get8(s);
   stbi__pnm_skip_whitespace(s, &c);

   *x = stbi__pnm_getinteger(s, &c); // read width
   if(*x == 0)
       return stbi__err(""invalid width"", ""PPM image header had zero or overflowing width"");
   stbi__pnm_skip_whitespace(s, &c);

   *y = stbi__pnm_getinteger(s, &c); // read height
   if (*y == 0)
       return stbi__err(""invalid width"", ""PPM image header had zero or overflowing width"");
   stbi__pnm_skip_whitespace(s, &c);

   maxv = stbi__pnm_getinteger(s, &c);  // read max value
   if (maxv > 65535)
      return stbi__err(""max value > 65535"", ""PPM image supports only 8-bit and 16-bit images"");
   else if (maxv > 255)
      return 16;
   else
      return 8;
}","{'begin': {'line': 7581, 'column': 1}, 'end': {'line': 7622, 'column': 2}}",show_image.c,"['解析', 'PNM', '图像', '头部', '信息', '，', '获取', '宽高', '、', '通道', '及位', '深']"
858,858,stbi__pnm_is16,int,int stbi__pnm_is16(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",检查PNM图像是否为16位格式,"static int stbi__pnm_is16(stbi__context *s)
{
   if (stbi__pnm_info(s, NULL, NULL, NULL) == 16)
	   return 1;
   return 0;
}","{'begin': {'line': 7624, 'column': 1}, 'end': {'line': 7629, 'column': 2}}",show_image.c,"['检查', 'PNM', '图像', '是否', '为', '16', '位', '格式']"
859,859,stbi__info_main,int,"int stbi__info_main(stbi__context * s, int * x, int * y, int * comp)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",检测图像格式并获取宽高及通道信息,"static int stbi__info_main(stbi__context *s, int *x, int *y, int *comp)
{
   #ifndef STBI_NO_JPEG
   if (stbi__jpeg_info(s, x, y, comp)) return 1;
   #endif

   #ifndef STBI_NO_PNG
   if (stbi__png_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_GIF
   if (stbi__gif_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_BMP
   if (stbi__bmp_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_PSD
   if (stbi__psd_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_PIC
   if (stbi__pic_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_PNM
   if (stbi__pnm_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_HDR
   if (stbi__hdr_info(s, x, y, comp))  return 1;
   #endif

   // test tga last because it's a crappy test!
   #ifndef STBI_NO_TGA
   if (stbi__tga_info(s, x, y, comp))
       return 1;
   #endif
   return stbi__err(""unknown image type"", ""Image not of any known type, or corrupt"");
}","{'begin': {'line': 7632, 'column': 1}, 'end': {'line': 7672, 'column': 2}}",show_image.c,"['检测', '图像', '格式', '图像格式', '并', '获取', '宽高及', '通道', '信息']"
860,860,stbi__is_16_main,int,int stbi__is_16_main(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",检测图像是否为16位格式,"static int stbi__is_16_main(stbi__context *s)
{
   #ifndef STBI_NO_PNG
   if (stbi__png_is16(s))  return 1;
   #endif

   #ifndef STBI_NO_PSD
   if (stbi__psd_is16(s))  return 1;
   #endif

   #ifndef STBI_NO_PNM
   if (stbi__pnm_is16(s))  return 1;
   #endif
   return 0;
}","{'begin': {'line': 7674, 'column': 1}, 'end': {'line': 7688, 'column': 2}}",show_image.c,"['检测', '图像', '是否', '为', '16', '位', '格式']"
861,861,stbi_info,int,"int stbi_info(const char * filename, int * x, int * y, int * comp)","[{'name': 'filename', 'type': 'const char *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",获取图像文件信息（宽、高、通道数）,"STBIDEF int stbi_info(char const *filename, int *x, int *y, int *comp)
{
    FILE *f = stbi__fopen(filename, ""rb"");
    int result;
    if (!f) return stbi__err(""can't fopen"", ""Unable to open file"");
    result = stbi_info_from_file(f, x, y, comp);
    fclose(f);
    return result;
}","{'begin': {'line': 7691, 'column': 1}, 'end': {'line': 7699, 'column': 2}}",show_image.c,"['获取', '图像', '文件', '图像文件', '信息', '（', '宽', '、', '高', '、', '通道', '数', '）']"
862,862,stbi_info_from_file,int,"int stbi_info_from_file(FILE * f, int * x, int * y, int * comp)","[{'name': 'f', 'type': 'FILE *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",从文件获取图像信息，不移动文件指针,"STBIDEF int stbi_info_from_file(FILE *f, int *x, int *y, int *comp)
{
   int r;
   stbi__context s;
   long pos = ftell(f);
   stbi__start_file(&s, f);
   r = stbi__info_main(&s,x,y,comp);
   fseek(f,pos,SEEK_SET);
   return r;
}","{'begin': {'line': 7701, 'column': 1}, 'end': {'line': 7710, 'column': 2}}",show_image.c,"['文件', '从文件', '获取', '图像', '信息', '，', '不', '移动', '文件', '指针']"
863,863,stbi_is_16_bit,int,int stbi_is_16_bit(const char * filename),"[{'name': 'filename', 'type': 'const char *'}]",检查指定文件是否为16位图像格式,"STBIDEF int stbi_is_16_bit(char const *filename)
{
    FILE *f = stbi__fopen(filename, ""rb"");
    int result;
    if (!f) return stbi__err(""can't fopen"", ""Unable to open file"");
    result = stbi_is_16_bit_from_file(f);
    fclose(f);
    return result;
}","{'begin': {'line': 7712, 'column': 1}, 'end': {'line': 7720, 'column': 2}}",show_image.c,"['检查', '指定', '文件', '是否', '为', '16', '位', '图像', '格式', '图像格式']"
864,864,stbi_is_16_bit_from_file,int,int stbi_is_16_bit_from_file(FILE * f),"[{'name': 'f', 'type': 'FILE *'}]",检查文件是否为16位图像，保持文件位置不变。,"STBIDEF int stbi_is_16_bit_from_file(FILE *f)
{
   int r;
   stbi__context s;
   long pos = ftell(f);
   stbi__start_file(&s, f);
   r = stbi__is_16_main(&s);
   fseek(f,pos,SEEK_SET);
   return r;
}","{'begin': {'line': 7722, 'column': 1}, 'end': {'line': 7731, 'column': 2}}",show_image.c,"['检查', '文件', '是否', '为', '16', '位', '图像', '，', '保持', '文件', '位置', '不变', '。']"
865,865,stbi_info_from_memory,int,"int stbi_info_from_memory(const stbi_uc * buffer, int len, int * x, int * y, int * comp)","[{'name': 'buffer', 'type': 'const stbi_uc *'}, {'name': 'len', 'type': 'int'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",从内存读取图像信息，获取宽高和通道数,"STBIDEF int stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__info_main(&s,x,y,comp);
}","{'begin': {'line': 7734, 'column': 1}, 'end': {'line': 7739, 'column': 2}}",show_image.c,"['从', '内存', '读取', '图像', '信息', '，', '获取', '宽高', '和', '通道', '数']"
866,866,stbi_info_from_callbacks,int,"int stbi_info_from_callbacks(const stbi_io_callbacks * c, void * user, int * x, int * y, int * comp)","[{'name': 'c', 'type': 'const stbi_io_callbacks *'}, {'name': 'user', 'type': 'void *'}, {'name': 'x', 'type': 'int *'}, {'name': 'y', 'type': 'int *'}, {'name': 'comp', 'type': 'int *'}]",通过回调获取图像尺寸和通道数,"STBIDEF int stbi_info_from_callbacks(stbi_io_callbacks const *c, void *user, int *x, int *y, int *comp)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) c, user);
   return stbi__info_main(&s,x,y,comp);
}","{'begin': {'line': 7741, 'column': 1}, 'end': {'line': 7746, 'column': 2}}",show_image.c,"['通过', '回调', '获取', '图像', '尺寸', '和', '通道', '数']"
867,867,stbi_is_16_bit_from_memory,int,"int stbi_is_16_bit_from_memory(const stbi_uc * buffer, int len)","[{'name': 'buffer', 'type': 'const stbi_uc *'}, {'name': 'len', 'type': 'int'}]",检查内存中的图像是否为16位格式,"STBIDEF int stbi_is_16_bit_from_memory(stbi_uc const *buffer, int len)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__is_16_main(&s);
}","{'begin': {'line': 7748, 'column': 1}, 'end': {'line': 7753, 'column': 2}}",show_image.c,"['检查', '内存', '中', '的', '图像', '是否', '为', '16', '位', '格式']"
868,868,stbi_is_16_bit_from_callbacks,int,"int stbi_is_16_bit_from_callbacks(const stbi_io_callbacks * c, void * user)","[{'name': 'c', 'type': 'const stbi_io_callbacks *'}, {'name': 'user', 'type': 'void *'}]",通过回调检测图像是否为16位格式,"STBIDEF int stbi_is_16_bit_from_callbacks(stbi_io_callbacks const *c, void *user)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) c, user);
   return stbi__is_16_main(&s);
}","{'begin': {'line': 7755, 'column': 1}, 'end': {'line': 7760, 'column': 2}}",show_image.c,"['通过', '回调', '检测', '图像', '是否', '为', '16', '位', '格式']"
869,869,stbi__sse2_available,int,int stbi__sse2_available(),[],检测SSE2指令集是否可用，返回1表示支持,"static int stbi__sse2_available(void)
{
   // If we're even attempting to compile this on GCC/Clang, that means
   // -msse2 is on, which means the compiler is allowed to use SSE2
   // instructions at will, and so are we.
   return 1;
}","{'begin': {'line': 765, 'column': 1}, 'end': {'line': 771, 'column': 2}}",stb_image.h,"['检测', 'SSE2', '指令', '指令集', '是否', '可用', '，', '返回', '1', '表示', '支持']"
870,870,stbi__start_mem,void,"void stbi__start_mem(stbi__context * s, const stbi_uc * buffer, int len)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'buffer', 'type': 'const stbi_uc *'}, {'name': 'len', 'type': 'int'}]",初始化内存读取上下文，配置缓冲区和终止位置指针,"static void stbi__start_mem(stbi__context *s, stbi_uc const *buffer, int len)
{
   s->io.read = NULL;
   s->read_from_callbacks = 0;
   s->callback_already_read = 0;
   s->img_buffer = s->img_buffer_original = (stbi_uc *) buffer;
   s->img_buffer_end = s->img_buffer_original_end = (stbi_uc *) buffer+len;
}","{'begin': {'line': 826, 'column': 1}, 'end': {'line': 833, 'column': 2}}",stb_image.h,"['初始', '初始化', '内存', '读取', '上下', '下文', '上下文', '，', '配置', '缓冲', '缓冲区', '和', '终止', '位置', '指针']"
871,871,stbi__start_callbacks,void,"void stbi__start_callbacks(stbi__context * s, stbi_io_callbacks * c, void * user)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'c', 'type': 'stbi_io_callbacks *'}, {'name': 'user', 'type': 'void *'}]",初始化图像读取回调并填充缓冲区,"static void stbi__start_callbacks(stbi__context *s, stbi_io_callbacks *c, void *user)
{
   s->io = *c;
   s->io_user_data = user;
   s->buflen = sizeof(s->buffer_start);
   s->read_from_callbacks = 1;
   s->callback_already_read = 0;
   s->img_buffer = s->img_buffer_original = s->buffer_start;
   stbi__refill_buffer(s);
   s->img_buffer_original_end = s->img_buffer_end;
}","{'begin': {'line': 836, 'column': 1}, 'end': {'line': 846, 'column': 2}}",stb_image.h,"['初始', '初始化', '图像', '读取', '回调', '并', '填充', '缓冲', '缓冲区']"
872,872,stbi__stdio_read,int,"int stbi__stdio_read(void * user, char * data, int size)","[{'name': 'user', 'type': 'void *'}, {'name': 'data', 'type': 'char *'}, {'name': 'size', 'type': 'int'}]",使用fread从文件指针读取数据,"static int stbi__stdio_read(void *user, char *data, int size)
{
   return (int) fread(data,1,size,(FILE*) user);
}","{'begin': {'line': 850, 'column': 1}, 'end': {'line': 853, 'column': 2}}",stb_image.h,"['使用', 'fread', '文件', '从文件', '指针', '读取', '数据', '读取数据']"
873,873,stbi__stdio_skip,void,"void stbi__stdio_skip(void * user, int n)","[{'name': 'user', 'type': 'void *'}, {'name': 'n', 'type': 'int'}]",跳过文件流的n字节并重置EOF标志,"static void stbi__stdio_skip(void *user, int n)
{
   int ch;
   fseek((FILE*) user, n, SEEK_CUR);
   ch = fgetc((FILE*) user);  /* have to read a byte to reset feof()'s flag */
   if (ch != EOF) {
      ungetc(ch, (FILE *) user);  /* push byte back onto stream if valid. */
   }
}","{'begin': {'line': 855, 'column': 1}, 'end': {'line': 863, 'column': 2}}",stb_image.h,"['跳过', '文件', '流', '的', 'n', '字节', '并', '重置', 'EOF', '标志']"
874,874,stbi__stdio_eof,int,int stbi__stdio_eof(void * user),"[{'name': 'user', 'type': 'void *'}]",检查文件流是否结束或出错,"static int stbi__stdio_eof(void *user)
{
   return feof((FILE*) user) || ferror((FILE *) user);
}","{'begin': {'line': 865, 'column': 1}, 'end': {'line': 868, 'column': 2}}",stb_image.h,"['检查', '文件', '流', '是否', '结束', '或', '出错']"
875,875,stbi__start_file,void,"void stbi__start_file(stbi__context * s, FILE * f)","[{'name': 's', 'type': 'stbi__context *'}, {'name': 'f', 'type': 'FILE *'}]",使用标准I/O回调初始化文件读取上下文,"static void stbi__start_file(stbi__context *s, FILE *f)
{
   stbi__start_callbacks(s, &stbi__stdio_callbacks, (void *) f);
}","{'begin': {'line': 877, 'column': 1}, 'end': {'line': 880, 'column': 2}}",stb_image.h,"['使用', '标准', 'I', '/', 'O', '回调', '初始', '初始化', '文件', '读取', '上下', '下文', '上下文']"
876,876,stbi__rewind,void,void stbi__rewind(stbi__context * s),"[{'name': 's', 'type': 'stbi__context *'}]",重置图像缓冲区到初始位置,"static void stbi__rewind(stbi__context *s)
{
   // conceptually rewind SHOULD rewind to the beginning of the stream,
   // but we just rewind to the beginning of the initial buffer, because
   // we only use it after doing 'test', which only ever looks at at most 92 bytes
   s->img_buffer = s->img_buffer_original;
   s->img_buffer_end = s->img_buffer_original_end;
}","{'begin': {'line': 886, 'column': 1}, 'end': {'line': 893, 'column': 2}}",stb_image.h,"['重置', '图像', '缓冲', '缓冲区', '到', '初始', '位置']"
877,877,stbi_failure_reason,const char *,const char * stbi_failure_reason(),[],返回最近图像处理失败的错误原因,"STBIDEF const char *stbi_failure_reason(void)
{
   return stbi__g_failure_reason;
}","{'begin': {'line': 972, 'column': 1}, 'end': {'line': 975, 'column': 2}}",stb_image.h,"['返回', '最近', '图像', '处理', '图像处理', '失败', '的', '错误', '原因']"
878,878,stbi__err,int,int stbi__err(const char * str),"[{'name': 'str', 'type': 'const char *'}]",设置错误描述信息并返回状态码0,"static int stbi__err(const char *str)
{
   stbi__g_failure_reason = str;
   return 0;
}","{'begin': {'line': 978, 'column': 1}, 'end': {'line': 982, 'column': 2}}",stb_image.h,"['设置', '错误', '描述', '信息', '并', '返回', '状态', '码', '0']"
