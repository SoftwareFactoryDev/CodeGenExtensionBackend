,Unnamed: 0.1,Unnamed: 0,name,return_type,signature,params,summary,source_code,extent,file_path,sum_tokenize
0,0,0,inte_fix_filter,void,"void inte_fix_filter(float dT, int * data)","[{'name': 'dT', 'type': 'float'}, {'name': 'data', 'type': 'int *'}]",根据数据点数量和限制值，调整数据点的输出和误差估计。,"void inte_fix_filter(float dT,_inte_fix_filter_st *data)
{
	float ei_lim_val;
	
	if(data->ei_limit>0)
	{		
		ei_lim_val = LIMIT(data->ei,-data->ei_limit,data->ei_limit);
	}
	else
	{
		ei_lim_val = data->ei;
	}	
	
	data->out = (data->in_est + ei_lim_val);
	
	data->e = data->fix_ki *(data->in_obs - data->out);

	data->ei += data->e *dT;

}","{'begin': {'line': 9, 'column': 1}, 'end': {'line': 28, 'column': 2}}",startup_msp432e401y_ewarm.c,"['根据', '数据', '点', '数量', '和', '限制', '值', '，', '调整', '数据', '点', '的', '输出', '和', '误差', '估计', '。']"
1,1,1,fix_inte_filter,void,"void fix_inte_filter(float dT, int * data)","[{'name': 'dT', 'type': 'float'}, {'name': 'data', 'type': 'int *'}]",根据输入的dT和data数组，更新data数组中的out和e值，并对e进行限制处理。,"void fix_inte_filter(float dT,_fix_inte_filter_st *data)
{
	
	data->out += (data->in_est_d + data->e ) *dT;
	
	data->e = data->fix_kp *(data->in_obs - data->out);

	if(data->e_limit>0)
	{		
		data->e = LIMIT(data->e,-data->e_limit,data->e_limit);
	}
	
}","{'begin': {'line': 30, 'column': 1}, 'end': {'line': 42, 'column': 2}}",startup_msp432e401y_ewarm.c,"['根据', '输入', '的', 'dT', '和', 'data', '数组', '，', '更新', 'data', '数组', '中', '的', 'out', '和', 'e', '值', '，', '并', '对', 'e', '进行', '限制', '处理', '。']"
2,2,2,limit_filter,void,"void limit_filter(float T, float hz, int * data, float in)","[{'name': 'T', 'type': 'float'}, {'name': 'hz', 'type': 'float'}, {'name': 'data', 'type': 'int *'}, {'name': 'in', 'type': 'float'}]",对输入数据进行增量滤波，适合大噪声低滞后场景，收敛快,"void limit_filter(float T,float hz,_lf_t *data,float in) //增量滤波，适合大噪声低滞后（无缝），收敛最快
{
	float abs_t;
// 	LPF_1(hz,T,	 in,&(data->lpf_1)); 
// 	abs_t = ABS(data->lpf_1);
// 	data->out = LIMIT(in,-abs_t,abs_t);
	LPF_1_(hz,T,	 in,(data->lpf_1)); 
 	abs_t = ABS(in);
	data->out = LIMIT((data->lpf_1),-abs_t,abs_t);
}","{'begin': {'line': 44, 'column': 1}, 'end': {'line': 53, 'column': 2}}",startup_msp432e401y_ewarm.c,"['对', '输入', '数据', '进行', '增量', '滤波', '，', '适合', '大', '噪声', '低', '滞后', '场景', '，', '收敛', '快']"
3,3,3,limit_filter_2,void,"void limit_filter_2(float T, float hz, int * data, float in)","[{'name': 'T', 'type': 'float'}, {'name': 'hz', 'type': 'float'}, {'name': 'data', 'type': 'int *'}, {'name': 'in', 'type': 'float'}]",对输入信号进行增量滤波和均衡处理，但存在一定的滞后。,"void limit_filter_2(float T,float hz,_lf_t *data,float in) //增量滤波，均衡，但滞后稍大(数据反向等待低通反向)
{
	float abs_t;
	LPF_1_(hz,T,	 in,(data->lpf_1)); 
	abs_t = ABS(data->lpf_1);
	data->out = LIMIT(in,-abs_t,abs_t);
// 	LPF_1(hz,T,	 in,&(data->lpf_1)); 
//  	abs_t = ABS(in);
// 	data->out = LIMIT((data->lpf_1),-abs_t,abs_t);
}","{'begin': {'line': 55, 'column': 1}, 'end': {'line': 64, 'column': 2}}",startup_msp432e401y_ewarm.c,"['对', '输入', '信号', '进行', '增量', '滤波', '和', '均衡', '处理', '，', '但', '存在', '一定', '的', '滞后', '。']"
4,4,4,limit_filter_3,void,"void limit_filter_3(float T, float hz, int * data, float in)","[{'name': 'T', 'type': 'float'}, {'name': 'hz', 'type': 'float'}, {'name': 'data', 'type': 'int *'}, {'name': 'in', 'type': 'float'}]",增量滤波函数，用于处理低噪声、小滞后情况，或噪声大但收敛速度较慢的情况。,"void limit_filter_3(float T,float hz,_lf_t *data,float in) //增量滤波，适合低噪声滞后较小(等幅大噪声平行不收敛),噪声大收敛过慢
{
	float abs_t;
	LPF_1_(hz,T,	 in,(data->lpf_1)); 
	abs_t = ABS(in);
	data->out = data->lpf_1 = LIMIT((data->lpf_1),-abs_t,abs_t);

}","{'begin': {'line': 66, 'column': 1}, 'end': {'line': 73, 'column': 2}}",startup_msp432e401y_ewarm.c,"['增量', '滤波', '函数', '，', '用于', '处理', '噪声', '低噪声', '、', '小', '滞后', '情况', '，', '或', '噪声', '大', '但', '收敛', '速度', '较慢', '的', '情况', '。']"
5,5,5,steepest_descend,void,"void steepest_descend(int[] arr, int len, int * steepest, int step_num, int in)","[{'name': 'arr', 'type': 'int[]'}, {'name': 'len', 'type': 'int'}, {'name': 'steepest', 'type': 'int *'}, {'name': 'step_num', 'type': 'int'}, {'name': 'in', 'type': 'int'}]",根据数组arr和步数step_num计算最陡下降路径，并更新最陡值和当前位置。,"void steepest_descend(s32 arr[],u8 len,_steepest_st *steepest,u8 step_num,s32 in)
{	
	u8 updw = 1;//0 dw,1up
	s16 i;
	u8 step_cnt=0;
	u8 step_slope_factor=1;
	u8 on = 1;
	s8 pn = 1;
	//float last = 0;
	float step = 0;
	s32 start_point = 0;
	s32 pow_sum = 0;
	
	steepest->lst_out = steepest->now_out;
	
	if( ++(steepest->cnt) >= len )	
	{
		(steepest->cnt) = 0; //now
	}
	
	//last = arr[ (steepest->cnt) ];
	
	arr[ (steepest->cnt) ] = in;
	
	step = (float)(in - steepest->lst_out)/step_num ;//梯度
	
	if(ABS(step)<1)//整形数据<1的有效判定
	{
		if(ABS(step)*step_num<2)
		{
			step = 0;
		}
		else
		{
		  step = (step > 0) ? 1 : -1;
		}
	}
	
	start_point = steepest->lst_out;
	do
	{
		//start_point = steepest->lst_out;
		for(i=0;i<len;i++)
		{
// 			j = steepest->cnt + i + 1;
// 			if( j >= len )	
// 			{
// 				j = j - len; //顺序排列
// 			}
			pow_sum += my_pow(arr[i] - start_point );// /step_num;//除法减小比例**
			
			//start_point += pn *(step_slope_factor *step/len);
		}
			
		if(pow_sum - steepest->lst_pow_sum > 0)
		{		
			if(updw==0)
			{
				on = 0;
			}
			updw = 1;//上升了
			pn = (pn == 1 )? -1:1;

		}
		else
		{
			updw = 0; //正在下降
 			if(step_slope_factor<step_num)
 			{
 				step_slope_factor++;
 			}
		}
			
		steepest->lst_pow_sum = pow_sum;		
		pow_sum = 0;
		start_point += pn *step;//调整
		
		if(++step_cnt > step_num)//限制计算次数
		{
			on = 0;
		}
			//////
			if(step_slope_factor>=2)//限制下降次数1次，节省时间，但会增大滞后，若cpu时间充裕可不用。
			{
				on = 0;

			}
			//////
		
	}
	while(on==1);
	
	steepest->now_out = start_point ;//0.5f *(start_point + steepest->lst_out);//
	
	steepest->now_velocity_xdt = steepest->now_out - steepest->lst_out;
}","{'begin': {'line': 78, 'column': 1}, 'end': {'line': 173, 'column': 2}}",startup_msp432e401y_ewarm.c,"['根据', '数组', 'arr', '和', '步数', 'step', '_', 'num', '计算', '最', '陡', '下降', '路径', '，', '并', '更新', '最', '陡值', '和', '当前', '位置', '。']"
6,6,6,fir_arrange_filter,void,"void fir_arrange_filter(float * arr, int len, int * fil_cnt, float in, float * arr_out)","[{'name': 'arr', 'type': 'float *'}, {'name': 'len', 'type': 'int'}, {'name': 'fil_cnt', 'type': 'int *'}, {'name': 'in', 'type': 'float'}, {'name': 'arr_out', 'type': 'float *'}]",对输入数组进行滤波和重排,"void fir_arrange_filter(float *arr,u16 len,u8 *fil_cnt,float in,float *arr_out) //len<=255 len >= 3
{
	//float arrange[len];
	float tmp;
	u8 i,j;
/*
窗口数据处理
*/		
	if( ++*fil_cnt >= len )	
	{
		*fil_cnt = 0; //now
	}
	
	arr[ *fil_cnt ] = in;
/*
窗口数据处理
*/	
	
/*
赋值、排列
*/	
	for(i=0;i<len;i++)
	{
		arr_out[i] = arr[i];
	}
	
	for(i=0;i<len-1;i++)
	{
		for(j=0;j<len-1-i;j++)
		{
			if(arr_out[j]>arr_out[j+1])
			{
				tmp = arr_out[j+1];
				arr_out[j+1] = arr_out[j];
				arr_out[j] = tmp;
			}
		}
	}
/*
赋值、排列
*/		
	

}","{'begin': {'line': 175, 'column': 1}, 'end': {'line': 218, 'column': 2}}",startup_msp432e401y_ewarm.c,"['对', '输入', '数组', '进行', '滤波', '和', '重排']"
7,7,7,Moving_Average,void,"void Moving_Average(float[] moavarray, int len, int * fil_cnt, float in, float * out)","[{'name': 'moavarray', 'type': 'float[]'}, {'name': 'len', 'type': 'int'}, {'name': 'fil_cnt', 'type': 'int *'}, {'name': 'in', 'type': 'float'}, {'name': 'out', 'type': 'float *'}]","{""name"": ""Moving_Average"", ""summary"": ""计算移动平均值，输入数组、长度、文件数量、当前值和输出数组""}","void Moving_Average(float moavarray[],u16 len ,u16 *fil_cnt,float in,float *out)
{
	u16 width_num;
	float last;

	width_num = len ;
	
	if( ++*fil_cnt >= width_num )	
	{
		*fil_cnt = 0; //now
	}
	
	last = moavarray[ *fil_cnt ];
	
	moavarray[ *fil_cnt ] = in;
	
	*out += ( in - ( last  ) )/(float)( width_num ) ;
	//*out += 0.00001f *(in - *out);
	*out += 0.00001f *LIMIT((in - *out),-1,1);  //数据精度误差修正
	
}","{'begin': {'line': 223, 'column': 2}, 'end': {'line': 243, 'column': 2}}",startup_msp432e401y_ewarm.c,"['{', '""', 'name', '""', ':', ' ', '""', 'Moving', '_', 'Average', '""', ',', ' ', '""', 'summary', '""', ':', ' ', '""', '计算', '移动', '平均', '均值', '平均值', '，', '输入', '数组', '、', '长度', '、', '文件', '数量', '、', '当前', '值', '和', '输出', '数组', '""', '}']"
8,8,8,LPF_1,void,"void LPF_1(float hz, float time, float in, float * out)","[{'name': 'hz', 'type': 'float'}, {'name': 'time', 'type': 'float'}, {'name': 'in', 'type': 'float'}, {'name': 'out', 'type': 'float *'}]",LPF_1函数用于低通滤波，输入频率、时间、输入值及输出值指针，计算并更新输出值。,"void LPF_1(float hz,float time,float in,float *out)  
{
	*out += ( 1 / ( 1 + 1 / ( hz *6.28f *time ) ) ) *( in - *out );

}","{'begin': {'line': 245, 'column': 1}, 'end': {'line': 249, 'column': 2}}",startup_msp432e401y_ewarm.c,"['LPF', '_', '1', '函数', '用于', '低', '滤波', '通滤波', '，', '输入', '频率', '、', '时间', '、', '输入', '值及', '输出', '值', '指针', '，', '计算', '并', '更新', '输出', '值', '。']"
9,9,9,LPF_1_db,void,"void LPF_1_db(float hz, float time, double in, double * out)","[{'name': 'hz', 'type': 'float'}, {'name': 'time', 'type': 'float'}, {'name': 'in', 'type': 'double'}, {'name': 'out', 'type': 'double *'}]",对输入信号进行低通滤波处理,"void LPF_1_db(float hz,float time,double in,double *out)
{
	*out += ( 1 / ( 1 + 1 / ( hz *6.28f *time ) ) ) *( in - *out );

}","{'begin': {'line': 251, 'column': 1}, 'end': {'line': 255, 'column': 2}}",startup_msp432e401y_ewarm.c,"['对', '输入', '信号', '进行', '低', '滤波', '通滤波', '处理']"
10,10,10,step_filter,void,"void step_filter(float step, float in, float * out)","[{'name': 'step', 'type': 'float'}, {'name': 'in', 'type': 'float'}, {'name': 'out', 'type': 'float *'}]",根据输入值in与输出值out的差值与step比较，对out进行相应的增加或减少操作。,"void step_filter(float step,float in,float *out) 
{
	if(in - *out > step)
	{
		*out += step;
	}
	else if(in - *out < -step)
	{
		*out -= step;
	}
	else
	{
		*out = in;
	}

}","{'begin': {'line': 257, 'column': 1}, 'end': {'line': 272, 'column': 2}}",startup_msp432e401y_ewarm.c,"['根据', '输入', '值', 'in', '与', '输出', '值', 'out', '的', '差值', '与', 'step', '比较', '，', '对', 'out', '进行', '相应', '的', '增加', '或', '减少', '操作', '。']"
11,11,11,my_hpf_limited,float,"float my_hpf_limited(float T, float hz, float x, float zoom, float * zoom_adj)","[{'name': 'T', 'type': 'float'}, {'name': 'hz', 'type': 'float'}, {'name': 'x', 'type': 'float'}, {'name': 'zoom', 'type': 'float'}, {'name': 'zoom_adj', 'type': 'float *'}]",调整并限制高频脉冲宽度，考虑T、hz、x、zoom参数，通过zoom_adj参数反馈调整。,"float my_hpf_limited(float T,float hz,float x,float zoom,float *zoom_adj)
{

	
	*zoom_adj += ( 1 / ( 1 + 1 / ( hz *6.28f *T ) ) ) *(x - *zoom_adj);
	*zoom_adj = LIMIT(*zoom_adj,-zoom,zoom);
	return (x - *zoom_adj);

}","{'begin': {'line': 274, 'column': 1}, 'end': {'line': 282, 'column': 2}}",startup_msp432e401y_ewarm.c,"['调整', '并', '限制', '高频', '脉冲', '宽度', '，', '考虑', 'T', '、', 'hz', '、', 'x', '、', 'zoom', '参数', '，', '通过', 'zoom', '_', 'adj', '参数', '反馈', '调整', '。']"
12,12,12,simple_3d_trans,void,"void simple_3d_trans(float ref, float in, float out)","[{'name': 'ref', 'type': 'float'}, {'name': 'in', 'type': 'float'}, {'name': 'out', 'type': 'float'}]",简单3D变换函数，用于在水平面附近有限范围内变换3D向量。,"void simple_3d_trans(float ref[VEC_XYZ], float in[VEC_XYZ], float out[VEC_XYZ]) //该函数只有在水平面附近一个有限的范围内正确。
{
	static s8 pn;
	static float h_tmp_x,h_tmp_y;
	
	h_tmp_x = my_sqrt(my_pow(ref[Z]) + my_pow(ref[Y]));
	h_tmp_y = my_sqrt(my_pow(ref[Z]) + my_pow(ref[X]));
	
	pn = ref[Z] < 0? -1 : 1;
	
	  out[X] = ( h_tmp_x *in[X] - pn *ref[X] *in[Z] ) ;
		out[Y] = ( pn *h_tmp_y *in[Y] - ref[Y] *in[Z] ) ;
	
// 	 out[X] = h_tmp_x *in[X] - ref[X] *in[Z];
// 	 out[Y] = ref[Z] *in[Y] - ref[Y] *in[Z];
	
	out[Z] = ref[X] *in[X] + ref[Y] *in[Y] + ref[Z] *in[Z] ;

}","{'begin': {'line': 284, 'column': 1}, 'end': {'line': 302, 'column': 2}}",startup_msp432e401y_ewarm.c,"['简单', '3D', '变换', '函数', '，', '用于', '在', '水平', '平面', '水平面', '附近', '有限', '范围', '内', '变换', '3D', '向量', '。']"
13,13,13,vec_3dh_transition,void,"void vec_3dh_transition(float ref, float in, float out)","[{'name': 'ref', 'type': 'float'}, {'name': 'in', 'type': 'float'}, {'name': 'out', 'type': 'float'}]",vec_3dh_transition函数用于执行向量三维空间中的过渡变换。,"void vec_3dh_transition(float ref[VEC_XYZ], float in[VEC_XYZ], float out[VEC_XYZ])
{
	simple_3d_trans(ref,in,out); //
}","{'begin': {'line': 304, 'column': 1}, 'end': {'line': 307, 'column': 2}}",startup_msp432e401y_ewarm.c,"['vec', '_', '3dh', '_', 'transition', '函数', '用于', '执行', '向量', '三维', '空间', '维空间', '三维空间', '中', '的', '过渡', '变换', '。']"
14,14,14,vec_3dh_transition_matrix,void,"void vec_3dh_transition_matrix(float ref, float wh_matrix)","[{'name': 'ref', 'type': 'float'}, {'name': 'wh_matrix', 'type': 'float'}]",计算3D空间中向量的过渡矩阵,"void vec_3dh_transition_matrix(float ref[VEC_XYZ],float wh_matrix[VEC_XYZ][VEC_XYZ])
{

}","{'begin': {'line': 309, 'column': 1}, 'end': {'line': 312, 'column': 2}}",startup_msp432e401y_ewarm.c,"['计算', '3D', '空间', '中', '向量', '的', '过渡', '矩阵']"
15,15,15,inte_fix_filter,void,"void inte_fix_filter(float dT, int * data)","[{'name': 'dT', 'type': 'float'}, {'name': 'data', 'type': 'int *'}]",根据输入的dT和ei_limit或ei值，计算并更新数据中的out、e和ei值。,"void inte_fix_filter(float dT,_inte_fix_filter_st *data)
{
	float ei_lim_val;
	
	if(data->ei_limit>0)
	{		
		ei_lim_val = LIMIT(data->ei,-data->ei_limit,data->ei_limit);
	}
	else
	{
		ei_lim_val = data->ei;
	}	
	
	data->out = (data->in_est + ei_lim_val);
	
	data->e = data->fix_ki *(data->in_obs - data->out);

	data->ei += data->e *dT;

}","{'begin': {'line': 9, 'column': 1}, 'end': {'line': 28, 'column': 2}}",system_msp432e401y.c,"['根据', '输入', '的', 'dT', '和', 'ei', '_', 'limit', '或', 'ei', '值', '，', '计算', '并', '更新', '数据', '中', '的', 'out', '、', 'e', '和', 'ei', '值', '。']"
16,16,16,fix_inte_filter,void,"void fix_inte_filter(float dT, int * data)","[{'name': 'dT', 'type': 'float'}, {'name': 'data', 'type': 'int *'}]",根据输入参数dT和数据指针data，计算并更新数据成员out和e的值，并限制e的值在-e_limit到e_limit之间。,"void fix_inte_filter(float dT,_fix_inte_filter_st *data)
{
	
	data->out += (data->in_est_d + data->e ) *dT;
	
	data->e = data->fix_kp *(data->in_obs - data->out);

	if(data->e_limit>0)
	{		
		data->e = LIMIT(data->e,-data->e_limit,data->e_limit);
	}
	
}","{'begin': {'line': 30, 'column': 1}, 'end': {'line': 42, 'column': 2}}",system_msp432e401y.c,"['根据', '输入', '参数', 'dT', '和', '数据', '指针', 'data', '，', '计算', '并', '更新', '数据', '成员', 'out', '和', 'e', '的', '值', '，', '并', '限制', 'e', '的', '值', '在', '-', 'e', '_', 'limit', '到', 'e', '_', 'limit', '之间', '。']"
17,17,17,limit_filter,void,"void limit_filter(float T, float hz, int * data, float in)","[{'name': 'T', 'type': 'float'}, {'name': 'hz', 'type': 'float'}, {'name': 'data', 'type': 'int *'}, {'name': 'in', 'type': 'float'}]","对输入信号进行滤波处理，使用LPF_1滤波器，输出限制在[-abs_t, abs_t]范围内。","void limit_filter(float T,float hz,_lf_t *data,float in) //增量滤波，适合大噪声低滞后（无缝），收敛最快
{
	float abs_t;
// 	LPF_1(hz,T,	 in,&(data->lpf_1)); 
// 	abs_t = ABS(data->lpf_1);
// 	data->out = LIMIT(in,-abs_t,abs_t);
	LPF_1_(hz,T,	 in,(data->lpf_1)); 
 	abs_t = ABS(in);
	data->out = LIMIT((data->lpf_1),-abs_t,abs_t);
}","{'begin': {'line': 44, 'column': 1}, 'end': {'line': 53, 'column': 2}}",system_msp432e401y.c,"['对', '输入', '信号', '进行', '滤波', '处理', '，', '使用', 'LPF', '_', '1', '滤波', '滤波器', '，', '输出', '限制', '在', '[', '-', 'abs', '_', 't', ',', ' ', 'abs', '_', 't', ']', '范围', '内', '。']"
18,18,18,limit_filter_2,void,"void limit_filter_2(float T, float hz, int * data, float in)","[{'name': 'T', 'type': 'float'}, {'name': 'hz', 'type': 'float'}, {'name': 'data', 'type': 'int *'}, {'name': 'in', 'type': 'float'}]",对输入数据进行增量滤波、均衡处理，但存在一定的滞后。,"void limit_filter_2(float T,float hz,_lf_t *data,float in) //增量滤波，均衡，但滞后稍大(数据反向等待低通反向)
{
	float abs_t;
	LPF_1_(hz,T,	 in,(data->lpf_1)); 
	abs_t = ABS(data->lpf_1);
	data->out = LIMIT(in,-abs_t,abs_t);
// 	LPF_1(hz,T,	 in,&(data->lpf_1)); 
//  	abs_t = ABS(in);
// 	data->out = LIMIT((data->lpf_1),-abs_t,abs_t);
}","{'begin': {'line': 55, 'column': 1}, 'end': {'line': 64, 'column': 2}}",system_msp432e401y.c,"['对', '输入', '数据', '进行', '增量', '滤波', '、', '均衡', '处理', '，', '但', '存在', '一定', '的', '滞后', '。']"
19,19,19,limit_filter_3,void,"void limit_filter_3(float T, float hz, int * data, float in)","[{'name': 'T', 'type': 'float'}, {'name': 'hz', 'type': 'float'}, {'name': 'data', 'type': 'int *'}, {'name': 'in', 'type': 'float'}]",增量滤波函数，适用于低噪声且滞后较小的场景，通过LPF_1_处理输入数据，并进行限幅操作以控制输出。,"void limit_filter_3(float T,float hz,_lf_t *data,float in) //增量滤波，适合低噪声滞后较小(等幅大噪声平行不收敛),噪声大收敛过慢
{
	float abs_t;
	LPF_1_(hz,T,	 in,(data->lpf_1)); 
	abs_t = ABS(in);
	data->out = data->lpf_1 = LIMIT((data->lpf_1),-abs_t,abs_t);

}","{'begin': {'line': 66, 'column': 1}, 'end': {'line': 73, 'column': 2}}",system_msp432e401y.c,"['增量', '滤波', '函数', '，', '适用', '于', '噪声', '低噪声', '且', '滞后', '较', '小', '的', '场景', '，', '通过', 'LPF', '_', '1', '_', '处理', '输入', '数据', '，', '并', '进行', '限幅', '操作', '以', '控制', '输出', '。']"
20,20,20,steepest_descend,void,"void steepest_descend(int[] arr, int len, int * steepest, int step_num, int in)","[{'name': 'arr', 'type': 'int[]'}, {'name': 'len', 'type': 'int'}, {'name': 'steepest', 'type': 'int *'}, {'name': 'step_num', 'type': 'int'}, {'name': 'in', 'type': 'int'}]",计算数组中每个点的梯度，并根据梯度和步数更新最陡下降路径。,"void steepest_descend(s32 arr[],u8 len,_steepest_st *steepest,u8 step_num,s32 in)
{	
	u8 updw = 1;//0 dw,1up
	s16 i;
	u8 step_cnt=0;
	u8 step_slope_factor=1;
	u8 on = 1;
	s8 pn = 1;
	//float last = 0;
	float step = 0;
	s32 start_point = 0;
	s32 pow_sum = 0;
	
	steepest->lst_out = steepest->now_out;
	
	if( ++(steepest->cnt) >= len )	
	{
		(steepest->cnt) = 0; //now
	}
	
	//last = arr[ (steepest->cnt) ];
	
	arr[ (steepest->cnt) ] = in;
	
	step = (float)(in - steepest->lst_out)/step_num ;//梯度
	
	if(ABS(step)<1)//整形数据<1的有效判定
	{
		if(ABS(step)*step_num<2)
		{
			step = 0;
		}
		else
		{
		  step = (step > 0) ? 1 : -1;
		}
	}
	
	start_point = steepest->lst_out;
	do
	{
		//start_point = steepest->lst_out;
		for(i=0;i<len;i++)
		{
// 			j = steepest->cnt + i + 1;
// 			if( j >= len )	
// 			{
// 				j = j - len; //顺序排列
// 			}
			pow_sum += my_pow(arr[i] - start_point );// /step_num;//除法减小比例**
			
			//start_point += pn *(step_slope_factor *step/len);
		}
			
		if(pow_sum - steepest->lst_pow_sum > 0)
		{		
			if(updw==0)
			{
				on = 0;
			}
			updw = 1;//上升了
			pn = (pn == 1 )? -1:1;

		}
		else
		{
			updw = 0; //正在下降
 			if(step_slope_factor<step_num)
 			{
 				step_slope_factor++;
 			}
		}
			
		steepest->lst_pow_sum = pow_sum;		
		pow_sum = 0;
		start_point += pn *step;//调整
		
		if(++step_cnt > step_num)//限制计算次数
		{
			on = 0;
		}
			//////
			if(step_slope_factor>=2)//限制下降次数1次，节省时间，但会增大滞后，若cpu时间充裕可不用。
			{
				on = 0;

			}
			//////
		
	}
	while(on==1);
	
	steepest->now_out = start_point ;//0.5f *(start_point + steepest->lst_out);//
	
	steepest->now_velocity_xdt = steepest->now_out - steepest->lst_out;
}","{'begin': {'line': 78, 'column': 1}, 'end': {'line': 173, 'column': 2}}",system_msp432e401y.c,"['计算', '数组', '中', '每个', '点', '的', '梯度', '，', '并', '根据', '梯度', '和', '步数', '更新', '最', '陡', '下降', '路径', '。']"
21,21,21,fir_arrange_filter,void,"void fir_arrange_filter(float * arr, int len, int * fil_cnt, float in, float * arr_out)","[{'name': 'arr', 'type': 'float *'}, {'name': 'len', 'type': 'int'}, {'name': 'fil_cnt', 'type': 'int *'}, {'name': 'in', 'type': 'float'}, {'name': 'arr_out', 'type': 'float *'}]",对输入数组进行滤波和排序处理,"void fir_arrange_filter(float *arr,u16 len,u8 *fil_cnt,float in,float *arr_out) //len<=255 len >= 3
{
	//float arrange[len];
	float tmp;
	u8 i,j;
/*
窗口数据处理
*/		
	if( ++*fil_cnt >= len )	
	{
		*fil_cnt = 0; //now
	}
	
	arr[ *fil_cnt ] = in;
/*
窗口数据处理
*/	
	
/*
赋值、排列
*/	
	for(i=0;i<len;i++)
	{
		arr_out[i] = arr[i];
	}
	
	for(i=0;i<len-1;i++)
	{
		for(j=0;j<len-1-i;j++)
		{
			if(arr_out[j]>arr_out[j+1])
			{
				tmp = arr_out[j+1];
				arr_out[j+1] = arr_out[j];
				arr_out[j] = tmp;
			}
		}
	}
/*
赋值、排列
*/		
	

}","{'begin': {'line': 175, 'column': 1}, 'end': {'line': 218, 'column': 2}}",system_msp432e401y.c,"['对', '输入', '数组', '进行', '滤波', '和', '排序', '处理']"
22,22,22,Moving_Average,void,"void Moving_Average(float[] moavarray, int len, int * fil_cnt, float in, float * out)","[{'name': 'moavarray', 'type': 'float[]'}, {'name': 'len', 'type': 'int'}, {'name': 'fil_cnt', 'type': 'int *'}, {'name': 'in', 'type': 'float'}, {'name': 'out', 'type': 'float *'}]",计算滑动平均数，更新数组和总和，修正数据精度误差。,"void Moving_Average(float moavarray[],u16 len ,u16 *fil_cnt,float in,float *out)
{
	u16 width_num;
	float last;

	width_num = len ;
	
	if( ++*fil_cnt >= width_num )	
	{
		*fil_cnt = 0; //now
	}
	
	last = moavarray[ *fil_cnt ];
	
	moavarray[ *fil_cnt ] = in;
	
	*out += ( in - ( last  ) )/(float)( width_num ) ;
	//*out += 0.00001f *(in - *out);
	*out += 0.00001f *LIMIT((in - *out),-1,1);  //数据精度误差修正
	
}","{'begin': {'line': 223, 'column': 2}, 'end': {'line': 243, 'column': 2}}",system_msp432e401y.c,"['计算', '滑动', '平均', '均数', '平均数', '，', '更新', '数组', '和', '总和', '，', '修正', '数据', '精度', '误差', '。']"
23,23,23,LPF_1,void,"void LPF_1(float hz, float time, float in, float * out)","[{'name': 'hz', 'type': 'float'}, {'name': 'time', 'type': 'float'}, {'name': 'in', 'type': 'float'}, {'name': 'out', 'type': 'float *'}]",对输入信号进行低通滤波处理，输出滤波后的信号。,"void LPF_1(float hz,float time,float in,float *out)  
{
	*out += ( 1 / ( 1 + 1 / ( hz *6.28f *time ) ) ) *( in - *out );

}","{'begin': {'line': 245, 'column': 1}, 'end': {'line': 249, 'column': 2}}",system_msp432e401y.c,"['对', '输入', '信号', '进行', '低', '滤波', '通滤波', '处理', '，', '输出', '滤波', '后', '的', '信号', '。']"
24,24,24,LPF_1_db,void,"void LPF_1_db(float hz, float time, double in, double * out)","[{'name': 'hz', 'type': 'float'}, {'name': 'time', 'type': 'float'}, {'name': 'in', 'type': 'double'}, {'name': 'out', 'type': 'double *'}]",对输入信号进行低通滤波处理，输出滤波后的信号。,"void LPF_1_db(float hz,float time,double in,double *out)
{
	*out += ( 1 / ( 1 + 1 / ( hz *6.28f *time ) ) ) *( in - *out );

}","{'begin': {'line': 251, 'column': 1}, 'end': {'line': 255, 'column': 2}}",system_msp432e401y.c,"['对', '输入', '信号', '进行', '低', '滤波', '通滤波', '处理', '，', '输出', '滤波', '后', '的', '信号', '。']"
25,25,25,step_filter,void,"void step_filter(float step, float in, float * out)","[{'name': 'step', 'type': 'float'}, {'name': 'in', 'type': 'float'}, {'name': 'out', 'type': 'float *'}]",根据输入值in与输出值out的差值与step的关系，调整输出值out。,"void step_filter(float step,float in,float *out) 
{
	if(in - *out > step)
	{
		*out += step;
	}
	else if(in - *out < -step)
	{
		*out -= step;
	}
	else
	{
		*out = in;
	}

}","{'begin': {'line': 257, 'column': 1}, 'end': {'line': 272, 'column': 2}}",system_msp432e401y.c,"['根据', '输入', '值', 'in', '与', '输出', '值', 'out', '的', '差值', '与', 'step', '的', '关系', '，', '调整', '输出', '值', 'out', '。']"
26,26,26,my_hpf_limited,float,"float my_hpf_limited(float T, float hz, float x, float zoom, float * zoom_adj)","[{'name': 'T', 'type': 'float'}, {'name': 'hz', 'type': 'float'}, {'name': 'x', 'type': 'float'}, {'name': 'zoom', 'type': 'float'}, {'name': 'zoom_adj', 'type': 'float *'}]",调整并限制高频滤波器增益,"float my_hpf_limited(float T,float hz,float x,float zoom,float *zoom_adj)
{

	
	*zoom_adj += ( 1 / ( 1 + 1 / ( hz *6.28f *T ) ) ) *(x - *zoom_adj);
	*zoom_adj = LIMIT(*zoom_adj,-zoom,zoom);
	return (x - *zoom_adj);

}","{'begin': {'line': 274, 'column': 1}, 'end': {'line': 282, 'column': 2}}",system_msp432e401y.c,"['调整', '并', '限制', '高频', '滤波', '滤波器', '增益']"
27,27,27,simple_3d_trans,void,"void simple_3d_trans(float ref, float in, float out)","[{'name': 'ref', 'type': 'float'}, {'name': 'in', 'type': 'float'}, {'name': 'out', 'type': 'float'}]",简单3D转换函数，处理三维向量的水平和垂直分量转换。,"void simple_3d_trans(float ref[VEC_XYZ], float in[VEC_XYZ], float out[VEC_XYZ]) //该函数只有在水平面附近一个有限的范围内正确。
{
	static s8 pn;
	static float h_tmp_x,h_tmp_y;
	
	h_tmp_x = my_sqrt(my_pow(ref[Z]) + my_pow(ref[Y]));
	h_tmp_y = my_sqrt(my_pow(ref[Z]) + my_pow(ref[X]));
	
	pn = ref[Z] < 0? -1 : 1;
	
	  out[X] = ( h_tmp_x *in[X] - pn *ref[X] *in[Z] ) ;
		out[Y] = ( pn *h_tmp_y *in[Y] - ref[Y] *in[Z] ) ;
	
// 	 out[X] = h_tmp_x *in[X] - ref[X] *in[Z];
// 	 out[Y] = ref[Z] *in[Y] - ref[Y] *in[Z];
	
	out[Z] = ref[X] *in[X] + ref[Y] *in[Y] + ref[Z] *in[Z] ;

}","{'begin': {'line': 284, 'column': 1}, 'end': {'line': 302, 'column': 2}}",system_msp432e401y.c,"['简单', '3D', '转换', '函数', '，', '处理', '三维', '向量', '的', '水平', '和', '垂直', '分量', '转换', '。']"
28,28,28,vec_3dh_transition,void,"void vec_3dh_transition(float ref, float in, float out)","[{'name': 'ref', 'type': 'float'}, {'name': 'in', 'type': 'float'}, {'name': 'out', 'type': 'float'}]",vec_3dh_transition函数用于执行三维向量的过渡操作。,"void vec_3dh_transition(float ref[VEC_XYZ], float in[VEC_XYZ], float out[VEC_XYZ])
{
	simple_3d_trans(ref,in,out); //
}","{'begin': {'line': 304, 'column': 1}, 'end': {'line': 307, 'column': 2}}",system_msp432e401y.c,"['vec', '_', '3dh', '_', 'transition', '函数', '用于', '执行', '三维', '向量', '的', '过渡', '操作', '。']"
29,29,29,vec_3dh_transition_matrix,void,"void vec_3dh_transition_matrix(float ref, float wh_matrix)","[{'name': 'ref', 'type': 'float'}, {'name': 'wh_matrix', 'type': 'float'}]",计算3D空间中向量的过渡矩阵,"void vec_3dh_transition_matrix(float ref[VEC_XYZ],float wh_matrix[VEC_XYZ][VEC_XYZ])
{

}","{'begin': {'line': 309, 'column': 1}, 'end': {'line': 312, 'column': 2}}",system_msp432e401y.c,"['计算', '3D', '空间', '中', '向量', '的', '过渡', '矩阵']"
30,30,30,inte_fix_filter,void,"void inte_fix_filter(float dT, int * data)","[{'name': 'dT', 'type': 'float'}, {'name': 'data', 'type': 'int *'}]",根据输入的dT和ei_limit，调整数据中的in_est、out、e和ei值。,"void inte_fix_filter(float dT,_inte_fix_filter_st *data)
{
	float ei_lim_val;
	
	if(data->ei_limit>0)
	{		
		ei_lim_val = LIMIT(data->ei,-data->ei_limit,data->ei_limit);
	}
	else
	{
		ei_lim_val = data->ei;
	}	
	
	data->out = (data->in_est + ei_lim_val);
	
	data->e = data->fix_ki *(data->in_obs - data->out);

	data->ei += data->e *dT;

}","{'begin': {'line': 9, 'column': 1}, 'end': {'line': 28, 'column': 2}}",Algorithm_xzhadd\DY_FcData.c,"['根据', '输入', '的', 'dT', '和', 'ei', '_', 'limit', '，', '调整', '数据', '中', '的', 'in', '_', 'est', '、', 'out', '、', 'e', '和', 'ei', '值', '。']"
31,31,31,fix_inte_filter,void,"void fix_inte_filter(float dT, int * data)","[{'name': 'dT', 'type': 'float'}, {'name': 'data', 'type': 'int *'}]",根据输入的dT和数据数组，计算并更新过滤后的数据。,"void fix_inte_filter(float dT,_fix_inte_filter_st *data)
{
	
	data->out += (data->in_est_d + data->e ) *dT;
	
	data->e = data->fix_kp *(data->in_obs - data->out);

	if(data->e_limit>0)
	{		
		data->e = LIMIT(data->e,-data->e_limit,data->e_limit);
	}
	
}","{'begin': {'line': 30, 'column': 1}, 'end': {'line': 42, 'column': 2}}",Algorithm_xzhadd\DY_FcData.c,"['根据', '输入', '的', 'dT', '和', '数据', '数组', '，', '计算', '并', '更新', '过滤', '后', '的', '数据', '。']"
32,32,32,limit_filter,void,"void limit_filter(float T, float hz, int * data, float in)","[{'name': 'T', 'type': 'float'}, {'name': 'hz', 'type': 'float'}, {'name': 'data', 'type': 'int *'}, {'name': 'in', 'type': 'float'}]",对输入数据进行增量滤波，适合大噪声低滞后场景，收敛快,"void limit_filter(float T,float hz,_lf_t *data,float in) //增量滤波，适合大噪声低滞后（无缝），收敛最快
{
	float abs_t;
// 	LPF_1(hz,T,	 in,&(data->lpf_1)); 
// 	abs_t = ABS(data->lpf_1);
// 	data->out = LIMIT(in,-abs_t,abs_t);
	LPF_1_(hz,T,	 in,(data->lpf_1)); 
 	abs_t = ABS(in);
	data->out = LIMIT((data->lpf_1),-abs_t,abs_t);
}","{'begin': {'line': 44, 'column': 1}, 'end': {'line': 53, 'column': 2}}",Algorithm_xzhadd\DY_FcData.c,"['对', '输入', '数据', '进行', '增量', '滤波', '，', '适合', '大', '噪声', '低', '滞后', '场景', '，', '收敛', '快']"
33,33,33,limit_filter_2,void,"void limit_filter_2(float T, float hz, int * data, float in)","[{'name': 'T', 'type': 'float'}, {'name': 'hz', 'type': 'float'}, {'name': 'data', 'type': 'int *'}, {'name': 'in', 'type': 'float'}]",对输入信号进行增量滤波、均衡处理，但存在一定的滞后。,"void limit_filter_2(float T,float hz,_lf_t *data,float in) //增量滤波，均衡，但滞后稍大(数据反向等待低通反向)
{
	float abs_t;
	LPF_1_(hz,T,	 in,(data->lpf_1)); 
	abs_t = ABS(data->lpf_1);
	data->out = LIMIT(in,-abs_t,abs_t);
// 	LPF_1(hz,T,	 in,&(data->lpf_1)); 
//  	abs_t = ABS(in);
// 	data->out = LIMIT((data->lpf_1),-abs_t,abs_t);
}","{'begin': {'line': 55, 'column': 1}, 'end': {'line': 64, 'column': 2}}",Algorithm_xzhadd\DY_FcData.c,"['对', '输入', '信号', '进行', '增量', '滤波', '、', '均衡', '处理', '，', '但', '存在', '一定', '的', '滞后', '。']"
34,34,34,limit_filter_3,void,"void limit_filter_3(float T, float hz, int * data, float in)","[{'name': 'T', 'type': 'float'}, {'name': 'hz', 'type': 'float'}, {'name': 'data', 'type': 'int *'}, {'name': 'in', 'type': 'float'}]",增量滤波函数，适用于低噪声滞后较小情况，对噪声大收敛较慢。,"void limit_filter_3(float T,float hz,_lf_t *data,float in) //增量滤波，适合低噪声滞后较小(等幅大噪声平行不收敛),噪声大收敛过慢
{
	float abs_t;
	LPF_1_(hz,T,	 in,(data->lpf_1)); 
	abs_t = ABS(in);
	data->out = data->lpf_1 = LIMIT((data->lpf_1),-abs_t,abs_t);

}","{'begin': {'line': 66, 'column': 1}, 'end': {'line': 73, 'column': 2}}",Algorithm_xzhadd\DY_FcData.c,"['增量', '滤波', '函数', '，', '适用', '于', '噪声', '低噪声', '滞后', '较', '小', '情况', '，', '对', '噪声', '大', '收敛', '较慢', '。']"
35,35,35,steepest_descend,void,"void steepest_descend(int[] arr, int len, int * steepest, int step_num, int in)","[{'name': 'arr', 'type': 'int[]'}, {'name': 'len', 'type': 'int'}, {'name': 'steepest', 'type': 'int *'}, {'name': 'step_num', 'type': 'int'}, {'name': 'in', 'type': 'int'}]",计算数组中最陡下降路径，并记录路径和速度。,"void steepest_descend(s32 arr[],u8 len,_steepest_st *steepest,u8 step_num,s32 in)
{	
	u8 updw = 1;//0 dw,1up
	s16 i;
	u8 step_cnt=0;
	u8 step_slope_factor=1;
	u8 on = 1;
	s8 pn = 1;
	//float last = 0;
	float step = 0;
	s32 start_point = 0;
	s32 pow_sum = 0;
	
	steepest->lst_out = steepest->now_out;
	
	if( ++(steepest->cnt) >= len )	
	{
		(steepest->cnt) = 0; //now
	}
	
	//last = arr[ (steepest->cnt) ];
	
	arr[ (steepest->cnt) ] = in;
	
	step = (float)(in - steepest->lst_out)/step_num ;//梯度
	
	if(ABS(step)<1)//整形数据<1的有效判定
	{
		if(ABS(step)*step_num<2)
		{
			step = 0;
		}
		else
		{
		  step = (step > 0) ? 1 : -1;
		}
	}
	
	start_point = steepest->lst_out;
	do
	{
		//start_point = steepest->lst_out;
		for(i=0;i<len;i++)
		{
// 			j = steepest->cnt + i + 1;
// 			if( j >= len )	
// 			{
// 				j = j - len; //顺序排列
// 			}
			pow_sum += my_pow(arr[i] - start_point );// /step_num;//除法减小比例**
			
			//start_point += pn *(step_slope_factor *step/len);
		}
			
		if(pow_sum - steepest->lst_pow_sum > 0)
		{		
			if(updw==0)
			{
				on = 0;
			}
			updw = 1;//上升了
			pn = (pn == 1 )? -1:1;

		}
		else
		{
			updw = 0; //正在下降
 			if(step_slope_factor<step_num)
 			{
 				step_slope_factor++;
 			}
		}
			
		steepest->lst_pow_sum = pow_sum;		
		pow_sum = 0;
		start_point += pn *step;//调整
		
		if(++step_cnt > step_num)//限制计算次数
		{
			on = 0;
		}
			//////
			if(step_slope_factor>=2)//限制下降次数1次，节省时间，但会增大滞后，若cpu时间充裕可不用。
			{
				on = 0;

			}
			//////
		
	}
	while(on==1);
	
	steepest->now_out = start_point ;//0.5f *(start_point + steepest->lst_out);//
	
	steepest->now_velocity_xdt = steepest->now_out - steepest->lst_out;
}","{'begin': {'line': 78, 'column': 1}, 'end': {'line': 173, 'column': 2}}",Algorithm_xzhadd\DY_FcData.c,"['计算', '数组', '中', '最', '陡', '下降', '路径', '，', '并', '记录', '路径', '和', '速度', '。']"
36,36,36,fir_arrange_filter,void,"void fir_arrange_filter(float * arr, int len, int * fil_cnt, float in, float * arr_out)","[{'name': 'arr', 'type': 'float *'}, {'name': 'len', 'type': 'int'}, {'name': 'fil_cnt', 'type': 'int *'}, {'name': 'in', 'type': 'float'}, {'name': 'arr_out', 'type': 'float *'}]","{
""name"": ""fir_arrange_filter"",
""summary"": ""对输入数组进行过滤和排序""
}","void fir_arrange_filter(float *arr,u16 len,u8 *fil_cnt,float in,float *arr_out) //len<=255 len >= 3
{
	//float arrange[len];
	float tmp;
	u8 i,j;
/*
窗口数据处理
*/		
	if( ++*fil_cnt >= len )	
	{
		*fil_cnt = 0; //now
	}
	
	arr[ *fil_cnt ] = in;
/*
窗口数据处理
*/	
	
/*
赋值、排列
*/	
	for(i=0;i<len;i++)
	{
		arr_out[i] = arr[i];
	}
	
	for(i=0;i<len-1;i++)
	{
		for(j=0;j<len-1-i;j++)
		{
			if(arr_out[j]>arr_out[j+1])
			{
				tmp = arr_out[j+1];
				arr_out[j+1] = arr_out[j];
				arr_out[j] = tmp;
			}
		}
	}
/*
赋值、排列
*/		
	

}","{'begin': {'line': 175, 'column': 1}, 'end': {'line': 218, 'column': 2}}",Algorithm_xzhadd\DY_FcData.c,"['{', '\n', '""', 'name', '""', ':', ' ', '""', 'fir', '_', 'arrange', '_', 'filter', '""', ',', '\n', '""', 'summary', '""', ':', ' ', '""', '对', '输入', '数组', '进行', '过滤', '和', '排序', '""', '\n', '}']"
37,37,37,Moving_Average,void,"void Moving_Average(float[] moavarray, int len, int * fil_cnt, float in, float * out)","[{'name': 'moavarray', 'type': 'float[]'}, {'name': 'len', 'type': 'int'}, {'name': 'fil_cnt', 'type': 'int *'}, {'name': 'in', 'type': 'float'}, {'name': 'out', 'type': 'float *'}]",计算滑动平均数，更新数组元素，并输出结果。,"void Moving_Average(float moavarray[],u16 len ,u16 *fil_cnt,float in,float *out)
{
	u16 width_num;
	float last;

	width_num = len ;
	
	if( ++*fil_cnt >= width_num )	
	{
		*fil_cnt = 0; //now
	}
	
	last = moavarray[ *fil_cnt ];
	
	moavarray[ *fil_cnt ] = in;
	
	*out += ( in - ( last  ) )/(float)( width_num ) ;
	//*out += 0.00001f *(in - *out);
	*out += 0.00001f *LIMIT((in - *out),-1,1);  //数据精度误差修正
	
}","{'begin': {'line': 223, 'column': 2}, 'end': {'line': 243, 'column': 2}}",Algorithm_xzhadd\DY_FcData.c,"['计算', '滑动', '平均', '均数', '平均数', '，', '更新', '数组', '元素', '，', '并', '输出', '结果', '。']"
38,38,38,LPF_1,void,"void LPF_1(float hz, float time, float in, float * out)","[{'name': 'hz', 'type': 'float'}, {'name': 'time', 'type': 'float'}, {'name': 'in', 'type': 'float'}, {'name': 'out', 'type': 'float *'}]",LPF_1函数用于低通滤波，输入频率、时间、输入值及输出值指针，计算后输出值。,"void LPF_1(float hz,float time,float in,float *out)  
{
	*out += ( 1 / ( 1 + 1 / ( hz *6.28f *time ) ) ) *( in - *out );

}","{'begin': {'line': 245, 'column': 1}, 'end': {'line': 249, 'column': 2}}",Algorithm_xzhadd\DY_FcData.c,"['LPF', '_', '1', '函数', '用于', '低', '滤波', '通滤波', '，', '输入', '频率', '、', '时间', '、', '输入', '值及', '输出', '值', '指针', '，', '计算', '后', '输出', '值', '。']"
39,39,39,LPF_1_db,void,"void LPF_1_db(float hz, float time, double in, double * out)","[{'name': 'hz', 'type': 'float'}, {'name': 'time', 'type': 'float'}, {'name': 'in', 'type': 'double'}, {'name': 'out', 'type': 'double *'}]",LPF_1_db函数用于低通滤波，输入频率、时间、输入值及输出值指针，计算后输出值。,"void LPF_1_db(float hz,float time,double in,double *out)
{
	*out += ( 1 / ( 1 + 1 / ( hz *6.28f *time ) ) ) *( in - *out );

}","{'begin': {'line': 251, 'column': 1}, 'end': {'line': 255, 'column': 2}}",Algorithm_xzhadd\DY_FcData.c,"['LPF', '_', '1', '_', 'db', '函数', '用于', '低', '滤波', '通滤波', '，', '输入', '频率', '、', '时间', '、', '输入', '值及', '输出', '值', '指针', '，', '计算', '后', '输出', '值', '。']"
40,40,40,step_filter,void,"void step_filter(float step, float in, float * out)","[{'name': 'step', 'type': 'float'}, {'name': 'in', 'type': 'float'}, {'name': 'out', 'type': 'float *'}]",根据输入值in与输出值out的差值与step的关系，调整输出值out。,"void step_filter(float step,float in,float *out) 
{
	if(in - *out > step)
	{
		*out += step;
	}
	else if(in - *out < -step)
	{
		*out -= step;
	}
	else
	{
		*out = in;
	}

}","{'begin': {'line': 257, 'column': 1}, 'end': {'line': 272, 'column': 2}}",Algorithm_xzhadd\DY_FcData.c,"['根据', '输入', '值', 'in', '与', '输出', '值', 'out', '的', '差值', '与', 'step', '的', '关系', '，', '调整', '输出', '值', 'out', '。']"
41,41,41,my_hpf_limited,float,"float my_hpf_limited(float T, float hz, float x, float zoom, float * zoom_adj)","[{'name': 'T', 'type': 'float'}, {'name': 'hz', 'type': 'float'}, {'name': 'x', 'type': 'float'}, {'name': 'zoom', 'type': 'float'}, {'name': 'zoom_adj', 'type': 'float *'}]",根据给定的参数，计算并返回处理后的信号值，同时调整缩放参数。,"float my_hpf_limited(float T,float hz,float x,float zoom,float *zoom_adj)
{

	
	*zoom_adj += ( 1 / ( 1 + 1 / ( hz *6.28f *T ) ) ) *(x - *zoom_adj);
	*zoom_adj = LIMIT(*zoom_adj,-zoom,zoom);
	return (x - *zoom_adj);

}","{'begin': {'line': 274, 'column': 1}, 'end': {'line': 282, 'column': 2}}",Algorithm_xzhadd\DY_FcData.c,"['根据', '给定', '的', '参数', '，', '计算', '并', '返回', '处理', '后', '的', '信号', '值', '，', '同时', '调整', '缩放', '参数', '。']"
42,42,42,simple_3d_trans,void,"void simple_3d_trans(float ref, float in, float out)","[{'name': 'ref', 'type': 'float'}, {'name': 'in', 'type': 'float'}, {'name': 'out', 'type': 'float'}]",简单三维变换函数，处理三个浮点数数组，实现特定变换。,"void simple_3d_trans(float ref[VEC_XYZ], float in[VEC_XYZ], float out[VEC_XYZ]) //该函数只有在水平面附近一个有限的范围内正确。
{
	static s8 pn;
	static float h_tmp_x,h_tmp_y;
	
	h_tmp_x = my_sqrt(my_pow(ref[Z]) + my_pow(ref[Y]));
	h_tmp_y = my_sqrt(my_pow(ref[Z]) + my_pow(ref[X]));
	
	pn = ref[Z] < 0? -1 : 1;
	
	  out[X] = ( h_tmp_x *in[X] - pn *ref[X] *in[Z] ) ;
		out[Y] = ( pn *h_tmp_y *in[Y] - ref[Y] *in[Z] ) ;
	
// 	 out[X] = h_tmp_x *in[X] - ref[X] *in[Z];
// 	 out[Y] = ref[Z] *in[Y] - ref[Y] *in[Z];
	
	out[Z] = ref[X] *in[X] + ref[Y] *in[Y] + ref[Z] *in[Z] ;

}","{'begin': {'line': 284, 'column': 1}, 'end': {'line': 302, 'column': 2}}",Algorithm_xzhadd\DY_FcData.c,"['简单', '三维', '变换', '函数', '，', '处理', '三个', '浮点', '点数', '浮点数', '数组', '，', '实现', '特定', '变换', '。']"
43,43,43,vec_3dh_transition,void,"void vec_3dh_transition(float ref, float in, float out)","[{'name': 'ref', 'type': 'float'}, {'name': 'in', 'type': 'float'}, {'name': 'out', 'type': 'float'}]",vec_3dh_transition函数接收三个浮点数数组作为参数，调用simple_3d_trans函数完成三维向量的过渡操作。,"void vec_3dh_transition(float ref[VEC_XYZ], float in[VEC_XYZ], float out[VEC_XYZ])
{
	simple_3d_trans(ref,in,out); //
}","{'begin': {'line': 304, 'column': 1}, 'end': {'line': 307, 'column': 2}}",Algorithm_xzhadd\DY_FcData.c,"['vec', '_', '3dh', '_', 'transition', '函数', '接收', '三个', '浮点', '点数', '浮点数', '数组', '作为', '参数', '，', '调用', 'simple', '_', '3d', '_', 'trans', '函数', '完成', '三维', '向量', '的', '过渡', '操作', '。']"
44,44,44,vec_3dh_transition_matrix,void,"void vec_3dh_transition_matrix(float ref, float wh_matrix)","[{'name': 'ref', 'type': 'float'}, {'name': 'wh_matrix', 'type': 'float'}]",计算3D空间中的向量过渡矩阵,"void vec_3dh_transition_matrix(float ref[VEC_XYZ],float wh_matrix[VEC_XYZ][VEC_XYZ])
{

}","{'begin': {'line': 309, 'column': 1}, 'end': {'line': 312, 'column': 2}}",Algorithm_xzhadd\DY_FcData.c,"['计算', '3D', '空间', '中', '的', '向量', '过渡', '矩阵']"
45,45,45,inte_fix_filter,void,"void inte_fix_filter(float dT, int * data)","[{'name': 'dT', 'type': 'float'}, {'name': 'data', 'type': 'int *'}]",根据数据点索引和限制值，调整滤波后的数据点位置，并更新相关变量,"void inte_fix_filter(float dT,_inte_fix_filter_st *data)
{
	float ei_lim_val;
	
	if(data->ei_limit>0)
	{		
		ei_lim_val = LIMIT(data->ei,-data->ei_limit,data->ei_limit);
	}
	else
	{
		ei_lim_val = data->ei;
	}	
	
	data->out = (data->in_est + ei_lim_val);
	
	data->e = data->fix_ki *(data->in_obs - data->out);

	data->ei += data->e *dT;

}","{'begin': {'line': 9, 'column': 1}, 'end': {'line': 28, 'column': 2}}",Algorithm_xzhadd\DY_Filter.c,"['根据', '数据', '点', '索引', '和', '限制', '值', '，', '调整', '滤波', '后', '的', '数据', '点', '位置', '，', '并', '更新', '相关', '变量']"
46,46,46,fix_inte_filter,void,"void fix_inte_filter(float dT, int * data)","[{'name': 'dT', 'type': 'float'}, {'name': 'data', 'type': 'int *'}]",根据输入参数更新数据过滤后的值,"void fix_inte_filter(float dT,_fix_inte_filter_st *data)
{
	
	data->out += (data->in_est_d + data->e ) *dT;
	
	data->e = data->fix_kp *(data->in_obs - data->out);

	if(data->e_limit>0)
	{		
		data->e = LIMIT(data->e,-data->e_limit,data->e_limit);
	}
	
}","{'begin': {'line': 30, 'column': 1}, 'end': {'line': 42, 'column': 2}}",Algorithm_xzhadd\DY_Filter.c,"['根据', '输入', '参数', '更新', '数据', '过滤', '后', '的', '值']"
47,47,47,limit_filter,void,"void limit_filter(float T, float hz, int * data, float in)","[{'name': 'T', 'type': 'float'}, {'name': 'hz', 'type': 'float'}, {'name': 'data', 'type': 'int *'}, {'name': 'in', 'type': 'float'}]",对输入信号进行滤波处理，返回滤波后的值。,"void limit_filter(float T,float hz,_lf_t *data,float in) //增量滤波，适合大噪声低滞后（无缝），收敛最快
{
	float abs_t;
// 	LPF_1(hz,T,	 in,&(data->lpf_1)); 
// 	abs_t = ABS(data->lpf_1);
// 	data->out = LIMIT(in,-abs_t,abs_t);
	LPF_1_(hz,T,	 in,(data->lpf_1)); 
 	abs_t = ABS(in);
	data->out = LIMIT((data->lpf_1),-abs_t,abs_t);
}","{'begin': {'line': 44, 'column': 1}, 'end': {'line': 53, 'column': 2}}",Algorithm_xzhadd\DY_Filter.c,"['对', '输入', '信号', '进行', '滤波', '处理', '，', '返回', '滤波', '后', '的', '值', '。']"
48,48,48,limit_filter_2,void,"void limit_filter_2(float T, float hz, int * data, float in)","[{'name': 'T', 'type': 'float'}, {'name': 'hz', 'type': 'float'}, {'name': 'data', 'type': 'int *'}, {'name': 'in', 'type': 'float'}]",对输入信号进行增量滤波和均衡处理，同时有一定的滞后。,"void limit_filter_2(float T,float hz,_lf_t *data,float in) //增量滤波，均衡，但滞后稍大(数据反向等待低通反向)
{
	float abs_t;
	LPF_1_(hz,T,	 in,(data->lpf_1)); 
	abs_t = ABS(data->lpf_1);
	data->out = LIMIT(in,-abs_t,abs_t);
// 	LPF_1(hz,T,	 in,&(data->lpf_1)); 
//  	abs_t = ABS(in);
// 	data->out = LIMIT((data->lpf_1),-abs_t,abs_t);
}","{'begin': {'line': 55, 'column': 1}, 'end': {'line': 64, 'column': 2}}",Algorithm_xzhadd\DY_Filter.c,"['对', '输入', '信号', '进行', '增量', '滤波', '和', '均衡', '处理', '，', '同时', '有', '一定', '的', '滞后', '。']"
49,49,49,limit_filter_3,void,"void limit_filter_3(float T, float hz, int * data, float in)","[{'name': 'T', 'type': 'float'}, {'name': 'hz', 'type': 'float'}, {'name': 'data', 'type': 'int *'}, {'name': 'in', 'type': 'float'}]",对输入数据进行增量滤波，过滤大小与输入信号频率有关，输出为滤波后的数据。,"void limit_filter_3(float T,float hz,_lf_t *data,float in) //增量滤波，适合低噪声滞后较小(等幅大噪声平行不收敛),噪声大收敛过慢
{
	float abs_t;
	LPF_1_(hz,T,	 in,(data->lpf_1)); 
	abs_t = ABS(in);
	data->out = data->lpf_1 = LIMIT((data->lpf_1),-abs_t,abs_t);

}","{'begin': {'line': 66, 'column': 1}, 'end': {'line': 73, 'column': 2}}",Algorithm_xzhadd\DY_Filter.c,"['对', '输入', '数据', '进行', '增量', '滤波', '，', '过滤', '大小', '与', '输入', '信号', '频率', '有关', '，', '输出', '为', '滤波', '后', '的', '数据', '。']"
50,50,50,steepest_descend,void,"void steepest_descend(int[] arr, int len, int * steepest, int step_num, int in)","[{'name': 'arr', 'type': 'int[]'}, {'name': 'len', 'type': 'int'}, {'name': 'steepest', 'type': 'int *'}, {'name': 'step_num', 'type': 'int'}, {'name': 'in', 'type': 'int'}]","{""name"": ""steepest_descend"", ""summary"": ""steepest_descend函数用于计算数组arr中元素按照给定步长和方向进行最陡下降的过程，返回最陡下降路径的终点。""}","void steepest_descend(s32 arr[],u8 len,_steepest_st *steepest,u8 step_num,s32 in)
{	
	u8 updw = 1;//0 dw,1up
	s16 i;
	u8 step_cnt=0;
	u8 step_slope_factor=1;
	u8 on = 1;
	s8 pn = 1;
	//float last = 0;
	float step = 0;
	s32 start_point = 0;
	s32 pow_sum = 0;
	
	steepest->lst_out = steepest->now_out;
	
	if( ++(steepest->cnt) >= len )	
	{
		(steepest->cnt) = 0; //now
	}
	
	//last = arr[ (steepest->cnt) ];
	
	arr[ (steepest->cnt) ] = in;
	
	step = (float)(in - steepest->lst_out)/step_num ;//梯度
	
	if(ABS(step)<1)//整形数据<1的有效判定
	{
		if(ABS(step)*step_num<2)
		{
			step = 0;
		}
		else
		{
		  step = (step > 0) ? 1 : -1;
		}
	}
	
	start_point = steepest->lst_out;
	do
	{
		//start_point = steepest->lst_out;
		for(i=0;i<len;i++)
		{
// 			j = steepest->cnt + i + 1;
// 			if( j >= len )	
// 			{
// 				j = j - len; //顺序排列
// 			}
			pow_sum += my_pow(arr[i] - start_point );// /step_num;//除法减小比例**
			
			//start_point += pn *(step_slope_factor *step/len);
		}
			
		if(pow_sum - steepest->lst_pow_sum > 0)
		{		
			if(updw==0)
			{
				on = 0;
			}
			updw = 1;//上升了
			pn = (pn == 1 )? -1:1;

		}
		else
		{
			updw = 0; //正在下降
 			if(step_slope_factor<step_num)
 			{
 				step_slope_factor++;
 			}
		}
			
		steepest->lst_pow_sum = pow_sum;		
		pow_sum = 0;
		start_point += pn *step;//调整
		
		if(++step_cnt > step_num)//限制计算次数
		{
			on = 0;
		}
			//////
			if(step_slope_factor>=2)//限制下降次数1次，节省时间，但会增大滞后，若cpu时间充裕可不用。
			{
				on = 0;

			}
			//////
		
	}
	while(on==1);
	
	steepest->now_out = start_point ;//0.5f *(start_point + steepest->lst_out);//
	
	steepest->now_velocity_xdt = steepest->now_out - steepest->lst_out;
}","{'begin': {'line': 78, 'column': 1}, 'end': {'line': 173, 'column': 2}}",Algorithm_xzhadd\DY_Filter.c,"['{', '""', 'name', '""', ':', ' ', '""', 'steepest', '_', 'descend', '""', ',', ' ', '""', 'summary', '""', ':', ' ', '""', 'steepest', '_', 'descend', '函数', '用于', '计算', '数组', 'arr', '中', '元素', '按照', '给定', '步长', '和', '方向', '进行', '最', '陡', '下降', '的', '过程', '，', '返回', '最', '陡', '下降', '路径', '的', '终点', '。', '""', '}']"
51,51,51,fir_arrange_filter,void,"void fir_arrange_filter(float * arr, int len, int * fil_cnt, float in, float * arr_out)","[{'name': 'arr', 'type': 'float *'}, {'name': 'len', 'type': 'int'}, {'name': 'fil_cnt', 'type': 'int *'}, {'name': 'in', 'type': 'float'}, {'name': 'arr_out', 'type': 'float *'}]","{
""name"": ""fir_arrange_filter"",
""summary"": ""对输入数组进行过滤和排列""
}","void fir_arrange_filter(float *arr,u16 len,u8 *fil_cnt,float in,float *arr_out) //len<=255 len >= 3
{
	//float arrange[len];
	float tmp;
	u8 i,j;
/*
窗口数据处理
*/		
	if( ++*fil_cnt >= len )	
	{
		*fil_cnt = 0; //now
	}
	
	arr[ *fil_cnt ] = in;
/*
窗口数据处理
*/	
	
/*
赋值、排列
*/	
	for(i=0;i<len;i++)
	{
		arr_out[i] = arr[i];
	}
	
	for(i=0;i<len-1;i++)
	{
		for(j=0;j<len-1-i;j++)
		{
			if(arr_out[j]>arr_out[j+1])
			{
				tmp = arr_out[j+1];
				arr_out[j+1] = arr_out[j];
				arr_out[j] = tmp;
			}
		}
	}
/*
赋值、排列
*/		
	

}","{'begin': {'line': 175, 'column': 1}, 'end': {'line': 218, 'column': 2}}",Algorithm_xzhadd\DY_Filter.c,"['{', '\n', '""', 'name', '""', ':', ' ', '""', 'fir', '_', 'arrange', '_', 'filter', '""', ',', '\n', '""', 'summary', '""', ':', ' ', '""', '对', '输入', '数组', '进行', '过滤', '和', '排列', '""', '\n', '}']"
52,52,52,Moving_Average,void,"void Moving_Average(float[] moavarray, int len, int * fil_cnt, float in, float * out)","[{'name': 'moavarray', 'type': 'float[]'}, {'name': 'len', 'type': 'int'}, {'name': 'fil_cnt', 'type': 'int *'}, {'name': 'in', 'type': 'float'}, {'name': 'out', 'type': 'float *'}]",计算滑动平均数，更新数组和计数器，返回调整后的平均值。,"void Moving_Average(float moavarray[],u16 len ,u16 *fil_cnt,float in,float *out)
{
	u16 width_num;
	float last;

	width_num = len ;
	
	if( ++*fil_cnt >= width_num )	
	{
		*fil_cnt = 0; //now
	}
	
	last = moavarray[ *fil_cnt ];
	
	moavarray[ *fil_cnt ] = in;
	
	*out += ( in - ( last  ) )/(float)( width_num ) ;
	//*out += 0.00001f *(in - *out);
	*out += 0.00001f *LIMIT((in - *out),-1,1);  //数据精度误差修正
	
}","{'begin': {'line': 223, 'column': 2}, 'end': {'line': 243, 'column': 2}}",Algorithm_xzhadd\DY_Filter.c,"['计算', '滑动', '平均', '均数', '平均数', '，', '更新', '数组', '和', '计数', '计数器', '，', '返回', '调整', '后', '的', '平均', '均值', '平均值', '。']"
53,53,53,LPF_1,void,"void LPF_1(float hz, float time, float in, float * out)","[{'name': 'hz', 'type': 'float'}, {'name': 'time', 'type': 'float'}, {'name': 'in', 'type': 'float'}, {'name': 'out', 'type': 'float *'}]",对输入信号进行低通滤波处理，输出滤波后的信号。,"void LPF_1(float hz,float time,float in,float *out)  
{
	*out += ( 1 / ( 1 + 1 / ( hz *6.28f *time ) ) ) *( in - *out );

}","{'begin': {'line': 245, 'column': 1}, 'end': {'line': 249, 'column': 2}}",Algorithm_xzhadd\DY_Filter.c,"['对', '输入', '信号', '进行', '低', '滤波', '通滤波', '处理', '，', '输出', '滤波', '后', '的', '信号', '。']"
54,54,54,LPF_1_db,void,"void LPF_1_db(float hz, float time, double in, double * out)","[{'name': 'hz', 'type': 'float'}, {'name': 'time', 'type': 'float'}, {'name': 'in', 'type': 'double'}, {'name': 'out', 'type': 'double *'}]",LPF_1_db函数对输入信号进行低通滤波处理，输出滤波后的信号。,"void LPF_1_db(float hz,float time,double in,double *out)
{
	*out += ( 1 / ( 1 + 1 / ( hz *6.28f *time ) ) ) *( in - *out );

}","{'begin': {'line': 251, 'column': 1}, 'end': {'line': 255, 'column': 2}}",Algorithm_xzhadd\DY_Filter.c,"['LPF', '_', '1', '_', 'db', '函数', '对', '输入', '信号', '进行', '低', '滤波', '通滤波', '处理', '，', '输出', '滤波', '后', '的', '信号', '。']"
55,55,55,step_filter,void,"void step_filter(float step, float in, float * out)","[{'name': 'step', 'type': 'float'}, {'name': 'in', 'type': 'float'}, {'name': 'out', 'type': 'float *'}]",根据输入值in与输出值out的差值与step的关系，调整输出值out的值。,"void step_filter(float step,float in,float *out) 
{
	if(in - *out > step)
	{
		*out += step;
	}
	else if(in - *out < -step)
	{
		*out -= step;
	}
	else
	{
		*out = in;
	}

}","{'begin': {'line': 257, 'column': 1}, 'end': {'line': 272, 'column': 2}}",Algorithm_xzhadd\DY_Filter.c,"['根据', '输入', '值', 'in', '与', '输出', '值', 'out', '的', '差值', '与', 'step', '的', '关系', '，', '调整', '输出', '值', 'out', '的', '值', '。']"
56,56,56,my_hpf_limited,float,"float my_hpf_limited(float T, float hz, float x, float zoom, float * zoom_adj)","[{'name': 'T', 'type': 'float'}, {'name': 'hz', 'type': 'float'}, {'name': 'x', 'type': 'float'}, {'name': 'zoom', 'type': 'float'}, {'name': 'zoom_adj', 'type': 'float *'}]","{
""name"": ""my_hpf_limited"",
""summary"": ""计算并限制高频脉冲宽度""
}","float my_hpf_limited(float T,float hz,float x,float zoom,float *zoom_adj)
{

	
	*zoom_adj += ( 1 / ( 1 + 1 / ( hz *6.28f *T ) ) ) *(x - *zoom_adj);
	*zoom_adj = LIMIT(*zoom_adj,-zoom,zoom);
	return (x - *zoom_adj);

}","{'begin': {'line': 274, 'column': 1}, 'end': {'line': 282, 'column': 2}}",Algorithm_xzhadd\DY_Filter.c,"['{', '\n', '""', 'name', '""', ':', ' ', '""', 'my', '_', 'hpf', '_', 'limited', '""', ',', '\n', '""', 'summary', '""', ':', ' ', '""', '计算', '并', '限制', '高频', '脉冲', '宽度', '""', '\n', '}']"
57,57,57,simple_3d_trans,void,"void simple_3d_trans(float ref, float in, float out)","[{'name': 'ref', 'type': 'float'}, {'name': 'in', 'type': 'float'}, {'name': 'out', 'type': 'float'}]",简单3D转换函数，用于在水平面附近有限范围内转换坐标。,"void simple_3d_trans(float ref[VEC_XYZ], float in[VEC_XYZ], float out[VEC_XYZ]) //该函数只有在水平面附近一个有限的范围内正确。
{
	static s8 pn;
	static float h_tmp_x,h_tmp_y;
	
	h_tmp_x = my_sqrt(my_pow(ref[Z]) + my_pow(ref[Y]));
	h_tmp_y = my_sqrt(my_pow(ref[Z]) + my_pow(ref[X]));
	
	pn = ref[Z] < 0? -1 : 1;
	
	  out[X] = ( h_tmp_x *in[X] - pn *ref[X] *in[Z] ) ;
		out[Y] = ( pn *h_tmp_y *in[Y] - ref[Y] *in[Z] ) ;
	
// 	 out[X] = h_tmp_x *in[X] - ref[X] *in[Z];
// 	 out[Y] = ref[Z] *in[Y] - ref[Y] *in[Z];
	
	out[Z] = ref[X] *in[X] + ref[Y] *in[Y] + ref[Z] *in[Z] ;

}","{'begin': {'line': 284, 'column': 1}, 'end': {'line': 302, 'column': 2}}",Algorithm_xzhadd\DY_Filter.c,"['简单', '3D', '转换', '函数', '，', '用于', '在', '水平', '平面', '水平面', '附近', '有限', '范围', '转换', '内转换', '坐标', '。']"
58,58,58,vec_3dh_transition,void,"void vec_3dh_transition(float ref, float in, float out)","[{'name': 'ref', 'type': 'float'}, {'name': 'in', 'type': 'float'}, {'name': 'out', 'type': 'float'}]",vec_3dh_transition函数用于将一个三维向量从一种状态过渡到另一种状态。,"void vec_3dh_transition(float ref[VEC_XYZ], float in[VEC_XYZ], float out[VEC_XYZ])
{
	simple_3d_trans(ref,in,out); //
}","{'begin': {'line': 304, 'column': 1}, 'end': {'line': 307, 'column': 2}}",Algorithm_xzhadd\DY_Filter.c,"['vec', '_', '3dh', '_', 'transition', '函数', '用于', '将', '一个', '三维', '一个三维', '向量', '从', '一种', '状态', '过渡', '到', '另', '一种', '状态', '。']"
59,59,59,vec_3dh_transition_matrix,void,"void vec_3dh_transition_matrix(float ref, float wh_matrix)","[{'name': 'ref', 'type': 'float'}, {'name': 'wh_matrix', 'type': 'float'}]",根据输入的参考向量和平移矩阵，计算3D空间中的过渡矩阵。,"void vec_3dh_transition_matrix(float ref[VEC_XYZ],float wh_matrix[VEC_XYZ][VEC_XYZ])
{

}","{'begin': {'line': 309, 'column': 1}, 'end': {'line': 312, 'column': 2}}",Algorithm_xzhadd\DY_Filter.c,"['根据', '输入', '的', '参考', '向量', '和', '平移', '矩阵', '，', '计算', '3D', '空间', '中', '的', '过渡', '矩阵', '。']"
60,60,60,dlon_180,int,int dlon_180(int x),"[{'name': 'x', 'type': 'int'}]",将输入的整数x转换到-180°到180°之间,"s32 dlon_180(s32 x) //10^-7
{
	return (x>1800000000?(x-3600000000):(x<-1800000000?(x+3600000000):x));

}","{'begin': {'line': 5, 'column': 1}, 'end': {'line': 9, 'column': 2}}",Algorithm_xzhadd\DY_Imu.c,"['将', '输入', '的', '整数', 'x', '转换', '到', '-', '180', '°', '到', '180', '°', '之间']"
61,61,61,dlon_180,int,int dlon_180(int x),"[{'name': 'x', 'type': 'int'}]","{""name"": ""dlon_180"", ""summary"": ""将输入的整数x转换为-180°到180°之间的值""}","s32 dlon_180(s32 x) //10^-7
{
	return (x>1800000000?(x-3600000000):(x<-1800000000?(x+3600000000):x));

}","{'begin': {'line': 5, 'column': 1}, 'end': {'line': 9, 'column': 2}}",Algorithm_xzhadd\DY_MotionCal.c,"['{', '""', 'name', '""', ':', ' ', '""', 'dlon', '_', '180', '""', ',', ' ', '""', 'summary', '""', ':', ' ', '""', '将', '输入', '的', '整数', 'x', '转换', '为', '-', '180', '°', '到', '180', '°', '之间', '的', '值', '""', '}']"
62,62,62,dlon_180,int,int dlon_180(int x),"[{'name': 'x', 'type': 'int'}]",将输入的整数x在-1800000000到1800000000之间转换为0到3600000000之间的角度值,"s32 dlon_180(s32 x) //10^-7
{
	return (x>1800000000?(x-3600000000):(x<-1800000000?(x+3600000000):x));

}","{'begin': {'line': 5, 'column': 1}, 'end': {'line': 9, 'column': 2}}",Algorithm_xzhadd\DY_Navigate.c,"['将', '输入', '的', '整数', 'x', '在', '-', '1800000000', '到', '1800000000', '之间', '转换', '为', '0', '到', '3600000000', '之间', '的', '角度', '值']"
63,63,63,ADC0_Init,void,void ADC0_Init(),[],初始化ADC0，配置系统控制寄存器，设置时钟和序列，启用中断。,"void ADC0_Init(void)
{
  MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_ADC0);
  while(!MAP_SysCtlPeripheralReady(SYSCTL_PERIPH_ADC0))
  {
  }
  MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOD);
  while(!MAP_SysCtlPeripheralReady(SYSCTL_PERIPH_GPIOD))
  {
  }
  
  MAP_GPIOPinTypeADC(GPIO_PORTD_BASE, GPIO_PIN_7);
  
  ADCClockConfigSet(ADC0_BASE, ADC_CLOCK_SRC_PLL | ADC_CLOCK_RATE_HALF, 30);    //480MHz/30=16MHz
  MAP_ADCSequenceConfigure(ADC0_BASE, 3, ADC_TRIGGER_ALWAYS, 0);
  MAP_ADCSequenceStepConfigure(ADC0_BASE, 3, 0, ADC_CTL_CH4 | ADC_CTL_IE | ADC_CTL_END);
  MAP_ADCSequenceEnable(ADC0_BASE, 3);
  
  MAP_ADCIntClear(ADC0_BASE, 3);
  MAP_ADCIntEnableEx(ADC0_BASE, ADC_INT_SS3);
  MAP_IntEnable(INT_ADC0SS3);
}","{'begin': {'line': 5, 'column': 1}, 'end': {'line': 26, 'column': 2}}",Application\Src\DY_Scheduler.c,"['初始', '初始化', 'ADC0', '，', '配置', '系统', '控制', '系统控制', '寄存', '寄存器', '，', '设置', '时钟', '和', '序列', '，', '启用', '中断', '。']"
64,64,64,ADC0SS3_IRQHandler,void,void ADC0SS3_IRQHandler(),[],清除ADC0SS3中断标志并获取序列数据,"void ADC0SS3_IRQHandler(void)
{
  MAP_ADCIntClearEx(ADC0_BASE, ADC_INT_SS3);
  MAP_ADCSequenceDataGet(ADC0_BASE, 3, adc0_value);
}","{'begin': {'line': 28, 'column': 1}, 'end': {'line': 32, 'column': 2}}",Application\Src\DY_Scheduler.c,"['清除', 'ADC0SS3', '中断', '标志', '并', '获取', '序列', '数据']"
65,65,65,Drv_Icm20602CSPin_Init,void,void Drv_Icm20602CSPin_Init(),[],初始化ICM20602的CS引脚，开启相关时钟，并配置为输出模式，最后将PN2输出设置为1。,"void Drv_Icm20602CSPin_Init(void)
{
    MAP_SysCtlPeripheralEnable(ICM20602_CS_SYSCTL);          // 开启传感器CS引脚对应时钟 CS:PN2
    while(!(MAP_SysCtlPeripheralReady(ICM20602_CS_SYSCTL)))
    {
    }
    
    GPIOPinTypeGPIOOutput(ICM20602_CS_GPIO, ICM20602_CS_PIN);// 设置PN2模式为输出
    
    GPIOPinWrite(ICM20602_CS_GPIO, ICM20602_CS_PIN, ICM20602_CS_PIN); // 设置设置PN2输出1
}","{'begin': {'line': 13, 'column': 1}, 'end': {'line': 23, 'column': 2}}",Application\Src\operation.c,"['初始', '初始化', 'ICM20602', '的', 'CS', '引脚', '，', '开启', '相关', '时钟', '，', '并', '配置', '为', '输出', '模式', '，', '最后', '将', 'PN2', '输出', '设置', '为', '1', '。']"
66,66,66,ADC0_Init,void,void ADC0_Init(),[],初始化ADC0外设，配置时钟、序列和中断。,"void ADC0_Init(void)
{
  MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_ADC0);
  while(!MAP_SysCtlPeripheralReady(SYSCTL_PERIPH_ADC0))
  {
  }
  MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOD);
  while(!MAP_SysCtlPeripheralReady(SYSCTL_PERIPH_GPIOD))
  {
  }
  
  MAP_GPIOPinTypeADC(GPIO_PORTD_BASE, GPIO_PIN_7);
  
  ADCClockConfigSet(ADC0_BASE, ADC_CLOCK_SRC_PLL | ADC_CLOCK_RATE_HALF, 30);    //480MHz/30=16MHz
  MAP_ADCSequenceConfigure(ADC0_BASE, 3, ADC_TRIGGER_ALWAYS, 0);
  MAP_ADCSequenceStepConfigure(ADC0_BASE, 3, 0, ADC_CTL_CH4 | ADC_CTL_IE | ADC_CTL_END);
  MAP_ADCSequenceEnable(ADC0_BASE, 3);
  
  MAP_ADCIntClear(ADC0_BASE, 3);
  MAP_ADCIntEnableEx(ADC0_BASE, ADC_INT_SS3);
  MAP_IntEnable(INT_ADC0SS3);
}","{'begin': {'line': 5, 'column': 1}, 'end': {'line': 26, 'column': 2}}",Drive\Src\Drv_adc.c,"['初始', '初始化', 'ADC0', '外设', '，', '配置', '时钟', '、', '序列', '和', '中断', '。']"
67,67,67,ADC0SS3_IRQHandler,void,void ADC0SS3_IRQHandler(),[],清除ADC0SS3中断标志并获取序列数据,"void ADC0SS3_IRQHandler(void)
{
  MAP_ADCIntClearEx(ADC0_BASE, ADC_INT_SS3);
  MAP_ADCSequenceDataGet(ADC0_BASE, 3, adc0_value);
}","{'begin': {'line': 28, 'column': 1}, 'end': {'line': 32, 'column': 2}}",Drive\Src\Drv_adc.c,"['清除', 'ADC0SS3', '中断', '标志', '并', '获取', '序列', '数据']"
68,68,68,Drv_Icm20602CSPin_Init,void,void Drv_Icm20602CSPin_Init(),[],初始化ICM20602的CS引脚，设置为输出模式并输出高电平,"void Drv_Icm20602CSPin_Init(void)
{
    MAP_SysCtlPeripheralEnable(ICM20602_CS_SYSCTL);          // 开启传感器CS引脚对应时钟 CS:PN2
    while(!(MAP_SysCtlPeripheralReady(ICM20602_CS_SYSCTL)))
    {
    }
    
    GPIOPinTypeGPIOOutput(ICM20602_CS_GPIO, ICM20602_CS_PIN);// 设置PN2模式为输出
    
    GPIOPinWrite(ICM20602_CS_GPIO, ICM20602_CS_PIN, ICM20602_CS_PIN); // 设置设置PN2输出1
}","{'begin': {'line': 13, 'column': 1}, 'end': {'line': 23, 'column': 2}}",Drive\Src\Drv_ak8975.c,"['初始', '初始化', 'ICM20602', '的', 'CS', '引脚', '，', '设置', '为', '输出', '模式', '并', '输出', '电平', '高电平']"
69,69,69,Drv_Icm20602CSPin_Init,void,void Drv_Icm20602CSPin_Init(),[],初始化ICM20602的CS引脚，开启相关时钟并设置输出模式为输出，最后将PN2输出设置为1,"void Drv_Icm20602CSPin_Init(void)
{
    MAP_SysCtlPeripheralEnable(ICM20602_CS_SYSCTL);          // 开启传感器CS引脚对应时钟 CS:PN2
    while(!(MAP_SysCtlPeripheralReady(ICM20602_CS_SYSCTL)))
    {
    }
    
    GPIOPinTypeGPIOOutput(ICM20602_CS_GPIO, ICM20602_CS_PIN);// 设置PN2模式为输出
    
    GPIOPinWrite(ICM20602_CS_GPIO, ICM20602_CS_PIN, ICM20602_CS_PIN); // 设置设置PN2输出1
}","{'begin': {'line': 13, 'column': 1}, 'end': {'line': 23, 'column': 2}}",Drive\Src\Drv_icm20602.c,"['初始', '初始化', 'ICM20602', '的', 'CS', '引脚', '，', '开启', '相关', '时钟', '并', '设置', '输出', '模式', '为', '输出', '，', '最后', '将', 'PN2', '输出', '设置', '为', '1']"
70,70,70,Drv_SPL06CSPin_Init,void,void Drv_SPL06CSPin_Init(),[],初始化SPL06 CSPin外设,"void Drv_SPL06CSPin_Init ( void )
{
    MAP_SysCtlPeripheralEnable(SPL06_CS_SYSCTL);
    while(!(MAP_SysCtlPeripheralReady(SPL06_CS_SYSCTL)))
    {
    }
    GPIOPinTypeGPIOOutput(SPL06_CS_GPIO, SPL06_CS_PIN);
    
    GPIOPinWrite(SPL06_CS_GPIO, SPL06_CS_PIN, SPL06_CS_PIN);
}","{'begin': {'line': 10, 'column': 1}, 'end': {'line': 19, 'column': 2}}",Drive\Src\Drv_spl06.c,"['初始', '初始化', 'SPL06', ' ', 'CSPin', '外设']"
71,71,71,inte_fix_filter,void,"void inte_fix_filter(float dT, int * data)","[{'name': 'dT', 'type': 'float'}, {'name': 'data', 'type': 'int *'}]",根据数据点数量和限制值处理滤波后的数据点,"void inte_fix_filter(float dT,_inte_fix_filter_st *data)
{
	float ei_lim_val;
	
	if(data->ei_limit>0)
	{		
		ei_lim_val = LIMIT(data->ei,-data->ei_limit,data->ei_limit);
	}
	else
	{
		ei_lim_val = data->ei;
	}	
	
	data->out = (data->in_est + ei_lim_val);
	
	data->e = data->fix_ki *(data->in_obs - data->out);

	data->ei += data->e *dT;

}","{'begin': {'line': 9, 'column': 1}, 'end': {'line': 28, 'column': 2}}",Drive\Vl53l0x\Src\vl53l0x_api_ranging.c,"['根据', '数据', '点', '数量', '和', '限制', '值', '处理', '滤波', '后', '的', '数据', '点']"
72,72,72,fix_inte_filter,void,"void fix_inte_filter(float dT, int * data)","[{'name': 'dT', 'type': 'float'}, {'name': 'data', 'type': 'int *'}]",根据输入的dT和数据指针，更新滤波器参数，包括输出值、中间估计误差、真实误差和限制后的误差。,"void fix_inte_filter(float dT,_fix_inte_filter_st *data)
{
	
	data->out += (data->in_est_d + data->e ) *dT;
	
	data->e = data->fix_kp *(data->in_obs - data->out);

	if(data->e_limit>0)
	{		
		data->e = LIMIT(data->e,-data->e_limit,data->e_limit);
	}
	
}","{'begin': {'line': 30, 'column': 1}, 'end': {'line': 42, 'column': 2}}",Drive\Vl53l0x\Src\vl53l0x_api_ranging.c,"['根据', '输入', '的', 'dT', '和', '数据', '指针', '，', '更新', '滤波', '滤波器', '参数', '，', '包括', '输出', '值', '、', '中间', '估计', '误差', '、', '真实', '误差', '和', '限制', '后', '的', '误差', '。']"
73,73,73,limit_filter,void,"void limit_filter(float T, float hz, int * data, float in)","[{'name': 'T', 'type': 'float'}, {'name': 'hz', 'type': 'float'}, {'name': 'data', 'type': 'int *'}, {'name': 'in', 'type': 'float'}]",对输入数据进行增量滤波，适合大噪声低滞后场景，收敛快。,"void limit_filter(float T,float hz,_lf_t *data,float in) //增量滤波，适合大噪声低滞后（无缝），收敛最快
{
	float abs_t;
// 	LPF_1(hz,T,	 in,&(data->lpf_1)); 
// 	abs_t = ABS(data->lpf_1);
// 	data->out = LIMIT(in,-abs_t,abs_t);
	LPF_1_(hz,T,	 in,(data->lpf_1)); 
 	abs_t = ABS(in);
	data->out = LIMIT((data->lpf_1),-abs_t,abs_t);
}","{'begin': {'line': 44, 'column': 1}, 'end': {'line': 53, 'column': 2}}",Drive\Vl53l0x\Src\vl53l0x_api_ranging.c,"['对', '输入', '数据', '进行', '增量', '滤波', '，', '适合', '大', '噪声', '低', '滞后', '场景', '，', '收敛', '快', '。']"
74,74,74,limit_filter_2,void,"void limit_filter_2(float T, float hz, int * data, float in)","[{'name': 'T', 'type': 'float'}, {'name': 'hz', 'type': 'float'}, {'name': 'data', 'type': 'int *'}, {'name': 'in', 'type': 'float'}]",增量滤波，均衡，但滞后稍大，对数据进行反向等待低通反向处理,"void limit_filter_2(float T,float hz,_lf_t *data,float in) //增量滤波，均衡，但滞后稍大(数据反向等待低通反向)
{
	float abs_t;
	LPF_1_(hz,T,	 in,(data->lpf_1)); 
	abs_t = ABS(data->lpf_1);
	data->out = LIMIT(in,-abs_t,abs_t);
// 	LPF_1(hz,T,	 in,&(data->lpf_1)); 
//  	abs_t = ABS(in);
// 	data->out = LIMIT((data->lpf_1),-abs_t,abs_t);
}","{'begin': {'line': 55, 'column': 1}, 'end': {'line': 64, 'column': 2}}",Drive\Vl53l0x\Src\vl53l0x_api_ranging.c,"['增量', '滤波', '，', '均衡', '，', '但', '滞后', '稍大', '，', '对', '数据', '进行', '反向', '等待', '低通', '反向', '处理']"
75,75,75,limit_filter_3,void,"void limit_filter_3(float T, float hz, int * data, float in)","[{'name': 'T', 'type': 'float'}, {'name': 'hz', 'type': 'float'}, {'name': 'data', 'type': 'int *'}, {'name': 'in', 'type': 'float'}]",增量滤波函数，适用于低噪声滞后较小且噪声大的情况，通过LPF_1_对数据进行滤波处理，并更新输出值和滤波器状态。,"void limit_filter_3(float T,float hz,_lf_t *data,float in) //增量滤波，适合低噪声滞后较小(等幅大噪声平行不收敛),噪声大收敛过慢
{
	float abs_t;
	LPF_1_(hz,T,	 in,(data->lpf_1)); 
	abs_t = ABS(in);
	data->out = data->lpf_1 = LIMIT((data->lpf_1),-abs_t,abs_t);

}","{'begin': {'line': 66, 'column': 1}, 'end': {'line': 73, 'column': 2}}",Drive\Vl53l0x\Src\vl53l0x_api_ranging.c,"['增量', '滤波', '函数', '，', '适用', '于', '噪声', '低噪声', '滞后', '较小且', '噪声', '大', '的', '情况', '，', '通过', 'LPF', '_', '1', '_', '对', '数据', '进行', '滤波', '处理', '，', '并', '更新', '输出', '值', '和', '滤波', '滤波器', '状态', '。']"
76,76,76,steepest_descend,void,"void steepest_descend(int[] arr, int len, int * steepest, int step_num, int in)","[{'name': 'arr', 'type': 'int[]'}, {'name': 'len', 'type': 'int'}, {'name': 'steepest', 'type': 'int *'}, {'name': 'step_num', 'type': 'int'}, {'name': 'in', 'type': 'int'}]",计算数组中每一步最陡峭的下降方向，并更新最陡峭方向和速度。,"void steepest_descend(s32 arr[],u8 len,_steepest_st *steepest,u8 step_num,s32 in)
{	
	u8 updw = 1;//0 dw,1up
	s16 i;
	u8 step_cnt=0;
	u8 step_slope_factor=1;
	u8 on = 1;
	s8 pn = 1;
	//float last = 0;
	float step = 0;
	s32 start_point = 0;
	s32 pow_sum = 0;
	
	steepest->lst_out = steepest->now_out;
	
	if( ++(steepest->cnt) >= len )	
	{
		(steepest->cnt) = 0; //now
	}
	
	//last = arr[ (steepest->cnt) ];
	
	arr[ (steepest->cnt) ] = in;
	
	step = (float)(in - steepest->lst_out)/step_num ;//梯度
	
	if(ABS(step)<1)//整形数据<1的有效判定
	{
		if(ABS(step)*step_num<2)
		{
			step = 0;
		}
		else
		{
		  step = (step > 0) ? 1 : -1;
		}
	}
	
	start_point = steepest->lst_out;
	do
	{
		//start_point = steepest->lst_out;
		for(i=0;i<len;i++)
		{
// 			j = steepest->cnt + i + 1;
// 			if( j >= len )	
// 			{
// 				j = j - len; //顺序排列
// 			}
			pow_sum += my_pow(arr[i] - start_point );// /step_num;//除法减小比例**
			
			//start_point += pn *(step_slope_factor *step/len);
		}
			
		if(pow_sum - steepest->lst_pow_sum > 0)
		{		
			if(updw==0)
			{
				on = 0;
			}
			updw = 1;//上升了
			pn = (pn == 1 )? -1:1;

		}
		else
		{
			updw = 0; //正在下降
 			if(step_slope_factor<step_num)
 			{
 				step_slope_factor++;
 			}
		}
			
		steepest->lst_pow_sum = pow_sum;		
		pow_sum = 0;
		start_point += pn *step;//调整
		
		if(++step_cnt > step_num)//限制计算次数
		{
			on = 0;
		}
			//////
			if(step_slope_factor>=2)//限制下降次数1次，节省时间，但会增大滞后，若cpu时间充裕可不用。
			{
				on = 0;

			}
			//////
		
	}
	while(on==1);
	
	steepest->now_out = start_point ;//0.5f *(start_point + steepest->lst_out);//
	
	steepest->now_velocity_xdt = steepest->now_out - steepest->lst_out;
}","{'begin': {'line': 78, 'column': 1}, 'end': {'line': 173, 'column': 2}}",Drive\Vl53l0x\Src\vl53l0x_api_ranging.c,"['计算', '数组', '中', '每', '一步', '最', '陡峭', '的', '下降', '方向', '，', '并', '更新', '最', '陡峭', '方向', '和', '速度', '。']"
77,77,77,fir_arrange_filter,void,"void fir_arrange_filter(float * arr, int len, int * fil_cnt, float in, float * arr_out)","[{'name': 'arr', 'type': 'float *'}, {'name': 'len', 'type': 'int'}, {'name': 'fil_cnt', 'type': 'int *'}, {'name': 'in', 'type': 'float'}, {'name': 'arr_out', 'type': 'float *'}]",对输入数组进行过滤和排列,"void fir_arrange_filter(float *arr,u16 len,u8 *fil_cnt,float in,float *arr_out) //len<=255 len >= 3
{
	//float arrange[len];
	float tmp;
	u8 i,j;
/*
窗口数据处理
*/		
	if( ++*fil_cnt >= len )	
	{
		*fil_cnt = 0; //now
	}
	
	arr[ *fil_cnt ] = in;
/*
窗口数据处理
*/	
	
/*
赋值、排列
*/	
	for(i=0;i<len;i++)
	{
		arr_out[i] = arr[i];
	}
	
	for(i=0;i<len-1;i++)
	{
		for(j=0;j<len-1-i;j++)
		{
			if(arr_out[j]>arr_out[j+1])
			{
				tmp = arr_out[j+1];
				arr_out[j+1] = arr_out[j];
				arr_out[j] = tmp;
			}
		}
	}
/*
赋值、排列
*/		
	

}","{'begin': {'line': 175, 'column': 1}, 'end': {'line': 218, 'column': 2}}",Drive\Vl53l0x\Src\vl53l0x_api_ranging.c,"['对', '输入', '数组', '进行', '过滤', '和', '排列']"
78,78,78,Moving_Average,void,"void Moving_Average(float[] moavarray, int len, int * fil_cnt, float in, float * out)","[{'name': 'moavarray', 'type': 'float[]'}, {'name': 'len', 'type': 'int'}, {'name': 'fil_cnt', 'type': 'int *'}, {'name': 'in', 'type': 'float'}, {'name': 'out', 'type': 'float *'}]",计算滑动平均数，更新数组元素，并输出结果。,"void Moving_Average(float moavarray[],u16 len ,u16 *fil_cnt,float in,float *out)
{
	u16 width_num;
	float last;

	width_num = len ;
	
	if( ++*fil_cnt >= width_num )	
	{
		*fil_cnt = 0; //now
	}
	
	last = moavarray[ *fil_cnt ];
	
	moavarray[ *fil_cnt ] = in;
	
	*out += ( in - ( last  ) )/(float)( width_num ) ;
	//*out += 0.00001f *(in - *out);
	*out += 0.00001f *LIMIT((in - *out),-1,1);  //数据精度误差修正
	
}","{'begin': {'line': 223, 'column': 2}, 'end': {'line': 243, 'column': 2}}",Drive\Vl53l0x\Src\vl53l0x_api_ranging.c,"['计算', '滑动', '平均', '均数', '平均数', '，', '更新', '数组', '元素', '，', '并', '输出', '结果', '。']"
79,79,79,LPF_1,void,"void LPF_1(float hz, float time, float in, float * out)","[{'name': 'hz', 'type': 'float'}, {'name': 'time', 'type': 'float'}, {'name': 'in', 'type': 'float'}, {'name': 'out', 'type': 'float *'}]",LPF_1函数用于低通滤波，输入频率、时间、输入值及输出值指针，计算并更新输出值。,"void LPF_1(float hz,float time,float in,float *out)  
{
	*out += ( 1 / ( 1 + 1 / ( hz *6.28f *time ) ) ) *( in - *out );

}","{'begin': {'line': 245, 'column': 1}, 'end': {'line': 249, 'column': 2}}",Drive\Vl53l0x\Src\vl53l0x_api_ranging.c,"['LPF', '_', '1', '函数', '用于', '低', '滤波', '通滤波', '，', '输入', '频率', '、', '时间', '、', '输入', '值及', '输出', '值', '指针', '，', '计算', '并', '更新', '输出', '值', '。']"
80,80,80,VL53L0X_write_multi,int,"int VL53L0X_write_multi(int address, int reg, int * pdata, int count)","[{'name': 'address', 'type': 'int'}, {'name': 'reg', 'type': 'int'}, {'name': 'pdata', 'type': 'int *'}, {'name': 'count', 'type': 'int'}]",VL53L0X_write_multi函数用于向指定地址和寄存器写入数据，参数包括地址、寄存器号、数据指针和写入次数。,"int32_t VL53L0X_write_multi(uint8_t address, uint8_t reg, uint8_t *pdata, int32_t count)
{
    int32_t status = STATUS_OK;
	if(IIC_Write_nByte(address,reg,count,pdata)==0)
		status = STATUS_OK;
	else
		status = STATUS_FAIL;
	
    return status;
}","{'begin': {'line': 3, 'column': 1}, 'end': {'line': 12, 'column': 2}}",Drive\Vl53l0x\Src\vl53l0x_i2c.c,"['VL53L0X', '_', 'write', '_', 'multi', '函数', '用于', '向', '指定', '地址', '和', '寄存', '寄存器', '写入', '数据', '，', '参数', '包括', '地址', '、', '寄存', '寄存器', '号', '、', '数据', '指针', '和', '写入', '次数', '。']"
81,81,81,VL53L0X_read_multi,int,"int VL53L0X_read_multi(int address, int index, int * pdata, int count)","[{'name': 'address', 'type': 'int'}, {'name': 'index', 'type': 'int'}, {'name': 'pdata', 'type': 'int *'}, {'name': 'count', 'type': 'int'}]",VL53L0X_read_multi函数用于读取IIC存储器中的数据。,"int32_t VL53L0X_read_multi(uint8_t address,  uint8_t index, uint8_t  *pdata, int32_t count)
{
    int32_t status = STATUS_OK;
    
	if(IIC_Read_nByte(address, index, count, pdata)==0)
		status = STATUS_OK;
	else
		status = STATUS_FAIL;

    return status;
}","{'begin': {'line': 13, 'column': 1}, 'end': {'line': 23, 'column': 2}}",Drive\Vl53l0x\Src\vl53l0x_i2c.c,"['VL53L0X', '_', 'read', '_', 'multi', '函数', '用于', '读取', 'IIC', '存储', '存储器', '中', '的', '数据', '。']"
82,82,82,VL53L0X_write_byte,int,"int VL53L0X_write_byte(int address, int index, int data)","[{'name': 'address', 'type': 'int'}, {'name': 'index', 'type': 'int'}, {'name': 'data', 'type': 'int'}]",向VL53L0X写入一个字节的数据。,"int32_t VL53L0X_write_byte(uint8_t address, uint8_t index, uint8_t data)
{
    int32_t status = STATUS_OK;
    const int32_t cbyte_count = 1;
    status = VL53L0X_write_multi(address, index, &data, cbyte_count);
    return status;
}","{'begin': {'line': 26, 'column': 1}, 'end': {'line': 32, 'column': 2}}",Drive\Vl53l0x\Src\vl53l0x_i2c.c,"['向', 'VL53L0X', '写入', '一个', '字节', '的', '数据', '。']"
83,83,83,VL53L0X_write_word,int,"int VL53L0X_write_word(int address, int index, int data)","[{'name': 'address', 'type': 'int'}, {'name': 'index', 'type': 'int'}, {'name': 'data', 'type': 'int'}]",VL53L0X_write_word函数用于向指定地址和索引写入一个16位的数据字。,"int32_t VL53L0X_write_word(uint8_t address, uint8_t index, uint16_t data)
{
    int32_t status = STATUS_OK;
    uint8_t  buffer[BYTES_PER_WORD];

    // Split 16-bit word into MS and LS uint8_t
    buffer[0] = (uint8_t)(data >> 8);
    buffer[1] = (uint8_t)(data &  0x00FF);

    if(index%2 == 1)
    {
        status = VL53L0X_write_multi(address, index, &buffer[0], 1);
        status = VL53L0X_write_multi(address, index + 1, &buffer[1], 1);
        // serial comms cannot handle word writes to non 2-byte aligned registers.
    }
    else
    {
        status = VL53L0X_write_multi(address, index, buffer, BYTES_PER_WORD);
    }

    return status;

}","{'begin': {'line': 35, 'column': 1}, 'end': {'line': 57, 'column': 2}}",Drive\Vl53l0x\Src\vl53l0x_i2c.c,"['VL53L0X', '_', 'write', '_', 'word', '函数', '用于', '向', '指定', '地址', '和', '索引', '写入', '一个', '16', '位', '的', '数据', '数据字', '。']"
84,84,84,VL53L0X_write_dword,int,"int VL53L0X_write_dword(int address, int index, int data)","[{'name': 'address', 'type': 'int'}, {'name': 'index', 'type': 'int'}, {'name': 'data', 'type': 'int'}]",将32位数据按字节拆分后写入指定地址和索引。,"int32_t VL53L0X_write_dword(uint8_t address, uint8_t index, uint32_t data)
{
    int32_t status = STATUS_OK;
    uint8_t  buffer[BYTES_PER_DWORD];

    // Split 32-bit word into MS ... LS bytes
    buffer[0] = (uint8_t) (data >> 24);
    buffer[1] = (uint8_t)((data &  0x00FF0000) >> 16);
    buffer[2] = (uint8_t)((data &  0x0000FF00) >> 8);
    buffer[3] = (uint8_t) (data &  0x000000FF);

    status = VL53L0X_write_multi(address, index, buffer, BYTES_PER_DWORD);

    return status;

}","{'begin': {'line': 60, 'column': 1}, 'end': {'line': 75, 'column': 2}}",Drive\Vl53l0x\Src\vl53l0x_i2c.c,"['将', '32', '位', '数据', '按', '字节', '拆分', '后', '写入', '指定', '地址', '和', '索引', '。']"
85,85,85,VL53L0X_read_byte,int,"int VL53L0X_read_byte(int address, int index, int * pdata)","[{'name': 'address', 'type': 'int'}, {'name': 'index', 'type': 'int'}, {'name': 'pdata', 'type': 'int *'}]",VL53L0X_read_byte函数用于从VL53L0X传感器读取单个字节数据。,"int32_t VL53L0X_read_byte(uint8_t address, uint8_t index, uint8_t *pdata)
{
    int32_t status = STATUS_OK;
    int32_t cbyte_count = 1;

    status = VL53L0X_read_multi(address, index, pdata, cbyte_count);

    return status;

}","{'begin': {'line': 78, 'column': 1}, 'end': {'line': 87, 'column': 2}}",Drive\Vl53l0x\Src\vl53l0x_i2c.c,"['VL53L0X', '_', 'read', '_', 'byte', '函数', '用于', '从', 'VL53L0X', '传感', '感器', '传感器', '读取', '单个', '字节', '数据', '。']"
86,86,86,VL53L0X_read_word,int,"int VL53L0X_read_word(int address, int index, int * pdata)","[{'name': 'address', 'type': 'int'}, {'name': 'index', 'type': 'int'}, {'name': 'pdata', 'type': 'int *'}]",VL53L0X_read_word函数用于从VL53L0X传感器读取一字节的数据到指定缓冲区，并返回状态码。,"int32_t VL53L0X_read_word(uint8_t address, uint8_t index, uint16_t *pdata)
{
    int32_t  status = STATUS_OK;
	uint8_t  buffer[BYTES_PER_WORD];

    status = VL53L0X_read_multi(address, index, buffer, BYTES_PER_WORD);
	*pdata = ((uint16_t)buffer[0]<<8) + (uint16_t)buffer[1];

    return status;

}","{'begin': {'line': 90, 'column': 1}, 'end': {'line': 100, 'column': 2}}",Drive\Vl53l0x\Src\vl53l0x_i2c.c,"['VL53L0X', '_', 'read', '_', 'word', '函数', '用于', '从', 'VL53L0X', '传感', '感器', '传感器', '读取', '一', '字节', '的', '数据', '到', '指定', '缓冲', '缓冲区', '，', '并', '返回', '状态', '码', '。']"
87,87,87,VL53L0X_read_dword,int,"int VL53L0X_read_dword(int address, int index, int * pdata)","[{'name': 'address', 'type': 'int'}, {'name': 'index', 'type': 'int'}, {'name': 'pdata', 'type': 'int *'}]",VL53L0X_read_dword函数用于从VL53L0X传感器读取一字节的数据到指定的缓冲区，并返回状态码。,"int32_t VL53L0X_read_dword(uint8_t address, uint8_t index, uint32_t *pdata)
{
    int32_t status = STATUS_OK;
	uint8_t  buffer[BYTES_PER_DWORD];

    status = VL53L0X_read_multi(address, index, buffer, BYTES_PER_DWORD);
    *pdata = ((uint32_t)buffer[0]<<24) + ((uint32_t)buffer[1]<<16) + ((uint32_t)buffer[2]<<8) + (uint32_t)buffer[3];

    return status;

}","{'begin': {'line': 102, 'column': 1}, 'end': {'line': 112, 'column': 2}}",Drive\Vl53l0x\Src\vl53l0x_i2c.c,"['VL53L0X', '_', 'read', '_', 'dword', '函数', '用于', '从', 'VL53L0X', '传感', '感器', '传感器', '读取', '一', '字节', '的', '数据', '到', '指定', '的', '缓冲', '缓冲区', '，', '并', '返回', '状态', '码', '。']"
88,88,88,VL53L0X_LockSequenceAccess,int,int VL53L0X_LockSequenceAccess(int Dev),"[{'name': 'Dev', 'type': 'int'}]",VL53L0X_LockSequenceAccess函数用于访问锁序列，参数为设备编号。,"VL53L0X_Error VL53L0X_LockSequenceAccess(VL53L0X_DEV Dev){
    VL53L0X_Error Status = VL53L0X_ERROR_NONE;

    return Status;
}","{'begin': {'line': 13, 'column': 1}, 'end': {'line': 17, 'column': 2}}",Drive\Vl53l0x\Src\vl53l0x_platform.c,"['VL53L0X', '_', 'LockSequenceAccess', '函数', '用于', '访问', '锁', '序列', '，', '参数', '为', '设备', '编号', '。']"
89,89,89,VL53L0X_UnlockSequenceAccess,int,int VL53L0X_UnlockSequenceAccess(int Dev),"[{'name': 'Dev', 'type': 'int'}]",解锁序列访问功能，返回状态码。,"VL53L0X_Error VL53L0X_UnlockSequenceAccess(VL53L0X_DEV Dev){
    VL53L0X_Error Status = VL53L0X_ERROR_NONE;

    return Status;
}","{'begin': {'line': 19, 'column': 1}, 'end': {'line': 23, 'column': 2}}",Drive\Vl53l0x\Src\vl53l0x_platform.c,"['解锁', '序列', '访问', '功能', '，', '返回', '状态', '码', '。']"
90,90,90,VL53L0X_WriteMulti,int,"int VL53L0X_WriteMulti(int Dev, int index, int * pdata, int count)","[{'name': 'Dev', 'type': 'int'}, {'name': 'index', 'type': 'int'}, {'name': 'pdata', 'type': 'int *'}, {'name': 'count', 'type': 'int'}]",VL53L0X_WriteMulti函数用于向指定设备写入多字节数据。,"VL53L0X_Error VL53L0X_WriteMulti(VL53L0X_DEV Dev, uint8_t index, uint8_t *pdata, uint32_t count){

    VL53L0X_Error Status = VL53L0X_ERROR_NONE;
    int32_t status_int = 0;
	uint8_t deviceAddress;

    if (count>=VL53L0X_MAX_I2C_XFER_SIZE){
        Status = VL53L0X_ERROR_INVALID_PARAMS;
    }

	deviceAddress = Dev->I2cDevAddr;

	status_int = VL53L0X_write_multi(deviceAddress, index, pdata, count);

	if (status_int != 0)
		Status = VL53L0X_ERROR_CONTROL_INTERFACE;

    return Status;
}","{'begin': {'line': 26, 'column': 1}, 'end': {'line': 44, 'column': 2}}",Drive\Vl53l0x\Src\vl53l0x_platform.c,"['VL53L0X', '_', 'WriteMulti', '函数', '用于', '向', '指定', '设备', '写入', '多', '字节', '数据', '。']"
91,91,91,VL53L0X_ReadMulti,int,"int VL53L0X_ReadMulti(int Dev, int index, int * pdata, int count)","[{'name': 'Dev', 'type': 'int'}, {'name': 'index', 'type': 'int'}, {'name': 'pdata', 'type': 'int *'}, {'name': 'count', 'type': 'int'}]",VL53L0X读取多字节数据，参数包括设备地址、索引、数据指针和数据量。,"VL53L0X_Error VL53L0X_ReadMulti(VL53L0X_DEV Dev, uint8_t index, uint8_t *pdata, uint32_t count){
    VL53L0X_I2C_USER_VAR
    VL53L0X_Error Status = VL53L0X_ERROR_NONE;
    int32_t status_int;
	uint8_t deviceAddress;

    if (count>=VL53L0X_MAX_I2C_XFER_SIZE){
        Status = VL53L0X_ERROR_INVALID_PARAMS;
    }

    deviceAddress = Dev->I2cDevAddr;

	status_int = VL53L0X_read_multi(deviceAddress, index, pdata, count);

	if (status_int != 0)
		Status = VL53L0X_ERROR_CONTROL_INTERFACE;

    return Status;
}","{'begin': {'line': 47, 'column': 1}, 'end': {'line': 65, 'column': 2}}",Drive\Vl53l0x\Src\vl53l0x_platform.c,"['VL53L0X', '读取', '多', '字节', '数据', '，', '参数', '包括', '设备', '地址', '、', '索引', '、', '数据', '指针', '和', '数据', '数据量', '。']"
92,92,92,VL53L0X_WrByte,int,"int VL53L0X_WrByte(int Dev, int index, int data)","[{'name': 'Dev', 'type': 'int'}, {'name': 'index', 'type': 'int'}, {'name': 'data', 'type': 'int'}]",向指定设备写入一个字节的数据，返回操作状态。,"VL53L0X_Error VL53L0X_WrByte(VL53L0X_DEV Dev, uint8_t index, uint8_t data){
    VL53L0X_Error Status = VL53L0X_ERROR_NONE;
    int32_t status_int;
	uint8_t deviceAddress;

    deviceAddress = Dev->I2cDevAddr;

	status_int = VL53L0X_write_byte(deviceAddress, index, data);

	if (status_int != 0)
		Status = VL53L0X_ERROR_CONTROL_INTERFACE;

    return Status;
}","{'begin': {'line': 68, 'column': 1}, 'end': {'line': 81, 'column': 2}}",Drive\Vl53l0x\Src\vl53l0x_platform.c,"['向', '指定', '设备', '写入', '一个', '字节', '的', '数据', '，', '返回', '操作', '状态', '。']"
93,93,93,VL53L0X_WrWord,int,"int VL53L0X_WrWord(int Dev, int index, int data)","[{'name': 'Dev', 'type': 'int'}, {'name': 'index', 'type': 'int'}, {'name': 'data', 'type': 'int'}]",VL53L0X_WrWord函数用于向指定设备写入数据。,"VL53L0X_Error VL53L0X_WrWord(VL53L0X_DEV Dev, uint8_t index, uint16_t data){
    VL53L0X_Error Status = VL53L0X_ERROR_NONE;
    int32_t status_int;
	uint8_t deviceAddress;

    deviceAddress = Dev->I2cDevAddr;

	status_int = VL53L0X_write_word(deviceAddress, index, data);

	if (status_int != 0)
		Status = VL53L0X_ERROR_CONTROL_INTERFACE;

    return Status;
}","{'begin': {'line': 83, 'column': 1}, 'end': {'line': 96, 'column': 2}}",Drive\Vl53l0x\Src\vl53l0x_platform.c,"['VL53L0X', '_', 'WrWord', '函数', '用于', '向', '指定', '设备', '写入', '数据', '。']"
94,94,94,VL53L0X_WrDWord,int,"int VL53L0X_WrDWord(int Dev, int index, int data)","[{'name': 'Dev', 'type': 'int'}, {'name': 'index', 'type': 'int'}, {'name': 'data', 'type': 'int'}]",将数据写入VL53L0X设备的指定内存地址。,"VL53L0X_Error VL53L0X_WrDWord(VL53L0X_DEV Dev, uint8_t index, uint32_t data){
    VL53L0X_Error Status = VL53L0X_ERROR_NONE;
    int32_t status_int;
	uint8_t deviceAddress;

    deviceAddress = Dev->I2cDevAddr;

	status_int = VL53L0X_write_dword(deviceAddress, index, data);

	if (status_int != 0)
		Status = VL53L0X_ERROR_CONTROL_INTERFACE;

    return Status;
}","{'begin': {'line': 98, 'column': 1}, 'end': {'line': 111, 'column': 2}}",Drive\Vl53l0x\Src\vl53l0x_platform.c,"['将', '数据', '写入', 'VL53L0X', '设备', '的', '指定', '内存', '地址', '内存地址', '。']"
95,95,95,VL53L0X_UpdateByte,int,"int VL53L0X_UpdateByte(int Dev, int index, int AndData, int OrData)","[{'name': 'Dev', 'type': 'int'}, {'name': 'index', 'type': 'int'}, {'name': 'AndData', 'type': 'int'}, {'name': 'OrData', 'type': 'int'}]",更新VL53L0X设备的字节数据,"VL53L0X_Error VL53L0X_UpdateByte(VL53L0X_DEV Dev, uint8_t index, uint8_t AndData, uint8_t OrData){
    VL53L0X_Error Status = VL53L0X_ERROR_NONE;
    int32_t status_int;
    uint8_t deviceAddress;
    uint8_t data;

    deviceAddress = Dev->I2cDevAddr;

    status_int = VL53L0X_read_byte(deviceAddress, index, &data);

    if (status_int != 0)
        Status = VL53L0X_ERROR_CONTROL_INTERFACE;

    if (Status == VL53L0X_ERROR_NONE) {
        data = (data & AndData) | OrData;
        status_int = VL53L0X_write_byte(deviceAddress, index, data);

        if (status_int != 0)
            Status = VL53L0X_ERROR_CONTROL_INTERFACE;
    }

    return Status;
}","{'begin': {'line': 113, 'column': 1}, 'end': {'line': 135, 'column': 2}}",Drive\Vl53l0x\Src\vl53l0x_platform.c,"['更新', 'VL53L0X', '设备', '的', '字节', '数据']"
96,96,96,VL53L0X_RdByte,int,"int VL53L0X_RdByte(int Dev, int index, int * data)","[{'name': 'Dev', 'type': 'int'}, {'name': 'index', 'type': 'int'}, {'name': 'data', 'type': 'int *'}]",VL53L0X_RdByte函数从设备读取字节数据。,"VL53L0X_Error VL53L0X_RdByte(VL53L0X_DEV Dev, uint8_t index, uint8_t *data){
    VL53L0X_Error Status = VL53L0X_ERROR_NONE;
    int32_t status_int;
    uint8_t deviceAddress;

    deviceAddress = Dev->I2cDevAddr;

    status_int = VL53L0X_read_byte(deviceAddress, index, data);

    if (status_int != 0)
        Status = VL53L0X_ERROR_CONTROL_INTERFACE;

    return Status;
}","{'begin': {'line': 137, 'column': 1}, 'end': {'line': 150, 'column': 2}}",Drive\Vl53l0x\Src\vl53l0x_platform.c,"['VL53L0X', '_', 'RdByte', '函数', '从', '设备', '读取', '字节', '数据', '。']"
97,97,97,VL53L0X_RdWord,int,"int VL53L0X_RdWord(int Dev, int index, int * data)","[{'name': 'Dev', 'type': 'int'}, {'name': 'index', 'type': 'int'}, {'name': 'data', 'type': 'int *'}]",读取VL53L0X设备指定索引处的字数据。,"VL53L0X_Error VL53L0X_RdWord(VL53L0X_DEV Dev, uint8_t index, uint16_t *data){
    VL53L0X_Error Status = VL53L0X_ERROR_NONE;
    int32_t status_int;
    uint8_t deviceAddress;

    deviceAddress = Dev->I2cDevAddr;

    status_int = VL53L0X_read_word(deviceAddress, index, data);

    if (status_int != 0)
        Status = VL53L0X_ERROR_CONTROL_INTERFACE;

    return Status;
}","{'begin': {'line': 152, 'column': 1}, 'end': {'line': 165, 'column': 2}}",Drive\Vl53l0x\Src\vl53l0x_platform.c,"['读取', 'VL53L0X', '设备', '指定', '索引', '处', '的', '字', '数据', '。']"
98,98,98,VL53L0X_RdDWord,int,"int VL53L0X_RdDWord(int Dev, int index, int * data)","[{'name': 'Dev', 'type': 'int'}, {'name': 'index', 'type': 'int'}, {'name': 'data', 'type': 'int *'}]",读取设备数据字节的函数，通过指定设备地址和索引来获取数据。,"VL53L0X_Error  VL53L0X_RdDWord(VL53L0X_DEV Dev, uint8_t index, uint32_t *data){
    VL53L0X_Error Status = VL53L0X_ERROR_NONE;
    int32_t status_int;
    uint8_t deviceAddress;

    deviceAddress = Dev->I2cDevAddr;

    status_int = VL53L0X_read_dword(deviceAddress, index, data);

    if (status_int != 0)
        Status = VL53L0X_ERROR_CONTROL_INTERFACE;

    return Status;
}","{'begin': {'line': 167, 'column': 1}, 'end': {'line': 180, 'column': 2}}",Drive\Vl53l0x\Src\vl53l0x_platform.c,"['读取', '设备', '数据', '字节', '的', '函数', '，', '通过', '指定', '设备', '地址', '和', '索引', '来', '获取', '数据', '获取数据', '。']"
99,99,99,VL53L0X_PollingDelay,int,int VL53L0X_PollingDelay(int Dev),"[{'name': 'Dev', 'type': 'int'}]",VL53L0X_PollingDelay函数用于执行轮询延迟，无实际操作。,"VL53L0X_Error VL53L0X_PollingDelay(VL53L0X_DEV Dev){
    VL53L0X_Error status = VL53L0X_ERROR_NONE;
    volatile uint32_t i;

    for(i=0;i<VL53L0X_POLLINGDELAY_LOOPNB;i++){
        //Do nothing
        ;;
    }

    return status;
}","{'begin': {'line': 183, 'column': 1}, 'end': {'line': 193, 'column': 2}}",Drive\Vl53l0x\Src\vl53l0x_platform.c,"['VL53L0X', '_', 'PollingDelay', '函数', '用于', '执行', '轮询', '延迟', '，', '无', '实际', '操作', '实际操作', '。']"
100,100,100,vl53l0x_measure_init,int,int vl53l0x_measure_init(int * pMyDevice),"[{'name': 'pMyDevice', 'type': 'int *'}]",初始化VL53L0X传感器，配置设备参数，启动测量。,"VL53L0X_Error vl53l0x_measure_init ( VL53L0X_Dev_t *pMyDevice )
{
    VL53L0X_Error Status = VL53L0X_ERROR_NONE;

    //FixPoint1616_t LimitCheckCurrent;
    uint32_t refSpadCount;
    uint8_t isApertureSpads;
    uint8_t VhvSettings;
    uint8_t PhaseCal;
    // Device Initialization
    Status = VL53L0X_StaticInit ( pMyDevice );
    if ( Status != VL53L0X_ERROR_NONE )
    {
        return Status;
    }
	if(1)
	{
		Status = VL53L0X_SetReferenceSpads ( pMyDevice, 5, 0 );
		if ( Status != VL53L0X_ERROR_NONE )
		{
			return Status;
		}
		Status = VL53L0X_SetRefCalibration ( pMyDevice, 0x1D, 1 );
		if ( Status != VL53L0X_ERROR_NONE )
		{
			return Status;
		}
	}
	else
	{
		//校准SPAD，校准后的两个结果refSpadCount，isApertureSpads
		Status = VL53L0X_PerformRefSpadManagement ( pMyDevice, &refSpadCount, &isApertureSpads );
		if ( Status != VL53L0X_ERROR_NONE )
		{
			return Status;
		}
		//校准温度相关参数，校准后的两个结果VhvSettings，PhaseCal
		Status = VL53L0X_PerformRefCalibration ( pMyDevice, &VhvSettings, &PhaseCal );
		if ( Status != VL53L0X_ERROR_NONE )
		{
			return Status;
		}
	}
    Status = VL53L0X_SetDeviceMode ( pMyDevice, VL53L0X_DEVICEMODE_CONTINUOUS_RANGING ); 
    if ( Status != VL53L0X_ERROR_NONE )
    {
        return Status;
    }

    if ( Status == VL53L0X_ERROR_NONE )
    {
        Status = VL53L0X_SetLimitCheckEnable ( pMyDevice, VL53L0X_CHECKENABLE_SIGMA_FINAL_RANGE, 1 );
    }
    if ( Status == VL53L0X_ERROR_NONE )
    {
        Status = VL53L0X_SetLimitCheckEnable ( pMyDevice, VL53L0X_CHECKENABLE_SIGNAL_RATE_FINAL_RANGE, 1 );
    }

    if ( Status == VL53L0X_ERROR_NONE )
    {
        Status = VL53L0X_SetLimitCheckValue ( pMyDevice, VL53L0X_CHECKENABLE_SIGNAL_RATE_FINAL_RANGE, ( FixPoint1616_t ) ( 0.1 * 65536 ) );
    }
    if ( Status == VL53L0X_ERROR_NONE )
    {
        Status = VL53L0X_SetLimitCheckValue ( pMyDevice, VL53L0X_CHECKENABLE_SIGMA_FINAL_RANGE, ( FixPoint1616_t ) ( 60 * 65536 ) );
    }
    if ( Status == VL53L0X_ERROR_NONE )
    {
        Status = VL53L0X_SetMeasurementTimingBudgetMicroSeconds ( pMyDevice, 33000 );
    }

    if ( Status == VL53L0X_ERROR_NONE )
    {
        Status = VL53L0X_SetVcselPulsePeriod ( pMyDevice, VL53L0X_VCSEL_PERIOD_PRE_RANGE, 18 );
    }
    if ( Status == VL53L0X_ERROR_NONE )
    {
        Status = VL53L0X_SetVcselPulsePeriod ( pMyDevice, VL53L0X_VCSEL_PERIOD_FINAL_RANGE, 14 );
    }

    if ( Status == VL53L0X_ERROR_NONE )
    {
        Status = VL53L0X_StartMeasurement ( pMyDevice );
    }

    return Status;
}","{'begin': {'line': 201, 'column': 1}, 'end': {'line': 287, 'column': 2}}",Drive\Vl53l0x\Src\vl53l0x_platform.c,"['初始', '初始化', 'VL53L0X', '传感', '感器', '传感器', '，', '配置', '设备', '参数', '，', '启动', '测量', '。']"
101,101,101,VL53L0X_Init,int,int VL53L0X_Init(),[],初始化VL53L0X设备，设置I2C地址、通信类型和速度，并进行数据初始化和设备信息获取。,"VL53L0X_Error VL53L0X_Init ( void )
{
    VL53L0X_Error Status = VL53L0X_ERROR_NONE;
    VL53L0X_Dev_t *pMyDevice = &vl53l0x_dev;
    pMyDevice->I2cDevAddr      = 0x52;
    pMyDevice->comms_type      =  1;
    pMyDevice->comms_speed_khz =  400;

    Status = VL53L0X_DataInit ( pMyDevice ); // Data initialization
    if ( Status != VL53L0X_ERROR_NONE )
    {
        return Status;
    }
    Status = VL53L0X_GetDeviceInfo ( pMyDevice, &vl53l0x_dev_info );
    if ( Status != VL53L0X_ERROR_NONE )
    {
        return Status;
    }
    if ( ( vl53l0x_dev_info.ProductRevisionMajor != 1 ) && ( vl53l0x_dev_info.ProductRevisionMinor != 1 ) )
    {
        Status = VL53L0X_ERROR_NOT_SUPPORTED;
        return Status;
    }
    Status = vl53l0x_measure_init ( pMyDevice );
    vl53l0x_status = Status;
    if ( Status != VL53L0X_ERROR_NONE )
    {
        return Status;
    }

    return Status;
}","{'begin': {'line': 289, 'column': 1}, 'end': {'line': 320, 'column': 2}}",Drive\Vl53l0x\Src\vl53l0x_platform.c,"['初始', '初始化', 'VL53L0X', '设备', '，', '设置', 'I2C', '地址', '、', '通信', '类型', '和', '速度', '，', '并', '进行', '数据', '初始', '初始化', '和', '设备', '信息', '获取', '。']"
102,102,102,VL53L0X_IfDataReady,int,int VL53L0X_IfDataReady(),[],检测IIC通信1字节中断状态，返回数据准备情况,"u8 VL53L0X_IfDataReady ( void )
{
	uint32_t InterruptMask;

	VL53L0X_GetInterruptMaskStatus ( &vl53l0x_dev, &InterruptMask );//IIC通信1字节
    if ( InterruptMask == VL53L0X_REG_SYSTEM_INTERRUPT_GPIO_NEW_SAMPLE_READY )
		return 1;
	else
		return 0;
}","{'begin': {'line': 321, 'column': 1}, 'end': {'line': 330, 'column': 2}}",Drive\Vl53l0x\Src\vl53l0x_platform.c,"['检测', 'IIC', '通信', '1', '字节', '中断', '状态', '，', '返回', '数据', '准备', '情况']"
103,103,103,VL53L0X_FastRead,int,int VL53L0X_FastRead(),[],VL53L0X_FastRead函数通过IIC通信读取两个字节的数据，并返回其合成的16位整数。,"u16 VL53L0X_FastRead( void )
{
	u8 datatemp[2];
	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
	
	Status = VL53L0X_ReadMulti ( &vl53l0x_dev, 0x1E, datatemp, 2 );	//IIC通信2字节
	//VL53L0X_ClearInterruptMask ( &vl53l0x_dev, VL53L0X_REG_SYSTEM_INTERRUPT_GPIO_NEW_SAMPLE_READY );//IIC通信3字节
	if(Status != VL53L0X_ERROR_NONE)
		return 0xffff;
	return VL53L0X_MAKEUINT16 ( datatemp[1], datatemp[0] );
}","{'begin': {'line': 331, 'column': 1}, 'end': {'line': 341, 'column': 2}}",Drive\Vl53l0x\Src\vl53l0x_platform.c,"['VL53L0X', '_', 'FastRead', '函数', '通过', 'IIC', '通信', '读取', '两个', '字节', '的', '数据', '，', '并', '返回', '其', '合成', '的', '16', '位', '整数', '。']"
104,104,104,data_save,void,void data_save(),[],data_save函数用于保存数据，根据flag.fly_ready的值设置para_sta.save_en和para_sta.save_trig的值。,"void data_save(void)
{
  para_sta.save_en = !flag.fly_ready;
  para_sta.save_trig = 1;
}","{'begin': {'line': 14, 'column': 1}, 'end': {'line': 18, 'column': 2}}",FlyControl_Algorithm\src\DY_FcData.c,"['data', '_', 'save', '函数', '用于', '保存', '数据', '，', '根据', 'flag', '.', 'fly', '_', 'ready', '的', '值', '设置', 'para', '_', 'sta', '.', 'save', '_', 'en', '和', 'para', '_', 'sta', '.', 'save', '_', 'trig', '的', '值', '。']"
105,105,105,Para_Data_Init,void,void Para_Data_Init(),[],调用DY_Parame_Read()函数初始化数据,"void Para_Data_Init()
{
  DY_Parame_Read();
}","{'begin': {'line': 20, 'column': 1}, 'end': {'line': 23, 'column': 2}}",FlyControl_Algorithm\src\DY_FcData.c,"['调用', 'DY', '_', 'Parame', '_', 'Read', '(', ')', '函数', '初始', '初始化', '数据']"
106,106,106,inte_fix_filter,void,"void inte_fix_filter(float dT, int * data)","[{'name': 'dT', 'type': 'float'}, {'name': 'data', 'type': 'int *'}]","{""name"": ""inte_fix_filter"", ""summary"": ""根据给定的上限或下限值，调整输入数据并计算输出结果""}","void inte_fix_filter(float dT,_inte_fix_filter_st *data)
{
	float ei_lim_val;
	
	if(data->ei_limit>0)
	{		
		ei_lim_val = LIMIT(data->ei,-data->ei_limit,data->ei_limit);
	}
	else
	{
		ei_lim_val = data->ei;
	}	
	
	data->out = (data->in_est + ei_lim_val);
	
	data->e = data->fix_ki *(data->in_obs - data->out);

	data->ei += data->e *dT;

}","{'begin': {'line': 9, 'column': 1}, 'end': {'line': 28, 'column': 2}}",FlyControl_Algorithm\src\DY_Filter.c,"['{', '""', 'name', '""', ':', ' ', '""', 'inte', '_', 'fix', '_', 'filter', '""', ',', ' ', '""', 'summary', '""', ':', ' ', '""', '根据', '给定', '的', '上限', '或', '下', '限值', '，', '调整', '输入', '数据', '并', '计算', '输出', '结果', '""', '}']"
107,107,107,fix_inte_filter,void,"void fix_inte_filter(float dT, int * data)","[{'name': 'dT', 'type': 'float'}, {'name': 'data', 'type': 'int *'}]",根据输入的dT和数据数组，更新数据数组中的元素，并对e进行限制处理,"void fix_inte_filter(float dT,_fix_inte_filter_st *data)
{
	
	data->out += (data->in_est_d + data->e ) *dT;
	
	data->e = data->fix_kp *(data->in_obs - data->out);

	if(data->e_limit>0)
	{		
		data->e = LIMIT(data->e,-data->e_limit,data->e_limit);
	}
	
}","{'begin': {'line': 30, 'column': 1}, 'end': {'line': 42, 'column': 2}}",FlyControl_Algorithm\src\DY_Filter.c,"['根据', '输入', '的', 'dT', '和', '数据', '数组', '，', '更新', '数据', '数组', '中', '的', '元素', '，', '并', '对', 'e', '进行', '限制', '处理']"
108,108,108,limit_filter,void,"void limit_filter(float T, float hz, int * data, float in)","[{'name': 'T', 'type': 'float'}, {'name': 'hz', 'type': 'float'}, {'name': 'data', 'type': 'int *'}, {'name': 'in', 'type': 'float'}]",对输入数据进行增量滤波，适合大噪声低滞后场景，收敛快,"void limit_filter(float T,float hz,_lf_t *data,float in) //增量滤波，适合大噪声低滞后（无缝），收敛最快
{
	float abs_t;
// 	LPF_1(hz,T,	 in,&(data->lpf_1)); 
// 	abs_t = ABS(data->lpf_1);
// 	data->out = LIMIT(in,-abs_t,abs_t);
	LPF_1_(hz,T,	 in,(data->lpf_1)); 
 	abs_t = ABS(in);
	data->out = LIMIT((data->lpf_1),-abs_t,abs_t);
}","{'begin': {'line': 44, 'column': 1}, 'end': {'line': 53, 'column': 2}}",FlyControl_Algorithm\src\DY_Filter.c,"['对', '输入', '数据', '进行', '增量', '滤波', '，', '适合', '大', '噪声', '低', '滞后', '场景', '，', '收敛', '快']"
109,109,109,limit_filter_2,void,"void limit_filter_2(float T, float hz, int * data, float in)","[{'name': 'T', 'type': 'float'}, {'name': 'hz', 'type': 'float'}, {'name': 'data', 'type': 'int *'}, {'name': 'in', 'type': 'float'}]",对输入数据进行增量滤波、均衡处理，但存在一定的滞后。,"void limit_filter_2(float T,float hz,_lf_t *data,float in) //增量滤波，均衡，但滞后稍大(数据反向等待低通反向)
{
	float abs_t;
	LPF_1_(hz,T,	 in,(data->lpf_1)); 
	abs_t = ABS(data->lpf_1);
	data->out = LIMIT(in,-abs_t,abs_t);
// 	LPF_1(hz,T,	 in,&(data->lpf_1)); 
//  	abs_t = ABS(in);
// 	data->out = LIMIT((data->lpf_1),-abs_t,abs_t);
}","{'begin': {'line': 55, 'column': 1}, 'end': {'line': 64, 'column': 2}}",FlyControl_Algorithm\src\DY_Filter.c,"['对', '输入', '数据', '进行', '增量', '滤波', '、', '均衡', '处理', '，', '但', '存在', '一定', '的', '滞后', '。']"
110,110,110,limit_filter_3,void,"void limit_filter_3(float T, float hz, int * data, float in)","[{'name': 'T', 'type': 'float'}, {'name': 'hz', 'type': 'float'}, {'name': 'data', 'type': 'int *'}, {'name': 'in', 'type': 'float'}]",增量滤波函数，适用于低噪声、小滞后情况，或噪声大但收敛较慢的情况。,"void limit_filter_3(float T,float hz,_lf_t *data,float in) //增量滤波，适合低噪声滞后较小(等幅大噪声平行不收敛),噪声大收敛过慢
{
	float abs_t;
	LPF_1_(hz,T,	 in,(data->lpf_1)); 
	abs_t = ABS(in);
	data->out = data->lpf_1 = LIMIT((data->lpf_1),-abs_t,abs_t);

}","{'begin': {'line': 66, 'column': 1}, 'end': {'line': 73, 'column': 2}}",FlyControl_Algorithm\src\DY_Filter.c,"['增量', '滤波', '函数', '，', '适用', '于', '噪声', '低噪声', '、', '小', '滞后', '情况', '，', '或', '噪声', '大', '但', '收敛', '较慢', '的', '情况', '。']"
111,111,111,steepest_descend,void,"void steepest_descend(int[] arr, int len, int * steepest, int step_num, int in)","[{'name': 'arr', 'type': 'int[]'}, {'name': 'len', 'type': 'int'}, {'name': 'steepest', 'type': 'int *'}, {'name': 'step_num', 'type': 'int'}, {'name': 'in', 'type': 'int'}]",计算数组中最陡下降路径，并更新最陡斜率和当前点。,"void steepest_descend(s32 arr[],u8 len,_steepest_st *steepest,u8 step_num,s32 in)
{	
	u8 updw = 1;//0 dw,1up
	s16 i;
	u8 step_cnt=0;
	u8 step_slope_factor=1;
	u8 on = 1;
	s8 pn = 1;
	//float last = 0;
	float step = 0;
	s32 start_point = 0;
	s32 pow_sum = 0;
	
	steepest->lst_out = steepest->now_out;
	
	if( ++(steepest->cnt) >= len )	
	{
		(steepest->cnt) = 0; //now
	}
	
	//last = arr[ (steepest->cnt) ];
	
	arr[ (steepest->cnt) ] = in;
	
	step = (float)(in - steepest->lst_out)/step_num ;//梯度
	
	if(ABS(step)<1)//整形数据<1的有效判定
	{
		if(ABS(step)*step_num<2)
		{
			step = 0;
		}
		else
		{
		  step = (step > 0) ? 1 : -1;
		}
	}
	
	start_point = steepest->lst_out;
	do
	{
		//start_point = steepest->lst_out;
		for(i=0;i<len;i++)
		{
// 			j = steepest->cnt + i + 1;
// 			if( j >= len )	
// 			{
// 				j = j - len; //顺序排列
// 			}
			pow_sum += my_pow(arr[i] - start_point );// /step_num;//除法减小比例**
			
			//start_point += pn *(step_slope_factor *step/len);
		}
			
		if(pow_sum - steepest->lst_pow_sum > 0)
		{		
			if(updw==0)
			{
				on = 0;
			}
			updw = 1;//上升了
			pn = (pn == 1 )? -1:1;

		}
		else
		{
			updw = 0; //正在下降
 			if(step_slope_factor<step_num)
 			{
 				step_slope_factor++;
 			}
		}
			
		steepest->lst_pow_sum = pow_sum;		
		pow_sum = 0;
		start_point += pn *step;//调整
		
		if(++step_cnt > step_num)//限制计算次数
		{
			on = 0;
		}
			//////
			if(step_slope_factor>=2)//限制下降次数1次，节省时间，但会增大滞后，若cpu时间充裕可不用。
			{
				on = 0;

			}
			//////
		
	}
	while(on==1);
	
	steepest->now_out = start_point ;//0.5f *(start_point + steepest->lst_out);//
	
	steepest->now_velocity_xdt = steepest->now_out - steepest->lst_out;
}","{'begin': {'line': 78, 'column': 1}, 'end': {'line': 173, 'column': 2}}",FlyControl_Algorithm\src\DY_Filter.c,"['计算', '数组', '中', '最', '陡', '下降', '路径', '，', '并', '更新', '最', '陡', '斜率', '和', '当前', '点', '。']"
112,112,112,fir_arrange_filter,void,"void fir_arrange_filter(float * arr, int len, int * fil_cnt, float in, float * arr_out)","[{'name': 'arr', 'type': 'float *'}, {'name': 'len', 'type': 'int'}, {'name': 'fil_cnt', 'type': 'int *'}, {'name': 'in', 'type': 'float'}, {'name': 'arr_out', 'type': 'float *'}]",对输入数组进行过滤和排列,"void fir_arrange_filter(float *arr,u16 len,u8 *fil_cnt,float in,float *arr_out) //len<=255 len >= 3
{
	//float arrange[len];
	float tmp;
	u8 i,j;
/*
窗口数据处理
*/		
	if( ++*fil_cnt >= len )	
	{
		*fil_cnt = 0; //now
	}
	
	arr[ *fil_cnt ] = in;
/*
窗口数据处理
*/	
	
/*
赋值、排列
*/	
	for(i=0;i<len;i++)
	{
		arr_out[i] = arr[i];
	}
	
	for(i=0;i<len-1;i++)
	{
		for(j=0;j<len-1-i;j++)
		{
			if(arr_out[j]>arr_out[j+1])
			{
				tmp = arr_out[j+1];
				arr_out[j+1] = arr_out[j];
				arr_out[j] = tmp;
			}
		}
	}
/*
赋值、排列
*/		
	

}","{'begin': {'line': 175, 'column': 1}, 'end': {'line': 218, 'column': 2}}",FlyControl_Algorithm\src\DY_Filter.c,"['对', '输入', '数组', '进行', '过滤', '和', '排列']"
113,113,113,Moving_Average,void,"void Moving_Average(float[] moavarray, int len, int * fil_cnt, float in, float * out)","[{'name': 'moavarray', 'type': 'float[]'}, {'name': 'len', 'type': 'int'}, {'name': 'fil_cnt', 'type': 'int *'}, {'name': 'in', 'type': 'float'}, {'name': 'out', 'type': 'float *'}]",计算滑动平均值的函数，接受一个浮点数数组、数组长度、文件计数器指针、新值及输出指针。,"void Moving_Average(float moavarray[],u16 len ,u16 *fil_cnt,float in,float *out)
{
	u16 width_num;
	float last;

	width_num = len ;
	
	if( ++*fil_cnt >= width_num )	
	{
		*fil_cnt = 0; //now
	}
	
	last = moavarray[ *fil_cnt ];
	
	moavarray[ *fil_cnt ] = in;
	
	*out += ( in - ( last  ) )/(float)( width_num ) ;
	//*out += 0.00001f *(in - *out);
	*out += 0.00001f *LIMIT((in - *out),-1,1);  //数据精度误差修正
	
}","{'begin': {'line': 223, 'column': 2}, 'end': {'line': 243, 'column': 2}}",FlyControl_Algorithm\src\DY_Filter.c,"['计算', '滑动', '平均', '均值', '平均值', '的', '函数', '，', '接受', '一个', '浮点', '点数', '浮点数', '数组', '、', '数组', '长度', '、', '文件', '计数', '计数器', '指针', '、', '新值', '及', '输出', '指针', '。']"
114,114,114,LPF_1,void,"void LPF_1(float hz, float time, float in, float * out)","[{'name': 'hz', 'type': 'float'}, {'name': 'time', 'type': 'float'}, {'name': 'in', 'type': 'float'}, {'name': 'out', 'type': 'float *'}]",对输入信号进行低通滤波处理，输出滤波后的信号。,"void LPF_1(float hz,float time,float in,float *out)  
{
	*out += ( 1 / ( 1 + 1 / ( hz *6.28f *time ) ) ) *( in - *out );

}","{'begin': {'line': 245, 'column': 1}, 'end': {'line': 249, 'column': 2}}",FlyControl_Algorithm\src\DY_Filter.c,"['对', '输入', '信号', '进行', '低', '滤波', '通滤波', '处理', '，', '输出', '滤波', '后', '的', '信号', '。']"
115,115,115,dlon_180,int,int dlon_180(int x),"[{'name': 'x', 'type': 'int'}]",将输入的整数x转换为180度的倍数,"s32 dlon_180(s32 x) //10^-7
{
	return (x>1800000000?(x-3600000000):(x<-1800000000?(x+3600000000):x));

}","{'begin': {'line': 5, 'column': 1}, 'end': {'line': 9, 'column': 2}}",FlyControl_Algorithm\src\DY_Math.c,"['将', '输入', '的', '整数', 'x', '转换', '为', '180', '度', '的', '倍数']"
116,116,116,dlon_180,int,int dlon_180(int x),"[{'name': 'x', 'type': 'int'}]","{""name"": ""dlon_180"", ""summary"": ""将输入的整数x转换为-180°到180°之间的角度""}","s32 dlon_180(s32 x) //10^-7
{
	return (x>1800000000?(x-3600000000):(x<-1800000000?(x+3600000000):x));

}","{'begin': {'line': 5, 'column': 1}, 'end': {'line': 9, 'column': 2}}",FlyControl_Algorithm\src\DY_Navigate.c,"['{', '""', 'name', '""', ':', ' ', '""', 'dlon', '_', '180', '""', ',', ' ', '""', 'summary', '""', ':', ' ', '""', '将', '输入', '的', '整数', 'x', '转换', '为', '-', '180', '°', '到', '180', '°', '之间', '的', '角度', '""', '}']"
